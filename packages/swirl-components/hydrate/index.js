'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*!
 Stencil Mock Doc v3.0.0 | MIT Licensed | https://stenciljs.com
 */
const CONTENT_REF_ID = 'r';
const ORG_LOCATION_ID = 'o';
const SLOT_NODE_ID = 's';
const TEXT_NODE_ID = 't';
const XLINK_NS = 'http://www.w3.org/1999/xlink';

const attrHandler = {
  get(obj, prop) {
    if (prop in obj) {
      return obj[prop];
    }
    if (typeof prop !== 'symbol' && !isNaN(prop)) {
      return obj.__items[prop];
    }
    return undefined;
  },
};
const createAttributeProxy = (caseInsensitive) => new Proxy(new MockAttributeMap(caseInsensitive), attrHandler);
class MockAttributeMap {
  constructor(caseInsensitive = false) {
    this.caseInsensitive = caseInsensitive;
    this.__items = [];
  }
  get length() {
    return this.__items.length;
  }
  item(index) {
    return this.__items[index] || null;
  }
  setNamedItem(attr) {
    attr.namespaceURI = null;
    this.setNamedItemNS(attr);
  }
  setNamedItemNS(attr) {
    if (attr != null && attr.value != null) {
      attr.value = String(attr.value);
    }
    const existingAttr = this.__items.find((a) => a.name === attr.name && a.namespaceURI === attr.namespaceURI);
    if (existingAttr != null) {
      existingAttr.value = attr.value;
    }
    else {
      this.__items.push(attr);
    }
  }
  getNamedItem(attrName) {
    if (this.caseInsensitive) {
      attrName = attrName.toLowerCase();
    }
    return this.getNamedItemNS(null, attrName);
  }
  getNamedItemNS(namespaceURI, attrName) {
    namespaceURI = getNamespaceURI(namespaceURI);
    return (this.__items.find((attr) => attr.name === attrName && getNamespaceURI(attr.namespaceURI) === namespaceURI) || null);
  }
  removeNamedItem(attr) {
    this.removeNamedItemNS(attr);
  }
  removeNamedItemNS(attr) {
    for (let i = 0, ii = this.__items.length; i < ii; i++) {
      if (this.__items[i].name === attr.name && this.__items[i].namespaceURI === attr.namespaceURI) {
        this.__items.splice(i, 1);
        break;
      }
    }
  }
  [Symbol.iterator]() {
    let i = 0;
    return {
      next: () => ({
        done: i === this.length,
        value: this.item(i++),
      }),
    };
  }
  get [Symbol.toStringTag]() {
    return 'MockAttributeMap';
  }
}
function getNamespaceURI(namespaceURI) {
  return namespaceURI === XLINK_NS ? null : namespaceURI;
}
function cloneAttributes(srcAttrs, sortByName = false) {
  const dstAttrs = new MockAttributeMap(srcAttrs.caseInsensitive);
  if (srcAttrs != null) {
    const attrLen = srcAttrs.length;
    if (sortByName && attrLen > 1) {
      const sortedAttrs = [];
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        sortedAttrs.push(dstAttr);
      }
      sortedAttrs.sort(sortAttributes).forEach((attr) => {
        dstAttrs.setNamedItemNS(attr);
      });
    }
    else {
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        dstAttrs.setNamedItemNS(dstAttr);
      }
    }
  }
  return dstAttrs;
}
function sortAttributes(a, b) {
  if (a.name < b.name)
    return -1;
  if (a.name > b.name)
    return 1;
  return 0;
}
class MockAttr {
  constructor(attrName, attrValue, namespaceURI = null) {
    this._name = attrName;
    this._value = String(attrValue);
    this._namespaceURI = namespaceURI;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = String(value);
  }
  get nodeName() {
    return this._name;
  }
  set nodeName(value) {
    this._name = value;
  }
  get nodeValue() {
    return this._value;
  }
  set nodeValue(value) {
    this._value = String(value);
  }
  get namespaceURI() {
    return this._namespaceURI;
  }
  set namespaceURI(namespaceURI) {
    this._namespaceURI = namespaceURI;
  }
}

class MockClassList {
  constructor(elm) {
    this.elm = elm;
  }
  add(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach((className) => {
      className = String(className);
      validateClass(className);
      if (clsNames.includes(className) === false) {
        clsNames.push(className);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, 'class', clsNames.join(' '));
    }
  }
  remove(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach((className) => {
      className = String(className);
      validateClass(className);
      const index = clsNames.indexOf(className);
      if (index > -1) {
        clsNames.splice(index, 1);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, 'class', clsNames.filter((c) => c.length > 0).join(' '));
    }
  }
  contains(className) {
    className = String(className);
    return getItems(this.elm).includes(className);
  }
  toggle(className) {
    className = String(className);
    if (this.contains(className) === true) {
      this.remove(className);
    }
    else {
      this.add(className);
    }
  }
  get length() {
    return getItems(this.elm).length;
  }
  item(index) {
    return getItems(this.elm)[index];
  }
  toString() {
    return getItems(this.elm).join(' ');
  }
}
function validateClass(className) {
  if (className === '') {
    throw new Error('The token provided must not be empty.');
  }
  if (/\s/.test(className)) {
    throw new Error(`The token provided ('${className}') contains HTML space characters, which are not valid in tokens.`);
  }
}
function getItems(elm) {
  const className = elm.getAttribute('class');
  if (typeof className === 'string' && className.length > 0) {
    return className
      .trim()
      .split(' ')
      .filter((c) => c.length > 0);
  }
  return [];
}

class MockCSSStyleDeclaration {
  constructor() {
    this._styles = new Map();
  }
  setProperty(prop, value) {
    prop = jsCaseToCssCase(prop);
    if (value == null || value === '') {
      this._styles.delete(prop);
    }
    else {
      this._styles.set(prop, String(value));
    }
  }
  getPropertyValue(prop) {
    prop = jsCaseToCssCase(prop);
    return String(this._styles.get(prop) || '');
  }
  removeProperty(prop) {
    prop = jsCaseToCssCase(prop);
    this._styles.delete(prop);
  }
  get length() {
    return this._styles.size;
  }
  get cssText() {
    const cssText = [];
    this._styles.forEach((value, prop) => {
      cssText.push(`${prop}: ${value};`);
    });
    return cssText.join(' ').trim();
  }
  set cssText(cssText) {
    if (cssText == null || cssText === '') {
      this._styles.clear();
      return;
    }
    cssText.split(';').forEach((rule) => {
      rule = rule.trim();
      if (rule.length > 0) {
        const splt = rule.split(':');
        if (splt.length > 1) {
          const prop = splt[0].trim();
          const value = splt.slice(1).join(':').trim();
          if (prop !== '' && value !== '') {
            this._styles.set(jsCaseToCssCase(prop), value);
          }
        }
      }
    });
  }
}
function createCSSStyleDeclaration() {
  return new Proxy(new MockCSSStyleDeclaration(), cssProxyHandler);
}
const cssProxyHandler = {
  get(cssStyle, prop) {
    if (prop in cssStyle) {
      return cssStyle[prop];
    }
    prop = cssCaseToJsCase(prop);
    return cssStyle.getPropertyValue(prop);
  },
  set(cssStyle, prop, value) {
    if (prop in cssStyle) {
      cssStyle[prop] = value;
    }
    else {
      cssStyle.setProperty(prop, value);
    }
    return true;
  },
};
function cssCaseToJsCase(str) {
  // font-size to fontSize
  if (str.length > 1 && str.includes('-') === true) {
    str = str
      .toLowerCase()
      .split('-')
      .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
      .join('');
    str = str.slice(0, 1).toLowerCase() + str.slice(1);
  }
  return str;
}
function jsCaseToCssCase(str) {
  // fontSize to font-size
  if (str.length > 1 && str.includes('-') === false && /[A-Z]/.test(str) === true) {
    str = str
      .replace(/([A-Z])/g, (g) => ' ' + g[0])
      .trim()
      .replace(/ /g, '-')
      .toLowerCase();
  }
  return str;
}

class MockCustomElementRegistry {
  constructor(win) {
    this.win = win;
  }
  define(tagName, cstr, options) {
    if (tagName.toLowerCase() !== tagName) {
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': "${tagName}" is not a valid custom element name`);
    }
    if (this.__registry == null) {
      this.__registry = new Map();
    }
    this.__registry.set(tagName, { cstr, options });
    if (this.__whenDefined != null) {
      const whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns != null) {
        whenDefinedResolveFns.forEach((whenDefinedResolveFn) => {
          whenDefinedResolveFn();
        });
        whenDefinedResolveFns.length = 0;
        this.__whenDefined.delete(tagName);
      }
    }
    const doc = this.win.document;
    if (doc != null) {
      const hosts = doc.querySelectorAll(tagName);
      hosts.forEach((host) => {
        if (upgradedElements.has(host) === false) {
          tempDisableCallbacks.add(doc);
          const upgradedCmp = createCustomElement(this, doc, tagName);
          for (let i = 0; i < host.childNodes.length; i++) {
            const childNode = host.childNodes[i];
            childNode.remove();
            upgradedCmp.appendChild(childNode);
          }
          tempDisableCallbacks.delete(doc);
          if (proxyElements.has(host)) {
            proxyElements.set(host, upgradedCmp);
          }
        }
        fireConnectedCallback(host);
      });
    }
  }
  get(tagName) {
    if (this.__registry != null) {
      const def = this.__registry.get(tagName.toLowerCase());
      if (def != null) {
        return def.cstr;
      }
    }
    return undefined;
  }
  upgrade(_rootNode) {
    //
  }
  clear() {
    if (this.__registry != null) {
      this.__registry.clear();
    }
    if (this.__whenDefined != null) {
      this.__whenDefined.clear();
    }
  }
  whenDefined(tagName) {
    tagName = tagName.toLowerCase();
    if (this.__registry != null && this.__registry.has(tagName) === true) {
      return Promise.resolve(this.__registry.get(tagName).cstr);
    }
    return new Promise((resolve) => {
      if (this.__whenDefined == null) {
        this.__whenDefined = new Map();
      }
      let whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns == null) {
        whenDefinedResolveFns = [];
        this.__whenDefined.set(tagName, whenDefinedResolveFns);
      }
      whenDefinedResolveFns.push(resolve);
    });
  }
}
function createCustomElement(customElements, ownerDocument, tagName) {
  const Cstr = customElements.get(tagName);
  if (Cstr != null) {
    const cmp = new Cstr(ownerDocument);
    cmp.nodeName = tagName.toUpperCase();
    upgradedElements.add(cmp);
    return cmp;
  }
  const host = new Proxy({}, {
    get(obj, prop) {
      const elm = proxyElements.get(host);
      if (elm != null) {
        return elm[prop];
      }
      return obj[prop];
    },
    set(obj, prop, val) {
      const elm = proxyElements.get(host);
      if (elm != null) {
        elm[prop] = val;
      }
      else {
        obj[prop] = val;
      }
      return true;
    },
    has(obj, prop) {
      const elm = proxyElements.get(host);
      if (prop in elm) {
        return true;
      }
      if (prop in obj) {
        return true;
      }
      return false;
    },
  });
  const elm = new MockHTMLElement(ownerDocument, tagName);
  proxyElements.set(host, elm);
  return host;
}
const proxyElements = new WeakMap();
const upgradedElements = new WeakSet();
function connectNode(ownerDocument, node) {
  node.ownerDocument = ownerDocument;
  if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
    if (ownerDocument != null && node.nodeName.includes('-')) {
      const win = ownerDocument.defaultView;
      if (win != null && typeof node.connectedCallback === 'function' && node.isConnected) {
        fireConnectedCallback(node);
      }
      const shadowRoot = node.shadowRoot;
      if (shadowRoot != null) {
        shadowRoot.childNodes.forEach((childNode) => {
          connectNode(ownerDocument, childNode);
        });
      }
    }
    node.childNodes.forEach((childNode) => {
      connectNode(ownerDocument, childNode);
    });
  }
  else {
    node.childNodes.forEach((childNode) => {
      childNode.ownerDocument = ownerDocument;
    });
  }
}
function fireConnectedCallback(node) {
  if (typeof node.connectedCallback === 'function') {
    if (tempDisableCallbacks.has(node.ownerDocument) === false) {
      try {
        node.connectedCallback();
      }
      catch (e) {
        console.error(e);
      }
    }
  }
}
function disconnectNode(node) {
  if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
    if (node.nodeName.includes('-') === true && typeof node.disconnectedCallback === 'function') {
      if (tempDisableCallbacks.has(node.ownerDocument) === false) {
        try {
          node.disconnectedCallback();
        }
        catch (e) {
          console.error(e);
        }
      }
    }
    node.childNodes.forEach(disconnectNode);
  }
}
function attributeChanged(node, attrName, oldValue, newValue) {
  attrName = attrName.toLowerCase();
  const observedAttributes = node.constructor.observedAttributes;
  if (Array.isArray(observedAttributes) === true &&
    observedAttributes.some((obs) => obs.toLowerCase() === attrName) === true) {
    try {
      node.attributeChangedCallback(attrName, oldValue, newValue);
    }
    catch (e) {
      console.error(e);
    }
  }
}
function checkAttributeChanged(node) {
  return node.nodeName.includes('-') === true && typeof node.attributeChangedCallback === 'function';
}
const tempDisableCallbacks = new Set();

function dataset(elm) {
  const ds = {};
  const attributes = elm.attributes;
  const attrLen = attributes.length;
  for (let i = 0; i < attrLen; i++) {
    const attr = attributes.item(i);
    const nodeName = attr.nodeName;
    if (nodeName.startsWith('data-')) {
      ds[dashToPascalCase(nodeName)] = attr.nodeValue;
    }
  }
  return new Proxy(ds, {
    get(_obj, camelCaseProp) {
      return ds[camelCaseProp];
    },
    set(_obj, camelCaseProp, value) {
      const dataAttr = toDataAttribute(camelCaseProp);
      elm.setAttribute(dataAttr, value);
      return true;
    },
  });
}
function toDataAttribute(str) {
  return ('data-' +
    String(str)
      .replace(/([A-Z0-9])/g, (g) => ' ' + g[0])
      .trim()
      .replace(/ /g, '-')
      .toLowerCase());
}
function dashToPascalCase(str) {
  str = String(str).slice(5);
  return str
    .split('-')
    .map((segment, index) => {
    if (index === 0) {
      return segment.charAt(0).toLowerCase() + segment.slice(1);
    }
    return segment.charAt(0).toUpperCase() + segment.slice(1);
  })
    .join('');
}

class MockEvent {
  constructor(type, eventInitDict) {
    this.bubbles = false;
    this.cancelBubble = false;
    this.cancelable = false;
    this.composed = false;
    this.currentTarget = null;
    this.defaultPrevented = false;
    this.srcElement = null;
    this.target = null;
    if (typeof type !== 'string') {
      throw new Error(`Event type required`);
    }
    this.type = type;
    this.timeStamp = Date.now();
    if (eventInitDict != null) {
      Object.assign(this, eventInitDict);
    }
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
  stopImmediatePropagation() {
    this.cancelBubble = true;
  }
  composedPath() {
    const composedPath = [];
    let currentElement = this.target;
    while (currentElement) {
      composedPath.push(currentElement);
      if (!currentElement.parentElement && currentElement.nodeName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
        // the current element doesn't have a parent, but we've detected it's our root document node. push the window
        // object associated with the document onto the path
        composedPath.push(currentElement.defaultView);
        break;
      }
      currentElement = currentElement.parentElement;
    }
    return composedPath;
  }
}
class MockCustomEvent extends MockEvent {
  constructor(type, customEventInitDic) {
    super(type);
    this.detail = null;
    if (customEventInitDic != null) {
      Object.assign(this, customEventInitDic);
    }
  }
}
class MockKeyboardEvent extends MockEvent {
  constructor(type, keyboardEventInitDic) {
    super(type);
    this.code = '';
    this.key = '';
    this.altKey = false;
    this.ctrlKey = false;
    this.metaKey = false;
    this.shiftKey = false;
    this.location = 0;
    this.repeat = false;
    if (keyboardEventInitDic != null) {
      Object.assign(this, keyboardEventInitDic);
    }
  }
}
class MockMouseEvent extends MockEvent {
  constructor(type, mouseEventInitDic) {
    super(type);
    this.screenX = 0;
    this.screenY = 0;
    this.clientX = 0;
    this.clientY = 0;
    this.ctrlKey = false;
    this.shiftKey = false;
    this.altKey = false;
    this.metaKey = false;
    this.button = 0;
    this.buttons = 0;
    this.relatedTarget = null;
    if (mouseEventInitDic != null) {
      Object.assign(this, mouseEventInitDic);
    }
  }
}
class MockUIEvent extends MockEvent {
  constructor(type, uiEventInitDic) {
    super(type);
    this.detail = null;
    this.view = null;
    if (uiEventInitDic != null) {
      Object.assign(this, uiEventInitDic);
    }
  }
}
class MockFocusEvent extends MockUIEvent {
  constructor(type, focusEventInitDic) {
    super(type);
    this.relatedTarget = null;
    if (focusEventInitDic != null) {
      Object.assign(this, focusEventInitDic);
    }
  }
}
class MockEventListener {
  constructor(type, handler) {
    this.type = type;
    this.handler = handler;
  }
}
function addEventListener(elm, type, handler) {
  const target = elm;
  if (target.__listeners == null) {
    target.__listeners = [];
  }
  target.__listeners.push(new MockEventListener(type, handler));
}
function removeEventListener(elm, type, handler) {
  const target = elm;
  if (target != null && Array.isArray(target.__listeners) === true) {
    const elmListener = target.__listeners.find((e) => e.type === type && e.handler === handler);
    if (elmListener != null) {
      const index = target.__listeners.indexOf(elmListener);
      target.__listeners.splice(index, 1);
    }
  }
}
function resetEventListeners(target) {
  if (target != null && target.__listeners != null) {
    target.__listeners = null;
  }
}
function triggerEventListener(elm, ev) {
  if (elm == null || ev.cancelBubble === true) {
    return;
  }
  const target = elm;
  ev.currentTarget = elm;
  if (Array.isArray(target.__listeners) === true) {
    const listeners = target.__listeners.filter((e) => e.type === ev.type);
    listeners.forEach((listener) => {
      try {
        listener.handler.call(target, ev);
      }
      catch (err) {
        console.error(err);
      }
    });
  }
  if (ev.bubbles === false) {
    return;
  }
  if (elm.nodeName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
    triggerEventListener(elm.defaultView, ev);
  }
  else {
    triggerEventListener(elm.parentElement, ev);
  }
}
function dispatchEvent(currentTarget, ev) {
  ev.target = currentTarget;
  triggerEventListener(currentTarget, ev);
  return true;
}

// Parse5 7.1.2
const e=function(e){const t=new Set([65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111]),s="�";var a;!function(e){e[e.EOF=-1]="EOF",e[e.NULL=0]="NULL",e[e.TABULATION=9]="TABULATION",e[e.CARRIAGE_RETURN=13]="CARRIAGE_RETURN",e[e.LINE_FEED=10]="LINE_FEED",e[e.FORM_FEED=12]="FORM_FEED",e[e.SPACE=32]="SPACE",e[e.EXCLAMATION_MARK=33]="EXCLAMATION_MARK",e[e.QUOTATION_MARK=34]="QUOTATION_MARK",e[e.NUMBER_SIGN=35]="NUMBER_SIGN",e[e.AMPERSAND=38]="AMPERSAND",e[e.APOSTROPHE=39]="APOSTROPHE",e[e.HYPHEN_MINUS=45]="HYPHEN_MINUS",e[e.SOLIDUS=47]="SOLIDUS",e[e.DIGIT_0=48]="DIGIT_0",e[e.DIGIT_9=57]="DIGIT_9",e[e.SEMICOLON=59]="SEMICOLON",e[e.LESS_THAN_SIGN=60]="LESS_THAN_SIGN",e[e.EQUALS_SIGN=61]="EQUALS_SIGN",e[e.GREATER_THAN_SIGN=62]="GREATER_THAN_SIGN",e[e.QUESTION_MARK=63]="QUESTION_MARK",e[e.LATIN_CAPITAL_A=65]="LATIN_CAPITAL_A",e[e.LATIN_CAPITAL_F=70]="LATIN_CAPITAL_F",e[e.LATIN_CAPITAL_X=88]="LATIN_CAPITAL_X",e[e.LATIN_CAPITAL_Z=90]="LATIN_CAPITAL_Z",e[e.RIGHT_SQUARE_BRACKET=93]="RIGHT_SQUARE_BRACKET",e[e.GRAVE_ACCENT=96]="GRAVE_ACCENT",e[e.LATIN_SMALL_A=97]="LATIN_SMALL_A",e[e.LATIN_SMALL_F=102]="LATIN_SMALL_F",e[e.LATIN_SMALL_X=120]="LATIN_SMALL_X",e[e.LATIN_SMALL_Z=122]="LATIN_SMALL_Z",e[e.REPLACEMENT_CHARACTER=65533]="REPLACEMENT_CHARACTER";}(a=a||(a={}));const r="[CDATA[",n="doctype",i="script";function o(e){return e>=55296&&e<=57343}function c(e){return 32!==e&&10!==e&&13!==e&&9!==e&&12!==e&&e>=1&&e<=31||e>=127&&e<=159}function E(e){return e>=64976&&e<=65007||t.has(e)}var T,h;!function(e){e.controlCharacterInInputStream="control-character-in-input-stream",e.noncharacterInInputStream="noncharacter-in-input-stream",e.surrogateInInputStream="surrogate-in-input-stream",e.nonVoidHtmlElementStartTagWithTrailingSolidus="non-void-html-element-start-tag-with-trailing-solidus",e.endTagWithAttributes="end-tag-with-attributes",e.endTagWithTrailingSolidus="end-tag-with-trailing-solidus",e.unexpectedSolidusInTag="unexpected-solidus-in-tag",e.unexpectedNullCharacter="unexpected-null-character",e.unexpectedQuestionMarkInsteadOfTagName="unexpected-question-mark-instead-of-tag-name",e.invalidFirstCharacterOfTagName="invalid-first-character-of-tag-name",e.unexpectedEqualsSignBeforeAttributeName="unexpected-equals-sign-before-attribute-name",e.missingEndTagName="missing-end-tag-name",e.unexpectedCharacterInAttributeName="unexpected-character-in-attribute-name",e.unknownNamedCharacterReference="unknown-named-character-reference",e.missingSemicolonAfterCharacterReference="missing-semicolon-after-character-reference",e.unexpectedCharacterAfterDoctypeSystemIdentifier="unexpected-character-after-doctype-system-identifier",e.unexpectedCharacterInUnquotedAttributeValue="unexpected-character-in-unquoted-attribute-value",e.eofBeforeTagName="eof-before-tag-name",e.eofInTag="eof-in-tag",e.missingAttributeValue="missing-attribute-value",e.missingWhitespaceBetweenAttributes="missing-whitespace-between-attributes",e.missingWhitespaceAfterDoctypePublicKeyword="missing-whitespace-after-doctype-public-keyword",e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers="missing-whitespace-between-doctype-public-and-system-identifiers",e.missingWhitespaceAfterDoctypeSystemKeyword="missing-whitespace-after-doctype-system-keyword",e.missingQuoteBeforeDoctypePublicIdentifier="missing-quote-before-doctype-public-identifier",e.missingQuoteBeforeDoctypeSystemIdentifier="missing-quote-before-doctype-system-identifier",e.missingDoctypePublicIdentifier="missing-doctype-public-identifier",e.missingDoctypeSystemIdentifier="missing-doctype-system-identifier",e.abruptDoctypePublicIdentifier="abrupt-doctype-public-identifier",e.abruptDoctypeSystemIdentifier="abrupt-doctype-system-identifier",e.cdataInHtmlContent="cdata-in-html-content",e.incorrectlyOpenedComment="incorrectly-opened-comment",e.eofInScriptHtmlCommentLikeText="eof-in-script-html-comment-like-text",e.eofInDoctype="eof-in-doctype",e.nestedComment="nested-comment",e.abruptClosingOfEmptyComment="abrupt-closing-of-empty-comment",e.eofInComment="eof-in-comment",e.incorrectlyClosedComment="incorrectly-closed-comment",e.eofInCdata="eof-in-cdata",e.absenceOfDigitsInNumericCharacterReference="absence-of-digits-in-numeric-character-reference",e.nullCharacterReference="null-character-reference",e.surrogateCharacterReference="surrogate-character-reference",e.characterReferenceOutsideUnicodeRange="character-reference-outside-unicode-range",e.controlCharacterReference="control-character-reference",e.noncharacterCharacterReference="noncharacter-character-reference",e.missingWhitespaceBeforeDoctypeName="missing-whitespace-before-doctype-name",e.missingDoctypeName="missing-doctype-name",e.invalidCharacterSequenceAfterDoctypeName="invalid-character-sequence-after-doctype-name",e.duplicateAttribute="duplicate-attribute",e.nonConformingDoctype="non-conforming-doctype",e.missingDoctype="missing-doctype",e.misplacedDoctype="misplaced-doctype",e.endTagWithoutMatchingOpenElement="end-tag-without-matching-open-element",e.closingOfElementWithOpenChildElements="closing-of-element-with-open-child-elements",e.disallowedContentInNoscriptInHead="disallowed-content-in-noscript-in-head",e.openElementsLeftAfterEof="open-elements-left-after-eof",e.abandonedHeadElementChild="abandoned-head-element-child",e.misplacedStartTagForHeadElement="misplaced-start-tag-for-head-element",e.nestedNoscriptInHead="nested-noscript-in-head",e.eofInElementThatCanContainOnlyText="eof-in-element-that-can-contain-only-text";}(T=T||(T={}));class _{constructor(e){this.handler=e,this.html="",this.pos=-1,this.lastGapPos=-2,this.gapStack=[],this.skipNextNewLine=!1,this.lastChunkWritten=!1,this.endOfChunkHit=!1,this.bufferWaterline=65536,this.isEol=!1,this.lineStartPos=0,this.droppedBufferSize=0,this.line=1,this.lastErrOffset=-1;}get col(){return this.pos-this.lineStartPos+Number(this.lastGapPos!==this.pos)}get offset(){return this.droppedBufferSize+this.pos}getError(e){const{line:t,col:s,offset:a}=this;return {code:e,startLine:t,endLine:t,startCol:s,endCol:s,startOffset:a,endOffset:a}}_err(e){this.handler.onParseError&&this.lastErrOffset!==this.offset&&(this.lastErrOffset=this.offset,this.handler.onParseError(this.getError(e)));}_addGap(){this.gapStack.push(this.lastGapPos),this.lastGapPos=this.pos;}_processSurrogate(e){if(this.pos!==this.html.length-1){const t=this.html.charCodeAt(this.pos+1);if(function(e){return e>=56320&&e<=57343}(t))return this.pos++,this._addGap(),1024*(e-55296)+9216+t}else if(!this.lastChunkWritten)return this.endOfChunkHit=!0,a.EOF;return this._err(T.surrogateInInputStream),e}willDropParsedChunk(){return this.pos>this.bufferWaterline}dropParsedChunk(){this.willDropParsedChunk()&&(this.html=this.html.substring(this.pos),this.lineStartPos-=this.pos,this.droppedBufferSize+=this.pos,this.pos=0,this.lastGapPos=-2,this.gapStack.length=0);}write(e,t){this.html.length>0?this.html+=e:this.html=e,this.endOfChunkHit=!1,this.lastChunkWritten=t;}insertHtmlAtCurrentPos(e){this.html=this.html.substring(0,this.pos+1)+e+this.html.substring(this.pos+1),this.endOfChunkHit=!1;}startsWith(e,t){if(this.pos+e.length>this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,!1;if(t)return this.html.startsWith(e,this.pos);for(let t=0;t<e.length;t++)if((32|this.html.charCodeAt(this.pos+t))!==e.charCodeAt(t))return !1;return !0}peek(e){const t=this.pos+e;if(t>=this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,a.EOF;const s=this.html.charCodeAt(t);return s===a.CARRIAGE_RETURN?a.LINE_FEED:s}advance(){if(this.pos++,this.isEol&&(this.isEol=!1,this.line++,this.lineStartPos=this.pos),this.pos>=this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,a.EOF;let e=this.html.charCodeAt(this.pos);return e===a.CARRIAGE_RETURN?(this.isEol=!0,this.skipNextNewLine=!0,a.LINE_FEED):e===a.LINE_FEED&&(this.isEol=!0,this.skipNextNewLine)?(this.line--,this.skipNextNewLine=!1,this._addGap(),this.advance()):(this.skipNextNewLine=!1,o(e)&&(e=this._processSurrogate(e)),null===this.handler.onParseError||e>31&&e<127||e===a.LINE_FEED||e===a.CARRIAGE_RETURN||e>159&&e<64976||this._checkForProblematicCharacters(e),e)}_checkForProblematicCharacters(e){c(e)?this._err(T.controlCharacterInInputStream):E(e)&&this._err(T.noncharacterInInputStream);}retreat(e){for(this.pos-=e;this.pos<this.lastGapPos;)this.lastGapPos=this.gapStack.pop(),this.pos--;this.isEol=!1;}}function A(e,t){for(let s=e.attrs.length-1;s>=0;s--)if(e.attrs[s].name===t)return e.attrs[s].value;return null}!function(e){e[e.CHARACTER=0]="CHARACTER",e[e.NULL_CHARACTER=1]="NULL_CHARACTER",e[e.WHITESPACE_CHARACTER=2]="WHITESPACE_CHARACTER",e[e.START_TAG=3]="START_TAG",e[e.END_TAG=4]="END_TAG",e[e.COMMENT=5]="COMMENT",e[e.DOCTYPE=6]="DOCTYPE",e[e.EOF=7]="EOF",e[e.HIBERNATION=8]="HIBERNATION";}(h=h||(h={}));var l="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function m(e,t,s){return e(s={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==t&&s.path)}},s.exports),s.exports}var p,d,I,N,u,C=m((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=new Uint16Array('ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((function(e){return e.charCodeAt(0)})));})),D=m((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=new Uint16Array("Ȁaglq\tɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((function(e){return e.charCodeAt(0)})));})),S=m((function(e,t){var s;Object.defineProperty(t,"__esModule",{value:!0}),t.replaceCodePoint=t.fromCodePoint=void 0;var a=new Map([[0,65533],[128,8364],[130,8218],[131,402],[132,8222],[133,8230],[134,8224],[135,8225],[136,710],[137,8240],[138,352],[139,8249],[140,338],[142,381],[145,8216],[146,8217],[147,8220],[148,8221],[149,8226],[150,8211],[151,8212],[152,732],[153,8482],[154,353],[155,8250],[156,339],[158,382],[159,376]]);function r(e){var t;return e>=55296&&e<=57343||e>1114111?65533:null!==(t=a.get(e))&&void 0!==t?t:e}t.fromCodePoint=null!==(s=String.fromCodePoint)&&void 0!==s?s:function(e){var t="";return e>65535&&(e-=65536,t+=String.fromCharCode(e>>>10&1023|55296),e=56320|1023&e),t+String.fromCharCode(e)},t.replaceCodePoint=r,t.default=function(e){return (0, t.fromCodePoint)(r(e))};})),R=m((function(e,t){var s=l&&l.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeXML=t.decodeHTMLStrict=t.decodeHTML=t.determineBranch=t.BinTrieFlags=t.fromCodePoint=t.replaceCodePoint=t.decodeCodePoint=t.xmlDecodeTree=t.htmlDecodeTree=void 0;var a=s(C);t.htmlDecodeTree=a.default;var r=s(D);t.xmlDecodeTree=r.default;var n=s(S);t.decodeCodePoint=n.default;var i,o,c=S;function E(e){return function(t,s){for(var a="",r=0,c=0;(c=t.indexOf("&",c))>=0;)if(a+=t.slice(r,c),r=c,c+=1,t.charCodeAt(c)!==i.NUM){for(var E=0,h=1,_=0,A=e[_];c<t.length&&!((_=T(e,A,_+1,t.charCodeAt(c)))<0);c++,h++){var l=(A=e[_])&o.VALUE_LENGTH;if(l){var m;if(s&&t.charCodeAt(c)!==i.SEMI||(E=_,h=0),0==(m=(l>>14)-1))break;_+=m;}}0!==E&&(a+=1==(m=(e[E]&o.VALUE_LENGTH)>>14)?String.fromCharCode(e[E]&~o.VALUE_LENGTH):2===m?String.fromCharCode(e[E+1]):String.fromCharCode(e[E+1],e[E+2]),r=c-h+1);}else {var p=c+1,d=10,I=t.charCodeAt(p);(I|i.To_LOWER_BIT)===i.LOWER_X&&(d=16,c+=1,p+=1);do{I=t.charCodeAt(++c);}while(I>=i.ZERO&&I<=i.NINE||16===d&&(I|i.To_LOWER_BIT)>=i.LOWER_A&&(I|i.To_LOWER_BIT)<=i.LOWER_F);if(p!==c){var N=t.substring(p,c),u=parseInt(N,d);if(t.charCodeAt(c)===i.SEMI)c+=1;else if(s)continue;a+=(0, n.default)(u),r=c;}}return a+t.slice(r)}}function T(e,t,s,a){var r=(t&o.BRANCH_LENGTH)>>7,n=t&o.JUMP_TABLE;if(0===r)return 0!==n&&a===n?s:-1;if(n){var i=a-n;return i<0||i>=r?-1:e[s+i]-1}for(var c=s,E=c+r-1;c<=E;){var T=c+E>>>1,h=e[T];if(h<a)c=T+1;else {if(!(h>a))return e[T+r];E=T-1;}}return -1}Object.defineProperty(t,"replaceCodePoint",{enumerable:!0,get:function(){return c.replaceCodePoint}}),Object.defineProperty(t,"fromCodePoint",{enumerable:!0,get:function(){return c.fromCodePoint}}),function(e){e[e.NUM=35]="NUM",e[e.SEMI=59]="SEMI",e[e.ZERO=48]="ZERO",e[e.NINE=57]="NINE",e[e.LOWER_A=97]="LOWER_A",e[e.LOWER_F=102]="LOWER_F",e[e.LOWER_X=120]="LOWER_X",e[e.To_LOWER_BIT=32]="To_LOWER_BIT";}(i||(i={})),function(e){e[e.VALUE_LENGTH=49152]="VALUE_LENGTH",e[e.BRANCH_LENGTH=16256]="BRANCH_LENGTH",e[e.JUMP_TABLE=127]="JUMP_TABLE";}(o=t.BinTrieFlags||(t.BinTrieFlags={})),t.determineBranch=T;var h=E(a.default),_=E(r.default);t.decodeHTML=function(e){return h(e,!1)},t.decodeHTMLStrict=function(e){return h(e,!0)},t.decodeXML=function(e){return _(e,!0)};}));!function(e){e.HTML="http://www.w3.org/1999/xhtml",e.MATHML="http://www.w3.org/1998/Math/MathML",e.SVG="http://www.w3.org/2000/svg",e.XLINK="http://www.w3.org/1999/xlink",e.XML="http://www.w3.org/XML/1998/namespace",e.XMLNS="http://www.w3.org/2000/xmlns/";}(p=p||(p={})),function(e){e.TYPE="type",e.ACTION="action",e.ENCODING="encoding",e.PROMPT="prompt",e.NAME="name",e.COLOR="color",e.FACE="face",e.SIZE="size";}(d=d||(d={})),function(e){e.NO_QUIRKS="no-quirks",e.QUIRKS="quirks",e.LIMITED_QUIRKS="limited-quirks";}(I=I||(I={})),function(e){e.A="a",e.ADDRESS="address",e.ANNOTATION_XML="annotation-xml",e.APPLET="applet",e.AREA="area",e.ARTICLE="article",e.ASIDE="aside",e.B="b",e.BASE="base",e.BASEFONT="basefont",e.BGSOUND="bgsound",e.BIG="big",e.BLOCKQUOTE="blockquote",e.BODY="body",e.BR="br",e.BUTTON="button",e.CAPTION="caption",e.CENTER="center",e.CODE="code",e.COL="col",e.COLGROUP="colgroup",e.DD="dd",e.DESC="desc",e.DETAILS="details",e.DIALOG="dialog",e.DIR="dir",e.DIV="div",e.DL="dl",e.DT="dt",e.EM="em",e.EMBED="embed",e.FIELDSET="fieldset",e.FIGCAPTION="figcaption",e.FIGURE="figure",e.FONT="font",e.FOOTER="footer",e.FOREIGN_OBJECT="foreignObject",e.FORM="form",e.FRAME="frame",e.FRAMESET="frameset",e.H1="h1",e.H2="h2",e.H3="h3",e.H4="h4",e.H5="h5",e.H6="h6",e.HEAD="head",e.HEADER="header",e.HGROUP="hgroup",e.HR="hr",e.HTML="html",e.I="i",e.IMG="img",e.IMAGE="image",e.INPUT="input",e.IFRAME="iframe",e.KEYGEN="keygen",e.LABEL="label",e.LI="li",e.LINK="link",e.LISTING="listing",e.MAIN="main",e.MALIGNMARK="malignmark",e.MARQUEE="marquee",e.MATH="math",e.MENU="menu",e.META="meta",e.MGLYPH="mglyph",e.MI="mi",e.MO="mo",e.MN="mn",e.MS="ms",e.MTEXT="mtext",e.NAV="nav",e.NOBR="nobr",e.NOFRAMES="noframes",e.NOEMBED="noembed",e.NOSCRIPT="noscript",e.OBJECT="object",e.OL="ol",e.OPTGROUP="optgroup",e.OPTION="option",e.P="p",e.PARAM="param",e.PLAINTEXT="plaintext",e.PRE="pre",e.RB="rb",e.RP="rp",e.RT="rt",e.RTC="rtc",e.RUBY="ruby",e.S="s",e.SCRIPT="script",e.SECTION="section",e.SELECT="select",e.SOURCE="source",e.SMALL="small",e.SPAN="span",e.STRIKE="strike",e.STRONG="strong",e.STYLE="style",e.SUB="sub",e.SUMMARY="summary",e.SUP="sup",e.TABLE="table",e.TBODY="tbody",e.TEMPLATE="template",e.TEXTAREA="textarea",e.TFOOT="tfoot",e.TD="td",e.TH="th",e.THEAD="thead",e.TITLE="title",e.TR="tr",e.TRACK="track",e.TT="tt",e.U="u",e.UL="ul",e.SVG="svg",e.VAR="var",e.WBR="wbr",e.XMP="xmp";}(N=N||(N={})),function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.A=1]="A",e[e.ADDRESS=2]="ADDRESS",e[e.ANNOTATION_XML=3]="ANNOTATION_XML",e[e.APPLET=4]="APPLET",e[e.AREA=5]="AREA",e[e.ARTICLE=6]="ARTICLE",e[e.ASIDE=7]="ASIDE",e[e.B=8]="B",e[e.BASE=9]="BASE",e[e.BASEFONT=10]="BASEFONT",e[e.BGSOUND=11]="BGSOUND",e[e.BIG=12]="BIG",e[e.BLOCKQUOTE=13]="BLOCKQUOTE",e[e.BODY=14]="BODY",e[e.BR=15]="BR",e[e.BUTTON=16]="BUTTON",e[e.CAPTION=17]="CAPTION",e[e.CENTER=18]="CENTER",e[e.CODE=19]="CODE",e[e.COL=20]="COL",e[e.COLGROUP=21]="COLGROUP",e[e.DD=22]="DD",e[e.DESC=23]="DESC",e[e.DETAILS=24]="DETAILS",e[e.DIALOG=25]="DIALOG",e[e.DIR=26]="DIR",e[e.DIV=27]="DIV",e[e.DL=28]="DL",e[e.DT=29]="DT",e[e.EM=30]="EM",e[e.EMBED=31]="EMBED",e[e.FIELDSET=32]="FIELDSET",e[e.FIGCAPTION=33]="FIGCAPTION",e[e.FIGURE=34]="FIGURE",e[e.FONT=35]="FONT",e[e.FOOTER=36]="FOOTER",e[e.FOREIGN_OBJECT=37]="FOREIGN_OBJECT",e[e.FORM=38]="FORM",e[e.FRAME=39]="FRAME",e[e.FRAMESET=40]="FRAMESET",e[e.H1=41]="H1",e[e.H2=42]="H2",e[e.H3=43]="H3",e[e.H4=44]="H4",e[e.H5=45]="H5",e[e.H6=46]="H6",e[e.HEAD=47]="HEAD",e[e.HEADER=48]="HEADER",e[e.HGROUP=49]="HGROUP",e[e.HR=50]="HR",e[e.HTML=51]="HTML",e[e.I=52]="I",e[e.IMG=53]="IMG",e[e.IMAGE=54]="IMAGE",e[e.INPUT=55]="INPUT",e[e.IFRAME=56]="IFRAME",e[e.KEYGEN=57]="KEYGEN",e[e.LABEL=58]="LABEL",e[e.LI=59]="LI",e[e.LINK=60]="LINK",e[e.LISTING=61]="LISTING",e[e.MAIN=62]="MAIN",e[e.MALIGNMARK=63]="MALIGNMARK",e[e.MARQUEE=64]="MARQUEE",e[e.MATH=65]="MATH",e[e.MENU=66]="MENU",e[e.META=67]="META",e[e.MGLYPH=68]="MGLYPH",e[e.MI=69]="MI",e[e.MO=70]="MO",e[e.MN=71]="MN",e[e.MS=72]="MS",e[e.MTEXT=73]="MTEXT",e[e.NAV=74]="NAV",e[e.NOBR=75]="NOBR",e[e.NOFRAMES=76]="NOFRAMES",e[e.NOEMBED=77]="NOEMBED",e[e.NOSCRIPT=78]="NOSCRIPT",e[e.OBJECT=79]="OBJECT",e[e.OL=80]="OL",e[e.OPTGROUP=81]="OPTGROUP",e[e.OPTION=82]="OPTION",e[e.P=83]="P",e[e.PARAM=84]="PARAM",e[e.PLAINTEXT=85]="PLAINTEXT",e[e.PRE=86]="PRE",e[e.RB=87]="RB",e[e.RP=88]="RP",e[e.RT=89]="RT",e[e.RTC=90]="RTC",e[e.RUBY=91]="RUBY",e[e.S=92]="S",e[e.SCRIPT=93]="SCRIPT",e[e.SECTION=94]="SECTION",e[e.SELECT=95]="SELECT",e[e.SOURCE=96]="SOURCE",e[e.SMALL=97]="SMALL",e[e.SPAN=98]="SPAN",e[e.STRIKE=99]="STRIKE",e[e.STRONG=100]="STRONG",e[e.STYLE=101]="STYLE",e[e.SUB=102]="SUB",e[e.SUMMARY=103]="SUMMARY",e[e.SUP=104]="SUP",e[e.TABLE=105]="TABLE",e[e.TBODY=106]="TBODY",e[e.TEMPLATE=107]="TEMPLATE",e[e.TEXTAREA=108]="TEXTAREA",e[e.TFOOT=109]="TFOOT",e[e.TD=110]="TD",e[e.TH=111]="TH",e[e.THEAD=112]="THEAD",e[e.TITLE=113]="TITLE",e[e.TR=114]="TR",e[e.TRACK=115]="TRACK",e[e.TT=116]="TT",e[e.U=117]="U",e[e.UL=118]="UL",e[e.SVG=119]="SVG",e[e.VAR=120]="VAR",e[e.WBR=121]="WBR",e[e.XMP=122]="XMP";}(u=u||(u={}));const O=new Map([[N.A,u.A],[N.ADDRESS,u.ADDRESS],[N.ANNOTATION_XML,u.ANNOTATION_XML],[N.APPLET,u.APPLET],[N.AREA,u.AREA],[N.ARTICLE,u.ARTICLE],[N.ASIDE,u.ASIDE],[N.B,u.B],[N.BASE,u.BASE],[N.BASEFONT,u.BASEFONT],[N.BGSOUND,u.BGSOUND],[N.BIG,u.BIG],[N.BLOCKQUOTE,u.BLOCKQUOTE],[N.BODY,u.BODY],[N.BR,u.BR],[N.BUTTON,u.BUTTON],[N.CAPTION,u.CAPTION],[N.CENTER,u.CENTER],[N.CODE,u.CODE],[N.COL,u.COL],[N.COLGROUP,u.COLGROUP],[N.DD,u.DD],[N.DESC,u.DESC],[N.DETAILS,u.DETAILS],[N.DIALOG,u.DIALOG],[N.DIR,u.DIR],[N.DIV,u.DIV],[N.DL,u.DL],[N.DT,u.DT],[N.EM,u.EM],[N.EMBED,u.EMBED],[N.FIELDSET,u.FIELDSET],[N.FIGCAPTION,u.FIGCAPTION],[N.FIGURE,u.FIGURE],[N.FONT,u.FONT],[N.FOOTER,u.FOOTER],[N.FOREIGN_OBJECT,u.FOREIGN_OBJECT],[N.FORM,u.FORM],[N.FRAME,u.FRAME],[N.FRAMESET,u.FRAMESET],[N.H1,u.H1],[N.H2,u.H2],[N.H3,u.H3],[N.H4,u.H4],[N.H5,u.H5],[N.H6,u.H6],[N.HEAD,u.HEAD],[N.HEADER,u.HEADER],[N.HGROUP,u.HGROUP],[N.HR,u.HR],[N.HTML,u.HTML],[N.I,u.I],[N.IMG,u.IMG],[N.IMAGE,u.IMAGE],[N.INPUT,u.INPUT],[N.IFRAME,u.IFRAME],[N.KEYGEN,u.KEYGEN],[N.LABEL,u.LABEL],[N.LI,u.LI],[N.LINK,u.LINK],[N.LISTING,u.LISTING],[N.MAIN,u.MAIN],[N.MALIGNMARK,u.MALIGNMARK],[N.MARQUEE,u.MARQUEE],[N.MATH,u.MATH],[N.MENU,u.MENU],[N.META,u.META],[N.MGLYPH,u.MGLYPH],[N.MI,u.MI],[N.MO,u.MO],[N.MN,u.MN],[N.MS,u.MS],[N.MTEXT,u.MTEXT],[N.NAV,u.NAV],[N.NOBR,u.NOBR],[N.NOFRAMES,u.NOFRAMES],[N.NOEMBED,u.NOEMBED],[N.NOSCRIPT,u.NOSCRIPT],[N.OBJECT,u.OBJECT],[N.OL,u.OL],[N.OPTGROUP,u.OPTGROUP],[N.OPTION,u.OPTION],[N.P,u.P],[N.PARAM,u.PARAM],[N.PLAINTEXT,u.PLAINTEXT],[N.PRE,u.PRE],[N.RB,u.RB],[N.RP,u.RP],[N.RT,u.RT],[N.RTC,u.RTC],[N.RUBY,u.RUBY],[N.S,u.S],[N.SCRIPT,u.SCRIPT],[N.SECTION,u.SECTION],[N.SELECT,u.SELECT],[N.SOURCE,u.SOURCE],[N.SMALL,u.SMALL],[N.SPAN,u.SPAN],[N.STRIKE,u.STRIKE],[N.STRONG,u.STRONG],[N.STYLE,u.STYLE],[N.SUB,u.SUB],[N.SUMMARY,u.SUMMARY],[N.SUP,u.SUP],[N.TABLE,u.TABLE],[N.TBODY,u.TBODY],[N.TEMPLATE,u.TEMPLATE],[N.TEXTAREA,u.TEXTAREA],[N.TFOOT,u.TFOOT],[N.TD,u.TD],[N.TH,u.TH],[N.THEAD,u.THEAD],[N.TITLE,u.TITLE],[N.TR,u.TR],[N.TRACK,u.TRACK],[N.TT,u.TT],[N.U,u.U],[N.UL,u.UL],[N.SVG,u.SVG],[N.VAR,u.VAR],[N.WBR,u.WBR],[N.XMP,u.XMP]]);function f(e){var t;return null!==(t=O.get(e))&&void 0!==t?t:u.UNKNOWN}const L=u,g={[p.HTML]:new Set([L.ADDRESS,L.APPLET,L.AREA,L.ARTICLE,L.ASIDE,L.BASE,L.BASEFONT,L.BGSOUND,L.BLOCKQUOTE,L.BODY,L.BR,L.BUTTON,L.CAPTION,L.CENTER,L.COL,L.COLGROUP,L.DD,L.DETAILS,L.DIR,L.DIV,L.DL,L.DT,L.EMBED,L.FIELDSET,L.FIGCAPTION,L.FIGURE,L.FOOTER,L.FORM,L.FRAME,L.FRAMESET,L.H1,L.H2,L.H3,L.H4,L.H5,L.H6,L.HEAD,L.HEADER,L.HGROUP,L.HR,L.HTML,L.IFRAME,L.IMG,L.INPUT,L.LI,L.LINK,L.LISTING,L.MAIN,L.MARQUEE,L.MENU,L.META,L.NAV,L.NOEMBED,L.NOFRAMES,L.NOSCRIPT,L.OBJECT,L.OL,L.P,L.PARAM,L.PLAINTEXT,L.PRE,L.SCRIPT,L.SECTION,L.SELECT,L.SOURCE,L.STYLE,L.SUMMARY,L.TABLE,L.TBODY,L.TD,L.TEMPLATE,L.TEXTAREA,L.TFOOT,L.TH,L.THEAD,L.TITLE,L.TR,L.TRACK,L.UL,L.WBR,L.XMP]),[p.MATHML]:new Set([L.MI,L.MO,L.MN,L.MS,L.MTEXT,L.ANNOTATION_XML]),[p.SVG]:new Set([L.TITLE,L.FOREIGN_OBJECT,L.DESC]),[p.XLINK]:new Set,[p.XML]:new Set,[p.XMLNS]:new Set};function M(e){return e===L.H1||e===L.H2||e===L.H3||e===L.H4||e===L.H5||e===L.H6}new Set([N.STYLE,N.SCRIPT,N.XMP,N.IFRAME,N.NOEMBED,N.NOFRAMES,N.PLAINTEXT]);const k=new Map([[128,8364],[130,8218],[131,402],[132,8222],[133,8230],[134,8224],[135,8225],[136,710],[137,8240],[138,352],[139,8249],[140,338],[142,381],[145,8216],[146,8217],[147,8220],[148,8221],[149,8226],[150,8211],[151,8212],[152,732],[153,8482],[154,353],[155,8250],[156,339],[158,382],[159,376]]);var P;!function(e){e[e.DATA=0]="DATA",e[e.RCDATA=1]="RCDATA",e[e.RAWTEXT=2]="RAWTEXT",e[e.SCRIPT_DATA=3]="SCRIPT_DATA",e[e.PLAINTEXT=4]="PLAINTEXT",e[e.TAG_OPEN=5]="TAG_OPEN",e[e.END_TAG_OPEN=6]="END_TAG_OPEN",e[e.TAG_NAME=7]="TAG_NAME",e[e.RCDATA_LESS_THAN_SIGN=8]="RCDATA_LESS_THAN_SIGN",e[e.RCDATA_END_TAG_OPEN=9]="RCDATA_END_TAG_OPEN",e[e.RCDATA_END_TAG_NAME=10]="RCDATA_END_TAG_NAME",e[e.RAWTEXT_LESS_THAN_SIGN=11]="RAWTEXT_LESS_THAN_SIGN",e[e.RAWTEXT_END_TAG_OPEN=12]="RAWTEXT_END_TAG_OPEN",e[e.RAWTEXT_END_TAG_NAME=13]="RAWTEXT_END_TAG_NAME",e[e.SCRIPT_DATA_LESS_THAN_SIGN=14]="SCRIPT_DATA_LESS_THAN_SIGN",e[e.SCRIPT_DATA_END_TAG_OPEN=15]="SCRIPT_DATA_END_TAG_OPEN",e[e.SCRIPT_DATA_END_TAG_NAME=16]="SCRIPT_DATA_END_TAG_NAME",e[e.SCRIPT_DATA_ESCAPE_START=17]="SCRIPT_DATA_ESCAPE_START",e[e.SCRIPT_DATA_ESCAPE_START_DASH=18]="SCRIPT_DATA_ESCAPE_START_DASH",e[e.SCRIPT_DATA_ESCAPED=19]="SCRIPT_DATA_ESCAPED",e[e.SCRIPT_DATA_ESCAPED_DASH=20]="SCRIPT_DATA_ESCAPED_DASH",e[e.SCRIPT_DATA_ESCAPED_DASH_DASH=21]="SCRIPT_DATA_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN=22]="SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN=23]="SCRIPT_DATA_ESCAPED_END_TAG_OPEN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME=24]="SCRIPT_DATA_ESCAPED_END_TAG_NAME",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START=25]="SCRIPT_DATA_DOUBLE_ESCAPE_START",e[e.SCRIPT_DATA_DOUBLE_ESCAPED=26]="SCRIPT_DATA_DOUBLE_ESCAPED",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH=27]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH=28]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN=29]="SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END=30]="SCRIPT_DATA_DOUBLE_ESCAPE_END",e[e.BEFORE_ATTRIBUTE_NAME=31]="BEFORE_ATTRIBUTE_NAME",e[e.ATTRIBUTE_NAME=32]="ATTRIBUTE_NAME",e[e.AFTER_ATTRIBUTE_NAME=33]="AFTER_ATTRIBUTE_NAME",e[e.BEFORE_ATTRIBUTE_VALUE=34]="BEFORE_ATTRIBUTE_VALUE",e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED=35]="ATTRIBUTE_VALUE_DOUBLE_QUOTED",e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED=36]="ATTRIBUTE_VALUE_SINGLE_QUOTED",e[e.ATTRIBUTE_VALUE_UNQUOTED=37]="ATTRIBUTE_VALUE_UNQUOTED",e[e.AFTER_ATTRIBUTE_VALUE_QUOTED=38]="AFTER_ATTRIBUTE_VALUE_QUOTED",e[e.SELF_CLOSING_START_TAG=39]="SELF_CLOSING_START_TAG",e[e.BOGUS_COMMENT=40]="BOGUS_COMMENT",e[e.MARKUP_DECLARATION_OPEN=41]="MARKUP_DECLARATION_OPEN",e[e.COMMENT_START=42]="COMMENT_START",e[e.COMMENT_START_DASH=43]="COMMENT_START_DASH",e[e.COMMENT=44]="COMMENT",e[e.COMMENT_LESS_THAN_SIGN=45]="COMMENT_LESS_THAN_SIGN",e[e.COMMENT_LESS_THAN_SIGN_BANG=46]="COMMENT_LESS_THAN_SIGN_BANG",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH=47]="COMMENT_LESS_THAN_SIGN_BANG_DASH",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH=48]="COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH",e[e.COMMENT_END_DASH=49]="COMMENT_END_DASH",e[e.COMMENT_END=50]="COMMENT_END",e[e.COMMENT_END_BANG=51]="COMMENT_END_BANG",e[e.DOCTYPE=52]="DOCTYPE",e[e.BEFORE_DOCTYPE_NAME=53]="BEFORE_DOCTYPE_NAME",e[e.DOCTYPE_NAME=54]="DOCTYPE_NAME",e[e.AFTER_DOCTYPE_NAME=55]="AFTER_DOCTYPE_NAME",e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD=56]="AFTER_DOCTYPE_PUBLIC_KEYWORD",e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER=57]="BEFORE_DOCTYPE_PUBLIC_IDENTIFIER",e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED=58]="DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED=59]="DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER=60]="AFTER_DOCTYPE_PUBLIC_IDENTIFIER",e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS=61]="BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS",e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD=62]="AFTER_DOCTYPE_SYSTEM_KEYWORD",e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER=63]="BEFORE_DOCTYPE_SYSTEM_IDENTIFIER",e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED=64]="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED=65]="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER=66]="AFTER_DOCTYPE_SYSTEM_IDENTIFIER",e[e.BOGUS_DOCTYPE=67]="BOGUS_DOCTYPE",e[e.CDATA_SECTION=68]="CDATA_SECTION",e[e.CDATA_SECTION_BRACKET=69]="CDATA_SECTION_BRACKET",e[e.CDATA_SECTION_END=70]="CDATA_SECTION_END",e[e.CHARACTER_REFERENCE=71]="CHARACTER_REFERENCE",e[e.NAMED_CHARACTER_REFERENCE=72]="NAMED_CHARACTER_REFERENCE",e[e.AMBIGUOUS_AMPERSAND=73]="AMBIGUOUS_AMPERSAND",e[e.NUMERIC_CHARACTER_REFERENCE=74]="NUMERIC_CHARACTER_REFERENCE",e[e.HEXADEMICAL_CHARACTER_REFERENCE_START=75]="HEXADEMICAL_CHARACTER_REFERENCE_START",e[e.HEXADEMICAL_CHARACTER_REFERENCE=76]="HEXADEMICAL_CHARACTER_REFERENCE",e[e.DECIMAL_CHARACTER_REFERENCE=77]="DECIMAL_CHARACTER_REFERENCE",e[e.NUMERIC_CHARACTER_REFERENCE_END=78]="NUMERIC_CHARACTER_REFERENCE_END";}(P||(P={}));const b={DATA:P.DATA,RCDATA:P.RCDATA,RAWTEXT:P.RAWTEXT,SCRIPT_DATA:P.SCRIPT_DATA,PLAINTEXT:P.PLAINTEXT,CDATA_SECTION:P.CDATA_SECTION};function B(e){return e>=a.DIGIT_0&&e<=a.DIGIT_9}function H(e){return e>=a.LATIN_CAPITAL_A&&e<=a.LATIN_CAPITAL_Z}function F(e){return function(e){return e>=a.LATIN_SMALL_A&&e<=a.LATIN_SMALL_Z}(e)||H(e)}function U(e){return F(e)||B(e)}function G(e){return e>=a.LATIN_CAPITAL_A&&e<=a.LATIN_CAPITAL_F}function y(e){return e>=a.LATIN_SMALL_A&&e<=a.LATIN_SMALL_F}function w(e){return e+32}function Y(e){return e===a.SPACE||e===a.LINE_FEED||e===a.TABULATION||e===a.FORM_FEED}function x(e){return Y(e)||e===a.SOLIDUS||e===a.GREATER_THAN_SIGN}class v{constructor(e,t){this.options=e,this.handler=t,this.paused=!1,this.inLoop=!1,this.inForeignNode=!1,this.lastStartTagName="",this.active=!1,this.state=P.DATA,this.returnState=P.DATA,this.charRefCode=-1,this.consumedAfterSnapshot=-1,this.currentCharacterToken=null,this.currentToken=null,this.currentAttr={name:"",value:""},this.preprocessor=new _(t),this.currentLocation=this.getCurrentLocation(-1);}_err(e){var t,s;null===(s=(t=this.handler).onParseError)||void 0===s||s.call(t,this.preprocessor.getError(e));}getCurrentLocation(e){return this.options.sourceCodeLocationInfo?{startLine:this.preprocessor.line,startCol:this.preprocessor.col-e,startOffset:this.preprocessor.offset-e,endLine:-1,endCol:-1,endOffset:-1}:null}_runParsingLoop(){if(!this.inLoop){for(this.inLoop=!0;this.active&&!this.paused;){this.consumedAfterSnapshot=0;const e=this._consume();this._ensureHibernation()||this._callState(e);}this.inLoop=!1;}}pause(){this.paused=!0;}resume(e){if(!this.paused)throw new Error("Parser was already resumed");this.paused=!1,this.inLoop||(this._runParsingLoop(),this.paused||null==e||e());}write(e,t,s){this.active=!0,this.preprocessor.write(e,t),this._runParsingLoop(),this.paused||null==s||s();}insertHtmlAtCurrentPos(e){this.active=!0,this.preprocessor.insertHtmlAtCurrentPos(e),this._runParsingLoop();}_ensureHibernation(){return !!this.preprocessor.endOfChunkHit&&(this._unconsume(this.consumedAfterSnapshot),this.active=!1,!0)}_consume(){return this.consumedAfterSnapshot++,this.preprocessor.advance()}_unconsume(e){this.consumedAfterSnapshot-=e,this.preprocessor.retreat(e);}_reconsumeInState(e,t){this.state=e,this._callState(t);}_advanceBy(e){this.consumedAfterSnapshot+=e;for(let t=0;t<e;t++)this.preprocessor.advance();}_consumeSequenceIfMatch(e,t){return !!this.preprocessor.startsWith(e,t)&&(this._advanceBy(e.length-1),!0)}_createStartTagToken(){this.currentToken={type:h.START_TAG,tagName:"",tagID:u.UNKNOWN,selfClosing:!1,ackSelfClosing:!1,attrs:[],location:this.getCurrentLocation(1)};}_createEndTagToken(){this.currentToken={type:h.END_TAG,tagName:"",tagID:u.UNKNOWN,selfClosing:!1,ackSelfClosing:!1,attrs:[],location:this.getCurrentLocation(2)};}_createCommentToken(e){this.currentToken={type:h.COMMENT,data:"",location:this.getCurrentLocation(e)};}_createDoctypeToken(e){this.currentToken={type:h.DOCTYPE,name:e,forceQuirks:!1,publicId:null,systemId:null,location:this.currentLocation};}_createCharacterToken(e,t){this.currentCharacterToken={type:e,chars:t,location:this.currentLocation};}_createAttr(e){this.currentAttr={name:e,value:""},this.currentLocation=this.getCurrentLocation(0);}_leaveAttrName(){var e,t;const s=this.currentToken;null===A(s,this.currentAttr.name)?(s.attrs.push(this.currentAttr),s.location&&this.currentLocation&&((null!==(e=(t=s.location).attrs)&&void 0!==e?e:t.attrs=Object.create(null))[this.currentAttr.name]=this.currentLocation,this._leaveAttrValue())):this._err(T.duplicateAttribute);}_leaveAttrValue(){this.currentLocation&&(this.currentLocation.endLine=this.preprocessor.line,this.currentLocation.endCol=this.preprocessor.col,this.currentLocation.endOffset=this.preprocessor.offset);}prepareToken(e){this._emitCurrentCharacterToken(e.location),this.currentToken=null,e.location&&(e.location.endLine=this.preprocessor.line,e.location.endCol=this.preprocessor.col+1,e.location.endOffset=this.preprocessor.offset+1),this.currentLocation=this.getCurrentLocation(-1);}emitCurrentTagToken(){const e=this.currentToken;this.prepareToken(e),e.tagID=f(e.tagName),e.type===h.START_TAG?(this.lastStartTagName=e.tagName,this.handler.onStartTag(e)):(e.attrs.length>0&&this._err(T.endTagWithAttributes),e.selfClosing&&this._err(T.endTagWithTrailingSolidus),this.handler.onEndTag(e)),this.preprocessor.dropParsedChunk();}emitCurrentComment(e){this.prepareToken(e),this.handler.onComment(e),this.preprocessor.dropParsedChunk();}emitCurrentDoctype(e){this.prepareToken(e),this.handler.onDoctype(e),this.preprocessor.dropParsedChunk();}_emitCurrentCharacterToken(e){if(this.currentCharacterToken){switch(e&&this.currentCharacterToken.location&&(this.currentCharacterToken.location.endLine=e.startLine,this.currentCharacterToken.location.endCol=e.startCol,this.currentCharacterToken.location.endOffset=e.startOffset),this.currentCharacterToken.type){case h.CHARACTER:this.handler.onCharacter(this.currentCharacterToken);break;case h.NULL_CHARACTER:this.handler.onNullCharacter(this.currentCharacterToken);break;case h.WHITESPACE_CHARACTER:this.handler.onWhitespaceCharacter(this.currentCharacterToken);}this.currentCharacterToken=null;}}_emitEOFToken(){const e=this.getCurrentLocation(0);e&&(e.endLine=e.startLine,e.endCol=e.startCol,e.endOffset=e.startOffset),this._emitCurrentCharacterToken(e),this.handler.onEof({type:h.EOF,location:e}),this.active=!1;}_appendCharToCurrentCharacterToken(e,t){if(this.currentCharacterToken){if(this.currentCharacterToken.type===e)return void(this.currentCharacterToken.chars+=t);this.currentLocation=this.getCurrentLocation(0),this._emitCurrentCharacterToken(this.currentLocation),this.preprocessor.dropParsedChunk();}this._createCharacterToken(e,t);}_emitCodePoint(e){const t=Y(e)?h.WHITESPACE_CHARACTER:e===a.NULL?h.NULL_CHARACTER:h.CHARACTER;this._appendCharToCurrentCharacterToken(t,String.fromCodePoint(e));}_emitChars(e){this._appendCharToCurrentCharacterToken(h.CHARACTER,e);}_matchNamedCharacterReference(e){let t=null,s=0,r=!1;for(let i=0,o=R.htmlDecodeTree[0];i>=0&&(i=R.determineBranch(R.htmlDecodeTree,o,i+1,e),!(i<0));e=this._consume()){s+=1,o=R.htmlDecodeTree[i];const c=o&R.BinTrieFlags.VALUE_LENGTH;if(c){const o=(c>>14)-1;if(e!==a.SEMICOLON&&this._isCharacterReferenceInAttribute()&&((n=this.preprocessor.peek(1))===a.EQUALS_SIGN||U(n))?(t=[a.AMPERSAND],i+=o):(t=0===o?[R.htmlDecodeTree[i]&~R.BinTrieFlags.VALUE_LENGTH]:1===o?[R.htmlDecodeTree[++i]]:[R.htmlDecodeTree[++i],R.htmlDecodeTree[++i]],s=0,r=e!==a.SEMICOLON),0===o){this._consume();break}}}var n;return this._unconsume(s),r&&!this.preprocessor.endOfChunkHit&&this._err(T.missingSemicolonAfterCharacterReference),this._unconsume(1),t}_isCharacterReferenceInAttribute(){return this.returnState===P.ATTRIBUTE_VALUE_DOUBLE_QUOTED||this.returnState===P.ATTRIBUTE_VALUE_SINGLE_QUOTED||this.returnState===P.ATTRIBUTE_VALUE_UNQUOTED}_flushCodePointConsumedAsCharacterReference(e){this._isCharacterReferenceInAttribute()?this.currentAttr.value+=String.fromCodePoint(e):this._emitCodePoint(e);}_callState(e){switch(this.state){case P.DATA:this._stateData(e);break;case P.RCDATA:this._stateRcdata(e);break;case P.RAWTEXT:this._stateRawtext(e);break;case P.SCRIPT_DATA:this._stateScriptData(e);break;case P.PLAINTEXT:this._statePlaintext(e);break;case P.TAG_OPEN:this._stateTagOpen(e);break;case P.END_TAG_OPEN:this._stateEndTagOpen(e);break;case P.TAG_NAME:this._stateTagName(e);break;case P.RCDATA_LESS_THAN_SIGN:this._stateRcdataLessThanSign(e);break;case P.RCDATA_END_TAG_OPEN:this._stateRcdataEndTagOpen(e);break;case P.RCDATA_END_TAG_NAME:this._stateRcdataEndTagName(e);break;case P.RAWTEXT_LESS_THAN_SIGN:this._stateRawtextLessThanSign(e);break;case P.RAWTEXT_END_TAG_OPEN:this._stateRawtextEndTagOpen(e);break;case P.RAWTEXT_END_TAG_NAME:this._stateRawtextEndTagName(e);break;case P.SCRIPT_DATA_LESS_THAN_SIGN:this._stateScriptDataLessThanSign(e);break;case P.SCRIPT_DATA_END_TAG_OPEN:this._stateScriptDataEndTagOpen(e);break;case P.SCRIPT_DATA_END_TAG_NAME:this._stateScriptDataEndTagName(e);break;case P.SCRIPT_DATA_ESCAPE_START:this._stateScriptDataEscapeStart(e);break;case P.SCRIPT_DATA_ESCAPE_START_DASH:this._stateScriptDataEscapeStartDash(e);break;case P.SCRIPT_DATA_ESCAPED:this._stateScriptDataEscaped(e);break;case P.SCRIPT_DATA_ESCAPED_DASH:this._stateScriptDataEscapedDash(e);break;case P.SCRIPT_DATA_ESCAPED_DASH_DASH:this._stateScriptDataEscapedDashDash(e);break;case P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:this._stateScriptDataEscapedLessThanSign(e);break;case P.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:this._stateScriptDataEscapedEndTagOpen(e);break;case P.SCRIPT_DATA_ESCAPED_END_TAG_NAME:this._stateScriptDataEscapedEndTagName(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPE_START:this._stateScriptDataDoubleEscapeStart(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPED:this._stateScriptDataDoubleEscaped(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:this._stateScriptDataDoubleEscapedDash(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:this._stateScriptDataDoubleEscapedDashDash(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:this._stateScriptDataDoubleEscapedLessThanSign(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPE_END:this._stateScriptDataDoubleEscapeEnd(e);break;case P.BEFORE_ATTRIBUTE_NAME:this._stateBeforeAttributeName(e);break;case P.ATTRIBUTE_NAME:this._stateAttributeName(e);break;case P.AFTER_ATTRIBUTE_NAME:this._stateAfterAttributeName(e);break;case P.BEFORE_ATTRIBUTE_VALUE:this._stateBeforeAttributeValue(e);break;case P.ATTRIBUTE_VALUE_DOUBLE_QUOTED:this._stateAttributeValueDoubleQuoted(e);break;case P.ATTRIBUTE_VALUE_SINGLE_QUOTED:this._stateAttributeValueSingleQuoted(e);break;case P.ATTRIBUTE_VALUE_UNQUOTED:this._stateAttributeValueUnquoted(e);break;case P.AFTER_ATTRIBUTE_VALUE_QUOTED:this._stateAfterAttributeValueQuoted(e);break;case P.SELF_CLOSING_START_TAG:this._stateSelfClosingStartTag(e);break;case P.BOGUS_COMMENT:this._stateBogusComment(e);break;case P.MARKUP_DECLARATION_OPEN:this._stateMarkupDeclarationOpen(e);break;case P.COMMENT_START:this._stateCommentStart(e);break;case P.COMMENT_START_DASH:this._stateCommentStartDash(e);break;case P.COMMENT:this._stateComment(e);break;case P.COMMENT_LESS_THAN_SIGN:this._stateCommentLessThanSign(e);break;case P.COMMENT_LESS_THAN_SIGN_BANG:this._stateCommentLessThanSignBang(e);break;case P.COMMENT_LESS_THAN_SIGN_BANG_DASH:this._stateCommentLessThanSignBangDash(e);break;case P.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:this._stateCommentLessThanSignBangDashDash(e);break;case P.COMMENT_END_DASH:this._stateCommentEndDash(e);break;case P.COMMENT_END:this._stateCommentEnd(e);break;case P.COMMENT_END_BANG:this._stateCommentEndBang(e);break;case P.DOCTYPE:this._stateDoctype(e);break;case P.BEFORE_DOCTYPE_NAME:this._stateBeforeDoctypeName(e);break;case P.DOCTYPE_NAME:this._stateDoctypeName(e);break;case P.AFTER_DOCTYPE_NAME:this._stateAfterDoctypeName(e);break;case P.AFTER_DOCTYPE_PUBLIC_KEYWORD:this._stateAfterDoctypePublicKeyword(e);break;case P.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:this._stateBeforeDoctypePublicIdentifier(e);break;case P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:this._stateDoctypePublicIdentifierDoubleQuoted(e);break;case P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:this._stateDoctypePublicIdentifierSingleQuoted(e);break;case P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:this._stateAfterDoctypePublicIdentifier(e);break;case P.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:this._stateBetweenDoctypePublicAndSystemIdentifiers(e);break;case P.AFTER_DOCTYPE_SYSTEM_KEYWORD:this._stateAfterDoctypeSystemKeyword(e);break;case P.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:this._stateBeforeDoctypeSystemIdentifier(e);break;case P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:this._stateDoctypeSystemIdentifierDoubleQuoted(e);break;case P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:this._stateDoctypeSystemIdentifierSingleQuoted(e);break;case P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:this._stateAfterDoctypeSystemIdentifier(e);break;case P.BOGUS_DOCTYPE:this._stateBogusDoctype(e);break;case P.CDATA_SECTION:this._stateCdataSection(e);break;case P.CDATA_SECTION_BRACKET:this._stateCdataSectionBracket(e);break;case P.CDATA_SECTION_END:this._stateCdataSectionEnd(e);break;case P.CHARACTER_REFERENCE:this._stateCharacterReference(e);break;case P.NAMED_CHARACTER_REFERENCE:this._stateNamedCharacterReference(e);break;case P.AMBIGUOUS_AMPERSAND:this._stateAmbiguousAmpersand(e);break;case P.NUMERIC_CHARACTER_REFERENCE:this._stateNumericCharacterReference(e);break;case P.HEXADEMICAL_CHARACTER_REFERENCE_START:this._stateHexademicalCharacterReferenceStart(e);break;case P.HEXADEMICAL_CHARACTER_REFERENCE:this._stateHexademicalCharacterReference(e);break;case P.DECIMAL_CHARACTER_REFERENCE:this._stateDecimalCharacterReference(e);break;case P.NUMERIC_CHARACTER_REFERENCE_END:this._stateNumericCharacterReferenceEnd(e);break;default:throw new Error("Unknown state")}}_stateData(e){switch(e){case a.LESS_THAN_SIGN:this.state=P.TAG_OPEN;break;case a.AMPERSAND:this.returnState=P.DATA,this.state=P.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitCodePoint(e);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateRcdata(e){switch(e){case a.AMPERSAND:this.returnState=P.RCDATA,this.state=P.CHARACTER_REFERENCE;break;case a.LESS_THAN_SIGN:this.state=P.RCDATA_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateRawtext(e){switch(e){case a.LESS_THAN_SIGN:this.state=P.RAWTEXT_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptData(e){switch(e){case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_statePlaintext(e){switch(e){case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateTagOpen(e){if(F(e))this._createStartTagToken(),this.state=P.TAG_NAME,this._stateTagName(e);else switch(e){case a.EXCLAMATION_MARK:this.state=P.MARKUP_DECLARATION_OPEN;break;case a.SOLIDUS:this.state=P.END_TAG_OPEN;break;case a.QUESTION_MARK:this._err(T.unexpectedQuestionMarkInsteadOfTagName),this._createCommentToken(1),this.state=P.BOGUS_COMMENT,this._stateBogusComment(e);break;case a.EOF:this._err(T.eofBeforeTagName),this._emitChars("<"),this._emitEOFToken();break;default:this._err(T.invalidFirstCharacterOfTagName),this._emitChars("<"),this.state=P.DATA,this._stateData(e);}}_stateEndTagOpen(e){if(F(e))this._createEndTagToken(),this.state=P.TAG_NAME,this._stateTagName(e);else switch(e){case a.GREATER_THAN_SIGN:this._err(T.missingEndTagName),this.state=P.DATA;break;case a.EOF:this._err(T.eofBeforeTagName),this._emitChars("</"),this._emitEOFToken();break;default:this._err(T.invalidFirstCharacterOfTagName),this._createCommentToken(2),this.state=P.BOGUS_COMMENT,this._stateBogusComment(e);}}_stateTagName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BEFORE_ATTRIBUTE_NAME;break;case a.SOLIDUS:this.state=P.SELF_CLOSING_START_TAG;break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentTagToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),t.tagName+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:t.tagName+=String.fromCodePoint(H(e)?w(e):e);}}_stateRcdataLessThanSign(e){e===a.SOLIDUS?this.state=P.RCDATA_END_TAG_OPEN:(this._emitChars("<"),this.state=P.RCDATA,this._stateRcdata(e));}_stateRcdataEndTagOpen(e){F(e)?(this.state=P.RCDATA_END_TAG_NAME,this._stateRcdataEndTagName(e)):(this._emitChars("</"),this.state=P.RCDATA,this._stateRcdata(e));}handleSpecialEndTag(e){if(!this.preprocessor.startsWith(this.lastStartTagName,!1))return !this._ensureHibernation();switch(this._createEndTagToken(),this.currentToken.tagName=this.lastStartTagName,this.preprocessor.peek(this.lastStartTagName.length)){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:return this._advanceBy(this.lastStartTagName.length),this.state=P.BEFORE_ATTRIBUTE_NAME,!1;case a.SOLIDUS:return this._advanceBy(this.lastStartTagName.length),this.state=P.SELF_CLOSING_START_TAG,!1;case a.GREATER_THAN_SIGN:return this._advanceBy(this.lastStartTagName.length),this.emitCurrentTagToken(),this.state=P.DATA,!1;default:return !this._ensureHibernation()}}_stateRcdataEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=P.RCDATA,this._stateRcdata(e));}_stateRawtextLessThanSign(e){e===a.SOLIDUS?this.state=P.RAWTEXT_END_TAG_OPEN:(this._emitChars("<"),this.state=P.RAWTEXT,this._stateRawtext(e));}_stateRawtextEndTagOpen(e){F(e)?(this.state=P.RAWTEXT_END_TAG_NAME,this._stateRawtextEndTagName(e)):(this._emitChars("</"),this.state=P.RAWTEXT,this._stateRawtext(e));}_stateRawtextEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=P.RAWTEXT,this._stateRawtext(e));}_stateScriptDataLessThanSign(e){switch(e){case a.SOLIDUS:this.state=P.SCRIPT_DATA_END_TAG_OPEN;break;case a.EXCLAMATION_MARK:this.state=P.SCRIPT_DATA_ESCAPE_START,this._emitChars("<!");break;default:this._emitChars("<"),this.state=P.SCRIPT_DATA,this._stateScriptData(e);}}_stateScriptDataEndTagOpen(e){F(e)?(this.state=P.SCRIPT_DATA_END_TAG_NAME,this._stateScriptDataEndTagName(e)):(this._emitChars("</"),this.state=P.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=P.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscapeStart(e){e===a.HYPHEN_MINUS?(this.state=P.SCRIPT_DATA_ESCAPE_START_DASH,this._emitChars("-")):(this.state=P.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscapeStartDash(e){e===a.HYPHEN_MINUS?(this.state=P.SCRIPT_DATA_ESCAPED_DASH_DASH,this._emitChars("-")):(this.state=P.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscaped(e){switch(e){case a.HYPHEN_MINUS:this.state=P.SCRIPT_DATA_ESCAPED_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptDataEscapedDash(e){switch(e){case a.HYPHEN_MINUS:this.state=P.SCRIPT_DATA_ESCAPED_DASH_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=P.SCRIPT_DATA_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=P.SCRIPT_DATA_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataEscapedDashDash(e){switch(e){case a.HYPHEN_MINUS:this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.GREATER_THAN_SIGN:this.state=P.SCRIPT_DATA,this._emitChars(">");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=P.SCRIPT_DATA_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=P.SCRIPT_DATA_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataEscapedLessThanSign(e){e===a.SOLIDUS?this.state=P.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:F(e)?(this._emitChars("<"),this.state=P.SCRIPT_DATA_DOUBLE_ESCAPE_START,this._stateScriptDataDoubleEscapeStart(e)):(this._emitChars("<"),this.state=P.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataEscapedEndTagOpen(e){F(e)?(this.state=P.SCRIPT_DATA_ESCAPED_END_TAG_NAME,this._stateScriptDataEscapedEndTagName(e)):(this._emitChars("</"),this.state=P.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataEscapedEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=P.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataDoubleEscapeStart(e){if(this.preprocessor.startsWith(i,!1)&&x(this.preprocessor.peek(i.length))){this._emitCodePoint(e);for(let e=0;e<i.length;e++)this._emitCodePoint(this._consume());this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED;}else this._ensureHibernation()||(this.state=P.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataDoubleEscaped(e){switch(e){case a.HYPHEN_MINUS:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedDash(e){switch(e){case a.HYPHEN_MINUS:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedDashDash(e){switch(e){case a.HYPHEN_MINUS:this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.GREATER_THAN_SIGN:this.state=P.SCRIPT_DATA,this._emitChars(">");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedLessThanSign(e){e===a.SOLIDUS?(this.state=P.SCRIPT_DATA_DOUBLE_ESCAPE_END,this._emitChars("/")):(this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._stateScriptDataDoubleEscaped(e));}_stateScriptDataDoubleEscapeEnd(e){if(this.preprocessor.startsWith(i,!1)&&x(this.preprocessor.peek(i.length))){this._emitCodePoint(e);for(let e=0;e<i.length;e++)this._emitCodePoint(this._consume());this.state=P.SCRIPT_DATA_ESCAPED;}else this._ensureHibernation()||(this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._stateScriptDataDoubleEscaped(e));}_stateBeforeAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.SOLIDUS:case a.GREATER_THAN_SIGN:case a.EOF:this.state=P.AFTER_ATTRIBUTE_NAME,this._stateAfterAttributeName(e);break;case a.EQUALS_SIGN:this._err(T.unexpectedEqualsSignBeforeAttributeName),this._createAttr("="),this.state=P.ATTRIBUTE_NAME;break;default:this._createAttr(""),this.state=P.ATTRIBUTE_NAME,this._stateAttributeName(e);}}_stateAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:case a.SOLIDUS:case a.GREATER_THAN_SIGN:case a.EOF:this._leaveAttrName(),this.state=P.AFTER_ATTRIBUTE_NAME,this._stateAfterAttributeName(e);break;case a.EQUALS_SIGN:this._leaveAttrName(),this.state=P.BEFORE_ATTRIBUTE_VALUE;break;case a.QUOTATION_MARK:case a.APOSTROPHE:case a.LESS_THAN_SIGN:this._err(T.unexpectedCharacterInAttributeName),this.currentAttr.name+=String.fromCodePoint(e);break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.name+=s;break;default:this.currentAttr.name+=String.fromCodePoint(H(e)?w(e):e);}}_stateAfterAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.SOLIDUS:this.state=P.SELF_CLOSING_START_TAG;break;case a.EQUALS_SIGN:this.state=P.BEFORE_ATTRIBUTE_VALUE;break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._createAttr(""),this.state=P.ATTRIBUTE_NAME,this._stateAttributeName(e);}}_stateBeforeAttributeValue(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:this.state=P.ATTRIBUTE_VALUE_DOUBLE_QUOTED;break;case a.APOSTROPHE:this.state=P.ATTRIBUTE_VALUE_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingAttributeValue),this.state=P.DATA,this.emitCurrentTagToken();break;default:this.state=P.ATTRIBUTE_VALUE_UNQUOTED,this._stateAttributeValueUnquoted(e);}}_stateAttributeValueDoubleQuoted(e){switch(e){case a.QUOTATION_MARK:this.state=P.AFTER_ATTRIBUTE_VALUE_QUOTED;break;case a.AMPERSAND:this.returnState=P.ATTRIBUTE_VALUE_DOUBLE_QUOTED,this.state=P.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAttributeValueSingleQuoted(e){switch(e){case a.APOSTROPHE:this.state=P.AFTER_ATTRIBUTE_VALUE_QUOTED;break;case a.AMPERSAND:this.returnState=P.ATTRIBUTE_VALUE_SINGLE_QUOTED,this.state=P.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAttributeValueUnquoted(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this._leaveAttrValue(),this.state=P.BEFORE_ATTRIBUTE_NAME;break;case a.AMPERSAND:this.returnState=P.ATTRIBUTE_VALUE_UNQUOTED,this.state=P.CHARACTER_REFERENCE;break;case a.GREATER_THAN_SIGN:this._leaveAttrValue(),this.state=P.DATA,this.emitCurrentTagToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.QUOTATION_MARK:case a.APOSTROPHE:case a.LESS_THAN_SIGN:case a.EQUALS_SIGN:case a.GRAVE_ACCENT:this._err(T.unexpectedCharacterInUnquotedAttributeValue),this.currentAttr.value+=String.fromCodePoint(e);break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAfterAttributeValueQuoted(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this._leaveAttrValue(),this.state=P.BEFORE_ATTRIBUTE_NAME;break;case a.SOLIDUS:this._leaveAttrValue(),this.state=P.SELF_CLOSING_START_TAG;break;case a.GREATER_THAN_SIGN:this._leaveAttrValue(),this.state=P.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._err(T.missingWhitespaceBetweenAttributes),this.state=P.BEFORE_ATTRIBUTE_NAME,this._stateBeforeAttributeName(e);}}_stateSelfClosingStartTag(e){switch(e){case a.GREATER_THAN_SIGN:this.currentToken.selfClosing=!0,this.state=P.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._err(T.unexpectedSolidusInTag),this.state=P.BEFORE_ATTRIBUTE_NAME,this._stateBeforeAttributeName(e);}}_stateBogusComment(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentComment(t);break;case a.EOF:this.emitCurrentComment(t),this._emitEOFToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),t.data+=s;break;default:t.data+=String.fromCodePoint(e);}}_stateMarkupDeclarationOpen(e){this._consumeSequenceIfMatch("--",!0)?(this._createCommentToken("--".length+1),this.state=P.COMMENT_START):this._consumeSequenceIfMatch(n,!1)?(this.currentLocation=this.getCurrentLocation(n.length+1),this.state=P.DOCTYPE):this._consumeSequenceIfMatch(r,!0)?this.inForeignNode?this.state=P.CDATA_SECTION:(this._err(T.cdataInHtmlContent),this._createCommentToken(r.length+1),this.currentToken.data="[CDATA[",this.state=P.BOGUS_COMMENT):this._ensureHibernation()||(this._err(T.incorrectlyOpenedComment),this._createCommentToken(2),this.state=P.BOGUS_COMMENT,this._stateBogusComment(e));}_stateCommentStart(e){switch(e){case a.HYPHEN_MINUS:this.state=P.COMMENT_START_DASH;break;case a.GREATER_THAN_SIGN:{this._err(T.abruptClosingOfEmptyComment),this.state=P.DATA;const e=this.currentToken;this.emitCurrentComment(e);break}default:this.state=P.COMMENT,this._stateComment(e);}}_stateCommentStartDash(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=P.COMMENT_END;break;case a.GREATER_THAN_SIGN:this._err(T.abruptClosingOfEmptyComment),this.state=P.DATA,this.emitCurrentComment(t);break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="-",this.state=P.COMMENT,this._stateComment(e);}}_stateComment(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=P.COMMENT_END_DASH;break;case a.LESS_THAN_SIGN:t.data+="<",this.state=P.COMMENT_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.data+=s;break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+=String.fromCodePoint(e);}}_stateCommentLessThanSign(e){const t=this.currentToken;switch(e){case a.EXCLAMATION_MARK:t.data+="!",this.state=P.COMMENT_LESS_THAN_SIGN_BANG;break;case a.LESS_THAN_SIGN:t.data+="<";break;default:this.state=P.COMMENT,this._stateComment(e);}}_stateCommentLessThanSignBang(e){e===a.HYPHEN_MINUS?this.state=P.COMMENT_LESS_THAN_SIGN_BANG_DASH:(this.state=P.COMMENT,this._stateComment(e));}_stateCommentLessThanSignBangDash(e){e===a.HYPHEN_MINUS?this.state=P.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:(this.state=P.COMMENT_END_DASH,this._stateCommentEndDash(e));}_stateCommentLessThanSignBangDashDash(e){e!==a.GREATER_THAN_SIGN&&e!==a.EOF&&this._err(T.nestedComment),this.state=P.COMMENT_END,this._stateCommentEnd(e);}_stateCommentEndDash(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=P.COMMENT_END;break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="-",this.state=P.COMMENT,this._stateComment(e);}}_stateCommentEnd(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentComment(t);break;case a.EXCLAMATION_MARK:this.state=P.COMMENT_END_BANG;break;case a.HYPHEN_MINUS:t.data+="-";break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="--",this.state=P.COMMENT,this._stateComment(e);}}_stateCommentEndBang(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:t.data+="--!",this.state=P.COMMENT_END_DASH;break;case a.GREATER_THAN_SIGN:this._err(T.incorrectlyClosedComment),this.state=P.DATA,this.emitCurrentComment(t);break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="--!",this.state=P.COMMENT,this._stateComment(e);}}_stateDoctype(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BEFORE_DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:this.state=P.BEFORE_DOCTYPE_NAME,this._stateBeforeDoctypeName(e);break;case a.EOF:{this._err(T.eofInDoctype),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this._emitEOFToken();break}default:this._err(T.missingWhitespaceBeforeDoctypeName),this.state=P.BEFORE_DOCTYPE_NAME,this._stateBeforeDoctypeName(e);}}_stateBeforeDoctypeName(e){if(H(e))this._createDoctypeToken(String.fromCharCode(w(e))),this.state=P.DOCTYPE_NAME;else switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.NULL:this._err(T.unexpectedNullCharacter),this._createDoctypeToken(s),this.state=P.DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:{this._err(T.missingDoctypeName),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this.state=P.DATA;break}case a.EOF:{this._err(T.eofInDoctype),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this._emitEOFToken();break}default:this._createDoctypeToken(String.fromCodePoint(e)),this.state=P.DOCTYPE_NAME;}}_stateDoctypeName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.AFTER_DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.NULL:this._err(T.unexpectedNullCharacter),t.name+=s;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.name+=String.fromCodePoint(H(e)?w(e):e);}}_stateAfterDoctypeName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._consumeSequenceIfMatch("public",!1)?this.state=P.AFTER_DOCTYPE_PUBLIC_KEYWORD:this._consumeSequenceIfMatch("system",!1)?this.state=P.AFTER_DOCTYPE_SYSTEM_KEYWORD:this._ensureHibernation()||(this._err(T.invalidCharacterSequenceAfterDoctypeName),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e));}}_stateAfterDoctypePublicKeyword(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceAfterDoctypePublicKeyword),t.publicId="",this.state=P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceAfterDoctypePublicKeyword),t.publicId="",this.state=P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypePublicIdentifier),t.forceQuirks=!0,this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypePublicIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBeforeDoctypePublicIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:t.publicId="",this.state=P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.publicId="",this.state=P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypePublicIdentifier),t.forceQuirks=!0,this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypePublicIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateDoctypePublicIdentifierDoubleQuoted(e){const t=this.currentToken;switch(e){case a.QUOTATION_MARK:this.state=P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.publicId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypePublicIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.publicId+=String.fromCodePoint(e);}}_stateDoctypePublicIdentifierSingleQuoted(e){const t=this.currentToken;switch(e){case a.APOSTROPHE:this.state=P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.publicId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypePublicIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.publicId+=String.fromCodePoint(e);}}_stateAfterDoctypePublicIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBetweenDoctypePublicAndSystemIdentifiers(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.QUOTATION_MARK:t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateAfterDoctypeSystemKeyword(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceAfterDoctypeSystemKeyword),t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceAfterDoctypeSystemKeyword),t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBeforeDoctypeSystemIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateDoctypeSystemIdentifierDoubleQuoted(e){const t=this.currentToken;switch(e){case a.QUOTATION_MARK:this.state=P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.systemId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypeSystemIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.systemId+=String.fromCodePoint(e);}}_stateDoctypeSystemIdentifierSingleQuoted(e){const t=this.currentToken;switch(e){case a.APOSTROPHE:this.state=P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.systemId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypeSystemIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.systemId+=String.fromCodePoint(e);}}_stateAfterDoctypeSystemIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.unexpectedCharacterAfterDoctypeSystemIdentifier),this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBogusDoctype(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.NULL:this._err(T.unexpectedNullCharacter);break;case a.EOF:this.emitCurrentDoctype(t),this._emitEOFToken();}}_stateCdataSection(e){switch(e){case a.RIGHT_SQUARE_BRACKET:this.state=P.CDATA_SECTION_BRACKET;break;case a.EOF:this._err(T.eofInCdata),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateCdataSectionBracket(e){e===a.RIGHT_SQUARE_BRACKET?this.state=P.CDATA_SECTION_END:(this._emitChars("]"),this.state=P.CDATA_SECTION,this._stateCdataSection(e));}_stateCdataSectionEnd(e){switch(e){case a.GREATER_THAN_SIGN:this.state=P.DATA;break;case a.RIGHT_SQUARE_BRACKET:this._emitChars("]");break;default:this._emitChars("]]"),this.state=P.CDATA_SECTION,this._stateCdataSection(e);}}_stateCharacterReference(e){e===a.NUMBER_SIGN?this.state=P.NUMERIC_CHARACTER_REFERENCE:U(e)?(this.state=P.NAMED_CHARACTER_REFERENCE,this._stateNamedCharacterReference(e)):(this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._reconsumeInState(this.returnState,e));}_stateNamedCharacterReference(e){const t=this._matchNamedCharacterReference(e);if(this._ensureHibernation());else if(t){for(let e=0;e<t.length;e++)this._flushCodePointConsumedAsCharacterReference(t[e]);this.state=this.returnState;}else this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this.state=P.AMBIGUOUS_AMPERSAND;}_stateAmbiguousAmpersand(e){U(e)?this._flushCodePointConsumedAsCharacterReference(e):(e===a.SEMICOLON&&this._err(T.unknownNamedCharacterReference),this._reconsumeInState(this.returnState,e));}_stateNumericCharacterReference(e){this.charRefCode=0,e===a.LATIN_SMALL_X||e===a.LATIN_CAPITAL_X?this.state=P.HEXADEMICAL_CHARACTER_REFERENCE_START:B(e)?(this.state=P.DECIMAL_CHARACTER_REFERENCE,this._stateDecimalCharacterReference(e)):(this._err(T.absenceOfDigitsInNumericCharacterReference),this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._flushCodePointConsumedAsCharacterReference(a.NUMBER_SIGN),this._reconsumeInState(this.returnState,e));}_stateHexademicalCharacterReferenceStart(e){!function(e){return B(e)||G(e)||y(e)}(e)?(this._err(T.absenceOfDigitsInNumericCharacterReference),this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._flushCodePointConsumedAsCharacterReference(a.NUMBER_SIGN),this._unconsume(2),this.state=this.returnState):(this.state=P.HEXADEMICAL_CHARACTER_REFERENCE,this._stateHexademicalCharacterReference(e));}_stateHexademicalCharacterReference(e){G(e)?this.charRefCode=16*this.charRefCode+e-55:y(e)?this.charRefCode=16*this.charRefCode+e-87:B(e)?this.charRefCode=16*this.charRefCode+e-48:e===a.SEMICOLON?this.state=P.NUMERIC_CHARACTER_REFERENCE_END:(this._err(T.missingSemicolonAfterCharacterReference),this.state=P.NUMERIC_CHARACTER_REFERENCE_END,this._stateNumericCharacterReferenceEnd(e));}_stateDecimalCharacterReference(e){B(e)?this.charRefCode=10*this.charRefCode+e-48:e===a.SEMICOLON?this.state=P.NUMERIC_CHARACTER_REFERENCE_END:(this._err(T.missingSemicolonAfterCharacterReference),this.state=P.NUMERIC_CHARACTER_REFERENCE_END,this._stateNumericCharacterReferenceEnd(e));}_stateNumericCharacterReferenceEnd(e){if(this.charRefCode===a.NULL)this._err(T.nullCharacterReference),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(this.charRefCode>1114111)this._err(T.characterReferenceOutsideUnicodeRange),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(o(this.charRefCode))this._err(T.surrogateCharacterReference),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(E(this.charRefCode))this._err(T.noncharacterCharacterReference);else if(c(this.charRefCode)||this.charRefCode===a.CARRIAGE_RETURN){this._err(T.controlCharacterReference);const e=k.get(this.charRefCode);void 0!==e&&(this.charRefCode=e);}this._flushCodePointConsumedAsCharacterReference(this.charRefCode),this._reconsumeInState(this.returnState,e);}}const Q=new Set([u.DD,u.DT,u.LI,u.OPTGROUP,u.OPTION,u.P,u.RB,u.RP,u.RT,u.RTC]),q=new Set([...Q,u.CAPTION,u.COLGROUP,u.TBODY,u.TD,u.TFOOT,u.TH,u.THEAD,u.TR]),W=new Map([[u.APPLET,p.HTML],[u.CAPTION,p.HTML],[u.HTML,p.HTML],[u.MARQUEE,p.HTML],[u.OBJECT,p.HTML],[u.TABLE,p.HTML],[u.TD,p.HTML],[u.TEMPLATE,p.HTML],[u.TH,p.HTML],[u.ANNOTATION_XML,p.MATHML],[u.MI,p.MATHML],[u.MN,p.MATHML],[u.MO,p.MATHML],[u.MS,p.MATHML],[u.MTEXT,p.MATHML],[u.DESC,p.SVG],[u.FOREIGN_OBJECT,p.SVG],[u.TITLE,p.SVG]]),X=[u.H1,u.H2,u.H3,u.H4,u.H5,u.H6],K=[u.TR,u.TEMPLATE,u.HTML],V=[u.TBODY,u.TFOOT,u.THEAD,u.TEMPLATE,u.HTML],z=[u.TABLE,u.TEMPLATE,u.HTML],j=[u.TD,u.TH];class J{get currentTmplContentOrNode(){return this._isInTemplate()?this.treeAdapter.getTemplateContent(this.current):this.current}constructor(e,t,s){this.treeAdapter=t,this.handler=s,this.items=[],this.tagIDs=[],this.stackTop=-1,this.tmplCount=0,this.currentTagId=u.UNKNOWN,this.current=e;}_indexOf(e){return this.items.lastIndexOf(e,this.stackTop)}_isInTemplate(){return this.currentTagId===u.TEMPLATE&&this.treeAdapter.getNamespaceURI(this.current)===p.HTML}_updateCurrentElement(){this.current=this.items[this.stackTop],this.currentTagId=this.tagIDs[this.stackTop];}push(e,t){this.stackTop++,this.items[this.stackTop]=e,this.current=e,this.tagIDs[this.stackTop]=t,this.currentTagId=t,this._isInTemplate()&&this.tmplCount++,this.handler.onItemPush(e,t,!0);}pop(){const e=this.current;this.tmplCount>0&&this._isInTemplate()&&this.tmplCount--,this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(e,!0);}replace(e,t){const s=this._indexOf(e);this.items[s]=t,s===this.stackTop&&(this.current=t);}insertAfter(e,t,s){const a=this._indexOf(e)+1;this.items.splice(a,0,t),this.tagIDs.splice(a,0,s),this.stackTop++,a===this.stackTop&&this._updateCurrentElement(),this.handler.onItemPush(this.current,this.currentTagId,a===this.stackTop);}popUntilTagNamePopped(e){let t=this.stackTop+1;do{t=this.tagIDs.lastIndexOf(e,t-1);}while(t>0&&this.treeAdapter.getNamespaceURI(this.items[t])!==p.HTML);this.shortenToLength(t<0?0:t);}shortenToLength(e){for(;this.stackTop>=e;){const t=this.current;this.tmplCount>0&&this._isInTemplate()&&(this.tmplCount-=1),this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(t,this.stackTop<e);}}popUntilElementPopped(e){const t=this._indexOf(e);this.shortenToLength(t<0?0:t);}popUntilPopped(e,t){const s=this._indexOfTagNames(e,t);this.shortenToLength(s<0?0:s);}popUntilNumberedHeaderPopped(){this.popUntilPopped(X,p.HTML);}popUntilTableCellPopped(){this.popUntilPopped(j,p.HTML);}popAllUpToHtmlElement(){this.tmplCount=0,this.shortenToLength(1);}_indexOfTagNames(e,t){for(let s=this.stackTop;s>=0;s--)if(e.includes(this.tagIDs[s])&&this.treeAdapter.getNamespaceURI(this.items[s])===t)return s;return -1}clearBackTo(e,t){const s=this._indexOfTagNames(e,t);this.shortenToLength(s+1);}clearBackToTableContext(){this.clearBackTo(z,p.HTML);}clearBackToTableBodyContext(){this.clearBackTo(V,p.HTML);}clearBackToTableRowContext(){this.clearBackTo(K,p.HTML);}remove(e){const t=this._indexOf(e);t>=0&&(t===this.stackTop?this.pop():(this.items.splice(t,1),this.tagIDs.splice(t,1),this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(e,!1)));}tryPeekProperlyNestedBodyElement(){return this.stackTop>=1&&this.tagIDs[1]===u.BODY?this.items[1]:null}contains(e){return this._indexOf(e)>-1}getCommonAncestor(e){const t=this._indexOf(e)-1;return t>=0?this.items[t]:null}isRootHtmlElementCurrent(){return 0===this.stackTop&&this.tagIDs[0]===u.HTML}hasInScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===p.HTML)return !0;if(W.get(s)===a)return !1}return !0}hasNumberedHeaderInScope(){for(let e=this.stackTop;e>=0;e--){const t=this.tagIDs[e],s=this.treeAdapter.getNamespaceURI(this.items[e]);if(M(t)&&s===p.HTML)return !0;if(W.get(t)===s)return !1}return !0}hasInListItemScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===p.HTML)return !0;if((s===u.UL||s===u.OL)&&a===p.HTML||W.get(s)===a)return !1}return !0}hasInButtonScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===p.HTML)return !0;if(s===u.BUTTON&&a===p.HTML||W.get(s)===a)return !1}return !0}hasInTableScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t];if(this.treeAdapter.getNamespaceURI(this.items[t])===p.HTML){if(s===e)return !0;if(s===u.TABLE||s===u.TEMPLATE||s===u.HTML)return !1}}return !0}hasTableBodyContextInTableScope(){for(let e=this.stackTop;e>=0;e--){const t=this.tagIDs[e];if(this.treeAdapter.getNamespaceURI(this.items[e])===p.HTML){if(t===u.TBODY||t===u.THEAD||t===u.TFOOT)return !0;if(t===u.TABLE||t===u.HTML)return !1}}return !0}hasInSelectScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t];if(this.treeAdapter.getNamespaceURI(this.items[t])===p.HTML){if(s===e)return !0;if(s!==u.OPTION&&s!==u.OPTGROUP)return !1}}return !0}generateImpliedEndTags(){for(;Q.has(this.currentTagId);)this.pop();}generateImpliedEndTagsThoroughly(){for(;q.has(this.currentTagId);)this.pop();}generateImpliedEndTagsWithExclusion(e){for(;this.currentTagId!==e&&q.has(this.currentTagId);)this.pop();}}var Z;!function(e){e[e.Marker=0]="Marker",e[e.Element=1]="Element";}(Z=Z||(Z={}));const $={type:Z.Marker};class ee{constructor(e){this.treeAdapter=e,this.entries=[],this.bookmark=null;}_getNoahArkConditionCandidates(e,t){const s=[],a=t.length,r=this.treeAdapter.getTagName(e),n=this.treeAdapter.getNamespaceURI(e);for(let e=0;e<this.entries.length;e++){const t=this.entries[e];if(t.type===Z.Marker)break;const{element:i}=t;if(this.treeAdapter.getTagName(i)===r&&this.treeAdapter.getNamespaceURI(i)===n){const t=this.treeAdapter.getAttrList(i);t.length===a&&s.push({idx:e,attrs:t});}}return s}_ensureNoahArkCondition(e){if(this.entries.length<3)return;const t=this.treeAdapter.getAttrList(e),s=this._getNoahArkConditionCandidates(e,t);if(s.length<3)return;const a=new Map(t.map((e=>[e.name,e.value])));let r=0;for(let e=0;e<s.length;e++){const t=s[e];t.attrs.every((e=>a.get(e.name)===e.value))&&(r+=1,r>=3&&this.entries.splice(t.idx,1));}}insertMarker(){this.entries.unshift($);}pushElement(e,t){this._ensureNoahArkCondition(e),this.entries.unshift({type:Z.Element,element:e,token:t});}insertElementAfterBookmark(e,t){const s=this.entries.indexOf(this.bookmark);this.entries.splice(s,0,{type:Z.Element,element:e,token:t});}removeEntry(e){const t=this.entries.indexOf(e);t>=0&&this.entries.splice(t,1);}clearToLastMarker(){const e=this.entries.indexOf($);e>=0?this.entries.splice(0,e+1):this.entries.length=0;}getElementEntryInScopeWithTagName(e){const t=this.entries.find((t=>t.type===Z.Marker||this.treeAdapter.getTagName(t.element)===e));return t&&t.type===Z.Element?t:null}getElementEntry(e){return this.entries.find((t=>t.type===Z.Element&&t.element===e))}}function te(e){return {nodeName:"#text",value:e,parentNode:null}}const se={createDocument:()=>({nodeName:"#document",mode:I.NO_QUIRKS,childNodes:[]}),createDocumentFragment:()=>({nodeName:"#document-fragment",childNodes:[]}),createElement:(e,t,s)=>({nodeName:e,tagName:e,attrs:s,namespaceURI:t,childNodes:[],parentNode:null}),createCommentNode:e=>({nodeName:"#comment",data:e,parentNode:null}),appendChild(e,t){e.childNodes.push(t),t.parentNode=e;},insertBefore(e,t,s){const a=e.childNodes.indexOf(s);e.childNodes.splice(a,0,t),t.parentNode=e;},setTemplateContent(e,t){e.content=t;},getTemplateContent:e=>e.content,setDocumentType(e,t,s,a){const r=e.childNodes.find((e=>"#documentType"===e.nodeName));if(r)r.name=t,r.publicId=s,r.systemId=a;else {const r={nodeName:"#documentType",name:t,publicId:s,systemId:a,parentNode:null};se.appendChild(e,r);}},setDocumentMode(e,t){e.mode=t;},getDocumentMode:e=>e.mode,detachNode(e){if(e.parentNode){const t=e.parentNode.childNodes.indexOf(e);e.parentNode.childNodes.splice(t,1),e.parentNode=null;}},insertText(e,t){if(e.childNodes.length>0){const s=e.childNodes[e.childNodes.length-1];if(se.isTextNode(s))return void(s.value+=t)}se.appendChild(e,te(t));},insertTextBefore(e,t,s){const a=e.childNodes[e.childNodes.indexOf(s)-1];a&&se.isTextNode(a)?a.value+=t:se.insertBefore(e,te(t),s);},adoptAttributes(e,t){const s=new Set(e.attrs.map((e=>e.name)));for(let a=0;a<t.length;a++)s.has(t[a].name)||e.attrs.push(t[a]);},getFirstChild:e=>e.childNodes[0],getChildNodes:e=>e.childNodes,getParentNode:e=>e.parentNode,getAttrList:e=>e.attrs,getTagName:e=>e.tagName,getNamespaceURI:e=>e.namespaceURI,getTextNodeContent:e=>e.value,getCommentNodeContent:e=>e.data,getDocumentTypeNodeName:e=>e.name,getDocumentTypeNodePublicId:e=>e.publicId,getDocumentTypeNodeSystemId:e=>e.systemId,isTextNode:e=>"#text"===e.nodeName,isCommentNode:e=>"#comment"===e.nodeName,isDocumentTypeNode:e=>"#documentType"===e.nodeName,isElementNode:e=>Object.prototype.hasOwnProperty.call(e,"tagName"),setNodeSourceCodeLocation(e,t){e.sourceCodeLocation=t;},getNodeSourceCodeLocation:e=>e.sourceCodeLocation,updateNodeSourceCodeLocation(e,t){e.sourceCodeLocation={...e.sourceCodeLocation,...t};}},ae="html",re=["+//silmaril//dtd html pro v0r11 19970101//","-//as//dtd html 3.0 aswedit + extensions//","-//advasoft ltd//dtd html 3.0 aswedit + extensions//","-//ietf//dtd html 2.0 level 1//","-//ietf//dtd html 2.0 level 2//","-//ietf//dtd html 2.0 strict level 1//","-//ietf//dtd html 2.0 strict level 2//","-//ietf//dtd html 2.0 strict//","-//ietf//dtd html 2.0//","-//ietf//dtd html 2.1e//","-//ietf//dtd html 3.0//","-//ietf//dtd html 3.2 final//","-//ietf//dtd html 3.2//","-//ietf//dtd html 3//","-//ietf//dtd html level 0//","-//ietf//dtd html level 1//","-//ietf//dtd html level 2//","-//ietf//dtd html level 3//","-//ietf//dtd html strict level 0//","-//ietf//dtd html strict level 1//","-//ietf//dtd html strict level 2//","-//ietf//dtd html strict level 3//","-//ietf//dtd html strict//","-//ietf//dtd html//","-//metrius//dtd metrius presentational//","-//microsoft//dtd internet explorer 2.0 html strict//","-//microsoft//dtd internet explorer 2.0 html//","-//microsoft//dtd internet explorer 2.0 tables//","-//microsoft//dtd internet explorer 3.0 html strict//","-//microsoft//dtd internet explorer 3.0 html//","-//microsoft//dtd internet explorer 3.0 tables//","-//netscape comm. corp.//dtd html//","-//netscape comm. corp.//dtd strict html//","-//o'reilly and associates//dtd html 2.0//","-//o'reilly and associates//dtd html extended 1.0//","-//o'reilly and associates//dtd html extended relaxed 1.0//","-//sq//dtd html 2.0 hotmetal + extensions//","-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//","-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//","-//spyglass//dtd html 2.0 extended//","-//sun microsystems corp.//dtd hotjava html//","-//sun microsystems corp.//dtd hotjava strict html//","-//w3c//dtd html 3 1995-03-24//","-//w3c//dtd html 3.2 draft//","-//w3c//dtd html 3.2 final//","-//w3c//dtd html 3.2//","-//w3c//dtd html 3.2s draft//","-//w3c//dtd html 4.0 frameset//","-//w3c//dtd html 4.0 transitional//","-//w3c//dtd html experimental 19960712//","-//w3c//dtd html experimental 970421//","-//w3c//dtd w3 html//","-//w3o//dtd w3 html 3.0//","-//webtechs//dtd mozilla html 2.0//","-//webtechs//dtd mozilla html//"],ne=[...re,"-//w3c//dtd html 4.01 frameset//","-//w3c//dtd html 4.01 transitional//"],ie=new Set(["-//w3o//dtd w3 html strict 3.0//en//","-/w3c/dtd html 4.0 transitional/en","html"]),oe=["-//w3c//dtd xhtml 1.0 frameset//","-//w3c//dtd xhtml 1.0 transitional//"],ce=[...oe,"-//w3c//dtd html 4.01 frameset//","-//w3c//dtd html 4.01 transitional//"];function Ee(e,t){return t.some((t=>e.startsWith(t)))}const Te=new Map(["attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","spreadMethod","startOffset","stdDeviation","stitchTiles","surfaceScale","systemLanguage","tableValues","targetX","targetY","textLength","viewBox","viewTarget","xChannelSelector","yChannelSelector","zoomAndPan"].map((e=>[e.toLowerCase(),e]))),he=new Map([["xlink:actuate",{prefix:"xlink",name:"actuate",namespace:p.XLINK}],["xlink:arcrole",{prefix:"xlink",name:"arcrole",namespace:p.XLINK}],["xlink:href",{prefix:"xlink",name:"href",namespace:p.XLINK}],["xlink:role",{prefix:"xlink",name:"role",namespace:p.XLINK}],["xlink:show",{prefix:"xlink",name:"show",namespace:p.XLINK}],["xlink:title",{prefix:"xlink",name:"title",namespace:p.XLINK}],["xlink:type",{prefix:"xlink",name:"type",namespace:p.XLINK}],["xml:base",{prefix:"xml",name:"base",namespace:p.XML}],["xml:lang",{prefix:"xml",name:"lang",namespace:p.XML}],["xml:space",{prefix:"xml",name:"space",namespace:p.XML}],["xmlns",{prefix:"",name:"xmlns",namespace:p.XMLNS}],["xmlns:xlink",{prefix:"xmlns",name:"xlink",namespace:p.XMLNS}]]),_e=new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map((e=>[e.toLowerCase(),e]))),Ae=new Set([u.B,u.BIG,u.BLOCKQUOTE,u.BODY,u.BR,u.CENTER,u.CODE,u.DD,u.DIV,u.DL,u.DT,u.EM,u.EMBED,u.H1,u.H2,u.H3,u.H4,u.H5,u.H6,u.HEAD,u.HR,u.I,u.IMG,u.LI,u.LISTING,u.MENU,u.META,u.NOBR,u.OL,u.P,u.PRE,u.RUBY,u.S,u.SMALL,u.SPAN,u.STRONG,u.STRIKE,u.SUB,u.SUP,u.TABLE,u.TT,u.U,u.UL,u.VAR]);function le(e){for(let t=0;t<e.attrs.length;t++)if("definitionurl"===e.attrs[t].name){e.attrs[t].name="definitionURL";break}}function me(e){for(let t=0;t<e.attrs.length;t++){const s=Te.get(e.attrs[t].name);null!=s&&(e.attrs[t].name=s);}}function pe(e){for(let t=0;t<e.attrs.length;t++){const s=he.get(e.attrs[t].name);s&&(e.attrs[t].prefix=s.prefix,e.attrs[t].name=s.name,e.attrs[t].namespace=s.namespace);}}var de;!function(e){e[e.INITIAL=0]="INITIAL",e[e.BEFORE_HTML=1]="BEFORE_HTML",e[e.BEFORE_HEAD=2]="BEFORE_HEAD",e[e.IN_HEAD=3]="IN_HEAD",e[e.IN_HEAD_NO_SCRIPT=4]="IN_HEAD_NO_SCRIPT",e[e.AFTER_HEAD=5]="AFTER_HEAD",e[e.IN_BODY=6]="IN_BODY",e[e.TEXT=7]="TEXT",e[e.IN_TABLE=8]="IN_TABLE",e[e.IN_TABLE_TEXT=9]="IN_TABLE_TEXT",e[e.IN_CAPTION=10]="IN_CAPTION",e[e.IN_COLUMN_GROUP=11]="IN_COLUMN_GROUP",e[e.IN_TABLE_BODY=12]="IN_TABLE_BODY",e[e.IN_ROW=13]="IN_ROW",e[e.IN_CELL=14]="IN_CELL",e[e.IN_SELECT=15]="IN_SELECT",e[e.IN_SELECT_IN_TABLE=16]="IN_SELECT_IN_TABLE",e[e.IN_TEMPLATE=17]="IN_TEMPLATE",e[e.AFTER_BODY=18]="AFTER_BODY",e[e.IN_FRAMESET=19]="IN_FRAMESET",e[e.AFTER_FRAMESET=20]="AFTER_FRAMESET",e[e.AFTER_AFTER_BODY=21]="AFTER_AFTER_BODY",e[e.AFTER_AFTER_FRAMESET=22]="AFTER_AFTER_FRAMESET";}(de||(de={}));const Ie={startLine:-1,startCol:-1,startOffset:-1,endLine:-1,endCol:-1,endOffset:-1},Ne=new Set([u.TABLE,u.TBODY,u.TFOOT,u.THEAD,u.TR]),ue={scriptingEnabled:!0,sourceCodeLocationInfo:!1,treeAdapter:se,onParseError:null};class Ce{constructor(e,t,s=null,a=null){this.fragmentContext=s,this.scriptHandler=a,this.currentToken=null,this.stopped=!1,this.insertionMode=de.INITIAL,this.originalInsertionMode=de.INITIAL,this.headElement=null,this.formElement=null,this.currentNotInHTML=!1,this.tmplInsertionModeStack=[],this.pendingCharacterTokens=[],this.hasNonWhitespacePendingCharacterToken=!1,this.framesetOk=!0,this.skipNextNewLine=!1,this.fosterParentingEnabled=!1,this.options={...ue,...e},this.treeAdapter=this.options.treeAdapter,this.onParseError=this.options.onParseError,this.onParseError&&(this.options.sourceCodeLocationInfo=!0),this.document=null!=t?t:this.treeAdapter.createDocument(),this.tokenizer=new v(this.options,this),this.activeFormattingElements=new ee(this.treeAdapter),this.fragmentContextID=s?f(this.treeAdapter.getTagName(s)):u.UNKNOWN,this._setContextModes(null!=s?s:this.document,this.fragmentContextID),this.openElements=new J(this.document,this.treeAdapter,this);}static parse(e,t){const s=new this(t);return s.tokenizer.write(e,!0),s.document}static getFragmentParser(e,t){const s={...ue,...t};null!=e||(e=s.treeAdapter.createElement(N.TEMPLATE,p.HTML,[]));const a=s.treeAdapter.createElement("documentmock",p.HTML,[]),r=new this(s,a,e);return r.fragmentContextID===u.TEMPLATE&&r.tmplInsertionModeStack.unshift(de.IN_TEMPLATE),r._initTokenizerForFragmentParsing(),r._insertFakeRootElement(),r._resetInsertionMode(),r._findFormInFragmentContext(),r}getFragment(){const e=this.treeAdapter.getFirstChild(this.document),t=this.treeAdapter.createDocumentFragment();return this._adoptNodes(e,t),t}_err(e,t,s){var a;if(!this.onParseError)return;const r=null!==(a=e.location)&&void 0!==a?a:Ie,n={code:t,startLine:r.startLine,startCol:r.startCol,startOffset:r.startOffset,endLine:s?r.startLine:r.endLine,endCol:s?r.startCol:r.endCol,endOffset:s?r.startOffset:r.endOffset};this.onParseError(n);}onItemPush(e,t,s){var a,r;null===(r=(a=this.treeAdapter).onItemPush)||void 0===r||r.call(a,e),s&&this.openElements.stackTop>0&&this._setContextModes(e,t);}onItemPop(e,t){var s,a;if(this.options.sourceCodeLocationInfo&&this._setEndLocation(e,this.currentToken),null===(a=(s=this.treeAdapter).onItemPop)||void 0===a||a.call(s,e,this.openElements.current),t){let e,t;0===this.openElements.stackTop&&this.fragmentContext?(e=this.fragmentContext,t=this.fragmentContextID):({current:e,currentTagId:t}=this.openElements),this._setContextModes(e,t);}}_setContextModes(e,t){const s=e===this.document||this.treeAdapter.getNamespaceURI(e)===p.HTML;this.currentNotInHTML=!s,this.tokenizer.inForeignNode=!s&&!this._isIntegrationPoint(t,e);}_switchToTextParsing(e,t){this._insertElement(e,p.HTML),this.tokenizer.state=t,this.originalInsertionMode=this.insertionMode,this.insertionMode=de.TEXT;}switchToPlaintextParsing(){this.insertionMode=de.TEXT,this.originalInsertionMode=de.IN_BODY,this.tokenizer.state=b.PLAINTEXT;}_getAdjustedCurrentElement(){return 0===this.openElements.stackTop&&this.fragmentContext?this.fragmentContext:this.openElements.current}_findFormInFragmentContext(){let e=this.fragmentContext;for(;e;){if(this.treeAdapter.getTagName(e)===N.FORM){this.formElement=e;break}e=this.treeAdapter.getParentNode(e);}}_initTokenizerForFragmentParsing(){if(this.fragmentContext&&this.treeAdapter.getNamespaceURI(this.fragmentContext)===p.HTML)switch(this.fragmentContextID){case u.TITLE:case u.TEXTAREA:this.tokenizer.state=b.RCDATA;break;case u.STYLE:case u.XMP:case u.IFRAME:case u.NOEMBED:case u.NOFRAMES:case u.NOSCRIPT:this.tokenizer.state=b.RAWTEXT;break;case u.SCRIPT:this.tokenizer.state=b.SCRIPT_DATA;break;case u.PLAINTEXT:this.tokenizer.state=b.PLAINTEXT;}}_setDocumentType(e){const t=e.name||"",s=e.publicId||"",a=e.systemId||"";if(this.treeAdapter.setDocumentType(this.document,t,s,a),e.location){const t=this.treeAdapter.getChildNodes(this.document).find((e=>this.treeAdapter.isDocumentTypeNode(e)));t&&this.treeAdapter.setNodeSourceCodeLocation(t,e.location);}}_attachElementToTree(e,t){if(this.options.sourceCodeLocationInfo){const s=t&&{...t,startTag:t};this.treeAdapter.setNodeSourceCodeLocation(e,s);}if(this._shouldFosterParentOnInsertion())this._fosterParentElement(e);else {const t=this.openElements.currentTmplContentOrNode;this.treeAdapter.appendChild(t,e);}}_appendElement(e,t){const s=this.treeAdapter.createElement(e.tagName,t,e.attrs);this._attachElementToTree(s,e.location);}_insertElement(e,t){const s=this.treeAdapter.createElement(e.tagName,t,e.attrs);this._attachElementToTree(s,e.location),this.openElements.push(s,e.tagID);}_insertFakeElement(e,t){const s=this.treeAdapter.createElement(e,p.HTML,[]);this._attachElementToTree(s,null),this.openElements.push(s,t);}_insertTemplate(e){const t=this.treeAdapter.createElement(e.tagName,p.HTML,e.attrs),s=this.treeAdapter.createDocumentFragment();this.treeAdapter.setTemplateContent(t,s),this._attachElementToTree(t,e.location),this.openElements.push(t,e.tagID),this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(s,null);}_insertFakeRootElement(){const e=this.treeAdapter.createElement(N.HTML,p.HTML,[]);this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(e,null),this.treeAdapter.appendChild(this.openElements.current,e),this.openElements.push(e,u.HTML);}_appendCommentNode(e,t){const s=this.treeAdapter.createCommentNode(e.data);this.treeAdapter.appendChild(t,s),this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(s,e.location);}_insertCharacters(e){let t,s;if(this._shouldFosterParentOnInsertion()?(({parent:t,beforeElement:s}=this._findFosterParentingLocation()),s?this.treeAdapter.insertTextBefore(t,e.chars,s):this.treeAdapter.insertText(t,e.chars)):(t=this.openElements.currentTmplContentOrNode,this.treeAdapter.insertText(t,e.chars)),!e.location)return;const a=this.treeAdapter.getChildNodes(t),r=s?a.lastIndexOf(s):a.length,n=a[r-1];if(this.treeAdapter.getNodeSourceCodeLocation(n)){const{endLine:t,endCol:s,endOffset:a}=e.location;this.treeAdapter.updateNodeSourceCodeLocation(n,{endLine:t,endCol:s,endOffset:a});}else this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(n,e.location);}_adoptNodes(e,t){for(let s=this.treeAdapter.getFirstChild(e);s;s=this.treeAdapter.getFirstChild(e))this.treeAdapter.detachNode(s),this.treeAdapter.appendChild(t,s);}_setEndLocation(e,t){if(this.treeAdapter.getNodeSourceCodeLocation(e)&&t.location){const s=t.location,a=this.treeAdapter.getTagName(e),r=t.type===h.END_TAG&&a===t.tagName?{endTag:{...s},endLine:s.endLine,endCol:s.endCol,endOffset:s.endOffset}:{endLine:s.startLine,endCol:s.startCol,endOffset:s.startOffset};this.treeAdapter.updateNodeSourceCodeLocation(e,r);}}shouldProcessStartTagTokenInForeignContent(e){if(!this.currentNotInHTML)return !1;let t,s;return 0===this.openElements.stackTop&&this.fragmentContext?(t=this.fragmentContext,s=this.fragmentContextID):({current:t,currentTagId:s}=this.openElements),(e.tagID!==u.SVG||this.treeAdapter.getTagName(t)!==N.ANNOTATION_XML||this.treeAdapter.getNamespaceURI(t)!==p.MATHML)&&(this.tokenizer.inForeignNode||(e.tagID===u.MGLYPH||e.tagID===u.MALIGNMARK)&&!this._isIntegrationPoint(s,t,p.HTML))}_processToken(e){switch(e.type){case h.CHARACTER:this.onCharacter(e);break;case h.NULL_CHARACTER:this.onNullCharacter(e);break;case h.COMMENT:this.onComment(e);break;case h.DOCTYPE:this.onDoctype(e);break;case h.START_TAG:this._processStartTag(e);break;case h.END_TAG:this.onEndTag(e);break;case h.EOF:this.onEof(e);break;case h.WHITESPACE_CHARACTER:this.onWhitespaceCharacter(e);}}_isIntegrationPoint(e,t,s){return function(e,t,s,a){return (!a||a===p.HTML)&&function(e,t,s){if(t===p.MATHML&&e===u.ANNOTATION_XML)for(let e=0;e<s.length;e++)if(s[e].name===d.ENCODING){const t=s[e].value.toLowerCase();return "text/html"===t||"application/xhtml+xml"===t}return t===p.SVG&&(e===u.FOREIGN_OBJECT||e===u.DESC||e===u.TITLE)}(e,t,s)||(!a||a===p.MATHML)&&function(e,t){return t===p.MATHML&&(e===u.MI||e===u.MO||e===u.MN||e===u.MS||e===u.MTEXT)}(e,t)}(e,this.treeAdapter.getNamespaceURI(t),this.treeAdapter.getAttrList(t),s)}_reconstructActiveFormattingElements(){const e=this.activeFormattingElements.entries.length;if(e){const t=this.activeFormattingElements.entries.findIndex((e=>e.type===Z.Marker||this.openElements.contains(e.element)));for(let s=t<0?e-1:t-1;s>=0;s--){const e=this.activeFormattingElements.entries[s];this._insertElement(e.token,this.treeAdapter.getNamespaceURI(e.element)),e.element=this.openElements.current;}}}_closeTableCell(){this.openElements.generateImpliedEndTags(),this.openElements.popUntilTableCellPopped(),this.activeFormattingElements.clearToLastMarker(),this.insertionMode=de.IN_ROW;}_closePElement(){this.openElements.generateImpliedEndTagsWithExclusion(u.P),this.openElements.popUntilTagNamePopped(u.P);}_resetInsertionMode(){for(let e=this.openElements.stackTop;e>=0;e--)switch(0===e&&this.fragmentContext?this.fragmentContextID:this.openElements.tagIDs[e]){case u.TR:return void(this.insertionMode=de.IN_ROW);case u.TBODY:case u.THEAD:case u.TFOOT:return void(this.insertionMode=de.IN_TABLE_BODY);case u.CAPTION:return void(this.insertionMode=de.IN_CAPTION);case u.COLGROUP:return void(this.insertionMode=de.IN_COLUMN_GROUP);case u.TABLE:return void(this.insertionMode=de.IN_TABLE);case u.BODY:return void(this.insertionMode=de.IN_BODY);case u.FRAMESET:return void(this.insertionMode=de.IN_FRAMESET);case u.SELECT:return void this._resetInsertionModeForSelect(e);case u.TEMPLATE:return void(this.insertionMode=this.tmplInsertionModeStack[0]);case u.HTML:return void(this.insertionMode=this.headElement?de.AFTER_HEAD:de.BEFORE_HEAD);case u.TD:case u.TH:if(e>0)return void(this.insertionMode=de.IN_CELL);break;case u.HEAD:if(e>0)return void(this.insertionMode=de.IN_HEAD)}this.insertionMode=de.IN_BODY;}_resetInsertionModeForSelect(e){if(e>0)for(let t=e-1;t>0;t--){const e=this.openElements.tagIDs[t];if(e===u.TEMPLATE)break;if(e===u.TABLE)return void(this.insertionMode=de.IN_SELECT_IN_TABLE)}this.insertionMode=de.IN_SELECT;}_isElementCausesFosterParenting(e){return Ne.has(e)}_shouldFosterParentOnInsertion(){return this.fosterParentingEnabled&&this._isElementCausesFosterParenting(this.openElements.currentTagId)}_findFosterParentingLocation(){for(let e=this.openElements.stackTop;e>=0;e--){const t=this.openElements.items[e];switch(this.openElements.tagIDs[e]){case u.TEMPLATE:if(this.treeAdapter.getNamespaceURI(t)===p.HTML)return {parent:this.treeAdapter.getTemplateContent(t),beforeElement:null};break;case u.TABLE:{const s=this.treeAdapter.getParentNode(t);return s?{parent:s,beforeElement:t}:{parent:this.openElements.items[e-1],beforeElement:null}}}}return {parent:this.openElements.items[0],beforeElement:null}}_fosterParentElement(e){const t=this._findFosterParentingLocation();t.beforeElement?this.treeAdapter.insertBefore(t.parent,e,t.beforeElement):this.treeAdapter.appendChild(t.parent,e);}_isSpecialElement(e,t){const s=this.treeAdapter.getNamespaceURI(e);return g[s].has(t)}onCharacter(e){if(this.skipNextNewLine=!1,this.tokenizer.inForeignNode)!function(e,t){e._insertCharacters(t),e.framesetOk=!1;}(this,e);else switch(this.insertionMode){case de.INITIAL:Pe(this,e);break;case de.BEFORE_HTML:be(this,e);break;case de.BEFORE_HEAD:Be(this,e);break;case de.IN_HEAD:Ue(this,e);break;case de.IN_HEAD_NO_SCRIPT:Ge(this,e);break;case de.AFTER_HEAD:ye(this,e);break;case de.IN_BODY:case de.IN_CAPTION:case de.IN_CELL:case de.IN_TEMPLATE:xe(this,e);break;case de.TEXT:case de.IN_SELECT:case de.IN_SELECT_IN_TABLE:this._insertCharacters(e);break;case de.IN_TABLE:case de.IN_TABLE_BODY:case de.IN_ROW:je(this,e);break;case de.IN_TABLE_TEXT:tt(this,e);break;case de.IN_COLUMN_GROUP:nt(this,e);break;case de.AFTER_BODY:lt(this,e);break;case de.AFTER_AFTER_BODY:mt(this,e);}}onNullCharacter(e){if(this.skipNextNewLine=!1,this.tokenizer.inForeignNode)!function(e,t){t.chars=s,e._insertCharacters(t);}(this,e);else switch(this.insertionMode){case de.INITIAL:Pe(this,e);break;case de.BEFORE_HTML:be(this,e);break;case de.BEFORE_HEAD:Be(this,e);break;case de.IN_HEAD:Ue(this,e);break;case de.IN_HEAD_NO_SCRIPT:Ge(this,e);break;case de.AFTER_HEAD:ye(this,e);break;case de.TEXT:this._insertCharacters(e);break;case de.IN_TABLE:case de.IN_TABLE_BODY:case de.IN_ROW:je(this,e);break;case de.IN_COLUMN_GROUP:nt(this,e);break;case de.AFTER_BODY:lt(this,e);break;case de.AFTER_AFTER_BODY:mt(this,e);}}onComment(e){if(this.skipNextNewLine=!1,this.currentNotInHTML)Me(this,e);else switch(this.insertionMode){case de.INITIAL:case de.BEFORE_HTML:case de.BEFORE_HEAD:case de.IN_HEAD:case de.IN_HEAD_NO_SCRIPT:case de.AFTER_HEAD:case de.IN_BODY:case de.IN_TABLE:case de.IN_CAPTION:case de.IN_COLUMN_GROUP:case de.IN_TABLE_BODY:case de.IN_ROW:case de.IN_CELL:case de.IN_SELECT:case de.IN_SELECT_IN_TABLE:case de.IN_TEMPLATE:case de.IN_FRAMESET:case de.AFTER_FRAMESET:Me(this,e);break;case de.IN_TABLE_TEXT:st(this,e);break;case de.AFTER_BODY:!function(e,t){e._appendCommentNode(t,e.openElements.items[0]);}(this,e);break;case de.AFTER_AFTER_BODY:case de.AFTER_AFTER_FRAMESET:!function(e,t){e._appendCommentNode(t,e.document);}(this,e);}}onDoctype(e){switch(this.skipNextNewLine=!1,this.insertionMode){case de.INITIAL:!function(e,t){e._setDocumentType(t);const s=t.forceQuirks?I.QUIRKS:function(e){if(e.name!==ae)return I.QUIRKS;const{systemId:t}=e;if(t&&"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"===t.toLowerCase())return I.QUIRKS;let{publicId:s}=e;if(null!==s){if(s=s.toLowerCase(),ie.has(s))return I.QUIRKS;let e=null===t?ne:re;if(Ee(s,e))return I.QUIRKS;if(e=null===t?oe:ce,Ee(s,e))return I.LIMITED_QUIRKS}return I.NO_QUIRKS}(t);(function(e){return e.name===ae&&null===e.publicId&&(null===e.systemId||"about:legacy-compat"===e.systemId)})(t)||e._err(t,T.nonConformingDoctype),e.treeAdapter.setDocumentMode(e.document,s),e.insertionMode=de.BEFORE_HTML;}(this,e);break;case de.BEFORE_HEAD:case de.IN_HEAD:case de.IN_HEAD_NO_SCRIPT:case de.AFTER_HEAD:this._err(e,T.misplacedDoctype);break;case de.IN_TABLE_TEXT:st(this,e);}}onStartTag(e){this.skipNextNewLine=!1,this.currentToken=e,this._processStartTag(e),e.selfClosing&&!e.ackSelfClosing&&this._err(e,T.nonVoidHtmlElementStartTagWithTrailingSolidus);}_processStartTag(e){this.shouldProcessStartTagTokenInForeignContent(e)?function(e,t){if(function(e){const t=e.tagID;return t===u.FONT&&e.attrs.some((({name:e})=>e===d.COLOR||e===d.SIZE||e===d.FACE))||Ae.has(t)}(t))pt(e),e._startTagOutsideForeignContent(t);else {const s=e._getAdjustedCurrentElement(),a=e.treeAdapter.getNamespaceURI(s);a===p.MATHML?le(t):a===p.SVG&&(function(e){const t=_e.get(e.tagName);null!=t&&(e.tagName=t,e.tagID=f(e.tagName));}(t),me(t)),pe(t),t.selfClosing?e._appendElement(t,a):e._insertElement(t,a),t.ackSelfClosing=!0;}}(this,e):this._startTagOutsideForeignContent(e);}_startTagOutsideForeignContent(e){switch(this.insertionMode){case de.INITIAL:Pe(this,e);break;case de.BEFORE_HTML:!function(e,t){t.tagID===u.HTML?(e._insertElement(t,p.HTML),e.insertionMode=de.BEFORE_HEAD):be(e,t);}(this,e);break;case de.BEFORE_HEAD:!function(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.HEAD:e._insertElement(t,p.HTML),e.headElement=e.openElements.current,e.insertionMode=de.IN_HEAD;break;default:Be(e,t);}}(this,e);break;case de.IN_HEAD:He(this,e);break;case de.IN_HEAD_NO_SCRIPT:!function(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.BASEFONT:case u.BGSOUND:case u.HEAD:case u.LINK:case u.META:case u.NOFRAMES:case u.STYLE:He(e,t);break;case u.NOSCRIPT:e._err(t,T.nestedNoscriptInHead);break;default:Ge(e,t);}}(this,e);break;case de.AFTER_HEAD:!function(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.BODY:e._insertElement(t,p.HTML),e.framesetOk=!1,e.insertionMode=de.IN_BODY;break;case u.FRAMESET:e._insertElement(t,p.HTML),e.insertionMode=de.IN_FRAMESET;break;case u.BASE:case u.BASEFONT:case u.BGSOUND:case u.LINK:case u.META:case u.NOFRAMES:case u.SCRIPT:case u.STYLE:case u.TEMPLATE:case u.TITLE:e._err(t,T.abandonedHeadElementChild),e.openElements.push(e.headElement,u.HEAD),He(e,t),e.openElements.remove(e.headElement);break;case u.HEAD:e._err(t,T.misplacedStartTagForHeadElement);break;default:ye(e,t);}}(this,e);break;case de.IN_BODY:Xe(this,e);break;case de.IN_TABLE:Je(this,e);break;case de.IN_TABLE_TEXT:st(this,e);break;case de.IN_CAPTION:!function(e,t){const s=t.tagID;at.has(s)?e.openElements.hasInTableScope(u.CAPTION)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(u.CAPTION),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=de.IN_TABLE,Je(e,t)):Xe(e,t);}(this,e);break;case de.IN_COLUMN_GROUP:rt(this,e);break;case de.IN_TABLE_BODY:it(this,e);break;case de.IN_ROW:ct(this,e);break;case de.IN_CELL:!function(e,t){const s=t.tagID;at.has(s)?(e.openElements.hasInTableScope(u.TD)||e.openElements.hasInTableScope(u.TH))&&(e._closeTableCell(),ct(e,t)):Xe(e,t);}(this,e);break;case de.IN_SELECT:Tt(this,e);break;case de.IN_SELECT_IN_TABLE:!function(e,t){const s=t.tagID;s===u.CAPTION||s===u.TABLE||s===u.TBODY||s===u.TFOOT||s===u.THEAD||s===u.TR||s===u.TD||s===u.TH?(e.openElements.popUntilTagNamePopped(u.SELECT),e._resetInsertionMode(),e._processStartTag(t)):Tt(e,t);}(this,e);break;case de.IN_TEMPLATE:!function(e,t){switch(t.tagID){case u.BASE:case u.BASEFONT:case u.BGSOUND:case u.LINK:case u.META:case u.NOFRAMES:case u.SCRIPT:case u.STYLE:case u.TEMPLATE:case u.TITLE:He(e,t);break;case u.CAPTION:case u.COLGROUP:case u.TBODY:case u.TFOOT:case u.THEAD:e.tmplInsertionModeStack[0]=de.IN_TABLE,e.insertionMode=de.IN_TABLE,Je(e,t);break;case u.COL:e.tmplInsertionModeStack[0]=de.IN_COLUMN_GROUP,e.insertionMode=de.IN_COLUMN_GROUP,rt(e,t);break;case u.TR:e.tmplInsertionModeStack[0]=de.IN_TABLE_BODY,e.insertionMode=de.IN_TABLE_BODY,it(e,t);break;case u.TD:case u.TH:e.tmplInsertionModeStack[0]=de.IN_ROW,e.insertionMode=de.IN_ROW,ct(e,t);break;default:e.tmplInsertionModeStack[0]=de.IN_BODY,e.insertionMode=de.IN_BODY,Xe(e,t);}}(this,e);break;case de.AFTER_BODY:!function(e,t){t.tagID===u.HTML?Xe(e,t):lt(e,t);}(this,e);break;case de.IN_FRAMESET:!function(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.FRAMESET:e._insertElement(t,p.HTML);break;case u.FRAME:e._appendElement(t,p.HTML),t.ackSelfClosing=!0;break;case u.NOFRAMES:He(e,t);}}(this,e);break;case de.AFTER_FRAMESET:!function(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.NOFRAMES:He(e,t);}}(this,e);break;case de.AFTER_AFTER_BODY:!function(e,t){t.tagID===u.HTML?Xe(e,t):mt(e,t);}(this,e);break;case de.AFTER_AFTER_FRAMESET:!function(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.NOFRAMES:He(e,t);}}(this,e);}}onEndTag(e){this.skipNextNewLine=!1,this.currentToken=e,this.currentNotInHTML?function(e,t){if(t.tagID===u.P||t.tagID===u.BR)return pt(e),void e._endTagOutsideForeignContent(t);for(let s=e.openElements.stackTop;s>0;s--){const a=e.openElements.items[s];if(e.treeAdapter.getNamespaceURI(a)===p.HTML){e._endTagOutsideForeignContent(t);break}const r=e.treeAdapter.getTagName(a);if(r.toLowerCase()===t.tagName){t.tagName=r,e.openElements.shortenToLength(s);break}}}(this,e):this._endTagOutsideForeignContent(e);}_endTagOutsideForeignContent(e){switch(this.insertionMode){case de.INITIAL:Pe(this,e);break;case de.BEFORE_HTML:!function(e,t){const s=t.tagID;s!==u.HTML&&s!==u.HEAD&&s!==u.BODY&&s!==u.BR||be(e,t);}(this,e);break;case de.BEFORE_HEAD:!function(e,t){const s=t.tagID;s===u.HEAD||s===u.BODY||s===u.HTML||s===u.BR?Be(e,t):e._err(t,T.endTagWithoutMatchingOpenElement);}(this,e);break;case de.IN_HEAD:!function(e,t){switch(t.tagID){case u.HEAD:e.openElements.pop(),e.insertionMode=de.AFTER_HEAD;break;case u.BODY:case u.BR:case u.HTML:Ue(e,t);break;case u.TEMPLATE:Fe(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case de.IN_HEAD_NO_SCRIPT:!function(e,t){switch(t.tagID){case u.NOSCRIPT:e.openElements.pop(),e.insertionMode=de.IN_HEAD;break;case u.BR:Ge(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case de.AFTER_HEAD:!function(e,t){switch(t.tagID){case u.BODY:case u.HTML:case u.BR:ye(e,t);break;case u.TEMPLATE:Fe(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case de.IN_BODY:Ve(this,e);break;case de.TEXT:!function(e,t){var s;t.tagID===u.SCRIPT&&(null===(s=e.scriptHandler)||void 0===s||s.call(e,e.openElements.current)),e.openElements.pop(),e.insertionMode=e.originalInsertionMode;}(this,e);break;case de.IN_TABLE:Ze(this,e);break;case de.IN_TABLE_TEXT:st(this,e);break;case de.IN_CAPTION:!function(e,t){const s=t.tagID;switch(s){case u.CAPTION:case u.TABLE:e.openElements.hasInTableScope(u.CAPTION)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(u.CAPTION),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=de.IN_TABLE,s===u.TABLE&&Ze(e,t));break;case u.BODY:case u.COL:case u.COLGROUP:case u.HTML:case u.TBODY:case u.TD:case u.TFOOT:case u.TH:case u.THEAD:case u.TR:break;default:Ve(e,t);}}(this,e);break;case de.IN_COLUMN_GROUP:!function(e,t){switch(t.tagID){case u.COLGROUP:e.openElements.currentTagId===u.COLGROUP&&(e.openElements.pop(),e.insertionMode=de.IN_TABLE);break;case u.TEMPLATE:Fe(e,t);break;case u.COL:break;default:nt(e,t);}}(this,e);break;case de.IN_TABLE_BODY:ot(this,e);break;case de.IN_ROW:Et(this,e);break;case de.IN_CELL:!function(e,t){const s=t.tagID;switch(s){case u.TD:case u.TH:e.openElements.hasInTableScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=de.IN_ROW);break;case u.TABLE:case u.TBODY:case u.TFOOT:case u.THEAD:case u.TR:e.openElements.hasInTableScope(s)&&(e._closeTableCell(),Et(e,t));break;case u.BODY:case u.CAPTION:case u.COL:case u.COLGROUP:case u.HTML:break;default:Ve(e,t);}}(this,e);break;case de.IN_SELECT:ht(this,e);break;case de.IN_SELECT_IN_TABLE:!function(e,t){const s=t.tagID;s===u.CAPTION||s===u.TABLE||s===u.TBODY||s===u.TFOOT||s===u.THEAD||s===u.TR||s===u.TD||s===u.TH?e.openElements.hasInTableScope(s)&&(e.openElements.popUntilTagNamePopped(u.SELECT),e._resetInsertionMode(),e.onEndTag(t)):ht(e,t);}(this,e);break;case de.IN_TEMPLATE:!function(e,t){t.tagID===u.TEMPLATE&&Fe(e,t);}(this,e);break;case de.AFTER_BODY:At(this,e);break;case de.IN_FRAMESET:!function(e,t){t.tagID!==u.FRAMESET||e.openElements.isRootHtmlElementCurrent()||(e.openElements.pop(),e.fragmentContext||e.openElements.currentTagId===u.FRAMESET||(e.insertionMode=de.AFTER_FRAMESET));}(this,e);break;case de.AFTER_FRAMESET:!function(e,t){t.tagID===u.HTML&&(e.insertionMode=de.AFTER_AFTER_FRAMESET);}(this,e);break;case de.AFTER_AFTER_BODY:mt(this,e);}}onEof(e){switch(this.insertionMode){case de.INITIAL:Pe(this,e);break;case de.BEFORE_HTML:be(this,e);break;case de.BEFORE_HEAD:Be(this,e);break;case de.IN_HEAD:Ue(this,e);break;case de.IN_HEAD_NO_SCRIPT:Ge(this,e);break;case de.AFTER_HEAD:ye(this,e);break;case de.IN_BODY:case de.IN_TABLE:case de.IN_CAPTION:case de.IN_COLUMN_GROUP:case de.IN_TABLE_BODY:case de.IN_ROW:case de.IN_CELL:case de.IN_SELECT:case de.IN_SELECT_IN_TABLE:ze(this,e);break;case de.TEXT:!function(e,t){e._err(t,T.eofInElementThatCanContainOnlyText),e.openElements.pop(),e.insertionMode=e.originalInsertionMode,e.onEof(t);}(this,e);break;case de.IN_TABLE_TEXT:st(this,e);break;case de.IN_TEMPLATE:_t(this,e);break;case de.AFTER_BODY:case de.IN_FRAMESET:case de.AFTER_FRAMESET:case de.AFTER_AFTER_BODY:case de.AFTER_AFTER_FRAMESET:ke(this,e);}}onWhitespaceCharacter(e){if(this.skipNextNewLine&&(this.skipNextNewLine=!1,e.chars.charCodeAt(0)===a.LINE_FEED)){if(1===e.chars.length)return;e.chars=e.chars.substr(1);}if(this.tokenizer.inForeignNode)this._insertCharacters(e);else switch(this.insertionMode){case de.IN_HEAD:case de.IN_HEAD_NO_SCRIPT:case de.AFTER_HEAD:case de.TEXT:case de.IN_COLUMN_GROUP:case de.IN_SELECT:case de.IN_SELECT_IN_TABLE:case de.IN_FRAMESET:case de.AFTER_FRAMESET:this._insertCharacters(e);break;case de.IN_BODY:case de.IN_CAPTION:case de.IN_CELL:case de.IN_TEMPLATE:case de.AFTER_BODY:case de.AFTER_AFTER_BODY:case de.AFTER_AFTER_FRAMESET:Ye(this,e);break;case de.IN_TABLE:case de.IN_TABLE_BODY:case de.IN_ROW:je(this,e);break;case de.IN_TABLE_TEXT:et(this,e);}}}function De(e,t){let s=e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);return s?e.openElements.contains(s.element)?e.openElements.hasInScope(t.tagID)||(s=null):(e.activeFormattingElements.removeEntry(s),s=null):Ke(e,t),s}function Se(e,t){let s=null,a=e.openElements.stackTop;for(;a>=0;a--){const r=e.openElements.items[a];if(r===t.element)break;e._isSpecialElement(r,e.openElements.tagIDs[a])&&(s=r);}return s||(e.openElements.shortenToLength(a<0?0:a),e.activeFormattingElements.removeEntry(t)),s}function Re(e,t,s){let a=t,r=e.openElements.getCommonAncestor(t);for(let n=0,i=r;i!==s;n++,i=r){r=e.openElements.getCommonAncestor(i);const s=e.activeFormattingElements.getElementEntry(i),o=s&&n>=3;!s||o?(o&&e.activeFormattingElements.removeEntry(s),e.openElements.remove(i)):(i=Oe(e,s),a===t&&(e.activeFormattingElements.bookmark=s),e.treeAdapter.detachNode(a),e.treeAdapter.appendChild(i,a),a=i);}return a}function Oe(e,t){const s=e.treeAdapter.getNamespaceURI(t.element),a=e.treeAdapter.createElement(t.token.tagName,s,t.token.attrs);return e.openElements.replace(t.element,a),t.element=a,a}function fe(e,t,s){const a=f(e.treeAdapter.getTagName(t));if(e._isElementCausesFosterParenting(a))e._fosterParentElement(s);else {const r=e.treeAdapter.getNamespaceURI(t);a===u.TEMPLATE&&r===p.HTML&&(t=e.treeAdapter.getTemplateContent(t)),e.treeAdapter.appendChild(t,s);}}function Le(e,t,s){const a=e.treeAdapter.getNamespaceURI(s.element),{token:r}=s,n=e.treeAdapter.createElement(r.tagName,a,r.attrs);e._adoptNodes(t,n),e.treeAdapter.appendChild(t,n),e.activeFormattingElements.insertElementAfterBookmark(n,r),e.activeFormattingElements.removeEntry(s),e.openElements.remove(s.element),e.openElements.insertAfter(t,n,r.tagID);}function ge(e,t){for(let s=0;s<8;s++){const s=De(e,t);if(!s)break;const a=Se(e,s);if(!a)break;e.activeFormattingElements.bookmark=s;const r=Re(e,a,s.element),n=e.openElements.getCommonAncestor(s.element);e.treeAdapter.detachNode(r),n&&fe(e,n,r),Le(e,a,s);}}function Me(e,t){e._appendCommentNode(t,e.openElements.currentTmplContentOrNode);}function ke(e,t){if(e.stopped=!0,t.location){const s=e.fragmentContext?0:2;for(let a=e.openElements.stackTop;a>=s;a--)e._setEndLocation(e.openElements.items[a],t);if(!e.fragmentContext&&e.openElements.stackTop>=0){const s=e.openElements.items[0],a=e.treeAdapter.getNodeSourceCodeLocation(s);if(a&&!a.endTag&&(e._setEndLocation(s,t),e.openElements.stackTop>=1)){const s=e.openElements.items[1],a=e.treeAdapter.getNodeSourceCodeLocation(s);a&&!a.endTag&&e._setEndLocation(s,t);}}}}function Pe(e,t){e._err(t,T.missingDoctype,!0),e.treeAdapter.setDocumentMode(e.document,I.QUIRKS),e.insertionMode=de.BEFORE_HTML,e._processToken(t);}function be(e,t){e._insertFakeRootElement(),e.insertionMode=de.BEFORE_HEAD,e._processToken(t);}function Be(e,t){e._insertFakeElement(N.HEAD,u.HEAD),e.headElement=e.openElements.current,e.insertionMode=de.IN_HEAD,e._processToken(t);}function He(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.BASE:case u.BASEFONT:case u.BGSOUND:case u.LINK:case u.META:e._appendElement(t,p.HTML),t.ackSelfClosing=!0;break;case u.TITLE:e._switchToTextParsing(t,b.RCDATA);break;case u.NOSCRIPT:e.options.scriptingEnabled?e._switchToTextParsing(t,b.RAWTEXT):(e._insertElement(t,p.HTML),e.insertionMode=de.IN_HEAD_NO_SCRIPT);break;case u.NOFRAMES:case u.STYLE:e._switchToTextParsing(t,b.RAWTEXT);break;case u.SCRIPT:e._switchToTextParsing(t,b.SCRIPT_DATA);break;case u.TEMPLATE:e._insertTemplate(t),e.activeFormattingElements.insertMarker(),e.framesetOk=!1,e.insertionMode=de.IN_TEMPLATE,e.tmplInsertionModeStack.unshift(de.IN_TEMPLATE);break;case u.HEAD:e._err(t,T.misplacedStartTagForHeadElement);break;default:Ue(e,t);}}function Fe(e,t){e.openElements.tmplCount>0?(e.openElements.generateImpliedEndTagsThoroughly(),e.openElements.currentTagId!==u.TEMPLATE&&e._err(t,T.closingOfElementWithOpenChildElements),e.openElements.popUntilTagNamePopped(u.TEMPLATE),e.activeFormattingElements.clearToLastMarker(),e.tmplInsertionModeStack.shift(),e._resetInsertionMode()):e._err(t,T.endTagWithoutMatchingOpenElement);}function Ue(e,t){e.openElements.pop(),e.insertionMode=de.AFTER_HEAD,e._processToken(t);}function Ge(e,t){const s=t.type===h.EOF?T.openElementsLeftAfterEof:T.disallowedContentInNoscriptInHead;e._err(t,s),e.openElements.pop(),e.insertionMode=de.IN_HEAD,e._processToken(t);}function ye(e,t){e._insertFakeElement(N.BODY,u.BODY),e.insertionMode=de.IN_BODY,we(e,t);}function we(e,t){switch(t.type){case h.CHARACTER:xe(e,t);break;case h.WHITESPACE_CHARACTER:Ye(e,t);break;case h.COMMENT:Me(e,t);break;case h.START_TAG:Xe(e,t);break;case h.END_TAG:Ve(e,t);break;case h.EOF:ze(e,t);}}function Ye(e,t){e._reconstructActiveFormattingElements(),e._insertCharacters(t);}function xe(e,t){e._reconstructActiveFormattingElements(),e._insertCharacters(t),e.framesetOk=!1;}function ve(e,t){e._reconstructActiveFormattingElements(),e._appendElement(t,p.HTML),e.framesetOk=!1,t.ackSelfClosing=!0;}function Qe(e){const t=A(e,d.TYPE);return null!=t&&"hidden"===t.toLowerCase()}function qe(e,t){e._switchToTextParsing(t,b.RAWTEXT);}function We(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML);}function Xe(e,t){switch(t.tagID){case u.I:case u.S:case u.B:case u.U:case u.EM:case u.TT:case u.BIG:case u.CODE:case u.FONT:case u.SMALL:case u.STRIKE:case u.STRONG:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case u.A:!function(e,t){const s=e.activeFormattingElements.getElementEntryInScopeWithTagName(N.A);s&&(ge(e,t),e.openElements.remove(s.element),e.activeFormattingElements.removeEntry(s)),e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case u.H1:case u.H2:case u.H3:case u.H4:case u.H5:case u.H6:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),M(e.openElements.currentTagId)&&e.openElements.pop(),e._insertElement(t,p.HTML);}(e,t);break;case u.P:case u.DL:case u.OL:case u.UL:case u.DIV:case u.DIR:case u.NAV:case u.MAIN:case u.MENU:case u.ASIDE:case u.CENTER:case u.FIGURE:case u.FOOTER:case u.HEADER:case u.HGROUP:case u.DIALOG:case u.DETAILS:case u.ADDRESS:case u.ARTICLE:case u.SECTION:case u.SUMMARY:case u.FIELDSET:case u.BLOCKQUOTE:case u.FIGCAPTION:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML);}(e,t);break;case u.LI:case u.DD:case u.DT:!function(e,t){e.framesetOk=!1;const s=t.tagID;for(let t=e.openElements.stackTop;t>=0;t--){const a=e.openElements.tagIDs[t];if(s===u.LI&&a===u.LI||(s===u.DD||s===u.DT)&&(a===u.DD||a===u.DT)){e.openElements.generateImpliedEndTagsWithExclusion(a),e.openElements.popUntilTagNamePopped(a);break}if(a!==u.ADDRESS&&a!==u.DIV&&a!==u.P&&e._isSpecialElement(e.openElements.items[t],a))break}e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML);}(e,t);break;case u.BR:case u.IMG:case u.WBR:case u.AREA:case u.EMBED:case u.KEYGEN:ve(e,t);break;case u.HR:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._appendElement(t,p.HTML),e.framesetOk=!1,t.ackSelfClosing=!0;}(e,t);break;case u.RB:case u.RTC:!function(e,t){e.openElements.hasInScope(u.RUBY)&&e.openElements.generateImpliedEndTags(),e._insertElement(t,p.HTML);}(e,t);break;case u.RT:case u.RP:!function(e,t){e.openElements.hasInScope(u.RUBY)&&e.openElements.generateImpliedEndTagsWithExclusion(u.RTC),e._insertElement(t,p.HTML);}(e,t);break;case u.PRE:case u.LISTING:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML),e.skipNextNewLine=!0,e.framesetOk=!1;}(e,t);break;case u.XMP:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._reconstructActiveFormattingElements(),e.framesetOk=!1,e._switchToTextParsing(t,b.RAWTEXT);}(e,t);break;case u.SVG:!function(e,t){e._reconstructActiveFormattingElements(),me(t),pe(t),t.selfClosing?e._appendElement(t,p.SVG):e._insertElement(t,p.SVG),t.ackSelfClosing=!0;}(e,t);break;case u.HTML:!function(e,t){0===e.openElements.tmplCount&&e.treeAdapter.adoptAttributes(e.openElements.items[0],t.attrs);}(e,t);break;case u.BASE:case u.LINK:case u.META:case u.STYLE:case u.TITLE:case u.SCRIPT:case u.BGSOUND:case u.BASEFONT:case u.TEMPLATE:He(e,t);break;case u.BODY:!function(e,t){const s=e.openElements.tryPeekProperlyNestedBodyElement();s&&0===e.openElements.tmplCount&&(e.framesetOk=!1,e.treeAdapter.adoptAttributes(s,t.attrs));}(e,t);break;case u.FORM:!function(e,t){const s=e.openElements.tmplCount>0;e.formElement&&!s||(e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML),s||(e.formElement=e.openElements.current));}(e,t);break;case u.NOBR:!function(e,t){e._reconstructActiveFormattingElements(),e.openElements.hasInScope(u.NOBR)&&(ge(e,t),e._reconstructActiveFormattingElements()),e._insertElement(t,p.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case u.MATH:!function(e,t){e._reconstructActiveFormattingElements(),le(t),pe(t),t.selfClosing?e._appendElement(t,p.MATHML):e._insertElement(t,p.MATHML),t.ackSelfClosing=!0;}(e,t);break;case u.TABLE:!function(e,t){e.treeAdapter.getDocumentMode(e.document)!==I.QUIRKS&&e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML),e.framesetOk=!1,e.insertionMode=de.IN_TABLE;}(e,t);break;case u.INPUT:!function(e,t){e._reconstructActiveFormattingElements(),e._appendElement(t,p.HTML),Qe(t)||(e.framesetOk=!1),t.ackSelfClosing=!0;}(e,t);break;case u.PARAM:case u.TRACK:case u.SOURCE:!function(e,t){e._appendElement(t,p.HTML),t.ackSelfClosing=!0;}(e,t);break;case u.IMAGE:!function(e,t){t.tagName=N.IMG,t.tagID=u.IMG,ve(e,t);}(e,t);break;case u.BUTTON:!function(e,t){e.openElements.hasInScope(u.BUTTON)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(u.BUTTON)),e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.framesetOk=!1;}(e,t);break;case u.APPLET:case u.OBJECT:case u.MARQUEE:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.activeFormattingElements.insertMarker(),e.framesetOk=!1;}(e,t);break;case u.IFRAME:!function(e,t){e.framesetOk=!1,e._switchToTextParsing(t,b.RAWTEXT);}(e,t);break;case u.SELECT:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.framesetOk=!1,e.insertionMode=e.insertionMode===de.IN_TABLE||e.insertionMode===de.IN_CAPTION||e.insertionMode===de.IN_TABLE_BODY||e.insertionMode===de.IN_ROW||e.insertionMode===de.IN_CELL?de.IN_SELECT_IN_TABLE:de.IN_SELECT;}(e,t);break;case u.OPTION:case u.OPTGROUP:!function(e,t){e.openElements.currentTagId===u.OPTION&&e.openElements.pop(),e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML);}(e,t);break;case u.NOEMBED:qe(e,t);break;case u.FRAMESET:!function(e,t){const s=e.openElements.tryPeekProperlyNestedBodyElement();e.framesetOk&&s&&(e.treeAdapter.detachNode(s),e.openElements.popAllUpToHtmlElement(),e._insertElement(t,p.HTML),e.insertionMode=de.IN_FRAMESET);}(e,t);break;case u.TEXTAREA:!function(e,t){e._insertElement(t,p.HTML),e.skipNextNewLine=!0,e.tokenizer.state=b.RCDATA,e.originalInsertionMode=e.insertionMode,e.framesetOk=!1,e.insertionMode=de.TEXT;}(e,t);break;case u.NOSCRIPT:e.options.scriptingEnabled?qe(e,t):We(e,t);break;case u.PLAINTEXT:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML),e.tokenizer.state=b.PLAINTEXT;}(e,t);break;case u.COL:case u.TH:case u.TD:case u.TR:case u.HEAD:case u.FRAME:case u.TBODY:case u.TFOOT:case u.THEAD:case u.CAPTION:case u.COLGROUP:break;default:We(e,t);}}function Ke(e,t){const s=t.tagName,a=t.tagID;for(let t=e.openElements.stackTop;t>0;t--){const r=e.openElements.items[t],n=e.openElements.tagIDs[t];if(a===n&&(a!==u.UNKNOWN||e.treeAdapter.getTagName(r)===s)){e.openElements.generateImpliedEndTagsWithExclusion(a),e.openElements.stackTop>=t&&e.openElements.shortenToLength(t);break}if(e._isSpecialElement(r,n))break}}function Ve(e,t){switch(t.tagID){case u.A:case u.B:case u.I:case u.S:case u.U:case u.EM:case u.TT:case u.BIG:case u.CODE:case u.FONT:case u.NOBR:case u.SMALL:case u.STRIKE:case u.STRONG:ge(e,t);break;case u.P:!function(e){e.openElements.hasInButtonScope(u.P)||e._insertFakeElement(N.P,u.P),e._closePElement();}(e);break;case u.DL:case u.UL:case u.OL:case u.DIR:case u.DIV:case u.NAV:case u.PRE:case u.MAIN:case u.MENU:case u.ASIDE:case u.BUTTON:case u.CENTER:case u.FIGURE:case u.FOOTER:case u.HEADER:case u.HGROUP:case u.DIALOG:case u.ADDRESS:case u.ARTICLE:case u.DETAILS:case u.SECTION:case u.SUMMARY:case u.LISTING:case u.FIELDSET:case u.BLOCKQUOTE:case u.FIGCAPTION:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s));}(e,t);break;case u.LI:!function(e){e.openElements.hasInListItemScope(u.LI)&&(e.openElements.generateImpliedEndTagsWithExclusion(u.LI),e.openElements.popUntilTagNamePopped(u.LI));}(e);break;case u.DD:case u.DT:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTagsWithExclusion(s),e.openElements.popUntilTagNamePopped(s));}(e,t);break;case u.H1:case u.H2:case u.H3:case u.H4:case u.H5:case u.H6:!function(e){e.openElements.hasNumberedHeaderInScope()&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilNumberedHeaderPopped());}(e);break;case u.BR:!function(e){e._reconstructActiveFormattingElements(),e._insertFakeElement(N.BR,u.BR),e.openElements.pop(),e.framesetOk=!1;}(e);break;case u.BODY:!function(e,t){if(e.openElements.hasInScope(u.BODY)&&(e.insertionMode=de.AFTER_BODY,e.options.sourceCodeLocationInfo)){const s=e.openElements.tryPeekProperlyNestedBodyElement();s&&e._setEndLocation(s,t);}}(e,t);break;case u.HTML:!function(e,t){e.openElements.hasInScope(u.BODY)&&(e.insertionMode=de.AFTER_BODY,At(e,t));}(e,t);break;case u.FORM:!function(e){const t=e.openElements.tmplCount>0,{formElement:s}=e;t||(e.formElement=null),(s||t)&&e.openElements.hasInScope(u.FORM)&&(e.openElements.generateImpliedEndTags(),t?e.openElements.popUntilTagNamePopped(u.FORM):s&&e.openElements.remove(s));}(e);break;case u.APPLET:case u.OBJECT:case u.MARQUEE:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s),e.activeFormattingElements.clearToLastMarker());}(e,t);break;case u.TEMPLATE:Fe(e,t);break;default:Ke(e,t);}}function ze(e,t){e.tmplInsertionModeStack.length>0?_t(e,t):ke(e,t);}function je(e,t){if(Ne.has(e.openElements.currentTagId))switch(e.pendingCharacterTokens.length=0,e.hasNonWhitespacePendingCharacterToken=!1,e.originalInsertionMode=e.insertionMode,e.insertionMode=de.IN_TABLE_TEXT,t.type){case h.CHARACTER:tt(e,t);break;case h.WHITESPACE_CHARACTER:et(e,t);}else $e(e,t);}function Je(e,t){switch(t.tagID){case u.TD:case u.TH:case u.TR:!function(e,t){e.openElements.clearBackToTableContext(),e._insertFakeElement(N.TBODY,u.TBODY),e.insertionMode=de.IN_TABLE_BODY,it(e,t);}(e,t);break;case u.STYLE:case u.SCRIPT:case u.TEMPLATE:He(e,t);break;case u.COL:!function(e,t){e.openElements.clearBackToTableContext(),e._insertFakeElement(N.COLGROUP,u.COLGROUP),e.insertionMode=de.IN_COLUMN_GROUP,rt(e,t);}(e,t);break;case u.FORM:!function(e,t){e.formElement||0!==e.openElements.tmplCount||(e._insertElement(t,p.HTML),e.formElement=e.openElements.current,e.openElements.pop());}(e,t);break;case u.TABLE:!function(e,t){e.openElements.hasInTableScope(u.TABLE)&&(e.openElements.popUntilTagNamePopped(u.TABLE),e._resetInsertionMode(),e._processStartTag(t));}(e,t);break;case u.TBODY:case u.TFOOT:case u.THEAD:!function(e,t){e.openElements.clearBackToTableContext(),e._insertElement(t,p.HTML),e.insertionMode=de.IN_TABLE_BODY;}(e,t);break;case u.INPUT:!function(e,t){Qe(t)?e._appendElement(t,p.HTML):$e(e,t),t.ackSelfClosing=!0;}(e,t);break;case u.CAPTION:!function(e,t){e.openElements.clearBackToTableContext(),e.activeFormattingElements.insertMarker(),e._insertElement(t,p.HTML),e.insertionMode=de.IN_CAPTION;}(e,t);break;case u.COLGROUP:!function(e,t){e.openElements.clearBackToTableContext(),e._insertElement(t,p.HTML),e.insertionMode=de.IN_COLUMN_GROUP;}(e,t);break;default:$e(e,t);}}function Ze(e,t){switch(t.tagID){case u.TABLE:e.openElements.hasInTableScope(u.TABLE)&&(e.openElements.popUntilTagNamePopped(u.TABLE),e._resetInsertionMode());break;case u.TEMPLATE:Fe(e,t);break;case u.BODY:case u.CAPTION:case u.COL:case u.COLGROUP:case u.HTML:case u.TBODY:case u.TD:case u.TFOOT:case u.TH:case u.THEAD:case u.TR:break;default:$e(e,t);}}function $e(e,t){const s=e.fosterParentingEnabled;e.fosterParentingEnabled=!0,we(e,t),e.fosterParentingEnabled=s;}function et(e,t){e.pendingCharacterTokens.push(t);}function tt(e,t){e.pendingCharacterTokens.push(t),e.hasNonWhitespacePendingCharacterToken=!0;}function st(e,t){let s=0;if(e.hasNonWhitespacePendingCharacterToken)for(;s<e.pendingCharacterTokens.length;s++)$e(e,e.pendingCharacterTokens[s]);else for(;s<e.pendingCharacterTokens.length;s++)e._insertCharacters(e.pendingCharacterTokens[s]);e.insertionMode=e.originalInsertionMode,e._processToken(t);}const at=new Set([u.CAPTION,u.COL,u.COLGROUP,u.TBODY,u.TD,u.TFOOT,u.TH,u.THEAD,u.TR]);function rt(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.COL:e._appendElement(t,p.HTML),t.ackSelfClosing=!0;break;case u.TEMPLATE:He(e,t);break;default:nt(e,t);}}function nt(e,t){e.openElements.currentTagId===u.COLGROUP&&(e.openElements.pop(),e.insertionMode=de.IN_TABLE,e._processToken(t));}function it(e,t){switch(t.tagID){case u.TR:e.openElements.clearBackToTableBodyContext(),e._insertElement(t,p.HTML),e.insertionMode=de.IN_ROW;break;case u.TH:case u.TD:e.openElements.clearBackToTableBodyContext(),e._insertFakeElement(N.TR,u.TR),e.insertionMode=de.IN_ROW,ct(e,t);break;case u.CAPTION:case u.COL:case u.COLGROUP:case u.TBODY:case u.TFOOT:case u.THEAD:e.openElements.hasTableBodyContextInTableScope()&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=de.IN_TABLE,Je(e,t));break;default:Je(e,t);}}function ot(e,t){const s=t.tagID;switch(t.tagID){case u.TBODY:case u.TFOOT:case u.THEAD:e.openElements.hasInTableScope(s)&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=de.IN_TABLE);break;case u.TABLE:e.openElements.hasTableBodyContextInTableScope()&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=de.IN_TABLE,Ze(e,t));break;case u.BODY:case u.CAPTION:case u.COL:case u.COLGROUP:case u.HTML:case u.TD:case u.TH:case u.TR:break;default:Ze(e,t);}}function ct(e,t){switch(t.tagID){case u.TH:case u.TD:e.openElements.clearBackToTableRowContext(),e._insertElement(t,p.HTML),e.insertionMode=de.IN_CELL,e.activeFormattingElements.insertMarker();break;case u.CAPTION:case u.COL:case u.COLGROUP:case u.TBODY:case u.TFOOT:case u.THEAD:case u.TR:e.openElements.hasInTableScope(u.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=de.IN_TABLE_BODY,it(e,t));break;default:Je(e,t);}}function Et(e,t){switch(t.tagID){case u.TR:e.openElements.hasInTableScope(u.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=de.IN_TABLE_BODY);break;case u.TABLE:e.openElements.hasInTableScope(u.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=de.IN_TABLE_BODY,ot(e,t));break;case u.TBODY:case u.TFOOT:case u.THEAD:(e.openElements.hasInTableScope(t.tagID)||e.openElements.hasInTableScope(u.TR))&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=de.IN_TABLE_BODY,ot(e,t));break;case u.BODY:case u.CAPTION:case u.COL:case u.COLGROUP:case u.HTML:case u.TD:case u.TH:break;default:Ze(e,t);}}function Tt(e,t){switch(t.tagID){case u.HTML:Xe(e,t);break;case u.OPTION:e.openElements.currentTagId===u.OPTION&&e.openElements.pop(),e._insertElement(t,p.HTML);break;case u.OPTGROUP:e.openElements.currentTagId===u.OPTION&&e.openElements.pop(),e.openElements.currentTagId===u.OPTGROUP&&e.openElements.pop(),e._insertElement(t,p.HTML);break;case u.INPUT:case u.KEYGEN:case u.TEXTAREA:case u.SELECT:e.openElements.hasInSelectScope(u.SELECT)&&(e.openElements.popUntilTagNamePopped(u.SELECT),e._resetInsertionMode(),t.tagID!==u.SELECT&&e._processStartTag(t));break;case u.SCRIPT:case u.TEMPLATE:He(e,t);}}function ht(e,t){switch(t.tagID){case u.OPTGROUP:e.openElements.stackTop>0&&e.openElements.currentTagId===u.OPTION&&e.openElements.tagIDs[e.openElements.stackTop-1]===u.OPTGROUP&&e.openElements.pop(),e.openElements.currentTagId===u.OPTGROUP&&e.openElements.pop();break;case u.OPTION:e.openElements.currentTagId===u.OPTION&&e.openElements.pop();break;case u.SELECT:e.openElements.hasInSelectScope(u.SELECT)&&(e.openElements.popUntilTagNamePopped(u.SELECT),e._resetInsertionMode());break;case u.TEMPLATE:Fe(e,t);}}function _t(e,t){e.openElements.tmplCount>0?(e.openElements.popUntilTagNamePopped(u.TEMPLATE),e.activeFormattingElements.clearToLastMarker(),e.tmplInsertionModeStack.shift(),e._resetInsertionMode(),e.onEof(t)):ke(e,t);}function At(e,t){var s;if(t.tagID===u.HTML){if(e.fragmentContext||(e.insertionMode=de.AFTER_AFTER_BODY),e.options.sourceCodeLocationInfo&&e.openElements.tagIDs[0]===u.HTML){e._setEndLocation(e.openElements.items[0],t);const a=e.openElements.items[1];a&&!(null===(s=e.treeAdapter.getNodeSourceCodeLocation(a))||void 0===s?void 0:s.endTag)&&e._setEndLocation(a,t);}}else lt(e,t);}function lt(e,t){e.insertionMode=de.IN_BODY,we(e,t);}function mt(e,t){e.insertionMode=de.IN_BODY,we(e,t);}function pt(e){for(;e.treeAdapter.getNamespaceURI(e.openElements.current)!==p.HTML&&!e._isIntegrationPoint(e.openElements.currentTagId,e.openElements.current);)e.openElements.pop();}return new Set([N.AREA,N.BASE,N.BASEFONT,N.BGSOUND,N.BR,N.COL,N.EMBED,N.FRAME,N.HR,N.IMG,N.INPUT,N.KEYGEN,N.LINK,N.META,N.PARAM,N.SOURCE,N.TRACK,N.WBR]),e.parse=function(e,t){return Ce.parse(e,t)},e.parseFragment=function(e,t,s){"string"==typeof e&&(s=t,t=e,e=null);const a=Ce.getFragmentParser(e,s);return a.tokenizer.write(t,!0),a.getFragment()},Object.defineProperty(e,"__esModule",{value:!0}),e}({});const parse=e.parse;const parseFragment=e.parseFragment;

const docParser = new WeakMap();
function parseDocumentUtil(ownerDocument, html) {
  const doc = parse(html.trim(), getParser(ownerDocument));
  doc.documentElement = doc.firstElementChild;
  doc.head = doc.documentElement.firstElementChild;
  doc.body = doc.head.nextElementSibling;
  return doc;
}
function parseFragmentUtil(ownerDocument, html) {
  if (typeof html === 'string') {
    html = html.trim();
  }
  else {
    html = '';
  }
  const frag = parseFragment(html, getParser(ownerDocument));
  return frag;
}
function getParser(ownerDocument) {
  let parseOptions = docParser.get(ownerDocument);
  if (parseOptions != null) {
    return parseOptions;
  }
  const treeAdapter = {
    createDocument() {
      const doc = ownerDocument.createElement("#document" /* NODE_NAMES.DOCUMENT_NODE */);
      doc['x-mode'] = 'no-quirks';
      return doc;
    },
    setNodeSourceCodeLocation(node, location) {
      node.sourceCodeLocation = location;
    },
    getNodeSourceCodeLocation(node) {
      return node.sourceCodeLocation;
    },
    createDocumentFragment() {
      return ownerDocument.createDocumentFragment();
    },
    createElement(tagName, namespaceURI, attrs) {
      const elm = ownerDocument.createElementNS(namespaceURI, tagName);
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (attr.namespace == null || attr.namespace === 'http://www.w3.org/1999/xhtml') {
          elm.setAttribute(attr.name, attr.value);
        }
        else {
          elm.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
      return elm;
    },
    createCommentNode(data) {
      return ownerDocument.createComment(data);
    },
    appendChild(parentNode, newNode) {
      parentNode.appendChild(newNode);
    },
    insertBefore(parentNode, newNode, referenceNode) {
      parentNode.insertBefore(newNode, referenceNode);
    },
    setTemplateContent(templateElement, contentElement) {
      templateElement.content = contentElement;
    },
    getTemplateContent(templateElement) {
      return templateElement.content;
    },
    setDocumentType(doc, name, publicId, systemId) {
      let doctypeNode = doc.childNodes.find((n) => n.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */);
      if (doctypeNode == null) {
        doctypeNode = ownerDocument.createDocumentTypeNode();
        doc.insertBefore(doctypeNode, doc.firstChild);
      }
      doctypeNode.nodeValue = '!DOCTYPE';
      doctypeNode['x-name'] = name;
      doctypeNode['x-publicId'] = publicId;
      doctypeNode['x-systemId'] = systemId;
    },
    setDocumentMode(doc, mode) {
      doc['x-mode'] = mode;
    },
    getDocumentMode(doc) {
      return doc['x-mode'];
    },
    detachNode(node) {
      node.remove();
    },
    insertText(parentNode, text) {
      const lastChild = parentNode.lastChild;
      if (lastChild != null && lastChild.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
        lastChild.nodeValue += text;
      }
      else {
        parentNode.appendChild(ownerDocument.createTextNode(text));
      }
    },
    insertTextBefore(parentNode, text, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode != null && prevNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
        prevNode.nodeValue += text;
      }
      else {
        parentNode.insertBefore(ownerDocument.createTextNode(text), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (recipient.hasAttributeNS(attr.namespace, attr.name) === false) {
          recipient.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
    },
    getFirstChild(node) {
      return node.childNodes[0];
    },
    getChildNodes(node) {
      return node.childNodes;
    },
    getParentNode(node) {
      return node.parentNode;
    },
    getAttrList(element) {
      const attrs = element.attributes.__items.map((attr) => {
        return {
          name: attr.name,
          value: attr.value,
          namespace: attr.namespaceURI,
          prefix: null,
        };
      });
      return attrs;
    },
    getTagName(element) {
      if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
        return element.nodeName.toLowerCase();
      }
      else {
        return element.nodeName;
      }
    },
    getNamespaceURI(element) {
      // mock-doc widens the type of an element's namespace uri to 'string | null'
      // we use a type assertion here to adhere to parse5's type definitions
      return element.namespaceURI;
    },
    getTextNodeContent(textNode) {
      return textNode.nodeValue;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.nodeValue;
    },
    getDocumentTypeNodeName(doctypeNode) {
      return doctypeNode['x-name'];
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      return doctypeNode['x-publicId'];
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      return doctypeNode['x-systemId'];
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['text']`. As a result, we cannot
    // complete this function signature
    isTextNode(node) {
      return node.nodeType === 3 /* NODE_TYPES.TEXT_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['comment']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isCommentNode(node) {
      return node.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['document']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isDocumentTypeNode(node) {
      return node.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['element']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isElementNode(node) {
      return node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */;
    },
  };
  parseOptions = {
    treeAdapter: treeAdapter,
  };
  docParser.set(ownerDocument, parseOptions);
  return parseOptions;
}

// Sizzle 2.3.9
const Sizzle = (function() {
const window = {
  document: {
  createElement() {
    return {};
  },
  nodeType: 9,
  documentElement: {
    nodeType: 1,
    nodeName: 'HTML'
  }
  }
};
const module = { exports: {} };

/*! Sizzle v2.3.9 | (c) JS Foundation and other contributors | js.foundation */
!function(e){var t,n,r,i,o,u,l,a,s,c,f,d,p,h,g,m,y,v,w,b="sizzle"+1*new Date,N=e.document,C=0,x=0,S=ae(),E=ae(),A=ae(),D=ae(),T=function(e,t){return e===t&&(f=!0),0},L={}.hasOwnProperty,q=[],I=q.pop,B=q.push,R=q.push,k=q.slice,$=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return -1},H="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",P="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",z="\\["+M+"*("+P+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+P+"))|)"+M+"*\\]",F=":("+P+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+z+")*)|.*)\\)|)",O=new RegExp(M+"+","g"),j=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),G=new RegExp("^"+M+"*,"+M+"*"),U=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),V=new RegExp(M+"|>"),X=new RegExp(F),J=new RegExp("^"+P+"$"),K={ID:new RegExp("^#("+P+")"),CLASS:new RegExp("^\\.("+P+")"),TAG:new RegExp("^("+P+"|[*])"),ATTR:new RegExp("^"+z),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+H+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Q=/HTML$/i,W=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){d();},ue=ve(function(e){return !0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{R.apply(q=k.call(N.childNodes),N.childNodes),q[N.childNodes.length].nodeType;}catch(e){R={apply:q.length?function(e,t){B.apply(e,k.call(t));}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1;}};}function le(e,t,r,i){var o,l,s,c,f,h,y,v=t&&t.ownerDocument,N=t?t.nodeType:9;if(r=r||[],"string"!=typeof e||!e||1!==N&&9!==N&&11!==N)return r;if(!i&&(d(t),t=t||p,g)){if(11!==N&&(f=_.exec(e)))if(o=f[1]){if(9===N){if(!(s=t.getElementById(o)))return r;if(s.id===o)return r.push(s),r}else if(v&&(s=v.getElementById(o))&&w(t,s)&&s.id===o)return r.push(s),r}else {if(f[2])return R.apply(r,t.getElementsByTagName(e)),r;if((o=f[3])&&n.getElementsByClassName&&t.getElementsByClassName)return R.apply(r,t.getElementsByClassName(o)),r}if(n.qsa&&!D[e+" "]&&(!m||!m.test(e))&&(1!==N||"object"!==t.nodeName.toLowerCase())){if(y=e,v=t,1===N&&(V.test(e)||U.test(e))){(v=ee.test(e)&&ge(t.parentNode)||t)===t&&n.scope||((c=t.getAttribute("id"))?c=c.replace(re,ie):t.setAttribute("id",c=b)),l=(h=u(e)).length;while(l--)h[l]=(c?"#"+c:":scope")+" "+ye(h[l]);y=h.join(",");}try{if(n.cssSupportsSelector&&!CSS.supports("selector(:is("+y+"))"))throw new Error;return R.apply(r,v.querySelectorAll(y)),r}catch(t){D(e,!0);}finally{c===b&&t.removeAttribute("id");}}}return a(e.replace(j,"$1"),t,r,i)}function ae(){var e=[];function t(n,i){return e.push(n+" ")>r.cacheLength&&delete t[e.shift()],t[n+" "]=i}return t}function se(e){return e[b]=!0,e}function ce(e){var t=p.createElement("fieldset");try{return !!e(t)}catch(e){return !1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null;}}function fe(e,t){var n=e.split("|"),i=n.length;while(i--)r.attrHandle[n[i]]=t;}function de(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return -1;return e?1:-1}function pe(e){return function(t){return "form"in t?t.parentNode&&!1===t.disabled?"label"in t?"label"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&ue(t)===e:t.disabled===e:"label"in t&&t.disabled===e}}function he(e){return se(function(t){return t=+t,se(function(n,r){var i,o=e([],n.length,t),u=o.length;while(u--)n[i=o[u]]&&(n[i]=!(r[i]=n[i]));})})}function ge(e){return e&&void 0!==e.getElementsByTagName&&e}n=le.support={},o=le.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return !Q.test(t||n&&n.nodeName||"HTML")},d=le.setDocument=function(e){var t,i,u=e?e.ownerDocument||e:N;return u!=p&&9===u.nodeType&&u.documentElement?(p=u,h=p.documentElement,g=!o(p),N!=p&&(i=p.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener("unload",oe,!1):i.attachEvent&&i.attachEvent("onunload",oe)),n.scope=ce(function(e){return h.appendChild(e).appendChild(p.createElement("div")),void 0!==e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),n.cssSupportsSelector=ce(function(){return CSS.supports("selector(*)")&&p.querySelectorAll(":is(:jqfake)")&&!CSS.supports("selector(:is(*,:jqfake))")}),n.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),n.getElementsByTagName=ce(function(e){return e.appendChild(p.createComment("")),!e.getElementsByTagName("*").length}),n.getElementsByClassName=Z.test(p.getElementsByClassName),n.getById=ce(function(e){return h.appendChild(e).id=b,!p.getElementsByName||!p.getElementsByName(b).length}),n.getById?(r.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},r.find.ID=function(e,t){if(void 0!==t.getElementById&&g){var n=t.getElementById(e);return n?[n]:[]}}):(r.filter.ID=function(e){var t=e.replace(te,ne);return function(e){var n=void 0!==e.getAttributeNode&&e.getAttributeNode("id");return n&&n.value===t}},r.find.ID=function(e,t){if(void 0!==t.getElementById&&g){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return [o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return [o]}return []}}),r.find.TAG=n.getElementsByTagName?function(e,t){return void 0!==t.getElementsByTagName?t.getElementsByTagName(e):n.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=n.getElementsByClassName&&function(e,t){if(void 0!==t.getElementsByClassName&&g)return t.getElementsByClassName(e)},y=[],m=[],(n.qsa=Z.test(p.querySelectorAll))&&(ce(function(e){var t;h.appendChild(e).innerHTML="<a id='"+b+"'></a><select id='"+b+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&m.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||m.push("\\["+M+"*(?:value|"+H+")"),e.querySelectorAll("[id~="+b+"-]").length||m.push("~="),(t=p.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||m.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||m.push(":checked"),e.querySelectorAll("a#"+b+"+*").length||m.push(".#.+[+~]"),e.querySelectorAll("\\\f"),m.push("[\\r\\n\\f]");}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=p.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&m.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&m.push(":enabled",":disabled"),h.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&m.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),m.push(",.*:");})),(n.matchesSelector=Z.test(v=h.matches||h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&ce(function(e){n.disconnectedMatch=v.call(e,"*"),v.call(e,"[s!='']:x"),y.push("!=",F);}),n.cssSupportsSelector||m.push(":has"),m=m.length&&new RegExp(m.join("|")),y=y.length&&new RegExp(y.join("|")),t=Z.test(h.compareDocumentPosition),w=t||Z.test(h.contains)?function(e,t){var n=9===e.nodeType&&e.documentElement||e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return !0;return !1},T=t?function(e,t){if(e===t)return f=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r||(1&(r=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!n.sortDetached&&t.compareDocumentPosition(e)===r?e==p||e.ownerDocument==N&&w(N,e)?-1:t==p||t.ownerDocument==N&&w(N,t)?1:c?$(c,e)-$(c,t):0:4&r?-1:1)}:function(e,t){if(e===t)return f=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,u=[e],l=[t];if(!i||!o)return e==p?-1:t==p?1:i?-1:o?1:c?$(c,e)-$(c,t):0;if(i===o)return de(e,t);n=e;while(n=n.parentNode)u.unshift(n);n=t;while(n=n.parentNode)l.unshift(n);while(u[r]===l[r])r++;return r?de(u[r],l[r]):u[r]==N?-1:l[r]==N?1:0},p):p},le.matches=function(e,t){return le(e,null,null,t)},le.matchesSelector=function(e,t){if(d(e),n.matchesSelector&&g&&!D[t+" "]&&(!y||!y.test(t))&&(!m||!m.test(t)))try{var r=v.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){D(t,!0);}return le(t,p,null,[e]).length>0},le.contains=function(e,t){return (e.ownerDocument||e)!=p&&d(e),w(e,t)},le.attr=function(e,t){(e.ownerDocument||e)!=p&&d(e);var i=r.attrHandle[t.toLowerCase()],o=i&&L.call(r.attrHandle,t.toLowerCase())?i(e,t,!g):void 0;return void 0!==o?o:n.attributes||!g?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null},le.escape=function(e){return (e+"").replace(re,ie)},le.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},le.uniqueSort=function(e){var t,r=[],i=0,o=0;if(f=!n.detectDuplicates,c=!n.sortStable&&e.slice(0),e.sort(T),f){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1);}return c=null,e},i=le.getText=function(e){var t,n="",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e);}else if(3===o||4===o)return e.nodeValue}else while(t=e[r++])n+=i(t);return n},(r=le.selectors={cacheLength:50,createPseudo:se,match:K,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||le.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&le.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return K.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=u(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return "*"===e?function(){return !0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=S[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&S(e,function(e){return t.test("string"==typeof e.className&&e.className||void 0!==e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=le.attr(r,e);return null==i?"!="===t:!t||(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i.replace(O," ")+" ").indexOf(n)>-1:"|="===t&&(i===n||i.slice(0,n.length+1)===n+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),u="last"!==e.slice(-4),l="of-type"===t;return 1===r&&0===i?function(e){return !!e.parentNode}:function(t,n,a){var s,c,f,d,p,h,g=o!==u?"nextSibling":"previousSibling",m=t.parentNode,y=l&&t.nodeName.toLowerCase(),v=!a&&!l,w=!1;if(m){if(o){while(g){d=t;while(d=d[g])if(l?d.nodeName.toLowerCase()===y:1===d.nodeType)return !1;h=g="only"===e&&!h&&"nextSibling";}return !0}if(h=[u?m.firstChild:m.lastChild],u&&v){w=(p=(s=(c=(f=(d=m)[b]||(d[b]={}))[d.uniqueID]||(f[d.uniqueID]={}))[e]||[])[0]===C&&s[1])&&s[2],d=p&&m.childNodes[p];while(d=++p&&d&&d[g]||(w=p=0)||h.pop())if(1===d.nodeType&&++w&&d===t){c[e]=[C,p,w];break}}else if(v&&(w=p=(s=(c=(f=(d=t)[b]||(d[b]={}))[d.uniqueID]||(f[d.uniqueID]={}))[e]||[])[0]===C&&s[1]),!1===w)while(d=++p&&d&&d[g]||(w=p=0)||h.pop())if((l?d.nodeName.toLowerCase()===y:1===d.nodeType)&&++w&&(v&&((c=(f=d[b]||(d[b]={}))[d.uniqueID]||(f[d.uniqueID]={}))[e]=[C,w]),d===t))break;return (w-=i)===r||w%r==0&&w/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||le.error("unsupported pseudo: "+e);return i[b]?i(t):i.length>1?(n=[e,e,"",t],r.setFilters.hasOwnProperty(e.toLowerCase())?se(function(e,n){var r,o=i(e,t),u=o.length;while(u--)e[r=$(e,o[u])]=!(n[r]=o[u]);}):function(e){return i(e,0,n)}):i}},pseudos:{not:se(function(e){var t=[],n=[],r=l(e.replace(j,"$1"));return r[b]?se(function(e,t,n,i){var o,u=r(e,null,i,[]),l=e.length;while(l--)(o=u[l])&&(e[l]=!(t[l]=o));}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:se(function(e){return function(t){return le(e,t).length>0}}),contains:se(function(e){return e=e.replace(te,ne),function(t){return (t.textContent||i(t)).indexOf(e)>-1}}),lang:se(function(e){return J.test(e||"")||le.error("unsupported lang: "+e),e=e.replace(te,ne).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return (n=n.toLowerCase())===e||0===n.indexOf(e+"-")}while((t=t.parentNode)&&1===t.nodeType);return !1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:pe(!1),disabled:pe(!0),checked:function(e){var t=e.nodeName.toLowerCase();return "input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return !1;return !0},parent:function(e){return !r.pseudos.empty(e)},header:function(e){return Y.test(e.nodeName)},input:function(e){return W.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return "input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return "input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:he(function(){return [0]}),last:he(function(e,t){return [t-1]}),eq:he(function(e,t,n){return [n<0?n+t:n]}),even:he(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:he(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:he(function(e,t,n){for(var r=n<0?n+t:n>t?t:n;--r>=0;)e.push(r);return e}),gt:he(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=r.pseudos.eq;for(t in {radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[t]=function(e){return function(t){return "input"===t.nodeName.toLowerCase()&&t.type===e}}(t);for(t in {submit:!0,reset:!0})r.pseudos[t]=function(e){return function(t){var n=t.nodeName.toLowerCase();return ("input"===n||"button"===n)&&t.type===e}}(t);function me(){}me.prototype=r.filters=r.pseudos,r.setFilters=new me,u=le.tokenize=function(e,t){var n,i,o,u,l,a,s,c=E[e+" "];if(c)return t?0:c.slice(0);l=e,a=[],s=r.preFilter;while(l){n&&!(i=G.exec(l))||(i&&(l=l.slice(i[0].length)||l),a.push(o=[])),n=!1,(i=U.exec(l))&&(n=i.shift(),o.push({value:n,type:i[0].replace(j," ")}),l=l.slice(n.length));for(u in r.filter)!(i=K[u].exec(l))||s[u]&&!(i=s[u](i))||(n=i.shift(),o.push({value:n,type:u,matches:i}),l=l.slice(n.length));if(!n)break}return t?l.length:l?le.error(e):E(e,a).slice(0)};function ye(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function ve(e,t,n){var r=t.dir,i=t.next,o=i||r,u=n&&"parentNode"===o,l=x++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||u)return e(t,n,i);return !1}:function(t,n,a){var s,c,f,d=[C,l];if(a){while(t=t[r])if((1===t.nodeType||u)&&e(t,n,a))return !0}else while(t=t[r])if(1===t.nodeType||u)if(f=t[b]||(t[b]={}),c=f[t.uniqueID]||(f[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else {if((s=c[o])&&s[0]===C&&s[1]===l)return d[2]=s[2];if(c[o]=d,d[2]=e(t,n,a))return !0}return !1}}function we(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return !1;return !0}:e[0]}function be(e,t,n){for(var r=0,i=t.length;r<i;r++)le(e,t[r],n);return n}function Ne(e,t,n,r,i){for(var o,u=[],l=0,a=e.length,s=null!=t;l<a;l++)(o=e[l])&&(n&&!n(o,r,i)||(u.push(o),s&&t.push(l)));return u}function Ce(e,t,n,r,i,o){return r&&!r[b]&&(r=Ce(r)),i&&!i[b]&&(i=Ce(i,o)),se(function(o,u,l,a){var s,c,f,d=[],p=[],h=u.length,g=o||be(t||"*",l.nodeType?[l]:l,[]),m=!e||!o&&t?g:Ne(g,d,e,l,a),y=n?i||(o?e:h||r)?[]:u:m;if(n&&n(m,y,l,a),r){s=Ne(y,p),r(s,[],l,a),c=s.length;while(c--)(f=s[c])&&(y[p[c]]=!(m[p[c]]=f));}if(o){if(i||e){if(i){s=[],c=y.length;while(c--)(f=y[c])&&s.push(m[c]=f);i(null,y=[],s,a);}c=y.length;while(c--)(f=y[c])&&(s=i?$(o,f):d[c])>-1&&(o[s]=!(u[s]=f));}}else y=Ne(y===u?y.splice(h,y.length):y),i?i(null,u,y,a):R.apply(u,y);})}function xe(e){for(var t,n,i,o=e.length,u=r.relative[e[0].type],l=u||r.relative[" "],a=u?1:0,c=ve(function(e){return e===t},l,!0),f=ve(function(e){return $(t,e)>-1},l,!0),d=[function(e,n,r){var i=!u&&(r||n!==s)||((t=n).nodeType?c(e,n,r):f(e,n,r));return t=null,i}];a<o;a++)if(n=r.relative[e[a].type])d=[ve(we(d),n)];else {if((n=r.filter[e[a].type].apply(null,e[a].matches))[b]){for(i=++a;i<o;i++)if(r.relative[e[i].type])break;return Ce(a>1&&we(d),a>1&&ye(e.slice(0,a-1).concat({value:" "===e[a-2].type?"*":""})).replace(j,"$1"),n,a<i&&xe(e.slice(a,i)),i<o&&xe(e=e.slice(i)),i<o&&ye(e))}d.push(n);}return we(d)}function Se(e,t){var n=t.length>0,i=e.length>0,o=function(o,u,l,a,c){var f,h,m,y=0,v="0",w=o&&[],b=[],N=s,x=o||i&&r.find.TAG("*",c),S=C+=null==N?1:Math.random()||.1,E=x.length;for(c&&(s=u==p||u||c);v!==E&&null!=(f=x[v]);v++){if(i&&f){h=0,u||f.ownerDocument==p||(d(f),l=!g);while(m=e[h++])if(m(f,u||p,l)){a.push(f);break}c&&(C=S);}n&&((f=!m&&f)&&y--,o&&w.push(f));}if(y+=v,n&&v!==y){h=0;while(m=t[h++])m(w,b,u,l);if(o){if(y>0)while(v--)w[v]||b[v]||(b[v]=I.call(a));b=Ne(b);}R.apply(a,b),c&&!o&&b.length>0&&y+t.length>1&&le.uniqueSort(a);}return c&&(C=S,s=N),w};return n?se(o):o}l=le.compile=function(e,t){var n,r=[],i=[],o=A[e+" "];if(!o){t||(t=u(e)),n=t.length;while(n--)(o=xe(t[n]))[b]?r.push(o):i.push(o);(o=A(e,Se(i,r))).selector=e;}return o},a=le.select=function(e,t,n,i){var o,a,s,c,f,d="function"==typeof e&&e,p=!i&&u(e=d.selector||e);if(n=n||[],1===p.length){if((a=p[0]=p[0].slice(0)).length>2&&"ID"===(s=a[0]).type&&9===t.nodeType&&g&&r.relative[a[1].type]){if(!(t=(r.find.ID(s.matches[0].replace(te,ne),t)||[])[0]))return n;d&&(t=t.parentNode),e=e.slice(a.shift().value.length);}o=K.needsContext.test(e)?0:a.length;while(o--){if(s=a[o],r.relative[c=s.type])break;if((f=r.find[c])&&(i=f(s.matches[0].replace(te,ne),ee.test(a[0].type)&&ge(t.parentNode)||t))){if(a.splice(o,1),!(e=i.length&&ye(a)))return R.apply(n,i),n;break}}}return (d||l(e,p))(i,t,!g,n,!t||ee.test(e)&&ge(t.parentNode)||t),n},n.sortStable=b.split("").sort(T).join("")===b,n.detectDuplicates=!!f,d(),n.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(p.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),n.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(H,function(e,t,n){var r;if(!n)return !0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null});var Ee=e.Sizzle;le.noConflict=function(){return e.Sizzle===le&&(e.Sizzle=Ee),le},"function"==typeof define&&define.amd?define(function(){return le}):"undefined"!=typeof module&&module.exports?module.exports=le:e.Sizzle=le;}(window);
//# sourceMappingURL=sizzle.min.map

return module.exports;
})();

function matches(selector, elm) {
  const r = Sizzle.matches(selector, [elm]);
  return r.length > 0;
}
function selectOne(selector, elm) {
  const r = Sizzle(selector, elm);
  return r[0] || null;
}
function selectAll(selector, elm) {
  return Sizzle(selector, elm);
}

function serializeNodeToHtml(elm, opts = {}) {
  const output = {
    currentLineWidth: 0,
    indent: 0,
    isWithinBody: false,
    text: [],
  };
  if (opts.prettyHtml) {
    if (typeof opts.indentSpaces !== 'number') {
      opts.indentSpaces = 2;
    }
    if (typeof opts.newLines !== 'boolean') {
      opts.newLines = true;
    }
    opts.approximateLineWidth = -1;
  }
  else {
    opts.prettyHtml = false;
    if (typeof opts.newLines !== 'boolean') {
      opts.newLines = false;
    }
    if (typeof opts.indentSpaces !== 'number') {
      opts.indentSpaces = 0;
    }
  }
  if (typeof opts.approximateLineWidth !== 'number') {
    opts.approximateLineWidth = -1;
  }
  if (typeof opts.removeEmptyAttributes !== 'boolean') {
    opts.removeEmptyAttributes = true;
  }
  if (typeof opts.removeAttributeQuotes !== 'boolean') {
    opts.removeAttributeQuotes = false;
  }
  if (typeof opts.removeBooleanAttributeQuotes !== 'boolean') {
    opts.removeBooleanAttributeQuotes = false;
  }
  if (typeof opts.removeHtmlComments !== 'boolean') {
    opts.removeHtmlComments = false;
  }
  if (typeof opts.serializeShadowRoot !== 'boolean') {
    opts.serializeShadowRoot = false;
  }
  if (opts.outerHtml) {
    serializeToHtml(elm, opts, output, false);
  }
  else {
    for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
      serializeToHtml(elm.childNodes[i], opts, output, false);
    }
  }
  if (output.text[0] === '\n') {
    output.text.shift();
  }
  if (output.text[output.text.length - 1] === '\n') {
    output.text.pop();
  }
  return output.text.join('');
}
function serializeToHtml(node, opts, output, isShadowRoot) {
  if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ || isShadowRoot) {
    const tagName = isShadowRoot ? 'mock:shadow-root' : getTagName(node);
    if (tagName === 'body') {
      output.isWithinBody = true;
    }
    const ignoreTag = opts.excludeTags != null && opts.excludeTags.includes(tagName);
    if (ignoreTag === false) {
      const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
      if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
        output.text.push('\n');
        output.currentLineWidth = 0;
      }
      if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
        for (let i = 0; i < output.indent; i++) {
          output.text.push(' ');
        }
        output.currentLineWidth += output.indent;
      }
      output.text.push('<' + tagName);
      output.currentLineWidth += tagName.length + 1;
      const attrsLength = node.attributes.length;
      const attributes = opts.prettyHtml && attrsLength > 1
        ? cloneAttributes(node.attributes, true)
        : node.attributes;
      for (let i = 0; i < attrsLength; i++) {
        const attr = attributes.item(i);
        const attrName = attr.name;
        if (attrName === 'style') {
          continue;
        }
        let attrValue = attr.value;
        if (opts.removeEmptyAttributes && attrValue === '' && REMOVE_EMPTY_ATTR.has(attrName)) {
          continue;
        }
        const attrNamespaceURI = attr.namespaceURI;
        if (attrNamespaceURI == null) {
          output.currentLineWidth += attrName.length + 1;
          if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            output.text.push('\n' + attrName);
            output.currentLineWidth = 0;
          }
          else {
            output.text.push(' ' + attrName);
          }
        }
        else if (attrNamespaceURI === 'http://www.w3.org/XML/1998/namespace') {
          output.text.push(' xml:' + attrName);
          output.currentLineWidth += attrName.length + 5;
        }
        else if (attrNamespaceURI === 'http://www.w3.org/2000/xmlns/') {
          if (attrName !== 'xmlns') {
            output.text.push(' xmlns:' + attrName);
            output.currentLineWidth += attrName.length + 7;
          }
          else {
            output.text.push(' ' + attrName);
            output.currentLineWidth += attrName.length + 1;
          }
        }
        else if (attrNamespaceURI === XLINK_NS) {
          output.text.push(' xlink:' + attrName);
          output.currentLineWidth += attrName.length + 7;
        }
        else {
          output.text.push(' ' + attrNamespaceURI + ':' + attrName);
          output.currentLineWidth += attrNamespaceURI.length + attrName.length + 2;
        }
        if (opts.prettyHtml && attrName === 'class') {
          attrValue = attr.value = attrValue
            .split(' ')
            .filter((t) => t !== '')
            .sort()
            .join(' ')
            .trim();
        }
        if (attrValue === '') {
          if (opts.removeBooleanAttributeQuotes && BOOLEAN_ATTR.has(attrName)) {
            continue;
          }
          if (opts.removeEmptyAttributes && attrName.startsWith('data-')) {
            continue;
          }
        }
        if (opts.removeAttributeQuotes && CAN_REMOVE_ATTR_QUOTES.test(attrValue)) {
          output.text.push('=' + escapeString(attrValue, true));
          output.currentLineWidth += attrValue.length + 1;
        }
        else {
          output.text.push('="' + escapeString(attrValue, true) + '"');
          output.currentLineWidth += attrValue.length + 3;
        }
      }
      if (node.hasAttribute('style')) {
        const cssText = node.style.cssText;
        if (opts.approximateLineWidth > 0 &&
          output.currentLineWidth + cssText.length + 10 > opts.approximateLineWidth) {
          output.text.push(`\nstyle="${cssText}">`);
          output.currentLineWidth = 0;
        }
        else {
          output.text.push(` style="${cssText}">`);
          output.currentLineWidth += cssText.length + 10;
        }
      }
      else {
        output.text.push('>');
        output.currentLineWidth += 1;
      }
    }
    if (EMPTY_ELEMENTS.has(tagName) === false) {
      if (opts.serializeShadowRoot && node.shadowRoot != null) {
        output.indent = output.indent + opts.indentSpaces;
        serializeToHtml(node.shadowRoot, opts, output, true);
        output.indent = output.indent - opts.indentSpaces;
        if (opts.newLines &&
          (node.childNodes.length === 0 ||
            (node.childNodes.length === 1 &&
              node.childNodes[0].nodeType === 3 /* NODE_TYPES.TEXT_NODE */ &&
              node.childNodes[0].nodeValue.trim() === ''))) {
          output.text.push('\n');
          output.currentLineWidth = 0;
          for (let i = 0; i < output.indent; i++) {
            output.text.push(' ');
          }
          output.currentLineWidth += output.indent;
        }
      }
      if (opts.excludeTagContent == null || opts.excludeTagContent.includes(tagName) === false) {
        const childNodes = tagName === 'template' ? node.content.childNodes : node.childNodes;
        const childNodeLength = childNodes.length;
        if (childNodeLength > 0) {
          if (childNodeLength === 1 &&
            childNodes[0].nodeType === 3 /* NODE_TYPES.TEXT_NODE */ &&
            (typeof childNodes[0].nodeValue !== 'string' || childNodes[0].nodeValue.trim() === '')) ;
          else {
            const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
            if (!isWithinWhitespaceSensitiveNode && opts.indentSpaces > 0 && ignoreTag === false) {
              output.indent = output.indent + opts.indentSpaces;
            }
            for (let i = 0; i < childNodeLength; i++) {
              serializeToHtml(childNodes[i], opts, output, false);
            }
            if (ignoreTag === false) {
              if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
                output.text.push('\n');
                output.currentLineWidth = 0;
              }
              if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
                output.indent = output.indent - opts.indentSpaces;
                for (let i = 0; i < output.indent; i++) {
                  output.text.push(' ');
                }
                output.currentLineWidth += output.indent;
              }
            }
          }
        }
        if (ignoreTag === false) {
          output.text.push('</' + tagName + '>');
          output.currentLineWidth += tagName.length + 3;
        }
      }
    }
    if (opts.approximateLineWidth > 0 && STRUCTURE_ELEMENTS.has(tagName)) {
      output.text.push('\n');
      output.currentLineWidth = 0;
    }
    if (tagName === 'body') {
      output.isWithinBody = false;
    }
  }
  else if (node.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
    let textContent = node.nodeValue;
    if (typeof textContent === 'string') {
      const trimmedTextContent = textContent.trim();
      if (trimmedTextContent === '') {
        // this text node is whitespace only
        if (isWithinWhitespaceSensitive(node)) {
          // whitespace matters within this element
          // just add the exact text we were given
          output.text.push(textContent);
          output.currentLineWidth += textContent.length;
        }
        else if (opts.approximateLineWidth > 0 && !output.isWithinBody) ;
        else if (!opts.prettyHtml) {
          // this text node is only whitespace, and it's not
          // within a whitespace sensitive element like <pre> or <code>
          // so replace the entire white space with a single new line
          output.currentLineWidth += 1;
          if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            // good enough for a new line
            // for perf these are all just estimates
            // we don't care to ensure exact line lengths
            output.text.push('\n');
            output.currentLineWidth = 0;
          }
          else {
            // let's keep it all on the same line yet
            output.text.push(' ');
          }
        }
      }
      else {
        // this text node has text content
        const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 || opts.prettyHtml ? isWithinWhitespaceSensitive(node) : false;
        if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
          output.text.push('\n');
          output.currentLineWidth = 0;
        }
        if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
          for (let i = 0; i < output.indent; i++) {
            output.text.push(' ');
          }
          output.currentLineWidth += output.indent;
        }
        let textContentLength = textContent.length;
        if (textContentLength > 0) {
          // this text node has text content
          const parentTagName = node.parentNode != null && node.parentNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */
            ? node.parentNode.nodeName
            : null;
          if (NON_ESCAPABLE_CONTENT.has(parentTagName)) {
            // this text node cannot have its content escaped since it's going
            // into an element like <style> or <script>
            if (isWithinWhitespaceSensitive(node)) {
              output.text.push(textContent);
            }
            else {
              output.text.push(trimmedTextContent);
              textContentLength = trimmedTextContent.length;
            }
            output.currentLineWidth += textContentLength;
          }
          else {
            // this text node is going into a normal element and html can be escaped
            if (opts.prettyHtml && !isWithinWhitespaceSensitiveNode) {
              // pretty print the text node
              output.text.push(escapeString(textContent.replace(/\s\s+/g, ' ').trim(), false));
              output.currentLineWidth += textContentLength;
            }
            else {
              // not pretty printing the text node
              if (isWithinWhitespaceSensitive(node)) {
                output.currentLineWidth += textContentLength;
              }
              else {
                // this element is not a whitespace sensitive one, like <pre> or <code> so
                // any whitespace at the start and end can be cleaned up to just be one space
                if (/\s/.test(textContent.charAt(0))) {
                  textContent = ' ' + textContent.trimLeft();
                }
                textContentLength = textContent.length;
                if (textContentLength > 1) {
                  if (/\s/.test(textContent.charAt(textContentLength - 1))) {
                    if (opts.approximateLineWidth > 0 &&
                      output.currentLineWidth + textContentLength > opts.approximateLineWidth) {
                      textContent = textContent.trimRight() + '\n';
                      output.currentLineWidth = 0;
                    }
                    else {
                      textContent = textContent.trimRight() + ' ';
                    }
                  }
                }
                output.currentLineWidth += textContentLength;
              }
              output.text.push(escapeString(textContent, false));
            }
          }
        }
      }
    }
  }
  else if (node.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */) {
    const nodeValue = node.nodeValue;
    if (opts.removeHtmlComments) {
      const isHydrateAnnotation = nodeValue.startsWith(CONTENT_REF_ID + '.') ||
        nodeValue.startsWith(ORG_LOCATION_ID + '.') ||
        nodeValue.startsWith(SLOT_NODE_ID + '.') ||
        nodeValue.startsWith(TEXT_NODE_ID + '.');
      if (!isHydrateAnnotation) {
        return;
      }
    }
    const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
    if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
      output.text.push('\n');
      output.currentLineWidth = 0;
    }
    if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
      for (let i = 0; i < output.indent; i++) {
        output.text.push(' ');
      }
      output.currentLineWidth += output.indent;
    }
    output.text.push('<!--' + nodeValue + '-->');
    output.currentLineWidth += nodeValue.length + 7;
  }
  else if (node.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */) {
    output.text.push('<!doctype html>');
  }
}
const AMP_REGEX = /&/g;
const NBSP_REGEX = /\u00a0/g;
const DOUBLE_QUOTE_REGEX = /"/g;
const LT_REGEX = /</g;
const GT_REGEX = />/g;
const CAN_REMOVE_ATTR_QUOTES = /^[^ \t\n\f\r"'`=<>\/\\-]+$/;
function getTagName(element) {
  if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
    return element.nodeName.toLowerCase();
  }
  else {
    return element.nodeName;
  }
}
function escapeString(str, attrMode) {
  str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');
  if (attrMode) {
    return str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
  }
  return str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
}
function isWithinWhitespaceSensitive(node) {
  while (node != null) {
    if (WHITESPACE_SENSITIVE.has(node.nodeName)) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
/*@__PURE__*/ const NON_ESCAPABLE_CONTENT = new Set([
  'STYLE',
  'SCRIPT',
  'IFRAME',
  'NOSCRIPT',
  'XMP',
  'NOEMBED',
  'NOFRAMES',
  'PLAINTEXT',
]);
/*@__PURE__*/ const WHITESPACE_SENSITIVE = new Set([
  'CODE',
  'OUTPUT',
  'PLAINTEXT',
  'PRE',
  'SCRIPT',
  'TEMPLATE',
  'TEXTAREA',
]);
/*@__PURE__*/ const EMPTY_ELEMENTS = new Set([
  'area',
  'base',
  'basefont',
  'bgsound',
  'br',
  'col',
  'embed',
  'frame',
  'hr',
  'img',
  'input',
  'keygen',
  'link',
  'meta',
  'param',
  'source',
  'trace',
  'wbr',
]);
/*@__PURE__*/ const REMOVE_EMPTY_ATTR = new Set(['class', 'dir', 'id', 'lang', 'name', 'title']);
/*@__PURE__*/ const BOOLEAN_ATTR = new Set([
  'allowfullscreen',
  'async',
  'autofocus',
  'autoplay',
  'checked',
  'compact',
  'controls',
  'declare',
  'default',
  'defaultchecked',
  'defaultmuted',
  'defaultselected',
  'defer',
  'disabled',
  'enabled',
  'formnovalidate',
  'hidden',
  'indeterminate',
  'inert',
  'ismap',
  'itemscope',
  'loop',
  'multiple',
  'muted',
  'nohref',
  'nomodule',
  'noresize',
  'noshade',
  'novalidate',
  'nowrap',
  'open',
  'pauseonexit',
  'readonly',
  'required',
  'reversed',
  'scoped',
  'seamless',
  'selected',
  'sortable',
  'truespeed',
  'typemustmatch',
  'visible',
]);
/*@__PURE__*/ const STRUCTURE_ELEMENTS = new Set([
  'html',
  'body',
  'head',
  'iframe',
  'meta',
  'link',
  'base',
  'title',
  'script',
  'style',
]);

class MockNode {
  constructor(ownerDocument, nodeType, nodeName, nodeValue) {
    this.ownerDocument = ownerDocument;
    this.nodeType = nodeType;
    this.nodeName = nodeName;
    this._nodeValue = nodeValue;
    this.parentNode = null;
    this.childNodes = [];
  }
  appendChild(newNode) {
    if (newNode.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
      const nodes = newNode.childNodes.slice();
      for (const child of nodes) {
        this.appendChild(child);
      }
    }
    else {
      newNode.remove();
      newNode.parentNode = this;
      this.childNodes.push(newNode);
      connectNode(this.ownerDocument, newNode);
    }
    return newNode;
  }
  append(...items) {
    items.forEach((item) => {
      const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
      this.appendChild(isNode ? item : this.ownerDocument.createTextNode(String(item)));
    });
  }
  prepend(...items) {
    const firstChild = this.firstChild;
    items.forEach((item) => {
      const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
      if (firstChild) {
        this.insertBefore(isNode ? item : this.ownerDocument.createTextNode(String(item)), firstChild);
      }
    });
  }
  cloneNode(deep) {
    throw new Error(`invalid node type to clone: ${this.nodeType}, deep: ${deep}`);
  }
  compareDocumentPosition(_other) {
    // unimplemented
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
    return -1;
  }
  get firstChild() {
    return this.childNodes[0] || null;
  }
  insertBefore(newNode, referenceNode) {
    if (newNode.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
      for (let i = 0, ii = newNode.childNodes.length; i < ii; i++) {
        insertBefore(this, newNode.childNodes[i], referenceNode);
      }
    }
    else {
      insertBefore(this, newNode, referenceNode);
    }
    return newNode;
  }
  get isConnected() {
    let node = this;
    while (node != null) {
      if (node.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */) {
        return true;
      }
      node = node.parentNode;
      if (node != null && node.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
        node = node.host;
      }
    }
    return false;
  }
  isSameNode(node) {
    return this === node;
  }
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  get nextSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) + 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  get nodeValue() {
    var _a;
    return (_a = this._nodeValue) !== null && _a !== void 0 ? _a : '';
  }
  set nodeValue(value) {
    this._nodeValue = value;
  }
  get parentElement() {
    return this.parentNode || null;
  }
  set parentElement(value) {
    this.parentNode = value;
  }
  get previousSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) - 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  contains(otherNode) {
    if (otherNode === this) {
      return true;
    }
    const childNodes = Array.from(this.childNodes);
    if (childNodes.includes(otherNode)) {
      return true;
    }
    return childNodes.some((node) => this.contains.bind(node)(otherNode));
  }
  removeChild(childNode) {
    const index = this.childNodes.indexOf(childNode);
    if (index > -1) {
      this.childNodes.splice(index, 1);
      if (this.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
        const wasConnected = this.isConnected;
        childNode.parentNode = null;
        if (wasConnected === true) {
          disconnectNode(childNode);
        }
      }
      else {
        childNode.parentNode = null;
      }
    }
    else {
      throw new Error(`node not found within childNodes during removeChild`);
    }
    return childNode;
  }
  remove() {
    if (this.parentNode != null) {
      this.parentNode.removeChild(this);
    }
  }
  replaceChild(newChild, oldChild) {
    if (oldChild.parentNode === this) {
      this.insertBefore(newChild, oldChild);
      oldChild.remove();
      return newChild;
    }
    return null;
  }
  get textContent() {
    var _a;
    return (_a = this._nodeValue) !== null && _a !== void 0 ? _a : '';
  }
  set textContent(value) {
    this._nodeValue = String(value);
  }
}
MockNode.ELEMENT_NODE = 1;
MockNode.TEXT_NODE = 3;
MockNode.PROCESSING_INSTRUCTION_NODE = 7;
MockNode.COMMENT_NODE = 8;
MockNode.DOCUMENT_NODE = 9;
MockNode.DOCUMENT_TYPE_NODE = 10;
MockNode.DOCUMENT_FRAGMENT_NODE = 11;
class MockNodeList {
  constructor(ownerDocument, childNodes, length) {
    this.ownerDocument = ownerDocument;
    this.childNodes = childNodes;
    this.length = length;
  }
}
class MockElement extends MockNode {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, 1 /* NODE_TYPES.ELEMENT_NODE */, typeof nodeName === 'string' ? nodeName : null, null);
    this.namespaceURI = null;
    this.__shadowRoot = null;
    this.__attributeMap = null;
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  attachShadow(_opts) {
    const shadowRoot = this.ownerDocument.createDocumentFragment();
    this.shadowRoot = shadowRoot;
    return shadowRoot;
  }
  blur() {
    dispatchEvent(this, new MockFocusEvent('blur', { relatedTarget: null, bubbles: true, cancelable: true, composed: true }));
  }
  get shadowRoot() {
    return this.__shadowRoot || null;
  }
  set shadowRoot(shadowRoot) {
    if (shadowRoot != null) {
      shadowRoot.host = this;
      this.__shadowRoot = shadowRoot;
    }
    else {
      delete this.__shadowRoot;
    }
  }
  get attributes() {
    if (this.__attributeMap == null) {
      const attrMap = createAttributeProxy(false);
      this.__attributeMap = attrMap;
      return attrMap;
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
  get children() {
    return this.childNodes.filter((n) => n.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */);
  }
  get childElementCount() {
    return this.childNodes.filter((n) => n.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */).length;
  }
  get className() {
    return this.getAttributeNS(null, 'class') || '';
  }
  set className(value) {
    this.setAttributeNS(null, 'class', value);
  }
  get classList() {
    return new MockClassList(this);
  }
  click() {
    dispatchEvent(this, new MockEvent('click', { bubbles: true, cancelable: true, composed: true }));
  }
  cloneNode(_deep) {
    // implemented on MockElement.prototype from within element.ts
    // @ts-ignore - implemented on MockElement.prototype from within element.ts
    return null;
  }
  closest(selector) {
    let elm = this;
    while (elm != null) {
      if (elm.matches(selector)) {
        return elm;
      }
      elm = elm.parentNode;
    }
    return null;
  }
  get dataset() {
    return dataset(this);
  }
  get dir() {
    return this.getAttributeNS(null, 'dir') || '';
  }
  set dir(value) {
    this.setAttributeNS(null, 'dir', value);
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get firstElementChild() {
    return this.children[0] || null;
  }
  focus(_options) {
    dispatchEvent(this, new MockFocusEvent('focus', { relatedTarget: null, bubbles: true, cancelable: true, composed: true }));
  }
  getAttribute(attrName) {
    if (attrName === 'style') {
      if (this.__style != null && this.__style.length > 0) {
        return this.style.cssText;
      }
      return null;
    }
    const attr = this.attributes.getNamedItem(attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getBoundingClientRect() {
    return { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 };
  }
  getRootNode(opts) {
    const isComposed = opts != null && opts.composed === true;
    let node = this;
    while (node.parentNode != null) {
      node = node.parentNode;
      if (isComposed === true && node.parentNode == null && node.host != null) {
        node = node.host;
      }
    }
    return node;
  }
  get draggable() {
    return this.getAttributeNS(null, 'draggable') === 'true';
  }
  set draggable(value) {
    this.setAttributeNS(null, 'draggable', value);
  }
  hasChildNodes() {
    return this.childNodes.length > 0;
  }
  get id() {
    return this.getAttributeNS(null, 'id') || '';
  }
  set id(value) {
    this.setAttributeNS(null, 'id', value);
  }
  get innerHTML() {
    if (this.childNodes.length === 0) {
      return '';
    }
    return serializeNodeToHtml(this, {
      newLines: false,
      indentSpaces: 0,
    });
  }
  set innerHTML(html) {
    var _a;
    if (NON_ESCAPABLE_CONTENT.has((_a = this.nodeName) !== null && _a !== void 0 ? _a : '') === true) {
      setTextContent(this, html);
    }
    else {
      for (let i = this.childNodes.length - 1; i >= 0; i--) {
        this.removeChild(this.childNodes[i]);
      }
      if (typeof html === 'string') {
        const frag = parseFragmentUtil(this.ownerDocument, html);
        while (frag.childNodes.length > 0) {
          this.appendChild(frag.childNodes[0]);
        }
      }
    }
  }
  get innerText() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join('');
  }
  set innerText(value) {
    setTextContent(this, value);
  }
  insertAdjacentElement(position, elm) {
    if (position === 'beforebegin') {
      insertBefore(this.parentNode, elm, this);
    }
    else if (position === 'afterbegin') {
      this.prepend(elm);
    }
    else if (position === 'beforeend') {
      this.appendChild(elm);
    }
    else if (position === 'afterend') {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
    return elm;
  }
  insertAdjacentHTML(position, html) {
    const frag = parseFragmentUtil(this.ownerDocument, html);
    if (position === 'beforebegin') {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[0], this);
      }
    }
    else if (position === 'afterbegin') {
      while (frag.childNodes.length > 0) {
        this.prepend(frag.childNodes[frag.childNodes.length - 1]);
      }
    }
    else if (position === 'beforeend') {
      while (frag.childNodes.length > 0) {
        this.appendChild(frag.childNodes[0]);
      }
    }
    else if (position === 'afterend') {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[frag.childNodes.length - 1], this.nextSibling);
      }
    }
  }
  insertAdjacentText(position, text) {
    const elm = this.ownerDocument.createTextNode(text);
    if (position === 'beforebegin') {
      insertBefore(this.parentNode, elm, this);
    }
    else if (position === 'afterbegin') {
      this.prepend(elm);
    }
    else if (position === 'beforeend') {
      this.appendChild(elm);
    }
    else if (position === 'afterend') {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
  }
  hasAttribute(attrName) {
    if (attrName === 'style') {
      return this.__style != null && this.__style.length > 0;
    }
    return this.getAttribute(attrName) !== null;
  }
  hasAttributeNS(namespaceURI, name) {
    return this.getAttributeNS(namespaceURI, name) !== null;
  }
  get hidden() {
    return this.hasAttributeNS(null, 'hidden');
  }
  set hidden(isHidden) {
    if (isHidden === true) {
      this.setAttributeNS(null, 'hidden', '');
    }
    else {
      this.removeAttributeNS(null, 'hidden');
    }
  }
  get lang() {
    return this.getAttributeNS(null, 'lang') || '';
  }
  set lang(value) {
    this.setAttributeNS(null, 'lang', value);
  }
  get lastElementChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  matches(selector) {
    return matches(selector, this);
  }
  get nextElementSibling() {
    const parentElement = this.parentElement;
    if (parentElement != null &&
      (parentElement.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
        parentElement.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */ ||
        parentElement.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */)) {
      const children = parentElement.children;
      const index = children.indexOf(this) + 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  get outerHTML() {
    return serializeNodeToHtml(this, {
      newLines: false,
      outerHtml: true,
      indentSpaces: 0,
    });
  }
  get previousElementSibling() {
    const parentElement = this.parentElement;
    if (parentElement != null &&
      (parentElement.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
        parentElement.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */ ||
        parentElement.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */)) {
      const children = parentElement.children;
      const index = children.indexOf(this) - 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  getElementsByClassName(classNames) {
    const classes = classNames
      .trim()
      .split(' ')
      .filter((c) => c.length > 0);
    const results = [];
    getElementsByClassName(this, classes, results);
    return results;
  }
  getElementsByTagName(tagName) {
    const results = [];
    getElementsByTagName(this, tagName.toLowerCase(), results);
    return results;
  }
  querySelector(selector) {
    return selectOne(selector, this);
  }
  querySelectorAll(selector) {
    return selectAll(selector, this);
  }
  removeAttribute(attrName) {
    if (attrName === 'style') {
      delete this.__style;
    }
    else {
      const attr = this.attributes.getNamedItem(attrName);
      if (attr != null) {
        this.attributes.removeNamedItemNS(attr);
        if (checkAttributeChanged(this) === true) {
          attributeChanged(this, attrName, attr.value, null);
        }
      }
    }
  }
  removeAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      this.attributes.removeNamedItemNS(attr);
      if (checkAttributeChanged(this) === true) {
        attributeChanged(this, attrName, attr.value, null);
      }
    }
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  setAttribute(attrName, value) {
    if (attrName === 'style') {
      this.style = value;
    }
    else {
      const attributes = this.attributes;
      let attr = attributes.getNamedItem(attrName);
      const checkAttrChanged = checkAttributeChanged(this);
      if (attr != null) {
        if (checkAttrChanged === true) {
          const oldValue = attr.value;
          attr.value = value;
          if (oldValue !== attr.value) {
            attributeChanged(this, attr.name, oldValue, attr.value);
          }
        }
        else {
          attr.value = value;
        }
      }
      else {
        if (attributes.caseInsensitive) {
          attrName = attrName.toLowerCase();
        }
        attr = new MockAttr(attrName, value);
        attributes.__items.push(attr);
        if (checkAttrChanged === true) {
          attributeChanged(this, attrName, null, attr.value);
        }
      }
    }
  }
  setAttributeNS(namespaceURI, attrName, value) {
    const attributes = this.attributes;
    let attr = attributes.getNamedItemNS(namespaceURI, attrName);
    const checkAttrChanged = checkAttributeChanged(this);
    if (attr != null) {
      if (checkAttrChanged === true) {
        const oldValue = attr.value;
        attr.value = value;
        if (oldValue !== attr.value) {
          attributeChanged(this, attr.name, oldValue, attr.value);
        }
      }
      else {
        attr.value = value;
      }
    }
    else {
      attr = new MockAttr(attrName, value, namespaceURI);
      attributes.__items.push(attr);
      if (checkAttrChanged === true) {
        attributeChanged(this, attrName, null, attr.value);
      }
    }
  }
  get style() {
    if (this.__style == null) {
      this.__style = createCSSStyleDeclaration();
    }
    return this.__style;
  }
  set style(val) {
    if (typeof val === 'string') {
      if (this.__style == null) {
        this.__style = createCSSStyleDeclaration();
      }
      this.__style.cssText = val;
    }
    else {
      this.__style = val;
    }
  }
  get tabIndex() {
    return parseInt(this.getAttributeNS(null, 'tabindex') || '-1', 10);
  }
  set tabIndex(value) {
    this.setAttributeNS(null, 'tabindex', value);
  }
  get tagName() {
    var _a;
    return (_a = this.nodeName) !== null && _a !== void 0 ? _a : '';
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get textContent() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join('');
  }
  set textContent(value) {
    setTextContent(this, value);
  }
  get title() {
    return this.getAttributeNS(null, 'title') || '';
  }
  set title(value) {
    this.setAttributeNS(null, 'title', value);
  }
  animate() {
    /**/
  }
  onanimationstart() {
    /**/
  }
  onanimationend() {
    /**/
  }
  onanimationiteration() {
    /**/
  }
  onabort() {
    /**/
  }
  onauxclick() {
    /**/
  }
  onbeforecopy() {
    /**/
  }
  onbeforecut() {
    /**/
  }
  onbeforepaste() {
    /**/
  }
  onblur() {
    /**/
  }
  oncancel() {
    /**/
  }
  oncanplay() {
    /**/
  }
  oncanplaythrough() {
    /**/
  }
  onchange() {
    /**/
  }
  onclick() {
    /**/
  }
  onclose() {
    /**/
  }
  oncontextmenu() {
    /**/
  }
  oncopy() {
    /**/
  }
  oncuechange() {
    /**/
  }
  oncut() {
    /**/
  }
  ondblclick() {
    /**/
  }
  ondrag() {
    /**/
  }
  ondragend() {
    /**/
  }
  ondragenter() {
    /**/
  }
  ondragleave() {
    /**/
  }
  ondragover() {
    /**/
  }
  ondragstart() {
    /**/
  }
  ondrop() {
    /**/
  }
  ondurationchange() {
    /**/
  }
  onemptied() {
    /**/
  }
  onended() {
    /**/
  }
  onerror() {
    /**/
  }
  onfocus() {
    /**/
  }
  onfocusin() {
    /**/
  }
  onfocusout() {
    /**/
  }
  onformdata() {
    /**/
  }
  onfullscreenchange() {
    /**/
  }
  onfullscreenerror() {
    /**/
  }
  ongotpointercapture() {
    /**/
  }
  oninput() {
    /**/
  }
  oninvalid() {
    /**/
  }
  onkeydown() {
    /**/
  }
  onkeypress() {
    /**/
  }
  onkeyup() {
    /**/
  }
  onload() {
    /**/
  }
  onloadeddata() {
    /**/
  }
  onloadedmetadata() {
    /**/
  }
  onloadstart() {
    /**/
  }
  onlostpointercapture() {
    /**/
  }
  onmousedown() {
    /**/
  }
  onmouseenter() {
    /**/
  }
  onmouseleave() {
    /**/
  }
  onmousemove() {
    /**/
  }
  onmouseout() {
    /**/
  }
  onmouseover() {
    /**/
  }
  onmouseup() {
    /**/
  }
  onmousewheel() {
    /**/
  }
  onpaste() {
    /**/
  }
  onpause() {
    /**/
  }
  onplay() {
    /**/
  }
  onplaying() {
    /**/
  }
  onpointercancel() {
    /**/
  }
  onpointerdown() {
    /**/
  }
  onpointerenter() {
    /**/
  }
  onpointerleave() {
    /**/
  }
  onpointermove() {
    /**/
  }
  onpointerout() {
    /**/
  }
  onpointerover() {
    /**/
  }
  onpointerup() {
    /**/
  }
  onprogress() {
    /**/
  }
  onratechange() {
    /**/
  }
  onreset() {
    /**/
  }
  onresize() {
    /**/
  }
  onscroll() {
    /**/
  }
  onsearch() {
    /**/
  }
  onseeked() {
    /**/
  }
  onseeking() {
    /**/
  }
  onselect() {
    /**/
  }
  onselectstart() {
    /**/
  }
  onstalled() {
    /**/
  }
  onsubmit() {
    /**/
  }
  onsuspend() {
    /**/
  }
  ontimeupdate() {
    /**/
  }
  ontoggle() {
    /**/
  }
  onvolumechange() {
    /**/
  }
  onwaiting() {
    /**/
  }
  onwebkitfullscreenchange() {
    /**/
  }
  onwebkitfullscreenerror() {
    /**/
  }
  onwheel() {
    /**/
  }
  requestFullscreen() {
    /**/
  }
  scrollBy() {
    /**/
  }
  scrollTo() {
    /**/
  }
  scrollIntoView() {
    /**/
  }
  toString(opts) {
    return serializeNodeToHtml(this, opts);
  }
}
function getElementsByClassName(elm, classNames, foundElms) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    for (let j = 0, jj = classNames.length; j < jj; j++) {
      if (childElm.classList.contains(classNames[j])) {
        foundElms.push(childElm);
      }
    }
    getElementsByClassName(childElm, classNames, foundElms);
  }
}
function getElementsByTagName(elm, tagName, foundElms) {
  var _a;
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (tagName === '*' || ((_a = childElm.nodeName) !== null && _a !== void 0 ? _a : '').toLowerCase() === tagName) {
      foundElms.push(childElm);
    }
    getElementsByTagName(childElm, tagName, foundElms);
  }
}
function resetElement(elm) {
  resetEventListeners(elm);
  delete elm.__attributeMap;
  delete elm.__shadowRoot;
  delete elm.__style;
}
function insertBefore(parentNode, newNode, referenceNode) {
  if (newNode !== referenceNode) {
    newNode.remove();
    newNode.parentNode = parentNode;
    newNode.ownerDocument = parentNode.ownerDocument;
    if (referenceNode != null) {
      const index = parentNode.childNodes.indexOf(referenceNode);
      if (index > -1) {
        parentNode.childNodes.splice(index, 0, newNode);
      }
      else {
        throw new Error(`referenceNode not found in parentNode.childNodes`);
      }
    }
    else {
      parentNode.childNodes.push(newNode);
    }
    connectNode(parentNode.ownerDocument, newNode);
  }
  return newNode;
}
class MockHTMLElement extends MockElement {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, typeof nodeName === 'string' ? nodeName.toUpperCase() : null);
    this.namespaceURI = 'http://www.w3.org/1999/xhtml';
  }
  get tagName() {
    var _a;
    return (_a = this.nodeName) !== null && _a !== void 0 ? _a : '';
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get attributes() {
    if (this.__attributeMap == null) {
      const attrMap = createAttributeProxy(true);
      this.__attributeMap = attrMap;
      return attrMap;
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
}
class MockTextNode extends MockNode {
  constructor(ownerDocument, text) {
    super(ownerDocument, 3 /* NODE_TYPES.TEXT_NODE */, "#text" /* NODE_NAMES.TEXT_NODE */, text);
  }
  cloneNode(_deep) {
    return new MockTextNode(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
  get data() {
    return this.nodeValue;
  }
  set data(text) {
    this.nodeValue = text;
  }
  get wholeText() {
    if (this.parentNode != null) {
      const text = [];
      for (let i = 0, ii = this.parentNode.childNodes.length; i < ii; i++) {
        const childNode = this.parentNode.childNodes[i];
        if (childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
          text.push(childNode.nodeValue);
        }
      }
      return text.join('');
    }
    return this.nodeValue;
  }
}
function getTextContent(childNodes, text) {
  for (let i = 0, ii = childNodes.length; i < ii; i++) {
    const childNode = childNodes[i];
    if (childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
      text.push(childNode.nodeValue);
    }
    else if (childNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
      getTextContent(childNode.childNodes, text);
    }
  }
}
function setTextContent(elm, text) {
  for (let i = elm.childNodes.length - 1; i >= 0; i--) {
    elm.removeChild(elm.childNodes[i]);
  }
  const textNode = new MockTextNode(elm.ownerDocument, text);
  elm.appendChild(textNode);
}

class MockComment extends MockNode {
  constructor(ownerDocument, data) {
    super(ownerDocument, 8 /* NODE_TYPES.COMMENT_NODE */, "#comment" /* NODE_NAMES.COMMENT_NODE */, data);
  }
  cloneNode(_deep) {
    return new MockComment(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
}

class MockDocumentFragment extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, null);
    this.nodeName = "#document-fragment" /* NODE_NAMES.DOCUMENT_FRAGMENT_NODE */;
    this.nodeType = 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */;
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  cloneNode(deep) {
    const cloned = new MockDocumentFragment(null);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const childNode = this.childNodes[i];
        if (childNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
          childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */ ||
          childNode.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */) {
          const clonedChildNode = this.childNodes[i].cloneNode(true);
          cloned.appendChild(clonedChildNode);
        }
      }
    }
    return cloned;
  }
}

class MockDocumentTypeNode extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, '!DOCTYPE');
    this.nodeType = 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */;
    this.setAttribute('html', '');
  }
}

class MockCSSRule {
  constructor(parentStyleSheet) {
    this.parentStyleSheet = parentStyleSheet;
    this.cssText = '';
    this.type = 0;
  }
}
class MockCSSStyleSheet {
  constructor(ownerNode) {
    this.type = 'text/css';
    this.parentStyleSheet = null;
    this.cssRules = [];
    this.ownerNode = ownerNode;
  }
  get rules() {
    return this.cssRules;
  }
  set rules(rules) {
    this.cssRules = rules;
  }
  deleteRule(index) {
    if (index >= 0 && index < this.cssRules.length) {
      this.cssRules.splice(index, 1);
      updateStyleTextNode(this.ownerNode);
    }
  }
  insertRule(rule, index = 0) {
    if (typeof index !== 'number') {
      index = 0;
    }
    if (index < 0) {
      index = 0;
    }
    if (index > this.cssRules.length) {
      index = this.cssRules.length;
    }
    const cssRule = new MockCSSRule(this);
    cssRule.cssText = rule;
    this.cssRules.splice(index, 0, cssRule);
    updateStyleTextNode(this.ownerNode);
    return index;
  }
}
function getStyleElementText(styleElm) {
  const output = [];
  for (let i = 0; i < styleElm.childNodes.length; i++) {
    output.push(styleElm.childNodes[i].nodeValue);
  }
  return output.join('');
}
function setStyleElementText(styleElm, text) {
  // keeping the innerHTML and the sheet.cssRules connected
  // is not technically correct, but since we're doing
  // SSR we'll need to turn any assigned cssRules into
  // real text, not just properties that aren't rendered
  const sheet = styleElm.sheet;
  sheet.cssRules.length = 0;
  sheet.insertRule(text);
  updateStyleTextNode(styleElm);
}
function updateStyleTextNode(styleElm) {
  const childNodeLen = styleElm.childNodes.length;
  if (childNodeLen > 1) {
    for (let i = childNodeLen - 1; i >= 1; i--) {
      styleElm.removeChild(styleElm.childNodes[i]);
    }
  }
  else if (childNodeLen < 1) {
    styleElm.appendChild(styleElm.ownerDocument.createTextNode(''));
  }
  const textNode = styleElm.childNodes[0];
  textNode.nodeValue = styleElm.sheet.cssRules.map((r) => r.cssText).join('\n');
}

function createElement(ownerDocument, tagName) {
  if (typeof tagName !== 'string' || tagName === '' || !/^[a-z0-9-_:]+$/i.test(tagName)) {
    throw new Error(`The tag name provided (${tagName}) is not a valid name.`);
  }
  tagName = tagName.toLowerCase();
  switch (tagName) {
    case 'a':
      return new MockAnchorElement(ownerDocument);
    case 'base':
      return new MockBaseElement(ownerDocument);
    case 'button':
      return new MockButtonElement(ownerDocument);
    case 'canvas':
      return new MockCanvasElement(ownerDocument);
    case 'form':
      return new MockFormElement(ownerDocument);
    case 'img':
      return new MockImageElement(ownerDocument);
    case 'input':
      return new MockInputElement(ownerDocument);
    case 'link':
      return new MockLinkElement(ownerDocument);
    case 'meta':
      return new MockMetaElement(ownerDocument);
    case 'script':
      return new MockScriptElement(ownerDocument);
    case 'style':
      return new MockStyleElement(ownerDocument);
    case 'template':
      return new MockTemplateElement(ownerDocument);
    case 'title':
      return new MockTitleElement(ownerDocument);
  }
  if (ownerDocument != null && tagName.includes('-')) {
    const win = ownerDocument.defaultView;
    if (win != null && win.customElements != null) {
      return createCustomElement(win.customElements, ownerDocument, tagName);
    }
  }
  return new MockHTMLElement(ownerDocument, tagName);
}
function createElementNS(ownerDocument, namespaceURI, tagName) {
  if (namespaceURI === 'http://www.w3.org/1999/xhtml') {
    return createElement(ownerDocument, tagName);
  }
  else if (namespaceURI === 'http://www.w3.org/2000/svg') {
    switch (tagName.toLowerCase()) {
      case 'text':
      case 'tspan':
      case 'tref':
      case 'altglyph':
      case 'textpath':
        return new MockSVGTextContentElement(ownerDocument, tagName);
      case 'circle':
      case 'ellipse':
      case 'image':
      case 'line':
      case 'path':
      case 'polygon':
      case 'polyline':
      case 'rect':
      case 'use':
        return new MockSVGGraphicsElement(ownerDocument, tagName);
      case 'svg':
        return new MockSVGSVGElement(ownerDocument, tagName);
      default:
        return new MockSVGElement(ownerDocument, tagName);
    }
  }
  else {
    return new MockElement(ownerDocument, tagName);
  }
}
class MockAnchorElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'a');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
  get pathname() {
    return new URL(this.href).pathname;
  }
}
class MockButtonElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'button');
  }
}
patchPropAttributes(MockButtonElement.prototype, {
  type: String,
}, {
  type: 'submit',
});
class MockImageElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'img');
  }
  get draggable() {
    return this.getAttributeNS(null, 'draggable') !== 'false';
  }
  set draggable(value) {
    this.setAttributeNS(null, 'draggable', value);
  }
  get src() {
    return fullUrl(this, 'src');
  }
  set src(value) {
    this.setAttribute('src', value);
  }
}
patchPropAttributes(MockImageElement.prototype, {
  height: Number,
  width: Number,
});
class MockInputElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'input');
  }
  get list() {
    const listId = this.getAttribute('list');
    if (listId) {
      return this.ownerDocument.getElementById(listId);
    }
    return null;
  }
}
patchPropAttributes(MockInputElement.prototype, {
  accept: String,
  autocomplete: String,
  autofocus: Boolean,
  capture: String,
  checked: Boolean,
  disabled: Boolean,
  form: String,
  formaction: String,
  formenctype: String,
  formmethod: String,
  formnovalidate: String,
  formtarget: String,
  height: Number,
  inputmode: String,
  max: String,
  maxLength: Number,
  min: String,
  minLength: Number,
  multiple: Boolean,
  name: String,
  pattern: String,
  placeholder: String,
  required: Boolean,
  readOnly: Boolean,
  size: Number,
  spellCheck: Boolean,
  src: String,
  step: String,
  type: String,
  value: String,
  width: Number,
}, {
  type: 'text',
});
class MockFormElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'form');
  }
}
patchPropAttributes(MockFormElement.prototype, {
  name: String,
});
class MockLinkElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'link');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
patchPropAttributes(MockLinkElement.prototype, {
  crossorigin: String,
  media: String,
  rel: String,
  type: String,
});
class MockMetaElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'meta');
  }
}
patchPropAttributes(MockMetaElement.prototype, {
  charset: String,
  content: String,
  name: String,
});
class MockScriptElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'script');
  }
  get src() {
    return fullUrl(this, 'src');
  }
  set src(value) {
    this.setAttribute('src', value);
  }
}
patchPropAttributes(MockScriptElement.prototype, {
  type: String,
});
class MockDOMMatrix {
  constructor() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
    this.m11 = 1;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;
    this.m21 = 0;
    this.m22 = 1;
    this.m23 = 0;
    this.m24 = 0;
    this.m31 = 0;
    this.m32 = 0;
    this.m33 = 1;
    this.m34 = 0;
    this.m41 = 0;
    this.m42 = 0;
    this.m43 = 0;
    this.m44 = 1;
    this.is2D = true;
    this.isIdentity = true;
  }
  static fromMatrix() {
    return new MockDOMMatrix();
  }
  inverse() {
    return new MockDOMMatrix();
  }
  flipX() {
    return new MockDOMMatrix();
  }
  flipY() {
    return new MockDOMMatrix();
  }
  multiply() {
    return new MockDOMMatrix();
  }
  rotate() {
    return new MockDOMMatrix();
  }
  rotateAxisAngle() {
    return new MockDOMMatrix();
  }
  rotateFromVector() {
    return new MockDOMMatrix();
  }
  scale() {
    return new MockDOMMatrix();
  }
  scaleNonUniform() {
    return new MockDOMMatrix();
  }
  skewX() {
    return new MockDOMMatrix();
  }
  skewY() {
    return new MockDOMMatrix();
  }
  toJSON() { }
  toString() { }
  transformPoint() {
    return new MockDOMPoint();
  }
  translate() {
    return new MockDOMMatrix();
  }
}
class MockDOMPoint {
  constructor() {
    this.w = 1;
    this.x = 0;
    this.y = 0;
    this.z = 0;
  }
  toJSON() { }
  matrixTransform() {
    return new MockDOMMatrix();
  }
}
class MockSVGRect {
  constructor() {
    this.height = 10;
    this.width = 10;
    this.x = 0;
    this.y = 0;
  }
}
class MockStyleElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'style');
    this.sheet = new MockCSSStyleSheet(this);
  }
  get innerHTML() {
    return getStyleElementText(this);
  }
  set innerHTML(value) {
    setStyleElementText(this, value);
  }
  get innerText() {
    return getStyleElementText(this);
  }
  set innerText(value) {
    setStyleElementText(this, value);
  }
  get textContent() {
    return getStyleElementText(this);
  }
  set textContent(value) {
    setStyleElementText(this, value);
  }
}
class MockSVGElement extends MockElement {
  // SVGElement properties and methods
  get ownerSVGElement() {
    return null;
  }
  get viewportElement() {
    return null;
  }
  onunload() {
    /**/
  }
  // SVGGeometryElement properties and methods
  get pathLength() {
    return 0;
  }
  isPointInFill(_pt) {
    return false;
  }
  isPointInStroke(_pt) {
    return false;
  }
  getTotalLength() {
    return 0;
  }
}
class MockSVGGraphicsElement extends MockSVGElement {
  getBBox(_options) {
    return new MockSVGRect();
  }
  getCTM() {
    return new MockDOMMatrix();
  }
  getScreenCTM() {
    return new MockDOMMatrix();
  }
}
class MockSVGSVGElement extends MockSVGGraphicsElement {
  createSVGPoint() {
    return new MockDOMPoint();
  }
}
class MockSVGTextContentElement extends MockSVGGraphicsElement {
  getComputedTextLength() {
    return 0;
  }
}
class MockBaseElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'base');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
class MockTemplateElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'template');
    this.content = new MockDocumentFragment(ownerDocument);
  }
  get innerHTML() {
    return this.content.innerHTML;
  }
  set innerHTML(html) {
    this.content.innerHTML = html;
  }
  cloneNode(deep) {
    const cloned = new MockTemplateElement(null);
    cloned.attributes = cloneAttributes(this.attributes);
    const styleCssText = this.getAttribute('style');
    if (styleCssText != null && styleCssText.length > 0) {
      cloned.setAttribute('style', styleCssText);
    }
    cloned.content = this.content.cloneNode(deep);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const clonedChildNode = this.childNodes[i].cloneNode(true);
        cloned.appendChild(clonedChildNode);
      }
    }
    return cloned;
  }
}
class MockTitleElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'title');
  }
  get text() {
    return this.textContent;
  }
  set text(value) {
    this.textContent = value;
  }
}
class MockCanvasElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'canvas');
  }
  getContext() {
    return {
      fillRect() {
        return;
      },
      clearRect() { },
      getImageData: function (_, __, w, h) {
        return {
          data: new Array(w * h * 4),
        };
      },
      putImageData() { },
      createImageData: function () {
        return [];
      },
      setTransform() { },
      drawImage() { },
      save() { },
      fillText() { },
      restore() { },
      beginPath() { },
      moveTo() { },
      lineTo() { },
      closePath() { },
      stroke() { },
      translate() { },
      scale() { },
      rotate() { },
      arc() { },
      fill() { },
      measureText() {
        return { width: 0 };
      },
      transform() { },
      rect() { },
      clip() { },
    };
  }
}
function fullUrl(elm, attrName) {
  const val = elm.getAttribute(attrName) || '';
  if (elm.ownerDocument != null) {
    const win = elm.ownerDocument.defaultView;
    if (win != null) {
      const loc = win.location;
      if (loc != null) {
        try {
          const url = new URL(val, loc.href);
          return url.href;
        }
        catch (e) { }
      }
    }
  }
  return val.replace(/\'|\"/g, '').trim();
}
function patchPropAttributes(prototype, attrs, defaults = {}) {
  Object.keys(attrs).forEach((propName) => {
    const attr = attrs[propName];
    const defaultValue = defaults[propName];
    if (attr === Boolean) {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName);
        },
        set(value) {
          if (value) {
            this.setAttribute(propName, '');
          }
          else {
            this.removeAttribute(propName);
          }
        },
      });
    }
    else if (attr === Number) {
      Object.defineProperty(prototype, propName, {
        get() {
          const value = this.getAttribute(propName);
          return value ? parseInt(value, 10) : defaultValue === undefined ? 0 : defaultValue;
        },
        set(value) {
          this.setAttribute(propName, value);
        },
      });
    }
    else {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName) ? this.getAttribute(propName) : defaultValue || '';
        },
        set(value) {
          this.setAttribute(propName, value);
        },
      });
    }
  });
}
MockElement.prototype.cloneNode = function (deep) {
  // because we're creating elements, which extending specific HTML base classes there
  // is a MockElement circular reference that bundling has trouble dealing with so
  // the fix is to add cloneNode() to MockElement's prototype after the HTML classes
  const cloned = createElement(this.ownerDocument, this.nodeName);
  cloned.attributes = cloneAttributes(this.attributes);
  const styleCssText = this.getAttribute('style');
  if (styleCssText != null && styleCssText.length > 0) {
    cloned.setAttribute('style', styleCssText);
  }
  if (deep) {
    for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
      const clonedChildNode = this.childNodes[i].cloneNode(true);
      cloned.appendChild(clonedChildNode);
    }
  }
  return cloned;
};

let sharedDocument;
function parseHtmlToDocument(html, ownerDocument = null) {
  if (ownerDocument == null) {
    if (sharedDocument == null) {
      sharedDocument = new MockDocument();
    }
    ownerDocument = sharedDocument;
  }
  return parseDocumentUtil(ownerDocument, html);
}
function parseHtmlToFragment(html, ownerDocument = null) {
  if (ownerDocument == null) {
    if (sharedDocument == null) {
      sharedDocument = new MockDocument();
    }
    ownerDocument = sharedDocument;
  }
  return parseFragmentUtil(ownerDocument, html);
}

const consoleNoop = () => {
  /**/
};
function createConsole() {
  return {
    debug: consoleNoop,
    error: consoleNoop,
    info: consoleNoop,
    log: consoleNoop,
    warn: consoleNoop,
    dir: consoleNoop,
    dirxml: consoleNoop,
    table: consoleNoop,
    trace: consoleNoop,
    group: consoleNoop,
    groupCollapsed: consoleNoop,
    groupEnd: consoleNoop,
    clear: consoleNoop,
    count: consoleNoop,
    countReset: consoleNoop,
    assert: consoleNoop,
    profile: consoleNoop,
    profileEnd: consoleNoop,
    time: consoleNoop,
    timeLog: consoleNoop,
    timeEnd: consoleNoop,
    timeStamp: consoleNoop,
    context: consoleNoop,
    memory: consoleNoop,
  };
}

class MockHeaders {
  constructor(init) {
    this._values = [];
    if (typeof init === 'object') {
      if (typeof init[Symbol.iterator] === 'function') {
        const kvs = [];
        for (const kv of init) {
          if (typeof kv[Symbol.iterator] === 'function') {
            kvs.push([...kv]);
          }
        }
        for (const kv of kvs) {
          this.append(kv[0], kv[1]);
        }
      }
      else {
        for (const key in init) {
          this.append(key, init[key]);
        }
      }
    }
  }
  append(key, value) {
    this._values.push([key, value + '']);
  }
  delete(key) {
    key = key.toLowerCase();
    for (let i = this._values.length - 1; i >= 0; i--) {
      if (this._values[i][0].toLowerCase() === key) {
        this._values.splice(i, 1);
      }
    }
  }
  entries() {
    const entries = [];
    for (const kv of this.keys()) {
      entries.push([kv, this.get(kv)]);
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: entries[index],
          done: !entries[index],
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  forEach(cb) {
    for (const kv of this.entries()) {
      cb(kv[1], kv[0]);
    }
  }
  get(key) {
    const rtn = [];
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        rtn.push(kv[1]);
      }
    }
    return rtn.length > 0 ? rtn.join(', ') : null;
  }
  has(key) {
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        return true;
      }
    }
    return false;
  }
  keys() {
    const keys = [];
    for (const kv of this._values) {
      const key = kv[0].toLowerCase();
      if (!keys.includes(key)) {
        keys.push(key);
      }
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: keys[index],
          done: !keys[index],
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  set(key, value) {
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key.toLowerCase()) {
        kv[1] = value + '';
        return;
      }
    }
    this.append(key, value);
  }
  values() {
    const values = this._values;
    let index = -1;
    return {
      next() {
        index++;
        const done = !values[index];
        return {
          value: done ? undefined : values[index][1],
          done,
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
}

class MockDOMParser {
  parseFromString(htmlToParse, mimeType) {
    if (mimeType !== 'text/html') {
      console.error('XML parsing not implemented yet, continuing as html');
    }
    return parseHtmlToDocument(htmlToParse);
  }
}

class MockRequest {
  constructor(input, init = {}) {
    this._method = 'GET';
    this._url = '/';
    this.bodyUsed = false;
    this.cache = 'default';
    this.credentials = 'same-origin';
    this.integrity = '';
    this.keepalive = false;
    this.mode = 'cors';
    this.redirect = 'follow';
    this.referrer = 'about:client';
    this.referrerPolicy = '';
    if (typeof input === 'string') {
      this.url = input;
    }
    else if (input) {
      Object.assign(this, input);
      this.headers = new MockHeaders(input.headers);
    }
    Object.assign(this, init);
    if (init.headers) {
      this.headers = new MockHeaders(init.headers);
    }
    if (!this.headers) {
      this.headers = new MockHeaders();
    }
  }
  get url() {
    if (typeof this._url === 'string') {
      return new URL(this._url, location.href).href;
    }
    return new URL('/', location.href).href;
  }
  set url(value) {
    this._url = value;
  }
  get method() {
    if (typeof this._method === 'string') {
      return this._method.toUpperCase();
    }
    return 'GET';
  }
  set method(value) {
    this._method = value;
  }
  clone() {
    const clone = { ...this };
    clone.headers = new MockHeaders(this.headers);
    return new MockRequest(clone);
  }
}
class MockResponse {
  constructor(body, init = {}) {
    this.ok = true;
    this.status = 200;
    this.statusText = '';
    this.type = 'default';
    this.url = '';
    this._body = body;
    if (init) {
      Object.assign(this, init);
    }
    this.headers = new MockHeaders(init.headers);
  }
  async json() {
    return JSON.parse(this._body);
  }
  async text() {
    return this._body;
  }
  clone() {
    const initClone = { ...this };
    initClone.headers = new MockHeaders(this.headers);
    return new MockResponse(this._body, initClone);
  }
}

function setupGlobal(gbl) {
  if (gbl.window == null) {
    const win = (gbl.window = new MockWindow());
    WINDOW_FUNCTIONS.forEach((fnName) => {
      if (!(fnName in gbl)) {
        gbl[fnName] = win[fnName].bind(win);
      }
    });
    WINDOW_PROPS.forEach((propName) => {
      if (!(propName in gbl)) {
        Object.defineProperty(gbl, propName, {
          get() {
            return win[propName];
          },
          set(val) {
            win[propName] = val;
          },
          configurable: true,
          enumerable: true,
        });
      }
    });
    GLOBAL_CONSTRUCTORS.forEach(([cstrName]) => {
      gbl[cstrName] = win[cstrName];
    });
  }
  return gbl.window;
}
function teardownGlobal(gbl) {
  const win = gbl.window;
  if (win && typeof win.close === 'function') {
    win.close();
  }
}
function patchWindow(winToBePatched) {
  const mockWin = new MockWindow(false);
  WINDOW_FUNCTIONS.forEach((fnName) => {
    if (typeof winToBePatched[fnName] !== 'function') {
      winToBePatched[fnName] = mockWin[fnName].bind(mockWin);
    }
  });
  WINDOW_PROPS.forEach((propName) => {
    if (winToBePatched === undefined) {
      Object.defineProperty(winToBePatched, propName, {
        get() {
          return mockWin[propName];
        },
        set(val) {
          mockWin[propName] = val;
        },
        configurable: true,
        enumerable: true,
      });
    }
  });
}
function addGlobalsToWindowPrototype(mockWinPrototype) {
  GLOBAL_CONSTRUCTORS.forEach(([cstrName, Cstr]) => {
    Object.defineProperty(mockWinPrototype, cstrName, {
      get() {
        return this['__' + cstrName] || Cstr;
      },
      set(cstr) {
        this['__' + cstrName] = cstr;
      },
      configurable: true,
      enumerable: true,
    });
  });
}
const WINDOW_FUNCTIONS = [
  'addEventListener',
  'alert',
  'blur',
  'cancelAnimationFrame',
  'cancelIdleCallback',
  'clearInterval',
  'clearTimeout',
  'close',
  'confirm',
  'dispatchEvent',
  'focus',
  'getComputedStyle',
  'matchMedia',
  'open',
  'prompt',
  'removeEventListener',
  'requestAnimationFrame',
  'requestIdleCallback',
  'URL',
];
const WINDOW_PROPS = [
  'customElements',
  'devicePixelRatio',
  'document',
  'history',
  'innerHeight',
  'innerWidth',
  'localStorage',
  'location',
  'navigator',
  'pageXOffset',
  'pageYOffset',
  'performance',
  'screenLeft',
  'screenTop',
  'screenX',
  'screenY',
  'scrollX',
  'scrollY',
  'sessionStorage',
  'CSS',
  'CustomEvent',
  'Event',
  'Element',
  'HTMLElement',
  'Node',
  'NodeList',
  'FocusEvent',
  'KeyboardEvent',
  'MouseEvent',
];
const GLOBAL_CONSTRUCTORS = [
  ['CustomEvent', MockCustomEvent],
  ['Event', MockEvent],
  ['Headers', MockHeaders],
  ['FocusEvent', MockFocusEvent],
  ['KeyboardEvent', MockKeyboardEvent],
  ['MouseEvent', MockMouseEvent],
  ['Request', MockRequest],
  ['Response', MockResponse],
  ['DOMParser', MockDOMParser],
  ['HTMLAnchorElement', MockAnchorElement],
  ['HTMLBaseElement', MockBaseElement],
  ['HTMLButtonElement', MockButtonElement],
  ['HTMLCanvasElement', MockCanvasElement],
  ['HTMLFormElement', MockFormElement],
  ['HTMLImageElement', MockImageElement],
  ['HTMLInputElement', MockInputElement],
  ['HTMLLinkElement', MockLinkElement],
  ['HTMLMetaElement', MockMetaElement],
  ['HTMLScriptElement', MockScriptElement],
  ['HTMLStyleElement', MockStyleElement],
  ['HTMLTemplateElement', MockTemplateElement],
  ['HTMLTitleElement', MockTitleElement],
];

class MockHistory {
  constructor() {
    this.items = [];
  }
  get length() {
    return this.items.length;
  }
  back() {
    this.go(-1);
  }
  forward() {
    this.go(1);
  }
  go(_value) {
    //
  }
  pushState(_state, _title, _url) {
    //
  }
  replaceState(_state, _title, _url) {
    //
  }
}

class MockIntersectionObserver {
  constructor() {
    /**/
  }
  disconnect() {
    /**/
  }
  observe() {
    /**/
  }
  takeRecords() {
    return [];
  }
  unobserve() {
    /**/
  }
}

class MockLocation {
  constructor() {
    this.ancestorOrigins = null;
    this.protocol = '';
    this.host = '';
    this.hostname = '';
    this.port = '';
    this.pathname = '';
    this.search = '';
    this.hash = '';
    this.username = '';
    this.password = '';
    this.origin = '';
    this._href = '';
  }
  get href() {
    return this._href;
  }
  set href(value) {
    const url = new URL(value, 'http://mockdoc.stenciljs.com');
    this._href = url.href;
    this.protocol = url.protocol;
    this.host = url.host;
    this.hostname = url.hostname;
    this.port = url.port;
    this.pathname = url.pathname;
    this.search = url.search;
    this.hash = url.hash;
    this.username = url.username;
    this.password = url.password;
    this.origin = url.origin;
  }
  assign(_url) {
    //
  }
  reload(_forcedReload) {
    //
  }
  replace(_url) {
    //
  }
  toString() {
    return this.href;
  }
}

class MockNavigator {
  constructor() {
    this.appCodeName = 'MockNavigator';
    this.appName = 'MockNavigator';
    this.appVersion = 'MockNavigator';
    this.platform = 'MockNavigator';
    this.userAgent = 'MockNavigator';
  }
}

/**
 * https://developer.mozilla.org/en-US/docs/Web/API/Performance
 */
class MockPerformance {
  constructor() {
    this.timeOrigin = Date.now();
    this.eventCounts = new Map();
  }
  addEventListener() {
    //
  }
  clearMarks() {
    //
  }
  clearMeasures() {
    //
  }
  clearResourceTimings() {
    //
  }
  dispatchEvent() {
    return true;
  }
  getEntries() {
    return [];
  }
  getEntriesByName() {
    return [];
  }
  getEntriesByType() {
    return [];
  }
  // Stencil's implementation of `mark` is non-compliant with the `Performance` interface. Because Stencil will
  // instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
  // type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
  // associated errors returned by the type checker)
  // @ts-ignore
  mark() {
    //
  }
  // Stencil's implementation of `measure` is non-compliant with the `Performance` interface. Because Stencil will
  // instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
  // type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
  // associated errors returned by the type checker)
  // @ts-ignore
  measure() {
    //
  }
  get navigation() {
    return {};
  }
  now() {
    return Date.now() - this.timeOrigin;
  }
  get onresourcetimingbufferfull() {
    return null;
  }
  removeEventListener() {
    //
  }
  setResourceTimingBufferSize() {
    //
  }
  get timing() {
    return {};
  }
  toJSON() {
    //
  }
}
function resetPerformance(perf) {
  if (perf != null) {
    try {
      perf.timeOrigin = Date.now();
    }
    catch (e) { }
  }
}

class MockStorage {
  constructor() {
    this.items = new Map();
  }
  key(_value) {
    //
  }
  getItem(key) {
    key = String(key);
    if (this.items.has(key)) {
      return this.items.get(key);
    }
    return null;
  }
  setItem(key, value) {
    if (value == null) {
      value = 'null';
    }
    this.items.set(String(key), String(value));
  }
  removeItem(key) {
    this.items.delete(String(key));
  }
  clear() {
    this.items.clear();
  }
}

const nativeClearInterval = clearInterval;
const nativeClearTimeout = clearTimeout;
const nativeSetInterval = setInterval;
const nativeSetTimeout = setTimeout;
const nativeURL = URL;
class MockWindow {
  constructor(html = null) {
    if (html !== false) {
      this.document = new MockDocument(html, this);
    }
    else {
      this.document = null;
    }
    this.performance = new MockPerformance();
    this.customElements = new MockCustomElementRegistry(this);
    this.console = createConsole();
    resetWindowDefaults(this);
    resetWindowDimensions(this);
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  alert(msg) {
    if (this.console) {
      this.console.debug(msg);
    }
    else {
      console.debug(msg);
    }
  }
  blur() {
    /**/
  }
  cancelAnimationFrame(id) {
    this.__clearTimeout(id);
  }
  cancelIdleCallback(id) {
    this.__clearTimeout(id);
  }
  get CharacterData() {
    if (this.__charDataCstr == null) {
      const ownerDocument = this.document;
      this.__charDataCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct CharacterData');
        }
      };
    }
    return this.__charDataCstr;
  }
  set CharacterData(charDataCstr) {
    this.__charDataCstr = charDataCstr;
  }
  clearInterval(id) {
    this.__clearInterval(id);
  }
  clearTimeout(id) {
    this.__clearTimeout(id);
  }
  close() {
    resetWindow(this);
  }
  confirm() {
    return false;
  }
  get CSS() {
    return {
      supports: () => true,
    };
  }
  get Document() {
    if (this.__docCstr == null) {
      const win = this;
      this.__docCstr = class extends MockDocument {
        constructor() {
          super(false, win);
          throw new Error('Illegal constructor: cannot construct Document');
        }
      };
    }
    return this.__docCstr;
  }
  set Document(docCstr) {
    this.__docCstr = docCstr;
  }
  get DocumentFragment() {
    if (this.__docFragCstr == null) {
      const ownerDocument = this.document;
      this.__docFragCstr = class extends MockDocumentFragment {
        constructor() {
          super(ownerDocument);
          throw new Error('Illegal constructor: cannot construct DocumentFragment');
        }
      };
    }
    return this.__docFragCstr;
  }
  set DocumentFragment(docFragCstr) {
    this.__docFragCstr = docFragCstr;
  }
  get DocumentType() {
    if (this.__docTypeCstr == null) {
      const ownerDocument = this.document;
      this.__docTypeCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct DocumentType');
        }
      };
    }
    return this.__docTypeCstr;
  }
  set DocumentType(docTypeCstr) {
    this.__docTypeCstr = docTypeCstr;
  }
  get DOMTokenList() {
    if (this.__domTokenListCstr == null) {
      this.__domTokenListCstr = class MockDOMTokenList {
      };
    }
    return this.__domTokenListCstr;
  }
  set DOMTokenList(domTokenListCstr) {
    this.__domTokenListCstr = domTokenListCstr;
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get Element() {
    if (this.__elementCstr == null) {
      const ownerDocument = this.document;
      this.__elementCstr = class extends MockElement {
        constructor() {
          super(ownerDocument, '');
          throw new Error('Illegal constructor: cannot construct Element');
        }
      };
    }
    return this.__elementCstr;
  }
  fetch(input, init) {
    if (typeof fetch === 'function') {
      return fetch(input, init);
    }
    throw new Error(`fetch() not implemented`);
  }
  focus() {
    /**/
  }
  getComputedStyle(_) {
    return {
      cssText: '',
      length: 0,
      parentRule: null,
      getPropertyPriority() {
        return null;
      },
      getPropertyValue() {
        return '';
      },
      item() {
        return null;
      },
      removeProperty() {
        return null;
      },
      setProperty() {
        return null;
      },
    };
  }
  get globalThis() {
    return this;
  }
  get history() {
    if (this.__history == null) {
      this.__history = new MockHistory();
    }
    return this.__history;
  }
  set history(hsty) {
    this.__history = hsty;
  }
  get JSON() {
    return JSON;
  }
  get HTMLElement() {
    if (this.__htmlElementCstr == null) {
      const ownerDocument = this.document;
      this.__htmlElementCstr = class extends MockHTMLElement {
        constructor() {
          super(ownerDocument, '');
          const observedAttributes = this.constructor.observedAttributes;
          if (Array.isArray(observedAttributes) && typeof this.attributeChangedCallback === 'function') {
            observedAttributes.forEach((attrName) => {
              const attrValue = this.getAttribute(attrName);
              if (attrValue != null) {
                this.attributeChangedCallback(attrName, null, attrValue);
              }
            });
          }
        }
      };
    }
    return this.__htmlElementCstr;
  }
  set HTMLElement(htmlElementCstr) {
    this.__htmlElementCstr = htmlElementCstr;
  }
  get IntersectionObserver() {
    return MockIntersectionObserver;
  }
  get localStorage() {
    if (this.__localStorage == null) {
      this.__localStorage = new MockStorage();
    }
    return this.__localStorage;
  }
  set localStorage(locStorage) {
    this.__localStorage = locStorage;
  }
  get location() {
    if (this.__location == null) {
      this.__location = new MockLocation();
    }
    return this.__location;
  }
  set location(val) {
    if (typeof val === 'string') {
      if (this.__location == null) {
        this.__location = new MockLocation();
      }
      this.__location.href = val;
    }
    else {
      this.__location = val;
    }
  }
  matchMedia() {
    return {
      matches: false,
    };
  }
  get Node() {
    if (this.__nodeCstr == null) {
      const ownerDocument = this.document;
      this.__nodeCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct Node');
        }
      };
    }
    return this.__nodeCstr;
  }
  get NodeList() {
    if (this.__nodeListCstr == null) {
      const ownerDocument = this.document;
      this.__nodeListCstr = class extends MockNodeList {
        constructor() {
          super(ownerDocument, [], 0);
          throw new Error('Illegal constructor: cannot construct NodeList');
        }
      };
    }
    return this.__nodeListCstr;
  }
  get navigator() {
    if (this.__navigator == null) {
      this.__navigator = new MockNavigator();
    }
    return this.__navigator;
  }
  set navigator(nav) {
    this.__navigator = nav;
  }
  get parent() {
    return null;
  }
  prompt() {
    return '';
  }
  open() {
    return null;
  }
  get origin() {
    return this.location.origin;
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  requestAnimationFrame(callback) {
    return this.setTimeout(() => {
      callback(Date.now());
    }, 0);
  }
  requestIdleCallback(callback) {
    return this.setTimeout(() => {
      callback({
        didTimeout: false,
        timeRemaining: () => 0,
      });
    }, 0);
  }
  scroll(_x, _y) {
    /**/
  }
  scrollBy(_x, _y) {
    /**/
  }
  scrollTo(_x, _y) {
    /**/
  }
  get self() {
    return this;
  }
  get sessionStorage() {
    if (this.__sessionStorage == null) {
      this.__sessionStorage = new MockStorage();
    }
    return this.__sessionStorage;
  }
  set sessionStorage(locStorage) {
    this.__sessionStorage = locStorage;
  }
  setInterval(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    if (this.__allowInterval) {
      const intervalId = this.__setInterval(() => {
        if (this.__timeouts) {
          this.__timeouts.delete(intervalId);
          try {
            callback(...args);
          }
          catch (e) {
            if (this.console) {
              this.console.error(e);
            }
            else {
              console.error(e);
            }
          }
        }
      }, ms);
      if (this.__timeouts) {
        this.__timeouts.add(intervalId);
      }
      return intervalId;
    }
    const timeoutId = this.__setTimeout(() => {
      if (this.__timeouts) {
        this.__timeouts.delete(timeoutId);
        try {
          callback(...args);
        }
        catch (e) {
          if (this.console) {
            this.console.error(e);
          }
          else {
            console.error(e);
          }
        }
      }
    }, ms);
    if (this.__timeouts) {
      this.__timeouts.add(timeoutId);
    }
    return timeoutId;
  }
  setTimeout(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    const timeoutId = this.__setTimeout(() => {
      if (this.__timeouts) {
        this.__timeouts.delete(timeoutId);
        try {
          callback(...args);
        }
        catch (e) {
          if (this.console) {
            this.console.error(e);
          }
          else {
            console.error(e);
          }
        }
      }
    }, ms);
    if (this.__timeouts) {
      this.__timeouts.add(timeoutId);
    }
    return timeoutId;
  }
  get top() {
    return this;
  }
  get window() {
    return this;
  }
  onanimationstart() {
    /**/
  }
  onanimationend() {
    /**/
  }
  onanimationiteration() {
    /**/
  }
  onabort() {
    /**/
  }
  onauxclick() {
    /**/
  }
  onbeforecopy() {
    /**/
  }
  onbeforecut() {
    /**/
  }
  onbeforepaste() {
    /**/
  }
  onblur() {
    /**/
  }
  oncancel() {
    /**/
  }
  oncanplay() {
    /**/
  }
  oncanplaythrough() {
    /**/
  }
  onchange() {
    /**/
  }
  onclick() {
    /**/
  }
  onclose() {
    /**/
  }
  oncontextmenu() {
    /**/
  }
  oncopy() {
    /**/
  }
  oncuechange() {
    /**/
  }
  oncut() {
    /**/
  }
  ondblclick() {
    /**/
  }
  ondrag() {
    /**/
  }
  ondragend() {
    /**/
  }
  ondragenter() {
    /**/
  }
  ondragleave() {
    /**/
  }
  ondragover() {
    /**/
  }
  ondragstart() {
    /**/
  }
  ondrop() {
    /**/
  }
  ondurationchange() {
    /**/
  }
  onemptied() {
    /**/
  }
  onended() {
    /**/
  }
  onerror() {
    /**/
  }
  onfocus() {
    /**/
  }
  onfocusin() {
    /**/
  }
  onfocusout() {
    /**/
  }
  onformdata() {
    /**/
  }
  onfullscreenchange() {
    /**/
  }
  onfullscreenerror() {
    /**/
  }
  ongotpointercapture() {
    /**/
  }
  oninput() {
    /**/
  }
  oninvalid() {
    /**/
  }
  onkeydown() {
    /**/
  }
  onkeypress() {
    /**/
  }
  onkeyup() {
    /**/
  }
  onload() {
    /**/
  }
  onloadeddata() {
    /**/
  }
  onloadedmetadata() {
    /**/
  }
  onloadstart() {
    /**/
  }
  onlostpointercapture() {
    /**/
  }
  onmousedown() {
    /**/
  }
  onmouseenter() {
    /**/
  }
  onmouseleave() {
    /**/
  }
  onmousemove() {
    /**/
  }
  onmouseout() {
    /**/
  }
  onmouseover() {
    /**/
  }
  onmouseup() {
    /**/
  }
  onmousewheel() {
    /**/
  }
  onpaste() {
    /**/
  }
  onpause() {
    /**/
  }
  onplay() {
    /**/
  }
  onplaying() {
    /**/
  }
  onpointercancel() {
    /**/
  }
  onpointerdown() {
    /**/
  }
  onpointerenter() {
    /**/
  }
  onpointerleave() {
    /**/
  }
  onpointermove() {
    /**/
  }
  onpointerout() {
    /**/
  }
  onpointerover() {
    /**/
  }
  onpointerup() {
    /**/
  }
  onprogress() {
    /**/
  }
  onratechange() {
    /**/
  }
  onreset() {
    /**/
  }
  onresize() {
    /**/
  }
  onscroll() {
    /**/
  }
  onsearch() {
    /**/
  }
  onseeked() {
    /**/
  }
  onseeking() {
    /**/
  }
  onselect() {
    /**/
  }
  onselectstart() {
    /**/
  }
  onstalled() {
    /**/
  }
  onsubmit() {
    /**/
  }
  onsuspend() {
    /**/
  }
  ontimeupdate() {
    /**/
  }
  ontoggle() {
    /**/
  }
  onvolumechange() {
    /**/
  }
  onwaiting() {
    /**/
  }
  onwebkitfullscreenchange() {
    /**/
  }
  onwebkitfullscreenerror() {
    /**/
  }
  onwheel() {
    /**/
  }
}
addGlobalsToWindowPrototype(MockWindow.prototype);
function resetWindowDefaults(win) {
  win.__clearInterval = nativeClearInterval;
  win.__clearTimeout = nativeClearTimeout;
  win.__setInterval = nativeSetInterval;
  win.__setTimeout = nativeSetTimeout;
  win.__maxTimeout = 30000;
  win.__allowInterval = true;
  win.URL = nativeURL;
}
function cloneWindow(srcWin, opts = {}) {
  if (srcWin == null) {
    return null;
  }
  const clonedWin = new MockWindow(false);
  if (!opts.customElementProxy) {
    // TODO(STENCIL-345) - Evaluate reconciling MockWindow, Window differences
    // @ts-ignore
    srcWin.customElements = null;
  }
  if (srcWin.document != null) {
    const clonedDoc = new MockDocument(false, clonedWin);
    clonedWin.document = clonedDoc;
    clonedDoc.documentElement = srcWin.document.documentElement.cloneNode(true);
  }
  else {
    clonedWin.document = new MockDocument(null, clonedWin);
  }
  return clonedWin;
}
function cloneDocument(srcDoc) {
  if (srcDoc == null) {
    return null;
  }
  const dstWin = cloneWindow(srcDoc.defaultView);
  return dstWin.document;
}
// TODO(STENCIL-345) - Evaluate reconciling MockWindow, Window differences
/**
 * Constrain setTimeout() to 1ms, but still async. Also
 * only allow setInterval() to fire once, also constrained to 1ms.
 * @param win the mock window instance to update
 */
function constrainTimeouts(win) {
  win.__allowInterval = false;
  win.__maxTimeout = 0;
}
function resetWindow(win) {
  if (win != null) {
    if (win.__timeouts) {
      win.__timeouts.forEach((timeoutId) => {
        nativeClearInterval(timeoutId);
        nativeClearTimeout(timeoutId);
      });
      win.__timeouts.clear();
    }
    if (win.customElements && win.customElements.clear) {
      win.customElements.clear();
    }
    resetDocument(win.document);
    resetPerformance(win.performance);
    for (const key in win) {
      if (win.hasOwnProperty(key) && key !== 'document' && key !== 'performance' && key !== 'customElements') {
        delete win[key];
      }
    }
    resetWindowDefaults(win);
    resetWindowDimensions(win);
    resetEventListeners(win);
    if (win.document != null) {
      try {
        win.document.defaultView = win;
      }
      catch (e) { }
    }
    // ensure we don't hold onto nodeFetch values
    win.fetch = null;
    win.Headers = null;
    win.Request = null;
    win.Response = null;
    win.FetchError = null;
  }
}
function resetWindowDimensions(win) {
  try {
    win.devicePixelRatio = 1;
    win.innerHeight = 768;
    win.innerWidth = 1366;
    win.pageXOffset = 0;
    win.pageYOffset = 0;
    win.screenLeft = 0;
    win.screenTop = 0;
    win.screenX = 0;
    win.screenY = 0;
    win.scrollX = 0;
    win.scrollY = 0;
    win.screen = {
      availHeight: win.innerHeight,
      availLeft: 0,
      availTop: 0,
      availWidth: win.innerWidth,
      colorDepth: 24,
      height: win.innerHeight,
      keepAwake: false,
      orientation: {
        angle: 0,
        type: 'portrait-primary',
      },
      pixelDepth: 24,
      width: win.innerWidth,
    };
  }
  catch (e) { }
}

class MockDocument extends MockHTMLElement {
  constructor(html = null, win = null) {
    super(null, null);
    this.nodeName = "#document" /* NODE_NAMES.DOCUMENT_NODE */;
    this.nodeType = 9 /* NODE_TYPES.DOCUMENT_NODE */;
    this.defaultView = win;
    this.cookie = '';
    this.referrer = '';
    this.appendChild(this.createDocumentTypeNode());
    if (typeof html === 'string') {
      const parsedDoc = parseDocumentUtil(this, html);
      const documentElement = parsedDoc.children.find((elm) => elm.nodeName === 'HTML');
      if (documentElement != null) {
        this.appendChild(documentElement);
        setOwnerDocument(documentElement, this);
      }
    }
    else if (html !== false) {
      const documentElement = new MockHTMLElement(this, 'html');
      this.appendChild(documentElement);
      documentElement.appendChild(new MockHTMLElement(this, 'head'));
      documentElement.appendChild(new MockHTMLElement(this, 'body'));
    }
  }
  get dir() {
    return this.documentElement.dir;
  }
  set dir(value) {
    this.documentElement.dir = value;
  }
  get location() {
    if (this.defaultView != null) {
      return this.defaultView.location;
    }
    return null;
  }
  set location(val) {
    if (this.defaultView != null) {
      this.defaultView.location = val;
    }
  }
  get baseURI() {
    const baseNode = this.head.childNodes.find((node) => node.nodeName === 'BASE');
    if (baseNode) {
      return baseNode.href;
    }
    return this.URL;
  }
  get URL() {
    return this.location.href;
  }
  get styleSheets() {
    return this.querySelectorAll('style');
  }
  get scripts() {
    return this.querySelectorAll('script');
  }
  get forms() {
    return this.querySelectorAll('form');
  }
  get images() {
    return this.querySelectorAll('img');
  }
  get scrollingElement() {
    return this.documentElement;
  }
  get documentElement() {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeName === 'HTML') {
        return this.childNodes[i];
      }
    }
    const documentElement = new MockHTMLElement(this, 'html');
    this.appendChild(documentElement);
    return documentElement;
  }
  set documentElement(documentElement) {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeType !== 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */) {
        this.childNodes[i].remove();
      }
    }
    if (documentElement != null) {
      this.appendChild(documentElement);
      setOwnerDocument(documentElement, this);
    }
  }
  get head() {
    const documentElement = this.documentElement;
    for (let i = 0; i < documentElement.childNodes.length; i++) {
      if (documentElement.childNodes[i].nodeName === 'HEAD') {
        return documentElement.childNodes[i];
      }
    }
    const head = new MockHTMLElement(this, 'head');
    documentElement.insertBefore(head, documentElement.firstChild);
    return head;
  }
  set head(head) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'HEAD') {
        documentElement.childNodes[i].remove();
      }
    }
    if (head != null) {
      documentElement.insertBefore(head, documentElement.firstChild);
      setOwnerDocument(head, this);
    }
  }
  get body() {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'BODY') {
        return documentElement.childNodes[i];
      }
    }
    const body = new MockHTMLElement(this, 'body');
    documentElement.appendChild(body);
    return body;
  }
  set body(body) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'BODY') {
        documentElement.childNodes[i].remove();
      }
    }
    if (body != null) {
      documentElement.appendChild(body);
      setOwnerDocument(body, this);
    }
  }
  appendChild(newNode) {
    newNode.remove();
    newNode.parentNode = this;
    this.childNodes.push(newNode);
    return newNode;
  }
  createComment(data) {
    return new MockComment(this, data);
  }
  createAttribute(attrName) {
    return new MockAttr(attrName.toLowerCase(), '');
  }
  createAttributeNS(namespaceURI, attrName) {
    return new MockAttr(attrName, '', namespaceURI);
  }
  createElement(tagName) {
    if (tagName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
      const doc = new MockDocument(false);
      doc.nodeName = tagName;
      doc.parentNode = null;
      return doc;
    }
    return createElement(this, tagName);
  }
  createElementNS(namespaceURI, tagName) {
    const elmNs = createElementNS(this, namespaceURI, tagName);
    elmNs.namespaceURI = namespaceURI;
    return elmNs;
  }
  createTextNode(text) {
    return new MockTextNode(this, text);
  }
  createDocumentFragment() {
    return new MockDocumentFragment(this);
  }
  createDocumentTypeNode() {
    return new MockDocumentTypeNode(this);
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  getElementsByName(elmName) {
    return getElementsByName(this, elmName.toLowerCase());
  }
  get title() {
    const title = this.head.childNodes.find((elm) => elm.nodeName === 'TITLE');
    if (title != null && typeof title.textContent === 'string') {
      return title.textContent.trim();
    }
    return '';
  }
  set title(value) {
    const head = this.head;
    let title = head.childNodes.find((elm) => elm.nodeName === 'TITLE');
    if (title == null) {
      title = this.createElement('title');
      head.appendChild(title);
    }
    title.textContent = value;
  }
}
function createDocument(html = null) {
  return new MockWindow(html).document;
}
function createFragment(html) {
  return parseHtmlToFragment(html, null);
}
function resetDocument(doc) {
  if (doc != null) {
    resetEventListeners(doc);
    const documentElement = doc.documentElement;
    if (documentElement != null) {
      resetElement(documentElement);
      for (let i = 0, ii = documentElement.childNodes.length; i < ii; i++) {
        const childNode = documentElement.childNodes[i];
        resetElement(childNode);
        childNode.childNodes.length = 0;
      }
    }
    for (const key in doc) {
      if (doc.hasOwnProperty(key) && !DOC_KEY_KEEPERS.has(key)) {
        delete doc[key];
      }
    }
    try {
      doc.nodeName = "#document" /* NODE_NAMES.DOCUMENT_NODE */;
    }
    catch (e) { }
    try {
      doc.nodeType = 9 /* NODE_TYPES.DOCUMENT_NODE */;
    }
    catch (e) { }
    try {
      doc.cookie = '';
    }
    catch (e) { }
    try {
      doc.referrer = '';
    }
    catch (e) { }
  }
}
const DOC_KEY_KEEPERS = new Set([
  'nodeName',
  'nodeType',
  'nodeValue',
  'ownerDocument',
  'parentNode',
  'childNodes',
  '_shadowRoot',
]);
function getElementById(elm, id) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.id === id) {
      return childElm;
    }
    const childElmFound = getElementById(childElm, id);
    if (childElmFound != null) {
      return childElmFound;
    }
  }
  return null;
}
function getElementsByName(elm, elmName, foundElms = []) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.name && childElm.name.toLowerCase() === elmName) {
      foundElms.push(childElm);
    }
    getElementsByName(childElm, elmName, foundElms);
  }
  return foundElms;
}
function setOwnerDocument(elm, ownerDocument) {
  for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
    elm.childNodes[i].ownerDocument = ownerDocument;
    if (elm.childNodes[i].nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
      setOwnerDocument(elm.childNodes[i], ownerDocument);
    }
  }
}

function hydrateFactory($stencilWindow, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve) {
  var globalThis = $stencilWindow;
  var self = $stencilWindow;
  var top = $stencilWindow;
  var parent = $stencilWindow;

  var addEventListener = $stencilWindow.addEventListener.bind($stencilWindow);
  var alert = $stencilWindow.alert.bind($stencilWindow);
  var blur = $stencilWindow.blur.bind($stencilWindow);
  var cancelAnimationFrame = $stencilWindow.cancelAnimationFrame.bind($stencilWindow);
  var cancelIdleCallback = $stencilWindow.cancelIdleCallback.bind($stencilWindow);
  var clearInterval = $stencilWindow.clearInterval.bind($stencilWindow);
  var clearTimeout = $stencilWindow.clearTimeout.bind($stencilWindow);
  var close = () => {};
  var confirm = $stencilWindow.confirm.bind($stencilWindow);
  var dispatchEvent = $stencilWindow.dispatchEvent.bind($stencilWindow);
  var focus = $stencilWindow.focus.bind($stencilWindow);
  var getComputedStyle = $stencilWindow.getComputedStyle.bind($stencilWindow);
  var matchMedia = $stencilWindow.matchMedia.bind($stencilWindow);
  var open = $stencilWindow.open.bind($stencilWindow);
  var prompt = $stencilWindow.prompt.bind($stencilWindow);
  var removeEventListener = $stencilWindow.removeEventListener.bind($stencilWindow);
  var requestAnimationFrame = $stencilWindow.requestAnimationFrame.bind($stencilWindow);
  var requestIdleCallback = $stencilWindow.requestIdleCallback.bind($stencilWindow);
  var setInterval = $stencilWindow.setInterval.bind($stencilWindow);
  var setTimeout = $stencilWindow.setTimeout.bind($stencilWindow);

  var CharacterData = $stencilWindow.CharacterData;
  var CSS = $stencilWindow.CSS;
  var CustomEvent = $stencilWindow.CustomEvent;
  var Document = $stencilWindow.Document;
  var DocumentFragment = $stencilWindow.DocumentFragment;
  var DocumentType = $stencilWindow.DocumentType;
  var DOMTokenList = $stencilWindow.DOMTokenList;
  var Element = $stencilWindow.Element;
  var Event = $stencilWindow.Event;
  var HTMLAnchorElement = $stencilWindow.HTMLAnchorElement;
  var HTMLBaseElement = $stencilWindow.HTMLBaseElement;
  var HTMLButtonElement = $stencilWindow.HTMLButtonElement;
  var HTMLCanvasElement = $stencilWindow.HTMLCanvasElement;
  var HTMLElement = $stencilWindow.HTMLElement;
  var HTMLFormElement = $stencilWindow.HTMLFormElement;
  var HTMLImageElement = $stencilWindow.HTMLImageElement;
  var HTMLInputElement = $stencilWindow.HTMLInputElement;
  var HTMLLinkElement = $stencilWindow.HTMLLinkElement;
  var HTMLMetaElement = $stencilWindow.HTMLMetaElement;
  var HTMLScriptElement = $stencilWindow.HTMLScriptElement;
  var HTMLStyleElement = $stencilWindow.HTMLStyleElement;
  var HTMLTemplateElement = $stencilWindow.HTMLTemplateElement;
  var HTMLTitleElement = $stencilWindow.HTMLTitleElement;
  var IntersectionObserver = $stencilWindow.IntersectionObserver;
  var KeyboardEvent = $stencilWindow.KeyboardEvent;
  var MouseEvent = $stencilWindow.MouseEvent;
  var Node = $stencilWindow.Node;
  var NodeList = $stencilWindow.NodeList;
  var URL = $stencilWindow.URL;

  var console = $stencilWindow.console;
  var customElements = $stencilWindow.customElements;
  var history = $stencilWindow.history;
  var localStorage = $stencilWindow.localStorage;
  var location = $stencilWindow.location;
  var navigator = $stencilWindow.navigator;
  var performance = $stencilWindow.performance;
  var sessionStorage = $stencilWindow.sessionStorage;

  var devicePixelRatio = $stencilWindow.devicePixelRatio;
  var innerHeight = $stencilWindow.innerHeight;
  var innerWidth = $stencilWindow.innerWidth;
  var origin = $stencilWindow.origin;
  var pageXOffset = $stencilWindow.pageXOffset;
  var pageYOffset = $stencilWindow.pageYOffset;
  var screen = $stencilWindow.screen;
  var screenLeft = $stencilWindow.screenLeft;
  var screenTop = $stencilWindow.screenTop;
  var screenX = $stencilWindow.screenX;
  var screenY = $stencilWindow.screenY;
  var scrollX = $stencilWindow.scrollX;
  var scrollY = $stencilWindow.scrollY;
  var exports = {};

  var fetch, FetchError, Headers, Request, Response;

  if (typeof $stencilWindow.fetch === 'function') {
  fetch = $stencilWindow.fetch;
  } else {
  fetch = $stencilWindow.fetch = function() { throw new Error('fetch() is not implemented'); };
  }

  if (typeof $stencilWindow.FetchError === 'function') {
  FetchError = $stencilWindow.FetchError;
  } else {
  FetchError = $stencilWindow.FetchError = class FetchError { constructor() { throw new Error('FetchError is not implemented'); } };
  }

  if (typeof $stencilWindow.Headers === 'function') {
  Headers = $stencilWindow.Headers;
  } else {
  Headers = $stencilWindow.Headers = class Headers { constructor() { throw new Error('Headers is not implemented'); } };
  }

  if (typeof $stencilWindow.Request === 'function') {
  Request = $stencilWindow.Request;
  } else {
  Request = $stencilWindow.Request = class Request { constructor() { throw new Error('Request is not implemented'); } };
  }

  if (typeof $stencilWindow.Response === 'function') {
  Response = $stencilWindow.Response;
  } else {
  Response = $stencilWindow.Response = class Response { constructor() { throw new Error('Response is not implemented'); } };
  }

  function hydrateAppClosure($stencilWindow) {
  const window = $stencilWindow;
  const document = $stencilWindow.document;
  /*hydrateAppClosure start*/


var require$$2 = require('fs');
var require$$4 = require('zlib');
var require$$5 = require('http');
var require$$6 = require('https');
var require$$7 = require('url');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5);
var require$$6__default = /*#__PURE__*/_interopDefaultLegacy(require$$6);
var require$$7__default = /*#__PURE__*/_interopDefaultLegacy(require$$7);

const NAMESPACE = 'swirl-components';
const BUILD = /* swirl-components */ { allRenderFn: true, appendChildSlotFix: false, asyncLoading: true, attachStyles: true, cloneNodeFix: false, cmpDidLoad: true, cmpDidRender: true, cmpDidUnload: false, cmpDidUpdate: false, cmpShouldUpdate: false, cmpWillLoad: true, cmpWillRender: false, cmpWillUpdate: false, connectedCallback: false, constructableCSS: false, cssAnnotations: true, cssVarShim: false, devTools: false, disconnectedCallback: true, dynamicImportShim: false, element: false, event: true, hasRenderFn: true, hostListener: true, hostListenerTarget: true, hostListenerTargetBody: false, hostListenerTargetDocument: false, hostListenerTargetParent: false, hostListenerTargetWindow: true, hotModuleReplacement: false, hydrateClientSide: true, hydrateServerSide: true, hydratedAttribute: false, hydratedClass: true, isDebug: false, isDev: false, isTesting: false, lazyLoad: true, lifecycle: true, lifecycleDOMEvents: false, member: true, method: true, mode: false, observeAttribute: true, profile: false, prop: true, propBoolean: true, propMutable: true, propNumber: true, propString: true, reflect: true, safari10: false, scoped: true, scriptDataOpts: false, shadowDelegatesFocus: false, shadowDom: true, shadowDomShim: true, slot: true, slotChildNodesFix: false, slotRelocation: true, state: true, style: true, svg: true, taskQueue: true, updatable: true, vdomAttribute: true, vdomClass: true, vdomFunctional: true, vdomKey: true, vdomListener: true, vdomPropOrAttr: true, vdomRef: true, vdomRender: true, vdomStyle: true, vdomText: true, vdomXlink: true, watchCallback: true };

function queryNonceMetaTagContent(e) {
 var t, o, n;
 return null !== (n = null === (o = null === (t = e.head) || void 0 === t ? void 0 : t.querySelector('meta[name="csp-nonce"]')) || void 0 === o ? void 0 : o.getAttribute("content")) && void 0 !== n ? n : void 0;
}

function componentOnReady() {
 return getHostRef(this).$onReadyPromise$;
}

function forceUpdate() {}

function hydrateApp(e, t, o, n, s) {
 function l() {
  if (global.clearTimeout(p), i.clear(), r.clear(), !h) {
   h = !0;
   try {
    t.clientHydrateAnnotations && insertVdomAnnotations(e.document, t.staticComponents), 
    e.dispatchEvent(new e.Event("DOMContentLoaded")), e.document.createElement = c, 
    e.document.createElementNS = $;
   } catch (e) {
    renderCatchError(t, o, e);
   }
  }
  n(e, t, o, s);
 }
 function a(e) {
  renderCatchError(t, o, e), l();
 }
 const r = new Set, i = new Set, d = new Set, c = e.document.createElement, $ = e.document.createElementNS, m = Promise.resolve();
 let p, h = !1;
 try {
  function u() {
   return g(this);
  }
  function f(e) {
   if (isValidComponent(e, t) && !getHostRef(e)) {
    const t = loadModule({
     $tagName$: e.nodeName.toLowerCase(),
     $flags$: null
    });
    null != t && null != t.cmpMeta && (i.add(e), e.connectedCallback = u, registerHost(e, t.cmpMeta), 
    function o(e, t) {
     if ("function" != typeof e.componentOnReady && (e.componentOnReady = componentOnReady), 
     "function" != typeof e.forceUpdate && (e.forceUpdate = forceUpdate), 1 & t.$flags$ && (e.shadowRoot = e), 
     null != t.$members$) {
      const o = getHostRef(e);
      Object.entries(t.$members$).forEach((([n, s]) => {
       const l = s[0];
       if (31 & l) {
        const a = s[1] || n, r = e.getAttribute(a);
        if (null != r) {
         const e = parsePropertyValue(r, l);
         o.$instanceValues$.set(n, e);
        }
        const i = e[n];
        void 0 !== i && (o.$instanceValues$.set(n, i), delete e[n]), Object.defineProperty(e, n, {
         get() {
          return getValue(this, n);
         },
         set(e) {
          setValue(this, n, e, t);
         },
         configurable: !0,
         enumerable: !0
        });
       } else 64 & l && Object.defineProperty(e, n, {
        value(...e) {
         const t = getHostRef(this);
         return t.$onInstancePromise$.then((() => t.$lazyInstance$[n](...e))).catch(consoleError);
        }
       });
      }));
     }
    }(e, t.cmpMeta));
   }
  }
  function g(n) {
   return i.delete(n), isValidComponent(n, t) && o.hydratedCount < t.maxHydrateCount && !r.has(n) && shouldHydrate(n) ? (r.add(n), 
   async function s(e, t, o, n, l) {
    o = o.toLowerCase();
    const a = loadModule({
     $tagName$: o,
     $flags$: null
    });
    if (null != a && null != a.cmpMeta) {
     l.add(n);
     try {
      connectedCallback(n), await n.componentOnReady(), t.hydratedCount++;
      const e = getHostRef(n), s = e.$modeName$ ? e.$modeName$ : "$";
      t.components.some((e => e.tag === o && e.mode === s)) || t.components.push({
       tag: o,
       mode: s,
       count: 0,
       depth: -1
      });
     } catch (t) {
      e.console.error(t);
     }
     l.delete(n);
    }
   }(e, o, n.nodeName, n, d)) : m;
  }
  e.document.createElement = function t(o) {
   const n = c.call(e.document, o);
   return f(n), n;
  }, e.document.createElementNS = function t(o, n) {
   const s = $.call(e.document, o, n);
   return f(s), s;
  }, p = global.setTimeout((function L() {
   a(`Hydrate exceeded timeout${function e(t) {
    return Array.from(t).map(waitingOnElementMsg);
   }(d)}`);
  }), t.timeout), plt.$resourcesUrl$ = new URL(t.resourcesUrl || "./", doc.baseURI).href, 
  function e(t) {
   if (null != t && 1 === t.nodeType) {
    f(t);
    const o = t.children;
    for (let t = 0, n = o.length; t < n; t++) e(o[t]);
   }
  }(e.document.body), function e() {
   const t = Array.from(i).filter((e => e.parentElement));
   return t.length > 0 ? Promise.all(t.map(g)).then(e) : m;
  }().then(l).catch(a);
 } catch (y) {
  a(y);
 }
}

function isValidComponent(e, t) {
 if (null != e && 1 === e.nodeType) {
  const o = e.nodeName;
  if ("string" == typeof o && o.includes("-")) return !t.excludeComponents.includes(o.toLowerCase());
 }
 return !1;
}

function shouldHydrate(e) {
 if (9 === e.nodeType) return !0;
 if (NO_HYDRATE_TAGS.has(e.nodeName)) return !1;
 if (e.hasAttribute("no-prerender")) return !1;
 const t = e.parentNode;
 return null == t || shouldHydrate(t);
}

function renderCatchError(e, t, o) {
 const n = {
  level: "error",
  type: "build",
  header: "Hydrate Error",
  messageText: "",
  relFilePath: null,
  absFilePath: null,
  lines: []
 };
 if (e.url) try {
  const t = new URL(e.url);
  "/" !== t.pathname && (n.header += ": " + t.pathname);
 } catch (e) {}
 null != o && (null != o.stack ? n.messageText = o.stack.toString() : null != o.message ? n.messageText = o.message.toString() : n.messageText = o.toString()), 
 t.diagnostics.push(n);
}

function printTag(e) {
 let t = `<${e.nodeName.toLowerCase()}`;
 if (Array.isArray(e.attributes)) for (let o = 0; o < e.attributes.length; o++) {
  const n = e.attributes[o];
  t += ` ${n.name}`, "" !== n.value && (t += `="${n.value}"`);
 }
 return t += ">", t;
}

function waitingOnElementMsg(e) {
 let t = "";
 if (e) {
  const o = [];
  t = " - waiting on:";
  let n = e;
  for (;n && 9 !== n.nodeType && "BODY" !== n.nodeName; ) o.unshift(printTag(n)), 
  n = n.parentElement;
  let s = "";
  for (const e of o) s += "  ", t += `\n${s}${e}`;
 }
 return t;
}

const createTime = (e, t = "") => {
 return () => {};
}, XLINK_NS = "http://www.w3.org/1999/xlink", EMPTY_OBJ = {}, isComplexType = e => "object" == (e = typeof e) || "function" === e, isPromise = e => !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then, h = (e, t, ...o) => {
 let n = null, s = null, l = null, a = !1, r = !1;
 const i = [], d = t => {
  for (let o = 0; o < t.length; o++) n = t[o], Array.isArray(n) ? d(n) : null != n && "boolean" != typeof n && ((a = "function" != typeof e && !isComplexType(n)) ? n = String(n) : BUILD.isDev  , 
  a && r ? i[i.length - 1].$text$ += n : i.push(a ? newVNode(null, n) : n), r = a);
 };
 if (d(o), t && (t.key && (s = t.key), 
 t.name && (l = t.name), BUILD.vdomClass)) {
  const e = t.className || t.class;
  e && (t.class = "object" != typeof e ? e : Object.keys(e).filter((t => e[t])).join(" "));
 }
 if ("function" == typeof e) return e(null === t ? {} : t, i, vdomFnUtils);
 const c = newVNode(e, null);
 return c.$attrs$ = t, i.length > 0 && (c.$children$ = i), (c.$key$ = s), 
 (c.$name$ = l), c;
}, newVNode = (e, t) => {
 const o = {
  $flags$: 0,
  $tag$: e,
  $text$: t,
  $elm$: null,
  $children$: null
 };
 return (o.$attrs$ = null), (o.$key$ = null), 
 (o.$name$ = null), o;
}, Host = {}, isHost = e => e && e.$tag$ === Host, vdomFnUtils = {
 forEach: (e, t) => e.map(convertToPublic).forEach(t),
 map: (e, t) => e.map(convertToPublic).map(t).map(convertToPrivate)
}, convertToPublic = e => ({
 vattrs: e.$attrs$,
 vchildren: e.$children$,
 vkey: e.$key$,
 vname: e.$name$,
 vtag: e.$tag$,
 vtext: e.$text$
}), convertToPrivate = e => {
 if ("function" == typeof e.vtag) {
  const t = {
   ...e.vattrs
  };
  return e.vkey && (t.key = e.vkey), e.vname && (t.name = e.vname), h(e.vtag, t, ...e.vchildren || []);
 }
 const t = newVNode(e.vtag, e.vtext);
 return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, 
 t;
}, clientHydrate = (e, t, o, n, s, l, a) => {
 let r, i, d, c;
 if (1 === l.nodeType) {
  for (r = l.getAttribute("c-id"), r && (i = r.split("."), i[0] !== a && "0" !== i[0] || (d = {
   $flags$: 0,
   $hostId$: i[0],
   $nodeId$: i[1],
   $depth$: i[2],
   $index$: i[3],
   $tag$: l.tagName.toLowerCase(),
   $elm$: l,
   $attrs$: null,
   $children$: null,
   $key$: null,
   $name$: null,
   $text$: null
  }, t.push(d), l.removeAttribute("c-id"), e.$children$ || (e.$children$ = []), e.$children$[d.$index$] = d, 
  e = d, n && "0" === d.$depth$ && (n[d.$index$] = d.$elm$))), c = l.childNodes.length - 1; c >= 0; c--) clientHydrate(e, t, o, n, s, l.childNodes[c], a);
  if (l.shadowRoot) for (c = l.shadowRoot.childNodes.length - 1; c >= 0; c--) clientHydrate(e, t, o, n, s, l.shadowRoot.childNodes[c], a);
 } else if (8 === l.nodeType) i = l.nodeValue.split("."), i[1] !== a && "0" !== i[1] || (r = i[0], 
 d = {
  $flags$: 0,
  $hostId$: i[1],
  $nodeId$: i[2],
  $depth$: i[3],
  $index$: i[4],
  $elm$: l,
  $attrs$: null,
  $children$: null,
  $key$: null,
  $name$: null,
  $tag$: null,
  $text$: null
 }, "t" === r ? (d.$elm$ = l.nextSibling, d.$elm$ && 3 === d.$elm$.nodeType && (d.$text$ = d.$elm$.textContent, 
 t.push(d), l.remove(), e.$children$ || (e.$children$ = []), e.$children$[d.$index$] = d, 
 n && "0" === d.$depth$ && (n[d.$index$] = d.$elm$))) : d.$hostId$ === a && ("s" === r ? (d.$tag$ = "slot", 
 i[5] ? l["s-sn"] = d.$name$ = i[5] : l["s-sn"] = "", l["s-sr"] = !0, n && (d.$elm$ = doc.createElement(d.$tag$), 
 d.$name$ && d.$elm$.setAttribute("name", d.$name$), l.parentNode.insertBefore(d.$elm$, l), 
 l.remove(), "0" === d.$depth$ && (n[d.$index$] = d.$elm$)), o.push(d), e.$children$ || (e.$children$ = []), 
 e.$children$[d.$index$] = d) : "r" === r && (n ? l.remove() : (s["s-cr"] = l, 
 l["s-cn"] = !0)))); else if (e && "style" === e.$tag$) {
  const t = newVNode(null, l.textContent);
  t.$elm$ = l, t.$index$ = "0", e.$children$ = [ t ];
 }
}, initializeDocumentHydrate = (e, t) => {
 if (1 === e.nodeType) {
  let o = 0;
  for (;o < e.childNodes.length; o++) initializeDocumentHydrate(e.childNodes[o], t);
  if (e.shadowRoot) for (o = 0; o < e.shadowRoot.childNodes.length; o++) initializeDocumentHydrate(e.shadowRoot.childNodes[o], t);
 } else if (8 === e.nodeType) {
  const o = e.nodeValue.split(".");
  "o" === o[0] && (t.set(o[1] + "." + o[2], e), e.nodeValue = "", e["s-en"] = o[3]);
 }
}, parsePropertyValue = (e, t) => null == e || isComplexType(e) ? e : 4 & t ? "false" !== e && ("" === e || !!e) : 2 & t ? parseFloat(e) : 1 & t ? String(e) : e, getElement = e => getHostRef(e).$hostElement$ , createEvent = (e, t, o) => {
 const n = getElement(e);
 return {
  emit: e => (emitEvent(n, t, {
   bubbles: !!(4 & o),
   composed: !!(2 & o),
   cancelable: !!(1 & o),
   detail: e
  }))
 };
}, emitEvent = (e, t, o) => {
 const n = plt.ce(t, o);
 return e.dispatchEvent(n), n;
}, rootAppliedStyles = new WeakMap, registerStyle = (e, t, o) => {
 let n = styles.get(e);
 n = t, styles.set(e, n);
}, addStyle = (e, t, o, n) => {
 var s;
 let l = getScopeId(t);
 const a = styles.get(l);
 if (e = 11 === e.nodeType ? e : doc, a) if ("string" == typeof a) {
  e = e.head || e;
  let o, r = rootAppliedStyles.get(e);
  if (r || rootAppliedStyles.set(e, r = new Set), !r.has(l)) {
   if (e.host && (o = e.querySelector(`[sty-id="${l}"]`))) o.innerHTML = a; else {
    o = doc.createElement("style"), o.innerHTML = a;
    const i = null !== (s = plt.$nonce$) && void 0 !== s ? s : queryNonceMetaTagContent(doc);
    null != i && o.setAttribute("nonce", i), o.setAttribute("sty-id", l), 
    e.insertBefore(o, e.querySelector("link"));
   }
   r && r.add(l);
  }
 }
 return l;
}, attachStyles = e => {
 const t = e.$cmpMeta$, o = e.$hostElement$, n = t.$flags$, s = createTime("attachStyles", t.$tagName$), l = addStyle(o.getRootNode(), t);
 10 & n && (o["s-sc"] = l, 
 o.classList.add(l + "-h"), 2 & n && o.classList.add(l + "-s")), 
 s();
}, getScopeId = (e, t) => "sc-" + (e.$tagName$), setAccessor = (e, t, o, n, s, l) => {
 if (o !== n) {
  let a = isMemberInElement(e, t), r = t.toLowerCase();
  if ("class" === t) {
   const t = e.classList, s = parseClassList(o), l = parseClassList(n);
   t.remove(...s.filter((e => e && !l.includes(e)))), t.add(...l.filter((e => e && !s.includes(e))));
  } else if ("style" === t) {
   for (const t in o) n && null != n[t] || (e.style[t] = "");
   for (const t in n) o && n[t] === o[t] || (e.style[t] = n[t]);
  } else if ("key" === t) ; else if ("ref" === t) n && n(e); else if ((a ) || "o" !== t[0] || "n" !== t[1]) {
   {
    const i = isComplexType(n);
    if ((a || i && null !== n) && !s) try {
     if (e.tagName.includes("-")) e[t] = n; else {
      const s = null == n ? "" : n;
      "list" === t ? a = !1 : null != o && e[t] == s || (e[t] = s);
     }
    } catch (e) {}
    let d = !1;
    r !== (r = r.replace(/^xlink\:?/, "")) && (t = r, d = !0), null == n || !1 === n ? !1 === n && "" !== e.getAttribute(t) || (d ? e.removeAttributeNS(XLINK_NS, t) : e.removeAttribute(t)) : (!a || 4 & l || s) && !i && (n = !0 === n ? "" : n, 
    d ? e.setAttributeNS(XLINK_NS, t, n) : e.setAttribute(t, n));
   }
  } else t = "-" === t[2] ? t.slice(3) : isMemberInElement(win, r) ? r.slice(2) : r[2] + t.slice(3), 
  o && plt.rel(e, t, o, !1), n && plt.ael(e, t, n, !1);
 }
}, parseClassListRegex = /\s/, parseClassList = e => e ? e.split(parseClassListRegex) : [], updateElement = (e, t, o, n) => {
 const s = 11 === t.$elm$.nodeType && t.$elm$.host ? t.$elm$.host : t.$elm$, l = e && e.$attrs$ || EMPTY_OBJ, a = t.$attrs$ || EMPTY_OBJ;
 for (n in l) n in a || setAccessor(s, n, l[n], void 0, o, t.$flags$);
 for (n in a) setAccessor(s, n, l[n], a[n], o, t.$flags$);
};

let scopeId, contentRef, hostTagName, useNativeShadowDom = !1, checkSlotFallbackVisibility = !1, checkSlotRelocate = !1, isSvgMode = !1;

const createElm = (e, t, o, n) => {
 const s = t.$children$[o];
 let l, a, r, i = 0;
 if (!useNativeShadowDom && (checkSlotRelocate = !0, "slot" === s.$tag$ && (scopeId && n.classList.add(scopeId + "-s"), 
 s.$flags$ |= s.$children$ ? 2 : 1)), null !== s.$text$) l = s.$elm$ = doc.createTextNode(s.$text$); else if (1 & s.$flags$) l = s.$elm$ = slotReferenceDebugNode(s) ; else {
  if (!isSvgMode && (isSvgMode = "svg" === s.$tag$), l = s.$elm$ = doc.createElementNS(isSvgMode ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", 2 & s.$flags$ ? "slot-fb" : s.$tag$) , 
  isSvgMode && "foreignObject" === s.$tag$ && (isSvgMode = !1), updateElement(null, s, isSvgMode), 
  null != scopeId && l["s-si"] !== scopeId && l.classList.add(l["s-si"] = scopeId), 
  s.$children$) for (i = 0; i < s.$children$.length; ++i) a = createElm(e, s, i, l), 
  a && l.appendChild(a);
  ("svg" === s.$tag$ ? isSvgMode = !1 : "foreignObject" === l.tagName && (isSvgMode = !0));
 }
 return (l["s-hn"] = hostTagName, 3 & s.$flags$ && (l["s-sr"] = !0, 
 l["s-cr"] = contentRef, l["s-sn"] = s.$name$ || "", r = e && e.$children$ && e.$children$[o], 
 r && r.$tag$ === s.$tag$ && e.$elm$ && putBackInOriginalLocation(e.$elm$, !1))), 
 l;
}, putBackInOriginalLocation = (e, t) => {
 plt.$flags$ |= 1;
 const o = e.childNodes;
 for (let e = o.length - 1; e >= 0; e--) {
  const n = o[e];
  n["s-hn"] !== hostTagName && n["s-ol"] && (parentReferenceNode(n).insertBefore(n, referenceNode(n)), 
  n["s-ol"].remove(), n["s-ol"] = void 0, checkSlotRelocate = !0), t && putBackInOriginalLocation(n, t);
 }
 plt.$flags$ &= -2;
}, addVnodes = (e, t, o, n, s, l) => {
 let a, r = e["s-cr"] && e["s-cr"].parentNode || e;
 for (r.shadowRoot && r.tagName === hostTagName && (r = r.shadowRoot); s <= l; ++s) n[s] && (a = createElm(null, o, s, e), 
 a && (n[s].$elm$ = a, r.insertBefore(a, referenceNode(t) )));
}, removeVnodes = (e, t, o, n, s) => {
 for (;t <= o; ++t) (n = e[t]) && (s = n.$elm$, callNodeRefs(n), (checkSlotFallbackVisibility = !0, 
 s["s-ol"] ? s["s-ol"].remove() : putBackInOriginalLocation(s, !0)), s.remove());
}, isSameVnode = (e, t) => e.$tag$ === t.$tag$ && ("slot" === e.$tag$ ? e.$name$ === t.$name$ : e.$key$ === t.$key$), referenceNode = e => e && e["s-ol"] || e, parentReferenceNode = e => (e["s-ol"] ? e["s-ol"] : e).parentNode, patch = (e, t) => {
 const o = t.$elm$ = e.$elm$, n = e.$children$, s = t.$children$, l = t.$tag$, a = t.$text$;
 let r;
 null !== a ? (r = o["s-cr"]) ? r.parentNode.textContent = a : e.$text$ !== a && (o.data = a) : ((isSvgMode = "svg" === l || "foreignObject" !== l && isSvgMode), 
 ("slot" === l || updateElement(e, t, isSvgMode)), 
 null !== n && null !== s ? ((e, t, o, n) => {
  let s, l, a = 0, r = 0, i = 0, d = 0, c = t.length - 1, $ = t[0], m = t[c], p = n.length - 1, h = n[0], u = n[p];
  for (;a <= c && r <= p; ) if (null == $) $ = t[++a]; else if (null == m) m = t[--c]; else if (null == h) h = n[++r]; else if (null == u) u = n[--p]; else if (isSameVnode($, h)) patch($, h), 
  $ = t[++a], h = n[++r]; else if (isSameVnode(m, u)) patch(m, u), m = t[--c], u = n[--p]; else if (isSameVnode($, u)) "slot" !== $.$tag$ && "slot" !== u.$tag$ || putBackInOriginalLocation($.$elm$.parentNode, !1), 
  patch($, u), e.insertBefore($.$elm$, m.$elm$.nextSibling), $ = t[++a], u = n[--p]; else if (isSameVnode(m, h)) "slot" !== $.$tag$ && "slot" !== u.$tag$ || putBackInOriginalLocation(m.$elm$.parentNode, !1), 
  patch(m, h), e.insertBefore(m.$elm$, $.$elm$), m = t[--c], h = n[++r]; else {
   if (i = -1, BUILD.vdomKey) for (d = a; d <= c; ++d) if (t[d] && null !== t[d].$key$ && t[d].$key$ === h.$key$) {
    i = d;
    break;
   }
   i >= 0 ? (l = t[i], l.$tag$ !== h.$tag$ ? s = createElm(t && t[r], o, i, e) : (patch(l, h), 
   t[i] = void 0, s = l.$elm$), h = n[++r]) : (s = createElm(t && t[r], o, r, e), h = n[++r]), 
   s && (parentReferenceNode($.$elm$).insertBefore(s, referenceNode($.$elm$)) );
  }
  a > c ? addVnodes(e, null == n[p + 1] ? null : n[p + 1].$elm$, o, n, r, p) : r > p && removeVnodes(t, a, c);
 })(o, n, t, s) : null !== s ? (null !== e.$text$ && (o.textContent = ""), 
 addVnodes(o, null, t, s, 0, s.length - 1)) : null !== n && removeVnodes(n, 0, n.length - 1), 
 isSvgMode && "svg" === l && (isSvgMode = !1));
}, updateFallbackSlotVisibility = e => {
 const t = e.childNodes;
 let o, n, s, l, a, r;
 for (n = 0, s = t.length; n < s; n++) if (o = t[n], 1 === o.nodeType) {
  if (o["s-sr"]) for (a = o["s-sn"], o.hidden = !1, l = 0; l < s; l++) if (r = t[l].nodeType, 
  t[l]["s-hn"] !== o["s-hn"] || "" !== a) {
   if (1 === r && a === t[l].getAttribute("slot")) {
    o.hidden = !0;
    break;
   }
  } else if (1 === r || 3 === r && "" !== t[l].textContent.trim()) {
   o.hidden = !0;
   break;
  }
  updateFallbackSlotVisibility(o);
 }
}, relocateNodes = [], relocateSlotContent = e => {
 let t, o, n, s, l, a, r = 0;
 const i = e.childNodes, d = i.length;
 for (;r < d; r++) {
  if (t = i[r], t["s-sr"] && (o = t["s-cr"]) && o.parentNode) for (n = o.parentNode.childNodes, 
  s = t["s-sn"], a = n.length - 1; a >= 0; a--) o = n[a], o["s-cn"] || o["s-nr"] || o["s-hn"] === t["s-hn"] || (isNodeLocatedInSlot(o, s) ? (l = relocateNodes.find((e => e.$nodeToRelocate$ === o)), 
  checkSlotFallbackVisibility = !0, o["s-sn"] = o["s-sn"] || s, l ? l.$slotRefNode$ = t : relocateNodes.push({
   $slotRefNode$: t,
   $nodeToRelocate$: o
  }), o["s-sr"] && relocateNodes.map((e => {
   isNodeLocatedInSlot(e.$nodeToRelocate$, o["s-sn"]) && (l = relocateNodes.find((e => e.$nodeToRelocate$ === o)), 
   l && !e.$slotRefNode$ && (e.$slotRefNode$ = l.$slotRefNode$));
  }))) : relocateNodes.some((e => e.$nodeToRelocate$ === o)) || relocateNodes.push({
   $nodeToRelocate$: o
  }));
  1 === t.nodeType && relocateSlotContent(t);
 }
}, isNodeLocatedInSlot = (e, t) => 1 === e.nodeType ? null === e.getAttribute("slot") && "" === t || e.getAttribute("slot") === t : e["s-sn"] === t || "" === t, callNodeRefs = e => {
 (e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(callNodeRefs));
}, renderVdom = (e, t) => {
 const o = e.$hostElement$, n = e.$cmpMeta$, s = e.$vnode$ || newVNode(null, null), l = isHost(t) ? t : h(null, null, t);
 if (hostTagName = o.tagName, BUILD.isDev  ) ;
 if (n.$attrsToReflect$ && (l.$attrs$ = l.$attrs$ || {}, n.$attrsToReflect$.map((([e, t]) => l.$attrs$[t] = o[e]))), 
 l.$tag$ = null, l.$flags$ |= 4, e.$vnode$ = l, l.$elm$ = s.$elm$ = o.shadowRoot || o, 
 (scopeId = o["s-sc"]), (contentRef = o["s-cr"], 
 useNativeShadowDom = supportsShadow, checkSlotFallbackVisibility = !1), patch(s, l), 
 BUILD.slotRelocation) {
  if (plt.$flags$ |= 1, checkSlotRelocate) {
   let e, t, o, n, s, a;
   relocateSlotContent(l.$elm$);
   let r = 0;
   for (;r < relocateNodes.length; r++) e = relocateNodes[r], t = e.$nodeToRelocate$, 
   t["s-ol"] || (o = originalLocationDebugNode(t) , 
   o["s-nr"] = t, t.parentNode.insertBefore(t["s-ol"] = o, t));
   for (r = 0; r < relocateNodes.length; r++) if (e = relocateNodes[r], t = e.$nodeToRelocate$, 
   e.$slotRefNode$) {
    for (n = e.$slotRefNode$.parentNode, s = e.$slotRefNode$.nextSibling, o = t["s-ol"]; o = o.previousSibling; ) if (a = o["s-nr"], 
    a && a["s-sn"] === t["s-sn"] && n === a.parentNode && (a = a.nextSibling, !a || !a["s-nr"])) {
     s = a;
     break;
    }
    (!s && n !== t.parentNode || t.nextSibling !== s) && t !== s && (!t["s-hn"] && t["s-ol"] && (t["s-hn"] = t["s-ol"].parentNode.nodeName), 
    n.insertBefore(t, s));
   } else 1 === t.nodeType && (t.hidden = !0);
  }
  checkSlotFallbackVisibility && updateFallbackSlotVisibility(l.$elm$), plt.$flags$ &= -2, 
  relocateNodes.length = 0;
 }
}, slotReferenceDebugNode = e => doc.createComment(`<slot${e.$name$ ? ' name="' + e.$name$ + '"' : ""}> (host=${hostTagName.toLowerCase()})`), originalLocationDebugNode = e => doc.createComment("org-location for " + (e.localName ? `<${e.localName}> (host=${e["s-hn"]})` : `[${e.textContent}]`)), attachToAncestor = (e, t) => {
 t && !e.$onRenderResolve$ && t["s-p"] && t["s-p"].push(new Promise((t => e.$onRenderResolve$ = t)));
}, scheduleUpdate = (e, t) => {
 if ((e.$flags$ |= 16), 4 & e.$flags$) return void (e.$flags$ |= 512);
 attachToAncestor(e, e.$ancestorComponent$);
 const o = () => dispatchHooks(e, t);
 return writeTask(o) ;
}, dispatchHooks = (e, t) => {
 const n = createTime("scheduleUpdate", e.$cmpMeta$.$tagName$), s = e.$lazyInstance$ ;
 let l;
 return t ? ((e.$flags$ |= 256, e.$queuedListeners$ && (e.$queuedListeners$.map((([e, t]) => safeCall(s, e, t))), 
 e.$queuedListeners$ = null)), (l = safeCall(s, "componentWillLoad"))) : (BUILD.cmpWillUpdate ), n(), then(l, (() => updateComponent(e, s, t)));
}, updateComponent = async (e, t, o) => {
 const n = e.$hostElement$, s = createTime("update", e.$cmpMeta$.$tagName$), l = n["s-rc"];
 o && attachStyles(e);
 const a = createTime("render", e.$cmpMeta$.$tagName$);
 if (await callRender(e, t) , 
 BUILD.hydrateServerSide) try {
  serverSideConnected(n), o && (1 & e.$cmpMeta$.$flags$ ? n["s-en"] = "" : 2 & e.$cmpMeta$.$flags$ && (n["s-en"] = "c"));
 } catch (e) {
  consoleError(e, n);
 }
 if (l && (l.map((e => e())), n["s-rc"] = void 0), a(), s(), 
 BUILD.asyncLoading) {
  const t = n["s-p"], o = () => postUpdateComponent(e);
  0 === t.length ? o() : (Promise.all(t).then(o), e.$flags$ |= 4, t.length = 0);
 }
};

const callRender = (e, t, o) => {
 try {
  if (t = t.render(), (e.$flags$ &= -17), 
  (e.$flags$ |= 2), BUILD.hasRenderFn ) {
   return Promise.resolve(t).then((t => renderVdom(e, t)));
  }
 } catch (t) {
  consoleError(t, e.$hostElement$);
 }
 return null;
}, postUpdateComponent = e => {
 const t = e.$cmpMeta$.$tagName$, o = e.$hostElement$, n = createTime("postUpdate", t), s = e.$lazyInstance$ , l = e.$ancestorComponent$;
 (safeCall(s, "componentDidRender"), 
 BUILD.isDev ), 64 & e.$flags$ ? (n()) : (e.$flags$ |= 64, addHydratedFlag(o), 
 (safeCall(s, "componentDidLoad"), 
 BUILD.isDev ), n(), (e.$onReadyResolve$(o), l || appDidLoad())), e.$onInstanceResolve$(o), (e.$onRenderResolve$ && (e.$onRenderResolve$(), 
 e.$onRenderResolve$ = void 0), 512 & e.$flags$ && nextTick((() => scheduleUpdate(e, !1))), 
 e.$flags$ &= -517);
}, appDidLoad = e => {
 addHydratedFlag(doc.documentElement), nextTick((() => emitEvent(win, "appload", {
  detail: {
   namespace: NAMESPACE
  }
 }))), BUILD.profile  ;
}, safeCall = (e, t, o) => {
 if (e && e[t]) try {
  return e[t](o);
 } catch (e) {
  consoleError(e);
 }
}, then = (e, t) => e && e.then ? e.then(t) : t(), addHydratedFlag = e => e.classList.add("hydrated") , serverSideConnected = e => {
 const t = e.children;
 if (null != t) for (let e = 0, o = t.length; e < o; e++) {
  const o = t[e];
  "function" == typeof o.connectedCallback && o.connectedCallback(), serverSideConnected(o);
 }
}, getValue = (e, t) => getHostRef(e).$instanceValues$.get(t), setValue = (e, t, o, n) => {
 const s = getHostRef(e), l = s.$hostElement$ , a = s.$instanceValues$.get(t), r = s.$flags$, i = s.$lazyInstance$ ;
 o = parsePropertyValue(o, n.$members$[t][0]);
 const d = Number.isNaN(a) && Number.isNaN(o), c = o !== a && !d;
 if ((!(8 & r) || void 0 === a) && c && (s.$instanceValues$.set(t, o), 
 i)) {
  if (n.$watchers$ && 128 & r) {
   const e = n.$watchers$[t];
   e && e.map((e => {
    try {
     i[e](o, a, t);
    } catch (e) {
     consoleError(e, l);
    }
   }));
  }
  if (2 == (18 & r)) {
   scheduleUpdate(s, !1);
  }
 }
}, proxyComponent = (e, t, o) => {
 if (t.$members$) {
  e.watchers && (t.$watchers$ = e.watchers);
  const n = Object.entries(t.$members$), s = e.prototype;
  if (n.map((([e, [n]]) => {
   (31 & n || (2 & o) && 32 & n) ? Object.defineProperty(s, e, {
    get() {
     return getValue(this, e);
    },
    set(s) {
     setValue(this, e, s, t);
    },
    configurable: !0,
    enumerable: !0
   }) : 1 & o && 64 & n && Object.defineProperty(s, e, {
    value(...t) {
     const o = getHostRef(this);
     return o.$onInstancePromise$.then((() => o.$lazyInstance$[e](...t)));
    }
   });
  })), (1 & o)) {
   const o = new Map;
   s.attributeChangedCallback = function(e, t, n) {
    plt.jmp((() => {
     const t = o.get(e);
     if (this.hasOwnProperty(t)) n = this[t], delete this[t]; else if (s.hasOwnProperty(t) && "number" == typeof this[t] && this[t] == n) return;
     this[t] = (null !== n || "boolean" != typeof this[t]) && n;
    }));
   }, e.observedAttributes = n.filter((([e, t]) => 15 & t[0])).map((([e, n]) => {
    const s = n[1] || e;
    return o.set(s, e), 512 & n[0] && t.$attrsToReflect$.push([ e, s ]), 
    s;
   }));
  }
 }
 return e;
}, initializeComponent = async (e, t, o, n, s) => {
 if (0 == (32 & t.$flags$)) {
  {
   if (t.$flags$ |= 32, (s = loadModule(o)).then) {
    const e = (() => {});
    s = await s, e();
   }
   !s.isProxied && ((o.$watchers$ = s.watchers), 
   proxyComponent(s, o, 2), s.isProxied = !0);
   const e = createTime("createInstance", o.$tagName$);
   (t.$flags$ |= 8);
   try {
    new s(t);
   } catch (e) {
    consoleError(e);
   }
   (t.$flags$ &= -9), (t.$flags$ |= 128), e(), 
   fireConnectedCallback();
  }
  if (s.style) {
   let n = s.style;
   const l = getScopeId(o);
   if (!styles.has(l)) {
    const e = createTime("registerStyles", o.$tagName$);
    registerStyle(l, n), e();
   }
  }
 }
 const r = t.$ancestorComponent$, i = () => scheduleUpdate(t, !0);
 r && r["s-rc"] ? r["s-rc"].push(i) : i();
}, fireConnectedCallback = e => {
}, connectedCallback = e => {
 if (0 == (1 & plt.$flags$)) {
  const t = getHostRef(e), o = t.$cmpMeta$, n = createTime("connectedCallback", o.$tagName$);
  if (1 & t.$flags$) addHostEventListeners(e, t, o.$listeners$), fireConnectedCallback(); else {
   let n;
   if (t.$flags$ |= 1, (n = e.getAttribute("s-id"), n)) {
    ((e, t, o, n) => {
     const s = createTime("hydrateClient", t), l = e.shadowRoot, a = [], r = l ? [] : null, i = n.$vnode$ = newVNode(t, null);
     plt.$orgLocNodes$ || initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = new Map), 
     e["s-id"] = o, e.removeAttribute("s-id"), clientHydrate(i, a, [], r, e, e, o), a.map((e => {
      const o = e.$hostId$ + "." + e.$nodeId$, n = plt.$orgLocNodes$.get(o), s = e.$elm$;
      n && supportsShadow && "" === n["s-en"] && n.parentNode.insertBefore(s, n.nextSibling), 
      l || (s["s-hn"] = t, n && (s["s-ol"] = n, s["s-ol"]["s-nr"] = s)), plt.$orgLocNodes$.delete(o);
     })), l && r.map((e => {
      e && l.appendChild(e);
     })), s();
    })(e, o.$tagName$, n, t);
   }
   if (!n && (BUILD.hydrateServerSide ) && setContentReference(e), 
   BUILD.asyncLoading) {
    let o = e;
    for (;o = o.parentNode || o.host; ) if (1 === o.nodeType && o.hasAttribute("s-id") && o["s-p"] || o["s-p"]) {
     attachToAncestor(t, t.$ancestorComponent$ = o);
     break;
    }
   }
   initializeComponent(e, t, o);
  }
  n();
 }
}, setContentReference = e => {
 const t = e["s-cr"] = doc.createComment("");
 t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, Fragment = (e, t) => t, addHostEventListeners = (e, t, o, n) => {
 o && (o.map((([o, n, s]) => {
  const l = getHostListenerTarget(e, o) , a = hostListenerProxy(t, s), r = hostListenerOpts(o);
  plt.ael(l, n, a, r), (t.$rmListeners$ = t.$rmListeners$ || []).push((() => plt.rel(l, n, a, r)));
 })));
}, hostListenerProxy = (e, t) => o => {
 try {
  256 & e.$flags$ ? e.$lazyInstance$[t](o) : (e.$queuedListeners$ = e.$queuedListeners$ || []).push([ t, o ]) ;
 } catch (e) {
  consoleError(e);
 }
}, getHostListenerTarget = (e, t) => 8 & t ? win : e, hostListenerOpts = e => 0 != (2 & e), insertVdomAnnotations = (e, t) => {
 if (null != e) {
  const o = {
   hostIds: 0,
   rootLevelIds: 0,
   staticComponents: new Set(t)
  }, n = [];
  parseVNodeAnnotations(e, e.body, o, n), n.forEach((t => {
   if (null != t) {
    const n = t["s-nr"];
    let s = n["s-host-id"], l = n["s-node-id"], a = `${s}.${l}`;
    if (null == s) if (s = 0, o.rootLevelIds++, l = o.rootLevelIds, a = `${s}.${l}`, 
    1 === n.nodeType) n.setAttribute("c-id", a); else if (3 === n.nodeType) {
     if (0 === s && "" === n.nodeValue.trim()) return void t.remove();
     const o = e.createComment(a);
     o.nodeValue = `t.${a}`, n.parentNode.insertBefore(o, n);
    }
    let r = `o.${a}`;
    const i = t.parentElement;
    i && ("" === i["s-en"] ? r += "." : "c" === i["s-en"] && (r += ".c")), t.nodeValue = r;
   }
  }));
 }
}, parseVNodeAnnotations = (e, t, o, n) => {
 null != t && (null != t["s-nr"] && n.push(t), 1 === t.nodeType && t.childNodes.forEach((t => {
  const s = getHostRef(t);
  if (null != s && !o.staticComponents.has(t.nodeName.toLowerCase())) {
   const n = {
    nodeIds: 0
   };
   insertVNodeAnnotations(e, t, s.$vnode$, o, n);
  }
  parseVNodeAnnotations(e, t, o, n);
 })));
}, insertVNodeAnnotations = (e, t, o, n, s) => {
 if (null != o) {
  const l = ++n.hostIds;
  if (t.setAttribute("s-id", l), null != t["s-cr"] && (t["s-cr"].nodeValue = `r.${l}`), 
  null != o.$children$) {
   const t = 0;
   o.$children$.forEach(((o, n) => {
    insertChildVNodeAnnotations(e, o, s, l, t, n);
   }));
  }
  if (t && o && o.$elm$ && !t.hasAttribute("c-id")) {
   const e = t.parentElement;
   if (e && e.childNodes) {
    const n = Array.from(e.childNodes), s = n.find((e => 8 === e.nodeType && e["s-sr"]));
    if (s) {
     const e = n.indexOf(t) - 1;
     o.$elm$.setAttribute("c-id", `${s["s-host-id"]}.${s["s-node-id"]}.0.${e}`);
    }
   }
  }
 }
}, insertChildVNodeAnnotations = (e, t, o, n, s, l) => {
 const a = t.$elm$;
 if (null == a) return;
 const r = o.nodeIds++, i = `${n}.${r}.${s}.${l}`;
 if (a["s-host-id"] = n, a["s-node-id"] = r, 1 === a.nodeType) a.setAttribute("c-id", i); else if (3 === a.nodeType) {
  const t = a.parentNode, o = t.nodeName;
  if ("STYLE" !== o && "SCRIPT" !== o) {
   const o = `t.${i}`, n = e.createComment(o);
   t.insertBefore(n, a);
  }
 } else if (8 === a.nodeType && a["s-sr"]) {
  const e = `s.${i}.${a["s-sn"] || ""}`;
  a.nodeValue = e;
 }
 if (null != t.$children$) {
  const l = s + 1;
  t.$children$.forEach(((t, s) => {
   insertChildVNodeAnnotations(e, t, o, n, l, s);
  }));
 }
}, hAsync = (e, t, ...o) => {
 if (Array.isArray(o) && o.length > 0) {
  const n = o.flat(1 / 0);
  return n.some(isPromise) ? Promise.all(n).then((o => h(e, t, ...o))).catch((o => h(e, t))) : h(e, t, ...o);
 }
 return h(e, t);
}, NO_HYDRATE_TAGS = new Set([ "CODE", "HEAD", "IFRAME", "INPUT", "OBJECT", "OUTPUT", "NOSCRIPT", "PRE", "SCRIPT", "SELECT", "STYLE", "TEMPLATE", "TEXTAREA" ]);

const cmpModules = new Map, getModule = e => {
 if ("string" == typeof e) {
  e = e.toLowerCase();
  const t = cmpModules.get(e);
  if (null != t) return t[e];
 }
 return null;
}, loadModule = (e, t, o) => getModule(e.$tagName$), isMemberInElement = (e, t) => {
 if (null != e) {
  if (t in e) return !0;
  const o = getModule(e.nodeName);
  if (null != o) {
   const e = o;
   if (null != e && null != e.cmpMeta && null != e.cmpMeta.$members$) return t in e.cmpMeta.$members$;
  }
 }
 return !1;
}, registerComponents = e => {
 for (const t of e) {
  const e = t.cmpMeta.$tagName$;
  cmpModules.set(e, {
   [e]: t
  });
 }
}, win = window, doc = win.document, writeTask = e => {
 process.nextTick((() => {
  try {
   e();
  } catch (e) {
   consoleError(e);
  }
 }));
}, resolved = Promise.resolve(), nextTick = e => resolved.then(e), defaultConsoleError = e => {
 null != e && console.error(e.stack || e.message || e);
}, consoleError = (e, t) => (defaultConsoleError)(e, t), plt = {
 $flags$: 0,
 $resourcesUrl$: "",
 jmp: e => e(),
 raf: e => requestAnimationFrame(e),
 ael: (e, t, o, n) => e.addEventListener(t, o, n),
 rel: (e, t, o, n) => e.removeEventListener(t, o, n),
 ce: (e, t) => new win.CustomEvent(e, t)
}, supportsShadow = !1, hostRefs = new WeakMap, getHostRef = e => hostRefs.get(e), registerInstance = (e, t) => hostRefs.set(t.$lazyInstance$ = e, t), registerHost = (e, t) => {
 const o = {
  $flags$: 0,
  $cmpMeta$: t,
  $hostElement$: e,
  $instanceValues$: new Map,
  $renderCount$: 0
 };
 return o.$onInstancePromise$ = new Promise((e => o.$onInstanceResolve$ = e)), o.$onReadyPromise$ = new Promise((e => o.$onReadyResolve$ = e)), 
 e["s-p"] = [], e["s-rc"] = [], addHostEventListeners(e, o, t.$listeners$), hostRefs.set(e, o);
}, styles = new Map;

const FileManagerMockData = {
  directories: [
    {
      name: "Development",
      description: "Updated 2 days ago.",
      children: [
        {
          description: "1.02 MB, updated 2 days ago.",
          name: "sample.pdf",
          type: "application/pdf",
          url: "/sample.pdf",
        },
        {
          description: "124 KB, updated a month ago.",
          name: "sample.jpg",
          type: "image/jpeg",
          url: "/sample.jpg",
        },
      ],
    },
    {
      name: "People",
      description: "Updated just now.",
      children: [],
    },
  ],
};
class FileManager {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.selectItem = (item) => {
      if ("type" in item) {
        this.selectedFile = item;
        this.layout.changeMobileView("body");
      }
      else {
        this.selectedDirectory = item;
      }
    };
    this.resetSelectedDirectory = () => {
      this.selectedDirectory = undefined;
    };
    this.toggleSidebar = () => {
      var _a;
      (_a = this.layout) === null || _a === void 0 ? void 0 : _a.toggleSidebar();
    };
    this.selectedDirectory = undefined;
    this.selectedFile = undefined;
  }
  renderNavigation() {
    const items = Boolean(this.selectedDirectory)
      ? this.selectedDirectory.children
      : FileManagerMockData.directories;
    return items.length > 0 ? (items.map((item) => (hAsync("swirl-resource-list-item", { description: item.description, key: item.name, label: item.name,
      // eslint-disable-next-line react/jsx-no-bind
      onClick: () => this.selectItem(item) }, "type" in item ? (hAsync("swirl-icon-file", { slot: "media" })) : (hAsync("swirl-icon-folder-shared", { slot: "media" })))))) : (hAsync("swirl-box", { padding: "16" }, hAsync("swirl-text", { color: "subdued", weight: "medium" }, "This directory is empty.")));
  }
  render() {
    var _a, _b;
    return (hAsync(Host, null, hAsync("swirl-app-layout", { appName: "Documents", backToNavigationViewButtonLabel: "Back to documents list", ctaIcon: "<swirl-icon-add></swirl-icon-add>", ctaLabel: "Upload file", navigationLabel: "Documents", onNavigationBackButtonClick: this.resetSelectedDirectory, ref: (el) => (this.layout = el), sidebarCloseButtonLabel: "Close file info", sidebarHeading: "File info", showNavigationBackButton: Boolean(this.selectedDirectory), transitionStyle: "dialog" }, hAsync("swirl-resource-list", { label: "Documents", slot: "navigation" }, this.renderNavigation()), hAsync("swirl-button", { id: "sort-button", label: "Sort items", slot: "navigation-controls" }), hAsync("swirl-stack", { orientation: "horizontal", slot: "app-bar" }, hAsync("swirl-stack", null, hAsync("swirl-heading", { as: "h2", level: 4, text: (_a = this.selectedFile) === null || _a === void 0 ? void 0 : _a.name }), hAsync("swirl-text", { color: "subdued", truncate: true }, (_b = this.selectedFile) === null || _b === void 0 ? void 0 : _b.description))), Boolean(this.selectedFile) ? (hAsync("swirl-file-viewer", { file: this.selectedFile.url, slot: "content", type: this.selectedFile.type })) : (hAsync("swirl-box", { cover: true, centerBlock: true, centerInline: true, padding: "16", slot: "content" }, hAsync("swirl-empty-state", { heading: "Nothing to see here.", illustration: "/images/empty-state-1.svg" }, "Please select a file from the list."))), hAsync("div", { slot: "app-bar-controls" }, this.selectedFile && (hAsync("swirl-button", { "hide-label": true, class: "info-button", icon: "<swirl-icon-info></swirl-icon-info>", label: "Open file info", onClick: this.toggleSidebar }))), hAsync("swirl-box", { padding: "16", slot: "sidebar" }, hAsync("swirl-text", { color: "subdued", weight: "medium" }, "File info goes here \u2026"))), hAsync("swirl-popover", { label: "Sort items", popoverId: "sort-menu", trigger: "sort-button" }, hAsync("swirl-option-list", { value: ["ascending"] }, hAsync("swirl-option-list-item", { icon: "<swirl-icon-expand-less></swirl-icon-expand-less>", label: "Ascending", value: "ascending" }), hAsync("swirl-option-list-item", { icon: "<swirl-icon-expand-more></swirl-icon-expand-more>", label: "Descending", value: "descending" }), hAsync("swirl-option-list-item", { icon: "<swirl-icon-time-outlined></swirl-icon-time-outlined>", label: "By date", value: "date" })))));
  }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "file-manager",
    "$members$": {
      "selectedDirectory": [32],
      "selectedFile": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

function closestPassShadow(node, selector) {
  if (!node) {
    return null;
  }
  if (node instanceof ShadowRoot) {
    return closestPassShadow(node.host, selector);
  }
  if (node instanceof HTMLElement) {
    if (node.matches(selector)) {
      return node;
    }
    else {
      return closestPassShadow(node.parentNode, selector);
    }
  }
  return closestPassShadow(node.parentNode, selector);
}
function getActiveElement(root = document) {
  const activeEl = root.activeElement;
  if (!Boolean(activeEl)) {
    return undefined;
  }
  if (Boolean(activeEl.shadowRoot)) {
    return getActiveElement(activeEl.shadowRoot);
  }
  else {
    return activeEl;
  }
}
const getDesktopMediaQuery = () => document.documentElement.classList.contains("disable-desktop-style-tweaks")
  ? window.matchMedia(null)
  : window.matchMedia("(min-width: 992px) and (max-width: 1439px) and (hover: hover), (min-width: 1440px)");
function debounce(func, wait, immediate = false) {
  let timeout;
  return async function executedFunction() {
    const context = this;
    const args = arguments;
    const later = function () {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const callNow = immediate && !Boolean(timeout);
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
function getVisibleHeight(element, container) {
  const scrollTop = container.scrollTop;
  const scrollBot = scrollTop + container.clientHeight;
  const containerRect = container.getBoundingClientRect();
  const eleRect = element.getBoundingClientRect();
  const rect = {
    top: eleRect.top - containerRect.top,
    right: eleRect.right - containerRect.right,
    bottom: eleRect.bottom - containerRect.bottom,
    left: eleRect.left - containerRect.left,
  };
  const eleTop = rect.top + scrollTop;
  const eleBot = eleTop + element.offsetHeight;
  const visibleTop = eleTop < scrollTop ? scrollTop : eleTop;
  const visibleBot = eleBot > scrollBot ? scrollBot : eleBot;
  return visibleBot - visibleTop;
}
function isMobileViewport() {
  return !window.matchMedia("(min-width: 768px)").matches;
}
function querySelectorAllDeep(root, selector) {
  function collectAllElementsDeep(selector, root) {
    if (!Boolean(root)) {
      return [];
    }
    const lightDomMatches = Array.from(root.querySelectorAll(selector));
    const slottedChildren = Boolean(window.HTMLSlotElement) && root instanceof HTMLSlotElement
      ? root.assignedElements()
      : [];
    const children = [...Array.from(root.children), ...slottedChildren];
    const shadowRoot = root.shadowRoot;
    const shadowRootElements = collectAllElementsDeep(selector, shadowRoot);
    const matches = [
      ...lightDomMatches,
      ...children
        .map((match) => collectAllElementsDeep(selector, match))
        .flat(),
      ...shadowRootElements,
    ];
    return matches;
  }
  const matches = collectAllElementsDeep(selector, root).filter((match, index, matches) => !matches.some((m, i) => m.isSameNode(match) && i > index));
  return matches;
}

const swirlActionListCss = "/*!@:host*/.sc-swirl-action-list-h{display:block;width:100%}/*!@:host **/.sc-swirl-action-list-h *.sc-swirl-action-list{box-sizing:border-box}/*!@.action-list*/.action-list.sc-swirl-action-list{background-color:var(--s-surface-overlay-default)}";

/**
 * @slot slot - The action list items and sections
 */
class SwirlActionList {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onKeyDown = (event) => {
      if (event.code === "ArrowDown" || event.code === "ArrowRight") {
        event.preventDefault();
        this.focusNextItem();
      }
      else if (event.code === "ArrowUp" || event.code === "ArrowLeft") {
        event.preventDefault();
        this.focusPreviousItem();
      }
    };
  }
  componentDidLoad() {
    this.updateItems();
    this.observeSlotChanges();
  }
  disconnectedCallback() {
    var _a;
    (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  observeSlotChanges() {
    this.observer = new MutationObserver(() => {
      this.updateItems();
    });
    this.observer.observe(this.el, { childList: true });
  }
  updateItems() {
    this.items = querySelectorAllDeep(this.el, '[role="menuitem"]');
  }
  focusNextItem() {
    const activeItemIndex = this.getActiveItemIndex();
    const newIndex = (activeItemIndex + 1) % this.items.length;
    this.items[newIndex].focus();
  }
  focusPreviousItem() {
    var _a;
    const activeItemIndex = this.getActiveItemIndex();
    const newIndex = activeItemIndex === 0 ? this.items.length - 1 : activeItemIndex - 1;
    (_a = this.items[newIndex]) === null || _a === void 0 ? void 0 : _a.focus();
  }
  getActiveItemIndex() {
    const activeElement = getActiveElement();
    return this.items.findIndex((item) => item === activeElement ||
      item === (activeElement === null || activeElement === void 0 ? void 0 : activeElement.querySelector('[role="menuitem"]')));
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { "aria-orientation": "vertical", class: "action-list", onKeyDown: this.onKeyDown, role: "menu" }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlActionListCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-action-list",
    "$members$": undefined,
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire();
		}
	}, fn(module, module.exports), module.exports;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if (module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

const swirlActionListItemCss = "/*!@:host*/.sc-swirl-action-list-item-h{display:block}/*!@:host **/.sc-swirl-action-list-item-h *.sc-swirl-action-list-item{box-sizing:border-box}/*!@.action-list-item*/.action-list-item.sc-swirl-action-list-item{display:inline-flex;width:100%;min-width:15rem;margin:0;padding:var(--s-space-12) var(--s-space-16);justify-content:flex-start;align-items:center;border:none;color:var(--s-text-default);background-color:var(--s-surface-overlay-default);font:inherit;line-height:var(--s-line-height-base);text-align:left;cursor:pointer;gap:var(--s-space-12)}/*!@.action-list-item:hover*/.action-list-item.sc-swirl-action-list-item:hover{background-color:var(--s-surface-overlay-hovered)}/*!@.action-list-item:focus*/.action-list-item.sc-swirl-action-list-item:focus{outline:none}/*!@.action-list-item:focus-visible*/.action-list-item.sc-swirl-action-list-item:focus-visible{background-color:var(--s-surface-overlay-hovered)}/*!@.action-list-item:active*/.action-list-item.sc-swirl-action-list-item:active{background-color:var(--s-surface-overlay-pressed)}/*!@.action-list-item:disabled*/.action-list-item.sc-swirl-action-list-item:disabled{background-color:var(--s-surface-overlay-default);cursor:default}/*!@.action-list-item:disabled .action-list-item__label,\n    .action-list-item:disabled .action-list-item__description*/.action-list-item.sc-swirl-action-list-item:disabled .action-list-item__label.sc-swirl-action-list-item,.action-list-item.sc-swirl-action-list-item:disabled .action-list-item__description.sc-swirl-action-list-item{color:var(--s-text-disabled)}/*!@.action-list-item:disabled .action-list-item__icon*/.action-list-item.sc-swirl-action-list-item:disabled .action-list-item__icon.sc-swirl-action-list-item{color:var(--s-icon-disabled)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.action-list-item*/.action-list-item.sc-swirl-action-list-item{padding:var(--s-space-8) var(--s-space-12);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm);gap:var(--s-space-8)}}/*!@.action-list-item--size-l*/.action-list-item--size-l.sc-swirl-action-list-item{padding:var(--s-space-16)}/*!@.action-list-item--intent-critical ::part(icon)*/.action-list-item--intent-critical.sc-swirl-action-list-item .sc-swirl-action-list-item::part(icon){color:var(--s-icon-critical)}/*!@.action-list-item--intent-critical:not(:disabled) .action-list-item__label*/.action-list-item--intent-critical.sc-swirl-action-list-item:not(:disabled) .action-list-item__label.sc-swirl-action-list-item{color:var(--s-text-critical)}/*!@.action-list-item--intent-critical:not(:disabled) .action-list-item__icon*/.action-list-item--intent-critical.sc-swirl-action-list-item:not(:disabled) .action-list-item__icon.sc-swirl-action-list-item{color:var(--s-icon-critical)}/*!@.action-list-item__icon*/.action-list-item__icon.sc-swirl-action-list-item{display:inline-flex;flex-shrink:0;color:var(--s-icon-default)}/*!@.action-list-item__label-container*/.action-list-item__label-container.sc-swirl-action-list-item{display:inline-flex;min-width:0;flex-grow:1;align-items:flex-start;flex-direction:column}/*!@.action-list-item__label*/.action-list-item__label.sc-swirl-action-list-item{overflow:hidden;max-width:100%;font-weight:var(--s-font-weight-medium);white-space:nowrap;text-overflow:ellipsis}/*!@.action-list-item__description*/.action-list-item__description.sc-swirl-action-list-item{color:var(--s-text-subdued)}/*!@.action-list-item__suffix*/.action-list-item__suffix.sc-swirl-action-list-item{display:inline-flex;flex-shrink:0;color:var(--s-icon-highlight)}";

class SwirlActionListItem {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.disabled = undefined;
    this.description = undefined;
    this.icon = undefined;
    this.intent = "default";
    this.label = undefined;
    this.size = "m";
    this.suffix = undefined;
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  componentDidRender() {
    this.forceIconProps(this.desktopMediaQuery.matches);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    var _a, _b;
    const icon = (_a = this.iconEl) === null || _a === void 0 ? void 0 : _a.children[0];
    const suffix = (_b = this.suffixEl) === null || _b === void 0 ? void 0 : _b.children[0];
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", smallIcon ? "20" : "24");
    suffix === null || suffix === void 0 ? void 0 : suffix.setAttribute("size", smallIcon ? "20" : "24");
  }
  render() {
    const showSuffix = Boolean(this.suffix) && !this.disabled;
    const className = classnames("action-list-item", `action-list-item--intent-${this.intent}`, `action-list-item--size-${this.size}`);
    return (hAsync(Host, null, hAsync("button", { class: className, disabled: this.disabled, part: "action-list-item", role: "menuitem", tabIndex: -1, type: "button" }, this.icon && (hAsync("span", { class: "action-list-item__icon", innerHTML: this.icon, ref: (el) => (this.iconEl = el) })), hAsync("span", { class: "action-list-item__label-container" }, hAsync("span", { class: "action-list-item__label" }, this.label), this.description && (hAsync("span", { class: "action-list-item__description" }, this.description))), showSuffix && (hAsync("span", { class: "action-list-item__suffix", innerHTML: this.suffix, ref: (el) => (this.suffixEl = el) })))));
  }
  static get style() { return swirlActionListItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-action-list-item",
    "$members$": {
      "disabled": [4],
      "description": [1],
      "icon": [1],
      "intent": [1],
      "label": [1],
      "size": [1],
      "suffix": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlActionListSectionCss = "/*!@:host*/.sc-swirl-action-list-section-h{display:block}/*!@:host **/.sc-swirl-action-list-section-h *.sc-swirl-action-list-section{box-sizing:border-box}/*!@.action-list-section*/.action-list-section.sc-swirl-action-list-section{background-color:var(--s-surface-overlay-default)}/*!@.action-list-section__label*/.action-list-section__label.sc-swirl-action-list-section{display:block;width:100%;padding:var(--s-space-8) var(--s-space-16);border-bottom:var(--s-border-width-default) solid var(--s-border-default);color:var(--s-text-subdued);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base);text-align:left}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.action-list-section__label*/.action-list-section__label.sc-swirl-action-list-section{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm);padding:var(--s-space-8) var(--s-space-12)}}";

/**
 * @slot slot - The action list item components
 */
class SwirlActionListSection {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.label = undefined;
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { "aria-labelledby": "label", class: "action-list-section", role: "group" }, hAsync("span", { class: "action-list-section__label", id: "label", part: "action-list-section__label" }, this.label), hAsync("div", { class: "action-list-section__items" }, hAsync("slot", null)))));
  }
  static get style() { return swirlActionListSectionCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-action-list-section",
    "$members$": {
      "label": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlAppBarCss = "/*!@:host*/.sc-swirl-app-bar-h{display:block;overflow-x:auto;width:100%}/*!@:host **/.sc-swirl-app-bar-h *.sc-swirl-app-bar{box-sizing:border-box}/*!@.app-bar*/.app-bar.sc-swirl-app-bar{display:flex;min-width:-webkit-min-content;min-width:-moz-min-content;min-width:min-content;min-height:3.5rem;padding-right:var(--s-space-16);padding-left:var(--s-space-16);align-items:center;gap:var(--s-space-16)}/*!@.app-bar--has-cta .app-bar__cta*/.app-bar--has-cta.sc-swirl-app-bar .app-bar__cta.sc-swirl-app-bar{display:block}/*!@.app-bar__left-controls*/.app-bar__left-controls.sc-swirl-app-bar{display:flex;min-width:0;flex-shrink:0;align-items:center;gap:var(--s-space-16)}/*!@.app-bar__main-navigation-control*/.app-bar__main-navigation-control.sc-swirl-app-bar{flex-shrink:0}/*!@.app-bar__cta*/.app-bar__cta.sc-swirl-app-bar{display:none}/*!@.app-bar__heading*/.app-bar__heading.sc-swirl-app-bar{display:flex;min-width:-webkit-min-content;min-width:-moz-min-content;min-width:min-content;flex-grow:1;align-items:center}@media (min-width: 992px){/*!@.app-bar__heading*/.app-bar__heading.sc-swirl-app-bar{flex-grow:0}}/*!@.app-bar__stepper-controls*/.app-bar__stepper-controls.sc-swirl-app-bar{position:relative;display:flex;flex-shrink:0;gap:var(--s-space-4)}/*!@.app-bar__stepper-controls:not(:first-child)*/.app-bar__stepper-controls.sc-swirl-app-bar:not(:first-child){padding-left:var(--s-space-16)}/*!@.app-bar__stepper-controls:not(:first-child):after*/.app-bar__stepper-controls.sc-swirl-app-bar:not(:first-child):after{position:absolute;top:50%;left:0;width:var(--s-border-width-default);height:1.25rem;background-color:var(--s-border-default);content:\"\";transform:translateY(-50%)}/*!@.app-bar__center-controls*/.app-bar__center-controls.sc-swirl-app-bar{display:none;flex-grow:1;justify-content:center;align-items:center}@media (min-width: 992px){/*!@.app-bar__center-controls*/.app-bar__center-controls.sc-swirl-app-bar{display:flex}}/*!@.app-bar__right-controls*/.app-bar__right-controls.sc-swirl-app-bar{display:flex;min-width:0;flex-shrink:0;justify-content:flex-end;align-items:center}";

/**
 * @slot heading - The app bar's heading element
 * @slot center-controls - Container for controls displayed in the center
 * @slot cta - Container for a call to action button
 * @slot heading - Container for controls displayed at the end of the bar
 */
class SwirlAppBar {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.backButtonClick = createEvent(this, "backButtonClick", 7);
    this.closeButtonClick = createEvent(this, "closeButtonClick", 7);
    this.stepUpButtonClick = createEvent(this, "stepUpButtonClick", 7);
    this.stepDownButtonClick = createEvent(this, "stepDownButtonClick", 7);
    this.onBackButtonClick = (event) => {
      this.backButtonClick.emit(event);
    };
    this.onCloseButtonClick = (event) => {
      this.closeButtonClick.emit(event);
    };
    this.onStepUpButtonClick = (event) => {
      this.stepUpButtonClick.emit(event);
    };
    this.onStepDownButtonClick = (event) => {
      this.stepDownButtonClick.emit(event);
    };
    this.backButtonLabel = "Go back";
    this.closeButtonLabel = "Close";
    this.stepUpButtonLabel = "Previous item";
    this.stepDownButtonLabel = "Next item";
    this.showBackButton = undefined;
    this.showCloseButton = undefined;
    this.showStepperControls = undefined;
    this.hasCta = undefined;
  }
  componentWillLoad() {
    this.mutationObserver = new MutationObserver(() => {
      this.updateCtaStatus();
    });
    this.mutationObserver.observe(this.el, { childList: true });
    queueMicrotask(() => {
      this.updateCtaStatus();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  updateCtaStatus() {
    this.hasCta = Boolean(this.el.querySelector('[slot="cta"]'));
  }
  render() {
    const showLeftControls = this.showBackButton || this.showCloseButton || this.showStepperControls;
    const className = classnames("app-bar", {
      "app-bar--has-cta": this.hasCta,
    });
    return (hAsync(Host, null, hAsync("div", { class: className }, showLeftControls && (hAsync("div", { class: "app-bar__left-controls" }, (this.showBackButton || this.showCloseButton) && (hAsync("div", { class: "app-bar__main-navigation-control" }, this.showBackButton && (hAsync("swirl-button", { hideLabel: true, icon: "<swirl-icon-arrow-back></swirl-icon-arrow-back>", label: this.backButtonLabel, onClick: this.onBackButtonClick })), this.showCloseButton && (hAsync("swirl-button", { hideLabel: true, icon: "<swirl-icon-close></swirl-icon-close>", label: this.closeButtonLabel, onClick: this.onCloseButtonClick })))), this.showStepperControls && (hAsync("div", { class: "app-bar__stepper-controls" }, hAsync("swirl-button", { hideLabel: true, icon: "<swirl-icon-arrow-upward></swirl-icon-arrow-upward>", label: this.stepUpButtonLabel, onClick: this.onStepUpButtonClick }), hAsync("swirl-button", { hideLabel: true, icon: "<swirl-icon-arrow-downward></swirl-icon-arrow-downward>", label: this.stepDownButtonLabel, onClick: this.onStepDownButtonClick }))))), hAsync("div", { class: "app-bar__cta" }, hAsync("slot", { name: "cta" })), hAsync("div", { class: "app-bar__heading" }, hAsync("slot", { name: "heading" })), hAsync("div", { class: "app-bar__center-controls" }, hAsync("slot", { name: "center-controls" })), hAsync("div", { class: "app-bar__right-controls" }, hAsync("slot", { name: "right-controls" })))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlAppBarCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-app-bar",
    "$members$": {
      "backButtonLabel": [1, "back-button-label"],
      "closeButtonLabel": [1, "close-button-label"],
      "stepUpButtonLabel": [1, "step-up-button-label"],
      "stepDownButtonLabel": [1, "step-down-button-label"],
      "showBackButton": [4, "show-back-button"],
      "showCloseButton": [4, "show-close-button"],
      "showStepperControls": [4, "show-stepper-controls"],
      "hasCta": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlAppIconCss = "/*!@:host*/.sc-swirl-app-icon-h{display:inline-flex}/*!@:host **/.sc-swirl-app-icon-h *.sc-swirl-app-icon{box-sizing:border-box}/*!@.app-icon*/.app-icon.sc-swirl-app-icon{position:relative;overflow:hidden;width:2.5rem;height:2.5rem;border-radius:0.625rem;background-color:var(--s-surface-default)}/*!@.app-icon > img*/.app-icon.sc-swirl-app-icon>img.sc-swirl-app-icon{width:100%;height:100%}/*!@.app-icon::after*/.app-icon.sc-swirl-app-icon::after{position:absolute;top:0;display:block;width:100%;height:100%;border-radius:0.625rem;content:\"\";box-shadow:0 0 var(--s-border-width-default) rgba(0, 0, 0, 0.1) inset,\n    0 0 var(--s-border-width-default) rgba(0, 0, 0, 0.1) inset}/*!@.app-icon--hide-border::after*/.app-icon--hide-border.sc-swirl-app-icon::after{box-shadow:none}/*!@.app-icon__icon*/.app-icon__icon.sc-swirl-app-icon{display:inline-flex;width:100%;height:100%;justify-content:center;align-items:center;color:var(--s-icon-default)}";

class SwirlAppIcon {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.setImageAvailable = () => {
      this.imageAvailable = true;
    };
    this.setImageUnavailable = () => {
      this.imageAvailable = false;
    };
    this.icon = undefined;
    this.src = undefined;
    this.hideBorder = false;
    this.imageAvailable = undefined;
  }
  render() {
    const showImage = Boolean(this.src) &&
      (this.imageAvailable || this.imageAvailable === undefined);
    const showIcon = !showImage && Boolean(this.icon);
    const showFallbackIcon = !showImage && !showIcon;
    const className = classnames("app-icon", {
      "app-icon--has-icon": showIcon || showFallbackIcon,
      "app-icon--hide-border": this.hideBorder,
    });
    return (hAsync(Host, null, hAsync("span", { class: className }, showImage && (hAsync("img", { alt: "", height: "40", onError: this.setImageUnavailable, onLoad: this.setImageAvailable, src: this.src, width: "40" })), showIcon && (hAsync("span", { class: "app-icon__icon", innerHTML: this.icon })))));
  }
  static get style() { return swirlAppIconCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-app-icon",
    "$members$": {
      "icon": [1],
      "src": [1],
      "hideBorder": [4, "hide-border"],
      "imageAvailable": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlAppLayoutCss = "/*!@:host*/.sc-swirl-app-layout-h{position:relative;z-index:1;display:flex;width:100%;height:100%}/*!@:host **/.sc-swirl-app-layout-h *.sc-swirl-app-layout{box-sizing:border-box}/*!@.app-layout*/.app-layout.sc-swirl-app-layout{display:flex;overflow:hidden;width:100%;height:100%;margin-right:auto;margin-left:auto}/*!@.app-layout__grid*/.app-layout__grid.sc-swirl-app-layout{position:relative;display:grid;width:100%;height:100%;grid-template-columns:100%;grid-template-rows:4rem 1fr;grid-template-areas:\"body\"\n    \"body\"}/*!@.app-layout:not(.app-layout--has-navigation) .app-layout__header,\n  .app-layout:not(.app-layout--has-navigation) .app-layout__navigation*/.app-layout.sc-swirl-app-layout:not(.app-layout--has-navigation) .app-layout__header.sc-swirl-app-layout,.app-layout.sc-swirl-app-layout:not(.app-layout--has-navigation) .app-layout__navigation.sc-swirl-app-layout{display:none}/*!@.app-layout:not(.app-layout--has-sidebar) .app-layout__sidebar*/.app-layout.sc-swirl-app-layout:not(.app-layout--has-sidebar) .app-layout__sidebar.sc-swirl-app-layout{display:none}@media (max-width: 767px){/*!@.app-layout:not(.app-layout--mobile-view-body) .app-layout__body*/.app-layout.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout{display:none}}@media (max-width: 767px){/*!@.app-layout:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar*/.app-layout.sc-swirl-app-layout:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar.sc-swirl-app-layout{display:none}}/*!@.app-layout--has-navigation .app-layout__grid*/.app-layout--has-navigation.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-columns:100%;grid-template-areas:\"header\"\n      \"navigation\"}@media (min-width: 768px){/*!@.app-layout--has-navigation .app-layout__grid*/.app-layout--has-navigation.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-columns:min(50%, 25rem) 1fr;grid-template-areas:\"header body\"\n        \"navigation body\"}}@media (min-width: 768px){/*!@.app-layout--has-navigation .app-layout__app-bar-mobile-menu-button*/.app-layout--has-navigation.sc-swirl-app-layout .app-layout__app-bar-mobile-menu-button.sc-swirl-app-layout{display:none}}@media (min-width: 768px){/*!@.app-layout--has-sidebar.app-layout--sidebar-active .app-layout__grid*/.app-layout--has-sidebar.app-layout--sidebar-active.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-columns:1fr min(50%, 25rem);grid-template-areas:\"body sidebar\"\n          \"body sidebar\"}}/*!@.app-layout--has-sidebar .app-layout__grid*/.app-layout--has-sidebar.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-columns:100%;grid-template-areas:\"body\"\n      \"body\"}@media (min-width: 1440px){/*!@.app-layout--has-navigation.app-layout--has-sidebar.app-layout--sidebar-active .app-layout__grid*/.app-layout--has-navigation.app-layout--has-sidebar.app-layout--sidebar-active.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{animation:app-layout-sidebar-slide-in 0.3s;grid-template-columns:25rem 1fr 25rem;grid-template-areas:\"header body sidebar\"\n          \"navigation body sidebar\"}}@media (min-width: 1440px){/*!@.app-layout--has-navigation.app-layout--has-sidebar.app-layout--sidebar-closing .app-layout__grid*/.app-layout--has-navigation.app-layout--has-sidebar.app-layout--sidebar-closing.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{animation:app-layout-sidebar-slide-out 0.3s}}@media (min-width: 768px){/*!@.app-layout--has-navigation.app-layout--has-sidebar .app-layout__grid*/.app-layout--has-navigation.app-layout--has-sidebar.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-columns:min(50%, 25rem) 1fr;grid-template-areas:\"header body\"\n        \"navigation body\"}}@media (min-width: 992px){/*!@.app-layout--has-navigation.app-layout--has-sidebar .app-layout__grid*/.app-layout--has-navigation.app-layout--has-sidebar.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-columns:25rem 1fr;grid-template-areas:\"header body\"\n        \"navigation body\"}}@media (min-width: 768px) and (max-width: 1439px){/*!@.app-layout--has-navigation.app-layout--has-sidebar .app-layout__sidebar*/.app-layout--has-navigation.app-layout--has-sidebar.sc-swirl-app-layout .app-layout__sidebar.sc-swirl-app-layout{position:absolute;top:0;right:0;bottom:0;width:min(40%, 25rem);border-left:var(--s-border-width-default) solid var(--s-border-default);box-shadow:var(--s-shadow-level-3)}}@media (max-width: 767px){/*!@.app-layout--mobile-view-navigation .app-layout__grid*/.app-layout--mobile-view-navigation.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-areas:\"header\"\n        \"navigation\"}/*!@.app-layout--mobile-view-navigation .app-layout__body,\n    .app-layout--mobile-view-navigation .app-layout__sidebar*/.app-layout--mobile-view-navigation.sc-swirl-app-layout .app-layout__body.sc-swirl-app-layout,.app-layout--mobile-view-navigation.sc-swirl-app-layout .app-layout__sidebar.sc-swirl-app-layout{display:none}}@media (max-width: 767px){/*!@.app-layout--mobile-view-body .app-layout__grid*/.app-layout--mobile-view-body.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-areas:\"body\"\n        \"body\"}/*!@.app-layout--mobile-view-body .app-layout__header,\n    .app-layout--mobile-view-body .app-layout__navigation,\n    .app-layout--mobile-view-body .app-layout__sidebar*/.app-layout--mobile-view-body.sc-swirl-app-layout .app-layout__header.sc-swirl-app-layout,.app-layout--mobile-view-body.sc-swirl-app-layout .app-layout__navigation.sc-swirl-app-layout,.app-layout--mobile-view-body.sc-swirl-app-layout .app-layout__sidebar.sc-swirl-app-layout{display:none}}@media (max-width: 767px){/*!@.app-layout--mobile-view-sidebar .app-layout__grid*/.app-layout--mobile-view-sidebar.sc-swirl-app-layout .app-layout__grid.sc-swirl-app-layout{grid-template-areas:\"sidebar\"\n        \"sidebar\"}/*!@.app-layout--mobile-view-sidebar .app-layout__header,\n    .app-layout--mobile-view-sidebar .app-layout__navigation,\n    .app-layout--mobile-view-sidebar .app-layout__body*/.app-layout--mobile-view-sidebar.sc-swirl-app-layout .app-layout__header.sc-swirl-app-layout,.app-layout--mobile-view-sidebar.sc-swirl-app-layout .app-layout__navigation.sc-swirl-app-layout,.app-layout--mobile-view-sidebar.sc-swirl-app-layout .app-layout__body.sc-swirl-app-layout{display:none}}/*!@.app-layout--has-sidebar:not(.app-layout--sidebar-active) .app-layout__sidebar*/.app-layout--has-sidebar.sc-swirl-app-layout:not(.app-layout--sidebar-active) .app-layout__sidebar.sc-swirl-app-layout{display:none}@media (min-width: 768px){/*!@.app-layout--sidebar-closing .app-layout__sidebar*/.app-layout--sidebar-closing.sc-swirl-app-layout .app-layout__sidebar.sc-swirl-app-layout{animation:app-layout-sidebar-overlay-slide-out 0.3s}}@media (min-width: 1440px){/*!@.app-layout--sidebar-closing .app-layout__sidebar*/.app-layout--sidebar-closing.sc-swirl-app-layout .app-layout__sidebar.sc-swirl-app-layout{animation:none}}/*!@.app-layout--has-app-bar-controls .app-layout__app-bar-controls*/.app-layout--has-app-bar-controls.sc-swirl-app-layout .app-layout__app-bar-controls.sc-swirl-app-layout{display:block}/*!@.app-layout__header*/.app-layout__header.sc-swirl-app-layout{z-index:1;display:flex;min-width:0;padding-top:var(--s-space-12);padding-right:var(--s-space-16);padding-bottom:var(--s-space-12);padding-left:var(--s-space-16);align-items:center;border-bottom:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-background-default);grid-area:header;will-change:transform;gap:var(--s-space-8)}@media (min-width: 768px){/*!@.app-layout__header*/.app-layout__header.sc-swirl-app-layout{border-right:var(--s-border-width-default) solid var(--s-border-default)}}/*!@.app-layout__app-name*/.app-layout__app-name.sc-swirl-app-layout{min-width:0}/*!@.app-layout__app-name .heading*/.app-layout__app-name.sc-swirl-app-layout .heading.sc-swirl-app-layout{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}/*!@.app-layout__app-bar-mobile-menu-button,\n.app-layout__navigation-mobile-menu-button*/.app-layout__app-bar-mobile-menu-button.sc-swirl-app-layout,.app-layout__navigation-mobile-menu-button.sc-swirl-app-layout{flex-shrink:0}@media (min-width: 992px){/*!@.app-layout__app-bar-mobile-menu-button,\n.app-layout__navigation-mobile-menu-button*/.app-layout__app-bar-mobile-menu-button.sc-swirl-app-layout,.app-layout__navigation-mobile-menu-button.sc-swirl-app-layout{display:none}}/*!@.app-layout__navigation-back-button*/.app-layout__navigation-back-button.sc-swirl-app-layout{margin-left:calc(-1 * var(--s-space-4))}/*!@.app-layout__floating-cta*/.app-layout__floating-cta.sc-swirl-app-layout{position:absolute;z-index:4;right:var(--s-space-16);bottom:var(--s-space-16)}/*!@.app-layout__navigation-controls*/.app-layout__navigation-controls.sc-swirl-app-layout{flex-shrink:0}/*!@.app-layout__navigation*/.app-layout__navigation.sc-swirl-app-layout{z-index:1;overflow-y:auto;border-right:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-background-default);grid-area:navigation;will-change:transform}/*!@.app-layout__body*/.app-layout__body.sc-swirl-app-layout{z-index:2;display:grid;width:100%;height:100%;grid-area:body;grid-template-rows:minmax(4rem, auto) auto 1fr;grid-template-areas:\"app-bar\"\n    \"banner\"\n    \"content\";will-change:transform}/*!@.app-layout__app-bar*/.app-layout__app-bar.sc-swirl-app-layout{display:flex;min-width:0;align-items:center;border-bottom:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-background-default);grid-area:app-bar;gap:var(--s-space-8)}/*!@.app-layout__back-to-navigation-button*/.app-layout__back-to-navigation-button.sc-swirl-app-layout{margin-left:calc(-1 * var(--s-space-4))}@media (min-width: 768px){/*!@.app-layout__back-to-navigation-button*/.app-layout__back-to-navigation-button.sc-swirl-app-layout{display:none}}/*!@.app-layout__banner*/.app-layout__banner.sc-swirl-app-layout{grid-area:banner}/*!@.app-layout__app-bar-content*/.app-layout__app-bar-content.sc-swirl-app-layout{min-width:0;flex-grow:1}/*!@.app-layout__app-bar-controls*/.app-layout__app-bar-controls.sc-swirl-app-layout{display:none;padding-right:var(--s-space-16)}/*!@.app-layout__content*/.app-layout__content.sc-swirl-app-layout{overflow:auto;background-color:var(--s-background-default);grid-area:content}/*!@.app-layout__sidebar*/.app-layout__sidebar.sc-swirl-app-layout{z-index:3;display:grid;width:100%;height:100%;border-left:var(--s-border-width-default) solid var(--s-border-default);will-change:transform;grid-area:sidebar;grid-template-rows:4rem 1fr;grid-template-areas:\"sidebar-header\"\n    \"sidebar-content\"}@media (min-width: 768px){/*!@.app-layout__sidebar*/.app-layout__sidebar.sc-swirl-app-layout{animation:app-layout-slide-in 0.3s}}@media (min-width: 1440px){/*!@.app-layout__sidebar*/.app-layout__sidebar.sc-swirl-app-layout{width:25rem;animation:none}}/*!@.app-layout__sidebar-header*/.app-layout__sidebar-header.sc-swirl-app-layout{display:flex;min-width:0;padding-top:var(--s-space-12);padding-right:var(--s-space-16);padding-bottom:var(--s-space-12);padding-left:var(--s-space-16);align-items:center;border-bottom:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-background-default);grid-area:sidebar-header;gap:var(--s-space-8)}@media (min-width: 992px){/*!@.app-layout__sidebar-header*/.app-layout__sidebar-header.sc-swirl-app-layout{padding-left:var(--s-space-16)}}/*!@.app-layout__sidebar-heading*/.app-layout__sidebar-heading.sc-swirl-app-layout{min-width:0;flex-grow:1}/*!@.app-layout__sidebar-heading .heading*/.app-layout__sidebar-heading.sc-swirl-app-layout .heading.sc-swirl-app-layout{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}/*!@.app-layout__sidebar-close-button*/.app-layout__sidebar-close-button.sc-swirl-app-layout{margin-left:calc(-1 * var(--s-space-4))}/*!@.app-layout__sidebar-content*/.app-layout__sidebar-content.sc-swirl-app-layout{overflow-y:auto;background-color:var(--s-background-default);grid-area:sidebar-content}@media (max-width: 767px){/*!@.app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__grid, .app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__grid*/.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__grid.sc-swirl-app-layout,.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__grid.sc-swirl-app-layout{grid-template-columns:100%;grid-template-areas:\"header\"\n          \"navigation\"}/*!@.app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__body, .app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__body*/.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout,.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__body.sc-swirl-app-layout{position:absolute;top:0;left:0;display:grid;width:100%;transform:translate3d(100%, 0, 0)}}@media (max-width: 767px){/*!@.app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__header*/.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__header.sc-swirl-app-layout{display:flex}/*!@.app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__navigation*/.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__navigation.sc-swirl-app-layout{display:block}}@media (max-width: 991px){/*!@.app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body:not(.app-layout--mobile-view-sidebar) .app-layout__grid, .app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__grid*/.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body:not(.app-layout--mobile-view-sidebar) .app-layout__grid.sc-swirl-app-layout,.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__grid.sc-swirl-app-layout{grid-template-columns:100%;grid-template-areas:\"body\"\n          \"body\"}/*!@.app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar, .app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar*/.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar.sc-swirl-app-layout,.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar.sc-swirl-app-layout{position:absolute;top:0;left:0;display:grid;border-left:var(--s-border-width-default) solid var(--s-border-default)}}@media (max-width: 991px){/*!@.app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__body*/.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout{display:grid}/*!@.app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar*/.app-layout.sc-swirl-app-layout:not(.app-layout--transition-none).app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar.sc-swirl-app-layout{display:grid}}@media (max-width: 767px){/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__header,\n      .app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__navigation,\n      .app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__header,\n      .app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__navigation*/.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__header.sc-swirl-app-layout,.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__navigation.sc-swirl-app-layout,.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__header.sc-swirl-app-layout,.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__navigation.sc-swirl-app-layout{animation:app-layout-slide-out 0.4s}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__body, .app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__body*/.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout,.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__body.sc-swirl-app-layout{animation:app-layout-slide-in 0.4s}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__body:after, .app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__body:after*/.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout:after,.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__body.sc-swirl-app-layout:after{position:absolute;top:0;right:100%;bottom:0;display:block;width:100%;background-color:rgba(0, 0, 0, 0.3);content:\"\";animation:app-layout-fade-in 0.4s}}@media (max-width: 767px){/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__header*/.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__header.sc-swirl-app-layout{animation-direction:reverse}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__navigation*/.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__navigation.sc-swirl-app-layout{animation-direction:reverse}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__body*/.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__body.sc-swirl-app-layout{animation-direction:reverse}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__body:after*/.app-layout--transition-style-slides.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__body.sc-swirl-app-layout:after{animation-direction:reverse}}@media (max-width: 991px){/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body:not(.app-layout--mobile-view-sidebar) .app-layout__body, .app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__body*/.app-layout--transition-style-slides.app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-sidebar) .app-layout__body.sc-swirl-app-layout,.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout{animation:app-layout-slide-out 0.4s}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar, .app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar*/.app-layout--transition-style-slides.app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar.sc-swirl-app-layout,.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__sidebar.sc-swirl-app-layout{animation:app-layout-slide-in 0.4s}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar:after, .app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar:after*/.app-layout--transition-style-slides.app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar.sc-swirl-app-layout:after,.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__sidebar.sc-swirl-app-layout:after{position:absolute;top:0;right:100%;bottom:0;display:block;width:100%;background-color:rgba(0, 0, 0, 0.3);content:\"\";animation:app-layout-fade-in 0.4s}}@media (max-width: 991px){/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__body*/.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout{animation-direction:reverse}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar*/.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__sidebar.sc-swirl-app-layout{animation-direction:reverse}/*!@.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar:after*/.app-layout--transition-style-slides.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__sidebar.sc-swirl-app-layout:after{animation-direction:reverse}}@media (max-width: 767px){/*!@.app-layout--transition-style-dialog.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation:not(.app-layout--mobile-view-body) .app-layout__body, .app-layout--transition-style-dialog.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__body*/.app-layout--transition-style-dialog.app-layout--transitioning-to-body.app-layout--transitioning-from-navigation.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout,.app-layout--transition-style-dialog.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__body.sc-swirl-app-layout{animation:app-layout-scale-in 0.3s}}@media (max-width: 767px){/*!@.app-layout--transition-style-dialog.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__header*/.app-layout--transition-style-dialog.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__header.sc-swirl-app-layout{animation-direction:reverse}/*!@.app-layout--transition-style-dialog.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__navigation*/.app-layout--transition-style-dialog.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__navigation.sc-swirl-app-layout{animation-direction:reverse}/*!@.app-layout--transition-style-dialog.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body:not(.app-layout--mobile-view-navigation) .app-layout__body*/.app-layout--transition-style-dialog.app-layout--transitioning-to-navigation.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-navigation) .app-layout__body.sc-swirl-app-layout{animation-direction:reverse}}@media (max-width: 991px){/*!@.app-layout--transition-style-dialog.app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar, .app-layout--transition-style-dialog.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar*/.app-layout--transition-style-dialog.app-layout--transitioning-to-sidebar.app-layout--transitioning-from-body.sc-swirl-app-layout:not(.app-layout--mobile-view-sidebar) .app-layout__sidebar.sc-swirl-app-layout,.app-layout--transition-style-dialog.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__sidebar.sc-swirl-app-layout{animation:app-layout-scale-in 0.3s}}@media (max-width: 991px){/*!@.app-layout--transition-style-dialog.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__body*/.app-layout--transition-style-dialog.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__body.sc-swirl-app-layout{animation-direction:reverse}/*!@.app-layout--transition-style-dialog.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar:not(.app-layout--mobile-view-body) .app-layout__sidebar*/.app-layout--transition-style-dialog.app-layout--transitioning-to-body.app-layout--transitioning-from-sidebar.sc-swirl-app-layout:not(.app-layout--mobile-view-body) .app-layout__sidebar.sc-swirl-app-layout{animation-direction:reverse}}@keyframes app-layout-sidebar-overlay-slide-out{0%{transform:translate3d(0, 0, 0)}100%{transform:translate3d(100%, 0, 0)}}@keyframes app-layout-slide-in{0%{transform:translate3d(100%, 0, 0)}100%{transform:translate3d(0, 0, 0)}}@keyframes app-layout-slide-out{0%{transform:translate3d(0, 0, 0)}100%{transform:translate3d(-20%, 0, 0)}}@keyframes app-layout-fade-in{0%{opacity:0}100%{opacity:1}}@keyframes app-layout-scale-in{from{transform:scale(0);box-shadow:0 0 0 100rem rgba(0, 0, 0, 0)}to{transform:scale(1);box-shadow:0 0 0 100rem rgba(0, 0, 0, 0.25)}}@keyframes app-layout-sidebar-slide-in{from{overflow:hidden;grid-template-columns:25rem 1fr 0}to{overflow:hidden;grid-template-columns:25rem 1fr 25rem}}@keyframes app-layout-sidebar-slide-out{from{overflow:hidden;grid-template-columns:25rem 1fr 25rem}to{overflow:hidden;grid-template-columns:25rem 1fr 0}}";

/**
 * @slot content - Main content area
 * @slot navigation - The navigation area content
 * @slot navigation-controls - Controls for the navigation header
 * @slot navigation-mobile-menu-button - Used to add a mobile shell layout menu button to navigation
 * @slot app-bar - The app bar contents
 * @slot app-bar-mobile-menu-button - Used to add a mobile shell layout menu button to the app bar
 * @slot banner - Used to show a banner below the app bar
 * @slot sidebar - Content of the right sidebar
 */
class SwirlAppLayout {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.ctaClick = createEvent(this, "ctaClick", 7);
    this.mobileViewChange = createEvent(this, "mobileViewChange", 7);
    this.navigationBackButtonClick = createEvent(this, "navigationBackButtonClick", 7);
    this.sidebarToggle = createEvent(this, "sidebarToggle", 7);
    this.onBackToNavigationViewButtonClick = () => {
      this.changeMobileView("navigation");
    };
    this.onCtaClick = (event) => {
      this.ctaClick.emit(event);
    };
    this.onNavigationBackButtonClick = (event) => {
      this.navigationBackButtonClick.emit(event);
    };
    this.onSidebarCloseButtonClick = () => {
      this.hideSidebar();
    };
    this.appName = undefined;
    this.backToNavigationViewButtonLabel = "Back to navigation";
    this.ctaIcon = undefined;
    this.ctaLabel = undefined;
    this.navigationBackButtonLabel = "Go back";
    this.navigationLabel = undefined;
    this.showNavigationBackButton = undefined;
    this.sidebarCloseButtonLabel = "Close sidebar";
    this.sidebarHeading = undefined;
    this.transitionStyle = "slides";
    this.hasNavigation = undefined;
    this.hasSidebar = undefined;
    this.mobileView = "navigation";
    this.sidebarActive = undefined;
    this.sidebarClosing = undefined;
    this.transitioningFrom = undefined;
    this.transitioningTo = undefined;
  }
  componentWillLoad() {
    this.mutationObserver = new MutationObserver(() => {
      this.updateNavigationStatus();
      this.updateSidebarStatus();
    });
    this.mutationObserver.observe(this.el, { childList: true });
    queueMicrotask(() => {
      this.updateSidebarStatus();
      this.updateNavigationStatus();
      this.checkMobileView();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  watchMobileView() {
    this.checkMobileView();
  }
  /**
   * Show the sidebar
   */
  async showSidebar() {
    if (this.sidebarActive || !this.hasSidebar) {
      return;
    }
    this.sidebarActive = true;
    this.changeMobileView("sidebar");
    this.sidebarToggle.emit(true);
  }
  /**
   * Hide the sidebar
   */
  async hideSidebar() {
    if (!this.sidebarActive || !this.hasSidebar) {
      return;
    }
    if (Boolean(this.sidebarClosingTimeout)) {
      clearTimeout(this.sidebarClosingTimeout);
    }
    this.sidebarClosing = true;
    const delay = isMobileViewport() ? 0 : 300;
    this.sidebarClosingTimeout = setTimeout(() => {
      this.sidebarActive = false;
      this.sidebarClosing = false;
      this.changeMobileView("body");
      this.sidebarToggle.emit(false);
    }, delay);
  }
  /**
   * Toggle the sidebar
   */
  async toggleSidebar() {
    if (!this.hasSidebar) {
      return;
    }
    if (this.sidebarActive) {
      this.hideSidebar();
    }
    else {
      this.showSidebar();
    }
  }
  /**
   * Change the currently displayed view on mobile viewports
   * @param mobileView
   */
  async changeMobileView(mobileView, transition = true) {
    if (this.mobileView === mobileView ||
      (mobileView === "navigation" && !this.hasNavigation) ||
      (mobileView === "sidebar" && !this.hasSidebar)) {
      return;
    }
    const mobile = isMobileViewport();
    if (!mobile || !transition) {
      this.mobileView = mobileView;
      this.mobileViewChange.emit(this.mobileView);
      return;
    }
    if (Boolean(this.transitionTimeout)) {
      clearTimeout(this.transitionTimeout);
    }
    this.transitioningFrom = this.mobileView;
    this.transitioningTo = mobileView;
    let delay = 0;
    if (this.transitionStyle === "slides") {
      delay = 400;
    }
    else if (this.transitionStyle === "dialog") {
      delay = 300;
    }
    this.transitionTimeout = setTimeout(() => {
      this.mobileView = mobileView;
      this.transitioningFrom = undefined;
      this.transitioningTo = undefined;
      this.mobileViewChange.emit(this.mobileView);
    }, delay);
  }
  checkMobileView() {
    if ((this.mobileView === "navigation" && !this.hasNavigation) ||
      (this.mobileView === "sidebar" && !this.hasSidebar)) {
      this.mobileView = "body";
      return;
    }
    const sidebarActive = this.mobileView === "sidebar" || this.sidebarActive;
    if (sidebarActive === this.sidebarActive) {
      return;
    }
    if (sidebarActive) {
      this.showSidebar();
    }
    else {
      this.hideSidebar();
    }
  }
  updateNavigationStatus() {
    this.hasNavigation = Boolean(this.el.querySelector('[slot="navigation"]'));
  }
  updateSidebarStatus() {
    this.hasSidebar = Boolean(this.el.querySelector('[slot="sidebar"]'));
  }
  render() {
    const showBackToNavigationButton = (this.mobileView === "body" || this.transitioningTo) &&
      this.hasNavigation;
    const hasAppBarControls = Boolean(this.el.querySelector('[slot="app-bar-controls"]'));
    const className = classnames("app-layout", `app-layout--mobile-view-${this.mobileView}`, `app-layout--transitioning-from-${this.transitioningFrom}`, `app-layout--transitioning-to-${this.transitioningTo}`, `app-layout--transition-style-${this.transitionStyle}`, {
      "app-layout--has-app-bar-controls": hasAppBarControls,
      "app-layout--has-navigation": this.hasNavigation,
      "app-layout--has-sidebar": this.hasSidebar,
      "app-layout--sidebar-active": this.mobileView === "sidebar" || this.sidebarActive,
      "app-layout--sidebar-closing": this.sidebarClosing,
    });
    return (hAsync(Host, null, hAsync("section", { "aria-labelledby": "app-name", class: className, role: "document", tabIndex: 0 }, hAsync("div", { class: "app-layout__grid" }, hAsync("header", { class: "app-layout__header" }, hAsync("span", { class: "app-layout__navigation-mobile-menu-button" }, hAsync("slot", { name: "navigation-mobile-menu-button" })), this.showNavigationBackButton && (hAsync("span", { class: "app-layout__navigation-back-button" }, hAsync("swirl-button", { hideLabel: true, icon: "<swirl-icon-arrow-back></swirl-icon-arrow-back>", label: this.navigationBackButtonLabel, onClick: this.onNavigationBackButtonClick }))), hAsync("swirl-heading", { as: "h1", class: "app-layout__app-name", headingId: "app-name", level: 3, text: this.appName }), this.hasNavigation && (hAsync("span", { class: "app-layout__navigation-controls" }, hAsync("slot", { name: "navigation-controls" })))), hAsync("nav", { "aria-label": this.navigationLabel, class: "app-layout__navigation" }, hAsync("slot", { name: "navigation" })), hAsync("section", { "aria-labelledby": "app-name", class: "app-layout__body" }, hAsync("header", { class: "app-layout__app-bar" }, hAsync("span", { class: "app-layout__app-bar-mobile-menu-button" }, hAsync("slot", { name: "app-bar-mobile-menu-button" })), showBackToNavigationButton && (hAsync("span", { class: "app-layout__back-to-navigation-button" }, hAsync("swirl-button", { hideLabel: true, icon: this.transitionStyle === "dialog"
        ? "<swirl-icon-close></swirl-icon-close>"
        : "<swirl-icon-arrow-back></swirl-icon-arrow-back>", label: this.backToNavigationViewButtonLabel, onClick: this.onBackToNavigationViewButtonClick }))), hAsync("div", { class: "app-layout__app-bar-content" }, hAsync("slot", { name: "app-bar" })), hAsync("div", { class: "app-layout__app-bar-controls" }, hAsync("slot", { name: "app-bar-controls" }))), hAsync("div", { class: "app-layout__banner" }, hAsync("slot", { name: "banner" })), hAsync("div", { class: "app-layout__content" }, hAsync("slot", { name: "content" }))), hAsync("aside", { class: "app-layout__sidebar" }, hAsync("header", { class: "app-layout__sidebar-header" }, hAsync("swirl-button", { class: "app-layout__sidebar-close-button", hideLabel: true, icon: "<swirl-icon-close></swirl-icon-close>", label: this.sidebarCloseButtonLabel, onClick: this.onSidebarCloseButtonClick }), hAsync("swirl-heading", { as: "h3", class: "app-layout__sidebar-heading", headingId: "sidebar-heading", level: 3, text: this.sidebarHeading })), hAsync("div", { class: "app-layout__sidebar-content" }, hAsync("slot", { name: "sidebar" }))), this.ctaLabel && (hAsync("span", { class: "app-layout__floating-cta" }, hAsync("swirl-button", { hideLabel: Boolean(this.ctaIcon), icon: this.ctaIcon, intent: "primary", label: this.ctaLabel, onClick: this.onCtaClick, variant: "floating" })))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "mobileView": ["watchMobileView"]
  }; }
  static get style() { return swirlAppLayoutCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-app-layout",
    "$members$": {
      "appName": [1, "app-name"],
      "backToNavigationViewButtonLabel": [1, "back-to-navigation-view-button-label"],
      "ctaIcon": [1, "cta-icon"],
      "ctaLabel": [1, "cta-label"],
      "navigationBackButtonLabel": [1, "navigation-back-button-label"],
      "navigationLabel": [1, "navigation-label"],
      "showNavigationBackButton": [4, "show-navigation-back-button"],
      "sidebarCloseButtonLabel": [1, "sidebar-close-button-label"],
      "sidebarHeading": [1, "sidebar-heading"],
      "transitionStyle": [1, "transition-style"],
      "hasNavigation": [32],
      "hasSidebar": [32],
      "mobileView": [32],
      "sidebarActive": [32],
      "sidebarClosing": [32],
      "transitioningFrom": [32],
      "transitioningTo": [32],
      "showSidebar": [64],
      "hideSidebar": [64],
      "toggleSidebar": [64],
      "changeMobileView": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

function getAlignment(placement) {
  return placement.split('-')[1];
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function getSide(placement) {
  return placement.split('-')[0];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

const min$1 = Math.min;
const max$1 = Math.max;

function within(min$1$1, value, max$1$1) {
  return max$1(min$1$1, min$1(value, max$1$1));
}

const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$map$so;
                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

async function convertValueToCoords(state, value) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(state) : value;

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: 'offset',
    options: value,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};

function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function getNodeName(node) {
  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';
}

function getUAString() {
  const uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands) {
    return uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
  }

  return navigator.userAgent;
}

function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  // TODO: Try and use feature detection here instead
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)
  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);
}
function isLayoutViewport() {
  // Not Safari
  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways
  // • Always-visible scrollbar or not
  // • Width of <html>, etc.
  // const vV = win.visualViewport;
  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}

const min = Math.min;
const max = Math.max;
const round = Math.round;

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;

  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)
  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || ( // DOM Element detected
    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }

  return composedOffsetParent(element);
}
/**
 * Polyfills the old offsetParent behavior from before the spec was changed:
 * https://github.com/w3c/csswg-drafts/issues/159
 */


function composedOffsetParent(element) {
  let {
    offsetParent
  } = element;
  let ancestor = element;
  let foundInsideSlot = false;

  while (ancestor && ancestor !== offsetParent) {
    const {
      assignedSlot
    } = ancestor;

    if (assignedSlot) {
      let newOffsetParent = assignedSlot.offsetParent;

      if (getComputedStyle$1(assignedSlot).display === 'contents') {
        const hadStyleAttribute = assignedSlot.hasAttribute('style');
        const oldDisplay = assignedSlot.style.display;
        assignedSlot.style.display = getComputedStyle$1(ancestor).display;
        newOffsetParent = assignedSlot.offsetParent;
        assignedSlot.style.display = oldDisplay;

        if (!hadStyleAttribute) {
          assignedSlot.removeAttribute('style');
        }
      }

      ancestor = assignedSlot;

      if (offsetParent !== newOffsetParent) {
        offsetParent = newOffsetParent;
        foundInsideSlot = true;
      }
    } else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {
      break;
    }

    ancestor = isShadowRoot(ancestor) && ancestor.host || ancestor.parentNode;
  }

  return offsetParent;
}

function getContainingBlock(element) {
  let currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      const parent = currentNode.parentNode;
      currentNode = isShadowRoot(parent) ? parent.host : parent;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }

  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);

  if (offsetParent === documentElement) {
    return rect;
  }

  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } // This doesn't appear to be need to be negated.
    // else if (documentElement) {
    //   offsets.x = getWindowScrollBarX(documentElement);
    // }

  }

  return { ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width,
    height,
    x,
    y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;

  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width,
    height,
    x,
    y
  };
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);

  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {
    // @ts-ignore assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }

  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;

  if (list === void 0) {
    list = [];
  }

  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here
  updatedList.concat(getOverflowAncestors(target));
}

function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;

    do {
      // use `===` replace node.isSameNode()
      if (next && parent === next) {
        return true;
      } // @ts-ignore: need a better way to handle this...


      next = next.parentNode || next.host;
    } while (next);
  }

  return false;
}

function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}

function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === 'viewport') {
    return rectToClientRect(getViewportRect(element, strategy));
  }

  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }

  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping ancestor" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // @ts-ignore isElement check ensures we return Array<Element>


  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');
} // Gets the maximum area that the element is visible in due to any number of
// clipping ancestors


function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: _ref => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: { ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$1(element).direction === 'rtl'
};

/**
 * Automatically updates the position of the floating element when necessary.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }

  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  let observer = null;

  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }

      initialUpdate = false;
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    observer.observe(floating);
  }

  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;

  if (animationFrame) {
    frameLoop();
  }

  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);

    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }

    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }

  update();
  return () => {
    var _observer;

    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;

    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */

const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
  platform,
  ...options
});

const swirlAutocompleteCss = ".sc-swirl-autocomplete-h{display:block}.sc-swirl-autocomplete-h *.sc-swirl-autocomplete{box-sizing:border-box}.autocomplete--inactive.sc-swirl-autocomplete .autocomplete__listbox-container.sc-swirl-autocomplete{display:none}.autocomplete__listbox-container.sc-swirl-autocomplete{position:fixed;z-index:var(--s-z-40);overflow:hidden;padding-top:var(--s-space-8);padding-bottom:var(--s-space-8);border-radius:var(--s-border-radius-sm);background-color:var(--s-surface-overlay-default);box-shadow:var(--s-shadow-level-1)}.autocomplete__listbox-container.sc-swirl-autocomplete:empty{display:none}.autocomplete__spinner.sc-swirl-autocomplete{display:flex;padding:var(--s-space-16);justify-content:center;align-items:center}";

class SwirlAutocomplete {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.onChange = debounce(async (event) => {
      this.value = event.detail;
      this.valueChange.emit(this.value);
      this.updateSuggestions();
      this.open();
    }, 250, false);
    this.onSelect = (event) => {
      var _a;
      if (Boolean(event.detail[0])) {
        this.value = event.detail[0];
        this.valueChange.emit(this.value);
      }
      (_a = this.inputEl.querySelector("input")) === null || _a === void 0 ? void 0 : _a.focus();
      this.close();
    };
    this.onFocusOut = (event) => {
      const relatedTarget = event.relatedTarget;
      if (Boolean(relatedTarget) && !this.el.contains(relatedTarget)) {
        this.close();
      }
    };
    this.onFocus = () => {
      this.updateSuggestions();
      this.open();
    };
    this.onKeyDown = (event) => {
      if (event.code === "Escape") {
        event.preventDefault();
        this.inputEl.querySelector("input").focus();
        this.close();
      }
    };
    this.onInputKeyDown = (event) => {
      if (event.code === "ArrowDown") {
        event.preventDefault();
        this.listboxEl.querySelector('[role="listbox"]').focus();
      }
    };
    this.autoSelect = undefined;
    this.clearable = true;
    this.clearButtonLabel = "Clear input";
    this.disabled = undefined;
    this.generateSuggestions = async () => [];
    this.inline = undefined;
    this.invalid = undefined;
    this.maxLength = undefined;
    this.menuLabel = "Suggestions";
    this.mode = undefined;
    this.required = undefined;
    this.spellCheck = undefined;
    this.swirlAriaDescribedby = undefined;
    this.value = undefined;
    this.active = false;
    this.loading = false;
    this.position = undefined;
    this.suggestions = [];
  }
  componentWillLoad() {
    const index = document.querySelectorAll("swirl-datepicker").length;
    this.id = `autocomplete-${index}`;
  }
  onWindowClick(event) {
    const target = event.target;
    if (!this.el.contains(target)) {
      this.close();
    }
  }
  async close() {
    if (!this.active) {
      return;
    }
    if (this.disableAutoUpdate) {
      this.disableAutoUpdate();
    }
    this.active = false;
  }
  async open() {
    if (this.active) {
      return;
    }
    this.active = true;
    requestAnimationFrame(async () => {
      await this.reposition();
      if (this.disableAutoUpdate) {
        this.disableAutoUpdate();
      }
      this.disableAutoUpdate = autoUpdate(this.inputEl, this.listboxContainerEl, this.reposition.bind(this));
      this.listboxContainerEl.scrollTop = 0;
    });
  }
  async reposition() {
    if (!Boolean(this.listboxContainerEl)) {
      return;
    }
    this.position = await computePosition(this.inputEl, this.listboxContainerEl, {
      middleware: [offset({ crossAxis: -16, mainAxis: 16 })],
      placement: "bottom-start",
      strategy: "fixed",
    });
  }
  async updateSuggestions() {
    this.loading = true;
    this.suggestions = [];
    this.suggestions = await this.generateSuggestions(this.value);
    this.loading = false;
  }
  render() {
    var _a, _b, _c;
    const suggestionsMenuId = `${this.id}-suggestions`;
    const className = classnames("autocomplete", {
      "autocomplete--inactive": !this.active,
    });
    return (hAsync(Host, null, hAsync("div", { class: className, onFocusout: this.onFocusOut, onKeyDown: this.onKeyDown }, hAsync("swirl-text-input", { autoSelect: this.autoSelect, class: "autocomplete__input", clearable: this.clearable, clearButtonLabel: this.clearButtonLabel, disabled: this.disabled, disableDynamicWidth: true, id: this.id, inline: this.inline, invalid: this.invalid, onInputFocus: this.onFocus, onKeyDown: this.onInputKeyDown, onValueChange: this.onChange, maxLength: this.maxLength, mode: this.mode, ref: (el) => (this.inputEl = el), required: this.required, spellCheck: this.spellCheck, swirlAriaAutocomplete: "list", swirlAriaControls: suggestionsMenuId, swirlAriaDescribedby: this.swirlAriaDescribedby, swirlAriaExpanded: String(this.active), swirlRole: "combobox", value: this.value }), hAsync("div", { class: "autocomplete__listbox-container", ref: (el) => (this.listboxContainerEl = el), style: {
        top: Boolean(this.position) ? `${(_a = this.position) === null || _a === void 0 ? void 0 : _a.y}px` : "",
        left: Boolean(this.position) ? `${(_b = this.position) === null || _b === void 0 ? void 0 : _b.x}px` : "",
        width: `${((_c = this.inputEl) === null || _c === void 0 ? void 0 : _c.getBoundingClientRect().width) + 32}px`,
      } }, this.loading && (hAsync("div", { class: "autocomplete__spinner" }, hAsync("swirl-spinner", null))), this.suggestions.length > 0 && (hAsync("swirl-option-list", { label: this.menuLabel, onValueChange: this.onSelect, optionListId: suggestionsMenuId, ref: (el) => (this.listboxEl = el), value: [this.value] }, this.suggestions.map((suggestion) => (hAsync("swirl-option-list-item", { selected: this.value === suggestion.label, key: suggestion.id, disabled: suggestion.disabled, label: suggestion.label, value: suggestion.label })))))))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlAutocompleteCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-autocomplete",
    "$members$": {
      "autoSelect": [4, "auto-select"],
      "clearable": [4],
      "clearButtonLabel": [1, "clear-button-label"],
      "disabled": [4],
      "generateSuggestions": [1040],
      "inline": [4],
      "invalid": [4],
      "maxLength": [2, "max-length"],
      "menuLabel": [1, "menu-label"],
      "mode": [1],
      "required": [4],
      "spellCheck": [4, "spell-check"],
      "swirlAriaDescribedby": [1, "swirl-aria-describedby"],
      "value": [1537],
      "active": [32],
      "loading": [32],
      "position": [32],
      "suggestions": [32]
    },
    "$listeners$": [[8, "click", "onWindowClick"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": [["value", "value"]]
  }; }
}

const swirlAvatarCss = "/*!@:host*/.sc-swirl-avatar-h{display:inline-flex;flex-shrink:0;align-items:center;flex-direction:column}/*!@:host **/.sc-swirl-avatar-h *.sc-swirl-avatar{box-sizing:border-box}/*!@.avatar*/.avatar.sc-swirl-avatar{position:relative;display:inline-flex;justify-content:center;align-items:center;border-radius:50%}/*!@.avatar--has-icon*/.avatar--has-icon.sc-swirl-avatar{color:var(--s-icon-default);background-color:var(--s-surface-raised-default)}/*!@.avatar--has-initials*/.avatar--has-initials.sc-swirl-avatar{padding-right:0;padding-left:0;color:#fff}/*!@.avatar--interactive*/.avatar--interactive.sc-swirl-avatar{cursor:pointer}/*!@.avatar--interactive:focus:not(:focus-visible)*/.avatar--interactive.sc-swirl-avatar:focus:not(:focus-visible){outline:none}/*!@.avatar--interactive:focus-visible*/.avatar--interactive.sc-swirl-avatar:focus-visible{outline-color:var(--s-focus-default)}/*!@.avatar--size-xs*/.avatar--size-xs.sc-swirl-avatar{width:1.75rem;height:1.75rem;font-size:0.75rem}/*!@.avatar--size-xs.avatar--has-icon*/.avatar--size-xs.avatar--has-icon.sc-swirl-avatar{padding-right:0.4375rem;padding-left:0.4375rem}/*!@.avatar--size-xs.avatar--variant-square,\n  .avatar--size-xs.avatar--variant-square .avatar__image,\n  .avatar--size-xs.avatar--variant-square .avatar__initials*/.avatar--size-xs.avatar--variant-square.sc-swirl-avatar,.avatar--size-xs.avatar--variant-square.sc-swirl-avatar .avatar__image.sc-swirl-avatar,.avatar--size-xs.avatar--variant-square.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{border-radius:0.5rem}/*!@.avatar--size-s*/.avatar--size-s.sc-swirl-avatar{width:2rem;height:2rem;font-size:0.75rem}/*!@.avatar--size-s.avatar--has-icon*/.avatar--size-s.avatar--has-icon.sc-swirl-avatar{padding-right:var(--s-space-8);padding-left:var(--s-space-8)}/*!@.avatar--size-s.avatar--variant-square,\n  .avatar--size-s.avatar--variant-square .avatar__image,\n  .avatar--size-s.avatar--variant-square .avatar__initials*/.avatar--size-s.avatar--variant-square.sc-swirl-avatar,.avatar--size-s.avatar--variant-square.sc-swirl-avatar .avatar__image.sc-swirl-avatar,.avatar--size-s.avatar--variant-square.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{border-radius:0.5rem}/*!@.avatar--size-m*/.avatar--size-m.sc-swirl-avatar{width:2.5rem;height:2.5rem;font-size:var(--s-font-size-base)}/*!@.avatar--size-m.avatar--has-icon*/.avatar--size-m.avatar--has-icon.sc-swirl-avatar{padding-right:0.625rem;padding-left:0.625rem}/*!@.avatar--size-m.avatar--variant-square,\n  .avatar--size-m.avatar--variant-square .avatar__image,\n  .avatar--size-m.avatar--variant-square .avatar__initials*/.avatar--size-m.avatar--variant-square.sc-swirl-avatar,.avatar--size-m.avatar--variant-square.sc-swirl-avatar .avatar__image.sc-swirl-avatar,.avatar--size-m.avatar--variant-square.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{border-radius:0.625rem}/*!@.avatar--size-l*/.avatar--size-l.sc-swirl-avatar{width:3rem;height:3rem;font-size:var(--s-font-size-lg)}/*!@.avatar--size-l.avatar--has-icon*/.avatar--size-l.avatar--has-icon.sc-swirl-avatar{padding-right:var(--s-space-12);padding-left:var(--s-space-12)}/*!@.avatar--size-l.avatar--variant-square,\n  .avatar--size-l.avatar--variant-square .avatar__image,\n  .avatar--size-l.avatar--variant-square .avatar__initials*/.avatar--size-l.avatar--variant-square.sc-swirl-avatar,.avatar--size-l.avatar--variant-square.sc-swirl-avatar .avatar__image.sc-swirl-avatar,.avatar--size-l.avatar--variant-square.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{border-radius:0.75rem}/*!@.avatar--size-xl*/.avatar--size-xl.sc-swirl-avatar{width:4rem;height:4rem;font-size:var(--s-font-size-xl)}/*!@.avatar--size-xl.avatar--has-icon*/.avatar--size-xl.avatar--has-icon.sc-swirl-avatar{padding-right:var(--s-space-16);padding-left:var(--s-space-16)}/*!@.avatar--size-xl.avatar--variant-square,\n  .avatar--size-xl.avatar--variant-square .avatar__image,\n  .avatar--size-xl.avatar--variant-square .avatar__initials*/.avatar--size-xl.avatar--variant-square.sc-swirl-avatar,.avatar--size-xl.avatar--variant-square.sc-swirl-avatar .avatar__image.sc-swirl-avatar,.avatar--size-xl.avatar--variant-square.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{border-radius:1rem}/*!@.avatar--size-2xl*/.avatar--size-2xl.sc-swirl-avatar{width:9rem;height:9rem;font-size:3.375rem}/*!@.avatar--size-2xl.avatar--has-icon*/.avatar--size-2xl.avatar--has-icon.sc-swirl-avatar{padding-right:var(--s-space-32);padding-left:var(--s-space-32)}/*!@.avatar--size-2xl.avatar--variant-square,\n  .avatar--size-2xl.avatar--variant-square .avatar__image,\n  .avatar--size-2xl.avatar--variant-square .avatar__initials*/.avatar--size-2xl.avatar--variant-square.sc-swirl-avatar,.avatar--size-2xl.avatar--variant-square.sc-swirl-avatar .avatar__image.sc-swirl-avatar,.avatar--size-2xl.avatar--variant-square.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{border-radius:2.25rem}/*!@.avatar--color-banana .avatar__initials*/.avatar--color-banana.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{color:var(--s-decorative-banana-text);background-color:var(--s-decorative-banana-surface-subdued)}/*!@.avatar--color-blueberry .avatar__initials*/.avatar--color-blueberry.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{color:var(--s-decorative-blueberry-text);background-color:var(--s-decorative-blueberry-surface-subdued)}/*!@.avatar--color-chilli .avatar__initials*/.avatar--color-chilli.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{color:var(--s-decorative-chilli-text);background-color:var(--s-decorative-chilli-surface-subdued)}/*!@.avatar--color-grape .avatar__initials*/.avatar--color-grape.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{color:var(--s-decorative-grape-text);background-color:var(--s-decorative-grape-surface-subdued)}/*!@.avatar--color-kiwi .avatar__initials*/.avatar--color-kiwi.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{color:var(--s-decorative-kiwi-text);background-color:var(--s-decorative-kiwi-surface-subdued)}/*!@.avatar--color-pumpkin .avatar__initials*/.avatar--color-pumpkin.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{color:var(--s-decorative-pumpkin-text);background-color:var(--s-decorative-pumpkin-surface-subdued)}/*!@.avatar--color-radish .avatar__initials*/.avatar--color-radish.sc-swirl-avatar .avatar__initials.sc-swirl-avatar{color:var(--s-decorative-radish-text);background-color:var(--s-decorative-radish-surface-subdued)}/*!@.avatar__image*/.avatar__image.sc-swirl-avatar{overflow:hidden;width:100%;height:100%;border-radius:50%}/*!@.avatar__image > img*/.avatar__image.sc-swirl-avatar>img.sc-swirl-avatar{width:100%;height:100%}/*!@.avatar__icon*/.avatar__icon.sc-swirl-avatar{display:inline-flex}/*!@.avatar__icon > **/.avatar__icon.sc-swirl-avatar>*.sc-swirl-avatar{width:100%;height:100%}/*!@.avatar__icon > *::part(icon)*/.avatar__icon.sc-swirl-avatar>*.sc-swirl-avatar::part(icon){width:100%;height:100%}/*!@.avatar__initials*/.avatar__initials.sc-swirl-avatar{display:inline-flex;width:100%;min-width:0;height:100%;padding-right:0.0625rem;padding-left:0.0625rem;justify-content:center;align-items:center;border-radius:50%;font-weight:var(--s-font-weight-medium)}/*!@.avatar__initials > span*/.avatar__initials.sc-swirl-avatar>span.sc-swirl-avatar{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}/*!@.avatar__badge*/.avatar__badge.sc-swirl-avatar{position:absolute;bottom:0;left:55%;display:inline-flex;min-width:1.5rem;height:1.5rem;transform:translate3d(0, 25%, 0)}/*!@.avatar__badge--position-top*/.avatar__badge--position-top.sc-swirl-avatar{top:0;bottom:auto;transform:translate3d(0, -25%, 0)}/*!@.avatar__label*/.avatar__label.sc-swirl-avatar{margin-top:var(--s-space-4);color:var(--s-icon-default);font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-sm);text-align:center}";

const swirlAvatarSizeMappings = {
  xs: 28,
  s: 32,
  m: 40,
  l: 48,
  xl: 64,
  "2xl": 144,
};
class SwirlAvatar {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.setImageAvailable = () => {
      this.imageAvailable = true;
    };
    this.setImageUnavailable = () => {
      this.imageAvailable = false;
    };
    this.onKeydown = (event) => {
      // The interactive avatar is activated by the space key on the keyup event,
      // but the default action for space is already triggered on keydown. It
      // needs to be prevented to stop scrolling the page before activating the
      // avatar.
      if (event.code === "Space") {
        event.preventDefault();
      }
      else if (event.code === "Enter") {
        event.preventDefault();
        this.element.click();
      }
    };
    this.onKeyup = (event) => {
      if (event.code === "Space") {
        event.preventDefault();
        this.element.click();
      }
    };
    this.badge = undefined;
    this.badgePosition = "bottom";
    this.color = "kiwi";
    this.icon = undefined;
    this.initials = undefined;
    this.interactive = false;
    this.label = undefined;
    this.showLabel = false;
    this.size = "m";
    this.src = undefined;
    this.variant = "round";
    this.imageAvailable = undefined;
  }
  componentDidLoad() {
    this.forceBadgeProps();
  }
  watchSrcProp() {
    this.imageAvailable = undefined;
  }
  forceBadgeProps() {
    if (!Boolean(this.badge)) {
      return;
    }
    const badge = this.badgeEl.querySelector("swirl-badge");
    badge === null || badge === void 0 ? void 0 : badge.setAttribute("size", "m");
  }
  render() {
    const showImage = Boolean(this.src) &&
      (this.imageAvailable || this.imageAvailable === undefined);
    const showInitials = !showImage && Boolean(this.initials);
    const showIcon = !showImage && !showInitials && Boolean(this.icon);
    const showFallbackIcon = !showImage && !showInitials && !showIcon;
    const showBadge = Boolean(this.badge) && this.size === "m";
    const role = this.interactive ? "button" : "img";
    const className = classnames("avatar", `avatar--color-${this.color}`, `avatar--size-${this.size}`, `avatar--variant-${this.variant}`, {
      "avatar--has-icon": showIcon || showFallbackIcon,
      "avatar--has-initials": showInitials,
      "avatar--interactive": this.interactive,
    });
    const badgeClassName = classnames("avatar__badge", `avatar__badge--position-${this.badgePosition}`);
    return (hAsync(Host, { "aria-label": this.label, onKeydown: this.interactive ? this.onKeydown : undefined, onKeyup: this.interactive ? this.onKeyup : undefined, role: role, tabIndex: this.interactive ? 0 : undefined }, hAsync("span", { class: className, part: "avatar" }, showImage && (hAsync("span", { class: "avatar__image" }, hAsync("img", { alt: "", height: swirlAvatarSizeMappings[this.size], onError: this.setImageUnavailable, onLoad: this.setImageAvailable, src: this.src, width: swirlAvatarSizeMappings[this.size] }))), showInitials && (hAsync("span", { class: "avatar__initials" }, hAsync("span", null, this.initials))), showIcon && hAsync("span", { class: "avatar__icon", innerHTML: this.icon }), showFallbackIcon && (hAsync("span", { class: "avatar__icon" }, hAsync("swirl-icon-person", null))), showBadge && (hAsync("span", { class: badgeClassName, innerHTML: this.badge, ref: (el) => (this.badgeEl = el) }))), this.showLabel && (hAsync("span", { "aria-hidden": true, class: "avatar__label" }, this.label))));
  }
  get element() { return getElement(this); }
  static get watchers() { return {
    "src": ["watchSrcProp"]
  }; }
  static get style() { return swirlAvatarCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-avatar",
    "$members$": {
      "badge": [1],
      "badgePosition": [1, "badge-position"],
      "color": [1],
      "icon": [1],
      "initials": [1],
      "interactive": [4],
      "label": [1],
      "showLabel": [4, "show-label"],
      "size": [1],
      "src": [1],
      "variant": [1],
      "imageAvailable": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlAvatarGroupCss = "/*!@:host*/.sc-swirl-avatar-group-h{display:inline-flex}/*!@:host **/.sc-swirl-avatar-group-h *.sc-swirl-avatar-group{box-sizing:border-box}/*!@.avatar-group*/.avatar-group.sc-swirl-avatar-group{position:relative;display:inline-grid;grid-template-rows:repeat(8, 1fr);grid-template-columns:repeat(8, 1fr)}/*!@.avatar-group ::slotted(*:first-of-type)*/.avatar-group .sc-swirl-avatar-group-s>*:first-of-type{z-index:1;display:inline-flex;border:0.25rem solid var(--swirl-avatar-group-border-color);border-radius:50%;grid-column-start:1;grid-column-end:7;grid-row-start:3;grid-row-end:9}/*!@.avatar-group ::slotted(*:nth-of-type(2))*/.avatar-group .sc-swirl-avatar-group-s>*:nth-of-type(2){z-index:0;display:inline-flex;border:0.25rem solid var(--swirl-avatar-group-border-color);border-radius:50%;grid-column-start:3;grid-column-end:9;grid-row-start:1;grid-row-end:7}/*!@.avatar-group__badge*/.avatar-group__badge.sc-swirl-avatar-group{position:absolute;z-index:2;right:0;bottom:0;display:inline-flex;width:1.5rem;height:1.5rem}";

/**
 * @slot slot - Your avatar components
 */
class SwirlAvatarGroup {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.badge = undefined;
  }
  componentDidLoad() {
    this.forceBadgeProps();
  }
  forceBadgeProps() {
    if (!Boolean(this.badge)) {
      return;
    }
    const badge = this.badgeEl.querySelector("swirl-badge");
    badge === null || badge === void 0 ? void 0 : badge.setAttribute("size", "m");
  }
  render() {
    const className = classnames("avatar-group", {
      "avatar-group--has-badge": Boolean(this.badge),
    });
    const badgeClassName = classnames("avatar-group__badge");
    return (hAsync(Host, null, hAsync("div", { class: className, role: "group" }, hAsync("slot", null), this.badge && (hAsync("span", { class: badgeClassName, innerHTML: this.badge, ref: (el) => (this.badgeEl = el) })))));
  }
  static get style() { return swirlAvatarGroupCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-avatar-group",
    "$members$": {
      "badge": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlBadgeCss = "/*!@:host*/.sc-swirl-badge-h{display:inline-flex;min-width:0;max-width:100%;justify-content:center;align-items:center}/*!@:host **/.sc-swirl-badge-h *.sc-swirl-badge{box-sizing:border-box}/*!@.badge*/.badge.sc-swirl-badge{display:inline-flex;max-width:100%;justify-content:center;align-items:center;border:0.25rem solid var(--swirl-badge-border-color);border-radius:2rem;color:var(--s-text-on-status);font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-medium)}/*!@.badge--size-s*/.badge--size-s.sc-swirl-badge{min-width:1.5rem;height:1.5rem;font-size:0.75rem}/*!@.badge--size-s .badge__label*/.badge--size-s.sc-swirl-badge .badge__label.sc-swirl-badge{padding-right:0.1875rem;padding-left:0.1875rem}/*!@.badge--size-s .badge__icon > swirl-icon,\n    .badge--size-s .badge__icon > *::part(icon)*/.badge--size-s.sc-swirl-badge .badge__icon.sc-swirl-badge>swirl-icon.sc-swirl-badge,.badge--size-s.sc-swirl-badge .badge__icon.sc-swirl-badge>*.sc-swirl-badge::part(icon){width:0.75rem;height:0.75rem}/*!@.badge--size-m*/.badge--size-m.sc-swirl-badge{min-width:2rem;height:2rem}/*!@.badge--size-m .badge__label*/.badge--size-m.sc-swirl-badge .badge__label.sc-swirl-badge{padding-right:0.375rem;padding-left:0.375rem}/*!@.badge--has-icon*/.badge--has-icon.sc-swirl-badge{padding-right:0;padding-left:0}/*!@.badge--intent-critical*/.badge--intent-critical.sc-swirl-badge{color:var(--s-text-on-status);background-color:var(--s-surface-critical-default)}/*!@.badge--intent-banana*/.badge--intent-banana.sc-swirl-badge{color:var(--s-text-dark);background-color:var(--s-decorative-banana-surface)}/*!@.badge--intent-blueberry*/.badge--intent-blueberry.sc-swirl-badge{color:var(--s-text-on-status);background-color:var(--s-decorative-blueberry-surface)}/*!@.badge--intent-chilli*/.badge--intent-chilli.sc-swirl-badge{color:var(--s-text-on-status);background-color:var(--s-decorative-chilli-surface)}/*!@.badge--intent-grape*/.badge--intent-grape.sc-swirl-badge{color:var(--s-text-on-status);background-color:var(--s-decorative-grape-surface)}/*!@.badge--intent-kiwi*/.badge--intent-kiwi.sc-swirl-badge{color:var(--s-text-on-status);background-color:var(--s-decorative-kiwi-surface)}/*!@.badge--intent-pumpkin*/.badge--intent-pumpkin.sc-swirl-badge{color:var(--s-text-dark);background-color:var(--s-decorative-pumpkin-surface)}/*!@.badge--intent-radish*/.badge--intent-radish.sc-swirl-badge{color:var(--s-text-on-status);background-color:var(--s-decorative-radish-surface)}/*!@.badge--variant-dot*/.badge--variant-dot.sc-swirl-badge{width:1.25rem;min-width:0;height:1.25rem}/*!@.badge--variant-dot .badge__label*/.badge--variant-dot.sc-swirl-badge .badge__label.sc-swirl-badge{padding-right:0;padding-left:0}/*!@.badge--variant-dot .badge__label,\n  .badge--variant-dot .badge__icon*/.badge--variant-dot.sc-swirl-badge .badge__label.sc-swirl-badge,.badge--variant-dot.sc-swirl-badge .badge__icon.sc-swirl-badge{display:none}/*!@.badge__icon*/.badge__icon.sc-swirl-badge{display:inline-flex}/*!@.badge__icon > swirl-icon,\n  .badge__icon > *::part(icon)*/.badge__icon.sc-swirl-badge>swirl-icon.sc-swirl-badge,.badge__icon.sc-swirl-badge>*.sc-swirl-badge::part(icon){width:1rem;height:1rem}/*!@.badge__label*/.badge__label.sc-swirl-badge{display:inline-flex;overflow:hidden;max-width:100%;white-space:nowrap;text-overflow:ellipsis}";

class SwirlBadge {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.icon = undefined;
    this.intent = "critical";
    this.label = undefined;
    this.size = "m";
    this.variant = "default";
  }
  render() {
    const className = classnames("badge", `badge--intent-${this.intent}`, `badge--size-${this.size}`, `badge--variant-${this.variant}`, {
      "badge--has-icon": this.icon,
    });
    return (hAsync(Host, { role: "status" }, hAsync("span", { class: className }, this.icon && hAsync("span", { class: "badge__icon", innerHTML: this.icon }), this.icon === undefined && (hAsync("span", { class: "badge__label" }, this.label)))));
  }
  static get style() { return swirlBadgeCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-badge",
    "$members$": {
      "icon": [1],
      "intent": [1],
      "label": [1],
      "size": [1],
      "variant": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlBannerCss = "/*!@:host*/.sc-swirl-banner-h{display:block}/*!@:host **/.sc-swirl-banner-h *.sc-swirl-banner{box-sizing:border-box}/*!@.banner*/.banner.sc-swirl-banner{display:flex;max-width:100%;padding:var(--s-space-12);align-items:baseline}/*!@.banner:focus:not(:focus-visible)*/.banner.sc-swirl-banner:focus:not(:focus-visible){outline:none}/*!@.banner:focus-visible*/.banner.sc-swirl-banner:focus-visible{outline-color:var(--s-focus-default);outline-offset:var(--s-space-4)}@media (min-width: 768px){/*!@.banner*/.banner.sc-swirl-banner{padding:var(--s-space-16)}}/*!@.banner--size-s*/.banner--size-s.sc-swirl-banner{padding:var(--s-space-8);justify-content:center}/*!@.banner--size-s .banner__content*/.banner--size-s.sc-swirl-banner .banner__content.sc-swirl-banner{flex-grow:0;text-align:center;margin-right:var(--s-space-8)}/*!@.banner--size-s .banner__controls*/.banner--size-s.sc-swirl-banner .banner__controls.sc-swirl-banner{margin-left:0;margin-right:var(--s-space-4)}/*!@.banner--intent-default .banner__icon,\n  .banner--intent-default .banner__content,\n  .banner--intent-default .banner__action-button,\n  .banner--intent-default .banner__dismiss-button,\n  .banner--intent-critical .banner__icon,\n  .banner--intent-critical .banner__content,\n  .banner--intent-critical .banner__action-button,\n  .banner--intent-critical .banner__dismiss-button,\n  .banner--intent-success .banner__icon,\n  .banner--intent-success .banner__content,\n  .banner--intent-success .banner__action-button,\n  .banner--intent-success .banner__dismiss-button,\n  .banner--intent-info .banner__icon,\n  .banner--intent-info .banner__content,\n  .banner--intent-info .banner__action-button,\n  .banner--intent-info .banner__dismiss-button*/.banner--intent-default.sc-swirl-banner .banner__icon.sc-swirl-banner,.banner--intent-default.sc-swirl-banner .banner__content.sc-swirl-banner,.banner--intent-default.sc-swirl-banner .banner__action-button.sc-swirl-banner,.banner--intent-default.sc-swirl-banner .banner__dismiss-button.sc-swirl-banner,.banner--intent-critical.sc-swirl-banner .banner__icon.sc-swirl-banner,.banner--intent-critical.sc-swirl-banner .banner__content.sc-swirl-banner,.banner--intent-critical.sc-swirl-banner .banner__action-button.sc-swirl-banner,.banner--intent-critical.sc-swirl-banner .banner__dismiss-button.sc-swirl-banner,.banner--intent-success.sc-swirl-banner .banner__icon.sc-swirl-banner,.banner--intent-success.sc-swirl-banner .banner__content.sc-swirl-banner,.banner--intent-success.sc-swirl-banner .banner__action-button.sc-swirl-banner,.banner--intent-success.sc-swirl-banner .banner__dismiss-button.sc-swirl-banner,.banner--intent-info.sc-swirl-banner .banner__icon.sc-swirl-banner,.banner--intent-info.sc-swirl-banner .banner__content.sc-swirl-banner,.banner--intent-info.sc-swirl-banner .banner__action-button.sc-swirl-banner,.banner--intent-info.sc-swirl-banner .banner__dismiss-button.sc-swirl-banner{color:var(--s-text-on-status)}/*!@.banner--intent-default*/.banner--intent-default.sc-swirl-banner{background-color:var(--s-surface-neutral-default)}/*!@.banner--intent-critical*/.banner--intent-critical.sc-swirl-banner{background-color:var(--s-surface-critical-default)}/*!@.banner--intent-success*/.banner--intent-success.sc-swirl-banner{background-color:var(--s-surface-success-default)}/*!@.banner--intent-info*/.banner--intent-info.sc-swirl-banner{background-color:var(--s-surface-info-default)}/*!@.banner--intent-warning*/.banner--intent-warning.sc-swirl-banner{background-color:var(--s-surface-warning-default)}/*!@.banner--intent-warning .banner__icon*/.banner--intent-warning.sc-swirl-banner .banner__icon.sc-swirl-banner{color:var(--s-icon-strong)}/*!@.banner--intent-warning .banner__content,\n  .banner--intent-warning .banner__action-button,\n  .banner--intent-warning .banner__dismiss-button*/.banner--intent-warning.sc-swirl-banner .banner__content.sc-swirl-banner,.banner--intent-warning.sc-swirl-banner .banner__action-button.sc-swirl-banner,.banner--intent-warning.sc-swirl-banner .banner__dismiss-button.sc-swirl-banner{color:var(--s-text-default)}@media (min-width: 375px){/*!@.banner--has-icon .banner__content*/.banner--has-icon.sc-swirl-banner .banner__content.sc-swirl-banner{padding-top:var(--s-space-2)}}/*!@.banner__icon*/.banner__icon.sc-swirl-banner{position:relative;top:var(--s-space-2);display:none;margin-right:var(--s-space-8);color:var(--s-icon-on-status)}@media (min-width: 375px){/*!@.banner__icon*/.banner__icon.sc-swirl-banner{display:inline-flex}}/*!@.banner__content*/.banner__content.sc-swirl-banner{min-height:1.5rem;margin-right:var(--s-space-12);flex-grow:1;line-height:var(--s-line-height-base)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.banner__content*/.banner__content.sc-swirl-banner{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.banner__controls*/.banner__controls.sc-swirl-banner{display:inline-flex;margin-left:var(--s-space-16);align-items:center;line-height:var(--s-line-height-base);gap:var(--s-space-16)}@media (min-width: 768px){/*!@.banner__controls*/.banner__controls.sc-swirl-banner{gap:var(--s-space-24)}}/*!@.banner__action-button,\n.banner__dismiss-button*/.banner__action-button.sc-swirl-banner,.banner__dismiss-button.sc-swirl-banner{display:inline-flex;overflow:hidden;max-width:7rem;height:1.5rem;padding:0;flex-shrink:0;align-items:center;border:none;background-color:transparent;font:inherit;font-weight:var(--s-font-weight-semibold);white-space:nowrap;text-overflow:ellipsis;cursor:pointer}/*!@.banner__action-button:focus, .banner__dismiss-button:focus*/.banner__action-button.sc-swirl-banner:focus,.banner__dismiss-button.sc-swirl-banner:focus{outline-color:var(--s-focus-default)}@media (min-width: 768px){/*!@.banner__action-button,\n.banner__dismiss-button*/.banner__action-button.sc-swirl-banner,.banner__dismiss-button.sc-swirl-banner{max-width:12rem}}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.banner__action-button,\n.banner__dismiss-button*/.banner__action-button.sc-swirl-banner,.banner__dismiss-button.sc-swirl-banner{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}";

const swirlBannerIconMapping = {
  default: undefined,
  critical: "<swirl-icon-error></swirl-icon-error>",
  success: "<swirl-icon-check-circle></swirl-icon-check-circle>",
  warning: "<swirl-icon-warning></swirl-icon-warning>",
  info: "<swirl-icon-info></swirl-icon-info>",
};
class SwirlBanner {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.action = createEvent(this, "action", 7);
    this.dismiss = createEvent(this, "dismiss", 7);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.onAction = (event) => {
      this.action.emit(event);
    };
    this.onDismiss = (event) => {
      this.dismiss.emit(event);
    };
    this.actionLabel = undefined;
    this.content = undefined;
    this.dismissable = false;
    this.dismissLabel = "Dismiss";
    this.importance = "status";
    this.intent = "default";
    this.showIcon = false;
    this.size = "m";
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    var _a, _b;
    const icon = (_a = this.iconEl) === null || _a === void 0 ? void 0 : _a.children[0];
    const dismissButtonIcon = (_b = this.dismissButtonEl) === null || _b === void 0 ? void 0 : _b.children[0];
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", smallIcon ? "20" : "24");
    dismissButtonIcon === null || dismissButtonIcon === void 0 ? void 0 : dismissButtonIcon.setAttribute("size", smallIcon ? "20" : "24");
  }
  render() {
    const icon = swirlBannerIconMapping[this.intent];
    const showControls = Boolean(this.actionLabel) || this.dismissable;
    const showIcon = this.showIcon && Boolean(icon);
    const className = classnames("banner", `banner--intent-${this.intent}`, `banner--size-${this.size}`, {
      "banner--has-icon": showIcon,
    });
    return (hAsync(Host, null, hAsync("div", { "aria-describedby": "content", class: className, role: this.importance, tabIndex: 0 }, showIcon && (hAsync("span", { "aria-hidden": "true", class: "banner__icon", innerHTML: icon, ref: (el) => (this.iconEl = el) })), hAsync("span", { class: "banner__content", id: "content", part: "banner__content" }, this.content), showControls && (hAsync("span", { class: "banner__controls" }, this.actionLabel && (hAsync("button", { class: "banner__action-button", onClick: this.onAction, part: "banner__action-button", type: "button" }, this.actionLabel)), this.dismissable && (hAsync("button", { "aria-label": this.dismissLabel, class: "banner__dismiss-button", onClick: this.onDismiss, part: "banner__dismiss-button", ref: (el) => (this.dismissButtonEl = el), type: "button" }, hAsync("swirl-icon-close", null))))))));
  }
  get element() { return getElement(this); }
  static get style() { return swirlBannerCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-banner",
    "$members$": {
      "actionLabel": [1, "action-label"],
      "content": [1],
      "dismissable": [4],
      "dismissLabel": [1, "dismiss-label"],
      "importance": [1],
      "intent": [1],
      "showIcon": [4, "show-icon"],
      "size": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlBoxCss = "/*!@:host*/.sc-swirl-box-h{display:block;width:100%}/*!@:host(.box--bordered)*/.box--bordered.sc-swirl-box-h{border:var(--s-border-width-default) solid var(--s-border-default)}/*!@:host(.box--cover)*/.box--cover.sc-swirl-box-h{width:100%;height:100%}/*!@:host **/.sc-swirl-box-h *.sc-swirl-box{box-sizing:border-box}";

/**
 * @slot slot - The box contents
 */
class SwirlBox {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.bordered = undefined;
    this.centerBlock = undefined;
    this.centerInline = undefined;
    this.cover = undefined;
    this.maxWidth = undefined;
    this.overflow = "visible";
    this.padding = "0";
    this.paddingBlockEnd = undefined;
    this.paddingBlockStart = undefined;
    this.paddingInlineEnd = undefined;
    this.paddingInlineStart = undefined;
  }
  render() {
    const styles = {
      alignItems: this.centerBlock ? "center" : undefined,
      display: this.centerBlock || this.centerInline ? "flex" : undefined,
      height: this.cover ? "100%" : undefined,
      justifyContent: this.centerInline ? "center" : undefined,
      overflow: this.overflow,
      padding: `var(--s-space-${this.padding})`,
      paddingBlockEnd: Boolean(this.paddingBlockEnd)
        ? `var(--s-space-${this.paddingBlockEnd})`
        : undefined,
      paddingBlockStart: Boolean(this.paddingBlockStart)
        ? `var(--s-space-${this.paddingBlockStart})`
        : undefined,
      paddingInlineEnd: Boolean(this.paddingInlineEnd)
        ? `var(--s-space-${this.paddingInlineEnd})`
        : undefined,
      paddingInlineStart: Boolean(this.paddingInlineStart)
        ? `var(--s-space-${this.paddingInlineStart})`
        : undefined,
      position: Boolean(this.overflow) ? "relative" : "",
      maxWidth: this.maxWidth,
      width: this.cover ? "100%" : undefined,
    };
    const className = classnames("box", {
      "box--bordered": this.bordered,
      "box--cover": this.cover,
    });
    return (hAsync(Host, { class: className, style: styles }, hAsync("slot", null)));
  }
  static get style() { return swirlBoxCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-box",
    "$members$": {
      "bordered": [4],
      "centerBlock": [4, "center-block"],
      "centerInline": [4, "center-inline"],
      "cover": [4],
      "maxWidth": [1, "max-width"],
      "overflow": [1],
      "padding": [1],
      "paddingBlockEnd": [1, "padding-block-end"],
      "paddingBlockStart": [1, "padding-block-start"],
      "paddingInlineEnd": [1, "padding-inline-end"],
      "paddingInlineStart": [1, "padding-inline-start"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlButtonCss = ".sc-swirl-button-h{display:inline-block;max-width:100%;flex-shrink:0}.sc-swirl-button-h *.sc-swirl-button{box-sizing:border-box}.button.sc-swirl-button{display:inline-flex;width:100%;padding:var(--s-space-8) var(--s-space-16);justify-content:center;align-items:center;border:none;border-top-left-radius:var(--swirl-button-border-top-left-radius);border-top-right-radius:var(--swirl-button-border-top-right-radius);border-bottom-right-radius:var(--swirl-button-border-bottom-right-radius);border-bottom-left-radius:var(--swirl-button-border-bottom-left-radius);color:var(--s-text-subdued);background-color:var(--swirl-ghost-button-background-default);font:inherit;font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-lg);text-decoration:none;cursor:pointer;gap:var(--s-space-8)}.button.sc-swirl-button:hover{background-color:var(--swirl-ghost-button-background-hovered)}.button.sc-swirl-button:active{background-color:var(--swirl-ghost-button-background-pressed)}.button.sc-swirl-button:disabled{color:var(--s-text-disabled);background-color:var(--swirl-ghost-button-background-default);cursor:default}.button.sc-swirl-button:disabled .button__icon.sc-swirl-button{color:var(--s-icon-disabled)}.button.sc-swirl-button:focus:not(:focus-visible){outline:none}.button.sc-swirl-button:focus-visible{outline-color:var(--s-focus-default);outline-offset:var(--s-space-2)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.button.sc-swirl-button{padding:var(--s-space-8) var(--s-space-12);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm);gap:var(--s-space-4)}}.button--variant-ghost.button--intent-primary.sc-swirl-button:not(:disabled){color:var(--s-text-highlight)}.button--variant-ghost.button--intent-primary.sc-swirl-button:not(:disabled) .button__icon.sc-swirl-button{color:var(--s-icon-highlight)}.button--variant-ghost.button--intent-critical.sc-swirl-button:not(:disabled){color:var(--s-text-critical)}.button--variant-ghost.button--intent-critical.sc-swirl-button:not(:disabled) .button__icon.sc-swirl-button{color:var(--s-icon-critical)}.button--variant-ghost.button--size-l.sc-swirl-button{padding:var(--s-space-12) var(--s-space-20)}.button--variant-ghost.button--size-l.button--icon-only.sc-swirl-button{padding:var(--s-space-12)}.button--variant-flat.sc-swirl-button{color:var(--s-text-default);background-color:var(--s-action-neutral-default)}.button--variant-flat.sc-swirl-button:hover{background-color:var(--s-action-neutral-hovered)}.button--variant-flat.sc-swirl-button:active{background-color:var(--s-action-neutral-pressed)}.button--variant-flat.sc-swirl-button:disabled{background-color:var(--s-action-neutral-disabled)}.button--variant-flat.button--intent-primary.sc-swirl-button:not(:disabled){color:var(--s-text-on-action-primary);background-color:var(--s-action-primary-default)}.button--variant-flat.button--intent-primary.sc-swirl-button:not(:disabled):hover{background-color:var(--s-action-primary-hovered)}.button--variant-flat.button--intent-primary.sc-swirl-button:not(:disabled):active{background-color:var(--s-action-primary-pressed)}.button--variant-flat.button--intent-primary.sc-swirl-button:not(:disabled) .button__icon.sc-swirl-button{color:var(--s-icon-on-action-primary)}.button--variant-flat.sc-swirl-button .button__icon.sc-swirl-button{color:var(--s-icon-strong)}.button--variant-outline.sc-swirl-button{color:var(--s-action-primary-default);box-shadow:inset 0 0 0 var(--s-border-width-default) var(--s-border-strong)}.button--variant-outline.sc-swirl-button:disabled{box-shadow:inset 0 0 0 var(--s-border-width-default)\n      var(--s-border-default)}.button--variant-outline.button--intent-critical.sc-swirl-button:not(:disabled){color:var(--s-text-critical);box-shadow:inset 0 0 0 var(--s-border-width-default)\n      var(--s-border-critical)}.button--variant-outline.button--intent-critical.sc-swirl-button:not(:disabled) .button__icon.sc-swirl-button{color:var(--s-icon-critical)}.button--variant-outline.button--size-l.sc-swirl-button{padding:var(--s-space-12) var(--s-space-20)}.button--variant-outline.button--size-l.button--icon-only.sc-swirl-button{padding:var(--s-space-12)}.button--variant-outline.sc-swirl-button .button__icon.sc-swirl-button{color:var(--s-action-primary-default)}.button--variant-plain.sc-swirl-button{padding:0;border-radius:0;color:var(--s-interactive-neutral-default);background-color:transparent}.button--variant-plain.sc-swirl-button:hover:not(:disabled){color:var(--s-interactive-neutral-default);background-color:transparent;text-decoration:underline;text-underline-offset:var(--s-space-4)}.button--variant-plain.sc-swirl-button:hover:not(:disabled) .button__icon.sc-swirl-button{color:var(--s-interactive-neutral-default)}.button--variant-plain.sc-swirl-button:active:not(:disabled){color:var(--s-interactive-neutral-hovered);background-color:transparent}.button--variant-plain.sc-swirl-button:active:not(:disabled) .button__icon.sc-swirl-button{color:var(--s-interactive-neutral-hovered)}.button--variant-plain.sc-swirl-button:disabled{color:var(--s-interactive-neutral-disabled);background-color:transparent}.button--variant-plain.sc-swirl-button:disabled .button__icon.sc-swirl-button{color:var(--s-interactive-neutral-disabled)}.button--variant-plain.button--intent-primary.sc-swirl-button{color:var(--s-interactive-primary-default)}.button--variant-plain.button--intent-primary.sc-swirl-button:hover{color:var(--s-interactive-primary-default)}.button--variant-plain.button--intent-primary.sc-swirl-button:hover .button__icon.sc-swirl-button{color:var(--s-interactive-primary-default)}.button--variant-plain.button--intent-primary.sc-swirl-button:active{color:var(--s-interactive-primary-hovered)}.button--variant-plain.button--intent-primary.sc-swirl-button:active .button__icon.sc-swirl-button{color:var(--s-interactive-primary-hovered)}.button--variant-plain.button--intent-primary.sc-swirl-button:disabled{color:var(--s-interactive-primary-disabled)}.button--variant-plain.button--intent-primary.sc-swirl-button:disabled .button__icon.sc-swirl-button{color:var(--s-interactive-primary-disabled)}.button--variant-plain.button--intent-primary.sc-swirl-button .button__icon.sc-swirl-button{color:var(--s-interactive-primary-default)}.button--variant-plain.sc-swirl-button .button__icon.sc-swirl-button{color:var(--s-interactive-neutral-default)}.button--variant-on-image.sc-swirl-button{color:var(--s-text-on-image);background:linear-gradient(0deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)),\n    rgba(255, 255, 255, 0.3)}.button--variant-on-image.sc-swirl-button:hover{background:linear-gradient(0deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)),\n      rgba(255, 255, 255, 0.4)}.button--variant-on-image.sc-swirl-button:active{background:linear-gradient(0deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)),\n      rgba(255, 255, 255, 0.5)}.button--variant-on-image.sc-swirl-button:disabled{color:var(--s-text-on-image);background:linear-gradient(0deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)),\n      rgba(255, 255, 255, 0.3)}.button--variant-on-image.sc-swirl-button:disabled .button__icon.sc-swirl-button{color:var(--s-icon-on-image)}.button--variant-on-image.sc-swirl-button .button__icon.sc-swirl-button{color:var(--s-icon-on-image)}.button--variant-floating.sc-swirl-button{color:var(--s-text-default);background-color:var(--s-surface-overlay-default);box-shadow:var(--s-shadow-level-1)}.button--variant-floating.sc-swirl-button:hover{color:var(--s-text-on-action-primary);background-color:var(--s-surface-overlay-hovered)}.button--variant-floating.sc-swirl-button:active{color:var(--s-text-on-action-primary);background-color:var(--s-surface-overlay-pressed)}.button--variant-floating.button--icon-only.sc-swirl-button{padding:var(--s-space-12)}.button--variant-floating.button--intent-primary.sc-swirl-button{padding:var(--s-space-12) var(--s-space-20);border-radius:1.5rem;color:var(--s-text-on-action-primary);background-color:var(--s-action-primary-default)}.button--variant-floating.button--intent-primary.sc-swirl-button:hover:not(:disabled){color:var(--s-text-on-action-primary);background-color:var(--s-action-primary-hovered)}.button--variant-floating.button--intent-primary.sc-swirl-button:active:not(:disabled){color:var(--s-text-on-action-primary);background-color:var(--s-action-primary-pressed)}.button--variant-floating.button--intent-primary.sc-swirl-button:disabled{color:var(--s-text-on-action-primary)}.button--variant-floating.button--intent-primary.sc-swirl-button:disabled .button__icon.sc-swirl-button{color:var(--s-icon-on-action-primary)}.button--variant-floating.button--intent-primary.button--icon-only.sc-swirl-button{padding:var(--s-space-12)}.button--variant-floating.button--intent-primary.sc-swirl-button .button__icon.sc-swirl-button{color:var(--s-icon-on-action-primary)}.button--variant-floating.sc-swirl-button .button__icon.sc-swirl-button{color:var(--s-icon-strong)}.button--icon-position-end.sc-swirl-button .button__icon.sc-swirl-button{margin-right:calc(-1 * var(--s-space-4));margin-left:0;order:2}.button--pill.sc-swirl-button{border-radius:1.25rem}.button--pill.button--size-l.sc-swirl-button{border-radius:1.5rem}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.button--pill.button--size-l.sc-swirl-button{border-radius:1.375rem}}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.button--pill.sc-swirl-button{border-radius:1.125rem}}.button--icon-only.sc-swirl-button{padding:var(--s-space-8)}.button--icon-only.button--pill.sc-swirl-button{border-top-left-radius:var(--swirl-icon-button-border-top-left-radius);border-top-right-radius:var(--swirl-icon-button-border-top-right-radius);border-bottom-right-radius:var(\n      --swirl-icon-button-border-bottom-right-radius\n    );border-bottom-left-radius:var(\n      --swirl-icon-button-border-bottom-left-radius\n    )}.button--icon-only.sc-swirl-button .button__icon.sc-swirl-button{margin-right:0;margin-left:0}.button__icon.sc-swirl-button{display:inline-flex;margin-left:calc(-1 * var(--s-space-4));color:var(--s-icon-default);order:0}.button__label.sc-swirl-button{overflow:hidden;max-width:100%;white-space:nowrap;text-overflow:ellipsis;order:1}";

class SwirlButton {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.disabled = undefined;
    this.download = undefined;
    this.swirlAriaDescribedby = undefined;
    this.swirlAriaExpanded = undefined;
    this.swirlAriaLabel = undefined;
    this.form = undefined;
    this.hideLabel = undefined;
    this.href = undefined;
    this.icon = undefined;
    this.iconPosition = "start";
    this.intent = "default";
    this.label = undefined;
    this.name = undefined;
    this.pill = undefined;
    this.size = "m";
    this.target = undefined;
    this.type = "button";
    this.value = undefined;
    this.variant = "ghost";
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  componentDidRender() {
    this.forceIconProps(this.desktopMediaQuery.matches);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    if (!Boolean(this.iconEl)) {
      return;
    }
    const icon = this.iconEl.children[0];
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", smallIcon ? "20" : "24");
  }
  getAriaLabel(hideLabel) {
    if (Boolean(this.swirlAriaLabel)) {
      return this.swirlAriaLabel;
    }
    else if (hideLabel) {
      return this.label;
    }
    return undefined;
  }
  render() {
    const hideLabel = (this.hideLabel && Boolean(this.icon)) ||
      (this.variant === "floating" && this.intent === "default");
    const isLink = Boolean(this.href);
    const ariaLabel = this.getAriaLabel(hideLabel);
    const className = classnames("button", `button--icon-position-${this.iconPosition}`, `button--intent-${this.intent}`, `button--size-${this.size}`, `button--variant-${this.variant}`, {
      "button--icon-only": hideLabel,
      "button--pill": this.pill,
    });
    const Tag = isLink ? "a" : "button";
    return (hAsync(Host, { style: { pointerEvents: this.disabled ? "none" : "" } }, hAsync(Tag, { "aria-describedby": this.swirlAriaDescribedby, "aria-disabled": this.disabled && !isLink ? "true" : undefined, "aria-expanded": this.swirlAriaExpanded, "aria-label": ariaLabel, class: className, disabled: isLink ? undefined : this.disabled, download: isLink ? undefined : this.download, form: isLink ? undefined : this.form, href: this.href, name: isLink ? undefined : this.name, target: isLink ? this.target : undefined, type: isLink ? undefined : this.type, value: isLink ? undefined : this.value }, this.icon && (hAsync("span", { class: "button__icon", innerHTML: this.icon, ref: (el) => (this.iconEl = el) })), !hideLabel && hAsync("span", { class: "button__label" }, this.label))));
  }
  static get style() { return swirlButtonCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-button",
    "$members$": {
      "disabled": [4],
      "download": [1],
      "swirlAriaDescribedby": [1, "swirl-aria-describedby"],
      "swirlAriaExpanded": [1, "swirl-aria-expanded"],
      "swirlAriaLabel": [1, "swirl-aria-label"],
      "form": [1],
      "hideLabel": [4, "hide-label"],
      "href": [1],
      "icon": [1],
      "iconPosition": [1, "icon-position"],
      "intent": [1],
      "label": [1],
      "name": [1],
      "pill": [4],
      "size": [1],
      "target": [1],
      "type": [1],
      "value": [1],
      "variant": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlButtonGroupCss = "/*!@:host*/.sc-swirl-button-group-h{display:block}/*!@:host **/.sc-swirl-button-group-h *.sc-swirl-button-group{box-sizing:border-box}/*!@.button-group--segmented ::slotted(*:not(:last-child))*/.button-group--segmented .sc-swirl-button-group-s>*:not(:last-child){position:relative}/*!@.button-group--segmented ::slotted(*:not(:last-child)):after*/.button-group--segmented .sc-swirl-button-group-s>*:not(:last-child):after{position:absolute;z-index:1;top:50%;left:100%;width:var(--s-border-width-default);height:calc(100% - var(--s-space-16));background-color:var(--s-border-strong);content:\"\";transform:translate3d(-50%, -50%, 0);pointer-events:none}/*!@.button-group--segmented ::slotted(*:not(:last-child):not([disabled])[intent=\"primary\"]):after*/.button-group--segmented .sc-swirl-button-group-s>*:not(:last-child):not([disabled])[intent=\"primary\"]:after{background-color:var(--s-text-on-action-primary)}/*!@.button-group--segmented ::slotted(*:not(:last-child)[disabled=\"false\"][intent=\"primary\"]):after*/.button-group--segmented .sc-swirl-button-group-s>*:not(:last-child)[disabled=\"false\"][intent=\"primary\"]:after{background-color:var(--s-text-on-action-primary)}/*!@.button-group--segmented ::slotted(*:not(:first-child):not(:last-child))*/.button-group--segmented .sc-swirl-button-group-s>*:not(:first-child):not(:last-child){--swirl-button-border-top-right-radius:0;--swirl-button-border-top-left-radius:0;--swirl-button-border-bottom-right-radius:0;--swirl-button-border-bottom-left-radius:0;--swirl-icon-button-border-top-right-radius:0;--swirl-icon-button-border-top-left-radius:0;--swirl-icon-button-border-bottom-right-radius:0;--swirl-icon-button-border-bottom-left-radius:0}/*!@.button-group--segmented ::slotted(*:first-child)*/.button-group--segmented .sc-swirl-button-group-s>*:first-child{--swirl-button-border-top-right-radius:0;--swirl-button-border-bottom-right-radius:0;--swirl-icon-button-border-top-right-radius:0;--swirl-icon-button-border-bottom-right-radius:0;--swirl-icon-button-border-top-left-radius:var(--s-border-radius-base);--swirl-icon-button-border-bottom-left-radius:var(--s-border-radius-base)}/*!@.button-group--segmented ::slotted(*:last-child)*/.button-group--segmented .sc-swirl-button-group-s>*:last-child{--swirl-button-border-top-left-radius:0;--swirl-button-border-bottom-left-radius:0;--swirl-icon-button-border-top-right-radius:var(--s-border-radius-base);--swirl-icon-button-border-bottom-right-radius:var(--s-border-radius-base);--swirl-icon-button-border-top-left-radius:0;--swirl-icon-button-border-bottom-left-radius:0}";

class SwirlButtonGroup {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.orientation = "horizontal";
    this.segmented = undefined;
    this.stretch = undefined;
    this.wrap = undefined;
  }
  render() {
    const spacing = this.segmented ? "0" : "8";
    const className = classnames("button-group", {
      "button-group--segmented": this.segmented,
    });
    return (hAsync(Host, null, hAsync("swirl-stack", { align: this.orientation === "vertical" && this.stretch
        ? "stretch"
        : "start", class: className, justify: this.orientation === "horizontal" && this.stretch
        ? "stretch"
        : "start", orientation: this.orientation, role: "group", spacing: spacing, wrap: this.wrap }, hAsync("slot", null))));
  }
  static get style() { return swirlButtonGroupCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-button-group",
    "$members$": {
      "orientation": [1],
      "segmented": [4],
      "stretch": [4],
      "wrap": [4]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlCardCss = "/*!@:host*/.sc-swirl-card-h{display:block}/*!@:host **/.sc-swirl-card-h *.sc-swirl-card{box-sizing:border-box}/*!@.card*/.card.sc-swirl-card{display:flex;overflow:hidden;width:100%;margin:0;padding:0;border:var(--s-border-width-default) solid var(--s-border-default);border-radius:var(--s-border-radius-base);color:var(--s-text-default);background-color:var(--s-surface-default);font:inherit;text-decoration:none;flex-direction:column;--swirl-ghost-button-background-default:var(--s-surface-default);--swirl-ghost-button-background-hovered:var(--s-surface-hovered);--swirl-ghost-button-background-pressed:var(--s-surface-pressed)}/*!@a.card,\nbutton.card,\n.card--interactive*/a.card.sc-swirl-card,button.card.sc-swirl-card,.card--interactive.sc-swirl-card{cursor:pointer}/*!@a.card:hover, button.card:hover, .card--interactive:hover*/a.card.sc-swirl-card:hover,button.card.sc-swirl-card:hover,.card--interactive.sc-swirl-card:hover{background-color:var(--s-surface-hovered)}/*!@a.card:active, button.card:active, .card--interactive:active*/a.card.sc-swirl-card:active,button.card.sc-swirl-card:active,.card--interactive.sc-swirl-card:active{background-color:var(--s-surface-pressed)}/*!@a.card:focus:not(:focus-visible), button.card:focus:not(:focus-visible), .card--interactive:focus:not(:focus-visible)*/a.card.sc-swirl-card:focus:not(:focus-visible),button.card.sc-swirl-card:focus:not(:focus-visible),.card--interactive.sc-swirl-card:focus:not(:focus-visible){outline:none}/*!@a.card:focus-visible, button.card:focus-visible, .card--interactive:focus-visible*/a.card.sc-swirl-card:focus-visible,button.card.sc-swirl-card:focus-visible,.card--interactive.sc-swirl-card:focus-visible{outline-color:var(--s-focus-default);outline-offset:var(--s-space-4)}/*!@.card--is--borderless*/.card--is--borderless.sc-swirl-card{border:0}/*!@.card--elevated*/.card--elevated.sc-swirl-card{border-color:transparent;box-shadow:0 0.75rem 1rem rgba(25, 26, 28, 0.12),\n    0 0.25rem 0.75rem rgba(25, 26, 28, 0.08)}/*!@.card--highlighted*/.card--highlighted.sc-swirl-card{border-width:0.1875rem;border-color:var(--s-border-highlight)}/*!@.card--justify-content-start .card__body*/.card--justify-content-start.sc-swirl-card .card__body.sc-swirl-card{justify-content:flex-start}/*!@.card--justify-content-center .card__body*/.card--justify-content-center.sc-swirl-card .card__body.sc-swirl-card{justify-content:center}/*!@.card--justify-content-end .card__body*/.card--justify-content-end.sc-swirl-card .card__body.sc-swirl-card{justify-content:flex-end}/*!@:not(.card--has-image) .card__image*/.sc-swirl-card:not(.card--has-image) .card__image.sc-swirl-card{overflow:hidden;height:0}/*!@.card--intent-critical-subdued*/.card--intent-critical-subdued.sc-swirl-card{background-color:var(--s-surface-critical-subdued)}/*!@.card--intent-info-subdued*/.card--intent-info-subdued.sc-swirl-card{background-color:var(--s-surface-info-subdued)}/*!@.card--intent-success-subdued*/.card--intent-success-subdued.sc-swirl-card{background-color:var(--s-surface-success-subdued)}/*!@.card--intent-warning-subdued*/.card--intent-warning-subdued.sc-swirl-card{background-color:var(--s-surface-warning-subdued)}/*!@.content-section*/.content-section.sc-swirl-card{padding:0 var(--s-space-16)}/*!@.card__image*/.card__image.sc-swirl-card{overflow:hidden;min-height:0}/*!@.card__image ::slotted(img)*/.card__image .sc-swirl-card-s>img{display:inline-flex;width:100%;max-height:100%;-o-object-fit:cover;object-fit:cover}/*!@.card__body*/.card__body.sc-swirl-card{display:flex;min-height:0;padding:var(--s-space-12) var(--s-space-16) var(--s-space-16);flex-grow:1;flex-direction:column;gap:var(--s-space-16)}/*!@.card__header*//*!@.card__content*/";

const swirlCardBorderRadiusTokens = ["xs", "sm", "base", "l", "xl"];
/**
 * @slot slot - The card contents
 */
class SwirlCard {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.as = "div";
    this.borderRadius = "base";
    this.elevated = undefined;
    this.height = undefined;
    this.highlighted = undefined;
    this.href = undefined;
    this.imageAspectRatio = undefined;
    this.intent = "default";
    this.isBorderless = undefined;
    this.interactive = undefined;
    this.justifyContent = "start";
    this.linkTarget = undefined;
    this.padding = undefined;
    this.paddingBlockEnd = undefined;
    this.paddingBlockStart = undefined;
    this.paddingInlineEnd = undefined;
    this.paddingInlineStart = undefined;
    this.swirlAriaLabel = undefined;
  }
  render() {
    const Tag = Boolean(this.href) ? "a" : this.as;
    const hasImage = Boolean(this.el.querySelector('[slot="image"]'));
    const styles = {
      borderRadius: swirlCardBorderRadiusTokens.includes(this.borderRadius)
        ? `var(--s-border-radius-${this.borderRadius})`
        : this.borderRadius,
      height: this.height,
    };
    const bodyStyles = {
      padding: Boolean(this.padding)
        ? `var(--s-space-${this.padding})`
        : undefined,
      paddingBlockEnd: Boolean(this.paddingBlockEnd)
        ? `var(--s-space-${this.paddingBlockEnd})`
        : undefined,
      paddingBlockStart: Boolean(this.paddingBlockStart)
        ? `var(--s-space-${this.paddingBlockStart})`
        : undefined,
      paddingInlineEnd: Boolean(this.paddingInlineEnd)
        ? `var(--s-space-${this.paddingInlineEnd})`
        : undefined,
      paddingInlineStart: Boolean(this.paddingInlineStart)
        ? `var(--s-space-${this.paddingInlineStart})`
        : undefined,
    };
    const className = classnames("card", `card--intent-${this.intent}`, `card--justify-content-${this.justifyContent}`, {
      "card--elevated": this.elevated,
      "card--has-image": hasImage,
      "card--highlighted": this.highlighted,
      "card--interactive": this.interactive || this.href,
      "card--is--borderless": this.isBorderless,
    });
    return (hAsync(Host, { styles: { height: this.height } }, hAsync(Tag, { "aria-label": this.swirlAriaLabel, class: className, href: this.href, rel: Boolean(this.href) && this.linkTarget === "_blank"
        ? "noreferrer"
        : undefined, style: styles, target: this.linkTarget }, hAsync("div", { class: "card__image", style: { aspectRatio: this.imageAspectRatio } }, hAsync("slot", { name: "image" })), hAsync("div", { class: "card__body", style: bodyStyles }, hAsync("div", { class: "card__content" }, hAsync("slot", { name: "content" }))))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlCardCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-card",
    "$members$": {
      "as": [1],
      "borderRadius": [1, "border-radius"],
      "elevated": [4],
      "height": [1],
      "highlighted": [4],
      "href": [1],
      "imageAspectRatio": [1, "image-aspect-ratio"],
      "intent": [1],
      "isBorderless": [4, "is-borderless"],
      "interactive": [4],
      "justifyContent": [1, "justify-content"],
      "linkTarget": [1, "link-target"],
      "padding": [1],
      "paddingBlockEnd": [1, "padding-block-end"],
      "paddingBlockStart": [1, "padding-block-start"],
      "paddingInlineEnd": [1, "padding-inline-end"],
      "paddingInlineStart": [1, "padding-inline-start"],
      "swirlAriaLabel": [1, "swirl-aria-label"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlCarouselCss = "/*!@:host*/.sc-swirl-carousel-h{position:relative;display:block;overflow:hidden;width:100%;margin-top:calc(-1 * var(--s-space-24));margin-bottom:calc(-1 * var(--s-space-24))}/*!@:host(:hover) .carousel__previous-slide-button*/.sc-swirl-carousel-h:hover .carousel__previous-slide-button.sc-swirl-carousel{pointer-events:auto;opacity:1}/*!@:host(:hover) .carousel__next-slide-button*/.sc-swirl-carousel-h:hover .carousel__next-slide-button.sc-swirl-carousel{pointer-events:auto;opacity:1}/*!@:host **/.sc-swirl-carousel-h *.sc-swirl-carousel{box-sizing:border-box}/*!@.carousel*/.carousel.sc-swirl-carousel{position:relative;overflow:hidden;width:100%}/*!@.carousel__slides*/.carousel__slides.sc-swirl-carousel{position:relative;display:flex;overflow-x:auto;overflow-y:hidden;width:100%;padding:var(--s-space-24) var(--s-space-16) var(--s-space-24)\n    var(--s-space-16);scroll-padding:var(--s-space-16);scrollbar-width:none;scroll-snap-type:x mandatory;scroll-behavior:smooth}/*!@.carousel__slides::-webkit-scrollbar*/.carousel__slides.sc-swirl-carousel::-webkit-scrollbar{display:none}/*!@.carousel__slides ::slotted(*)*/.carousel__slides .sc-swirl-carousel-s>*{margin-left:var(--s-space-16);flex-grow:0;flex-shrink:0;scroll-snap-align:start}@media (min-width: 768px){/*!@.carousel__slides ::slotted(*)*/.carousel__slides .sc-swirl-carousel-s>*{margin-left:var(--s-space-24)}}@media (min-width: 768px){/*!@.carousel__slides*/.carousel__slides.sc-swirl-carousel{padding-right:var(--s-space-24);padding-left:var(--s-space-24);scroll-padding:var(--s-space-24)}}/*!@.carousel__previous-slide-button*/.carousel__previous-slide-button.sc-swirl-carousel{position:absolute;z-index:1;top:calc(50% - var(--s-space-12));left:var(--s-space-4);visibility:hidden;transition:opacity 0.2s;transform:translateY(-50%) scale(0.72);pointer-events:none;opacity:0}@media (min-width: 768px){/*!@.carousel__previous-slide-button*/.carousel__previous-slide-button.sc-swirl-carousel{visibility:visible}}/*!@.carousel__next-slide-button*/.carousel__next-slide-button.sc-swirl-carousel{position:absolute;z-index:1;top:calc(50% - var(--s-space-12));right:var(--s-space-4);visibility:hidden;transition:opacity 0.2s;transform:translateY(-50%) scale(0.72);pointer-events:none;opacity:0}@media (min-width: 768px){/*!@.carousel__next-slide-button*/.carousel__next-slide-button.sc-swirl-carousel{visibility:visible}}";

/**
 * slot - The slides
 */
class SwirlCarousel {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activeSlidesChange = createEvent(this, "activeSlidesChange", 7);
    this.activeSlides = [];
    this.updateActiveSlideReferences = debounce(() => {
      const activeSlides = this.getActiveSlides();
      const activeSlidesChanged = activeSlides.some((slide, index) => this.activeSlides[index] !== slide);
      if (activeSlidesChanged) {
        this.activeSlides = activeSlides;
        this.activeSlidesChange.emit(this.activeSlides);
      }
    }, 100);
    this.onPreviousSlideButtonClick = () => {
      this.previousSlide();
    };
    this.onNextSlideButtonClick = () => {
      this.nextSlide();
    };
    this.onSlotChange = () => {
      var _a;
      // restore scroll position to active slide when slides are removed or added after first render
      (_a = this.activeSlides[0]) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: "nearest", inline: "start" });
    };
    this.onScroll = () => {
      this.updateActiveSlideReferences();
      this.checkScrollPosition();
    };
    this.label = undefined;
    this.nextSlideButtonLabel = "Next slide";
    this.previousSlideButtonLabel = "Previous slide";
    this.loopAround = false;
    this.isAtEnd = undefined;
    this.isAtStart = undefined;
    this.isScrollable = undefined;
  }
  onWindowResize() {
    this.checkScrollStatus();
  }
  componentDidLoad() {
    queueMicrotask(() => {
      this.checkScrollStatus();
      this.checkScrollPosition();
    });
  }
  /**
   * Scroll to slide with id.
   */
  async scrollToSlide(id) {
    const slides = this.getSlides();
    const slide = slides.find((slide) => slide.id === id);
    if (!Boolean(slide)) {
      return;
    }
    slide.scrollIntoView({ block: "nearest", inline: "start" });
  }
  previousSlide() {
    const slides = this.getSlides();
    const activeSlides = this.getActiveSlides();
    const previouSlide = activeSlides[0].previousElementSibling ||
      (this.loopAround ? slides[slides.length - 1] : activeSlides[0]);
    previouSlide === null || previouSlide === void 0 ? void 0 : previouSlide.scrollIntoView({ block: "nearest", inline: "start" });
  }
  nextSlide() {
    const slides = this.getSlides();
    const activeSlides = this.getActiveSlides();
    const isAtEnd = !Boolean(activeSlides[activeSlides.length - 1].nextElementSibling);
    const nextSlide = isAtEnd && this.loopAround
      ? slides[0]
      : activeSlides[0].nextElementSibling;
    nextSlide === null || nextSlide === void 0 ? void 0 : nextSlide.scrollIntoView({ block: "nearest", inline: "start" });
  }
  getSlides() {
    return Array.from(this.el.querySelectorAll("swirl-carousel-slide"));
  }
  getActiveSlides() {
    const slides = this.getSlides();
    return slides.filter((slide) => this.checkInView(slide));
  }
  checkScrollStatus() {
    this.isScrollable =
      this.slidesContainer.scrollWidth > this.slidesContainer.offsetWidth;
  }
  checkScrollPosition() {
    const slides = this.getSlides();
    const activeSlides = this.getActiveSlides();
    const isAtStart = activeSlides[0] === slides[0];
    const isAtEnd = activeSlides[activeSlides.length - 1] === slides[slides.length - 1];
    if (isAtStart !== this.isAtStart) {
      this.isAtStart = isAtStart;
    }
    if (isAtEnd !== this.isAtEnd) {
      this.isAtEnd = isAtEnd;
    }
  }
  checkInView(element) {
    let containerLeft = this.slidesContainer.scrollLeft;
    let containerRight = containerLeft + this.slidesContainer.clientWidth;
    let elementLeft = element.offsetLeft;
    let elementRight = elementLeft + element.clientWidth;
    let inInView = elementLeft >= containerLeft && elementRight <= containerRight;
    return inInView;
  }
  render() {
    return (hAsync(Host, { "aria-label": this.label, "aria-roledescription": "carousel", role: "group" }, hAsync("div", { class: "carousel" }, this.isScrollable && !this.isAtStart && (hAsync("swirl-button", { class: "carousel__previous-slide-button", hideLabel: true, icon: "<swirl-icon-arrow-back></swirl-icon-arrow-back>", label: this.previousSlideButtonLabel, onClick: this.onPreviousSlideButtonClick, pill: true, variant: "floating" })), this.isScrollable && !this.isAtEnd && (hAsync("swirl-button", { class: "carousel__next-slide-button", hideLabel: true, icon: "<swirl-icon-arrow-forward></swirl-icon-arrow-forward>", label: this.nextSlideButtonLabel, onClick: this.onNextSlideButtonClick, pill: true, variant: "floating" })), hAsync("div", { "aria-live": "polite", class: "carousel__slides", onScroll: this.onScroll, ref: (el) => (this.slidesContainer = el) }, hAsync("slot", { onSlotchange: this.onSlotChange })))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlCarouselCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-carousel",
    "$members$": {
      "label": [1],
      "nextSlideButtonLabel": [1, "next-slide-button-label"],
      "previousSlideButtonLabel": [1, "previous-slide-button-label"],
      "loopAround": [4, "loop-around"],
      "isAtEnd": [32],
      "isAtStart": [32],
      "isScrollable": [32],
      "scrollToSlide": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlCarouselSlideCss = "/*!@:host*/.sc-swirl-carousel-slide-h{display:block;min-width:0}/*!@:host(.carousel-slide--has-min-height) ::slotted(*)*/.sc-swirl-carousel-slide-h.carousel-slide--has-min-height .sc-swirl-carousel-slide-s>*{height:100%}/*!@:host **/.sc-swirl-carousel-slide-h *.sc-swirl-carousel-slide{box-sizing:border-box}/*!@:host ::slotted(*)*/.sc-swirl-carousel-slide-h .sc-swirl-carousel-slide-s>*{width:100%;min-height:100%}";

/**
 * slot - The slide contents
 */
class SwirlCarouselSlide {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.label = undefined;
    this.minHeight = undefined;
    this.width = "15.5rem";
  }
  render() {
    const className = classnames("carousel-slide", {
      "carousel-slide--has-min-height": Boolean(this.minHeight),
    });
    return (hAsync(Host, { "aria-roledescription": "slide", "aria-label": this.label, class: className, role: "group", style: { flexBasis: this.width, minHeight: this.minHeight }, tabIndex: 0 }, hAsync("slot", null)));
  }
  static get style() { return swirlCarouselSlideCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-carousel-slide",
    "$members$": {
      "label": [1],
      "minHeight": [1, "min-height"],
      "width": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlCheckboxCss = ".sc-swirl-checkbox-h{display:inline-flex}.sc-swirl-checkbox-h *.sc-swirl-checkbox{box-sizing:border-box}.checkbox.sc-swirl-checkbox{display:inline-flex;line-height:var(--s-line-height-base);cursor:pointer}.checkbox.sc-swirl-checkbox:focus-within .checkbox__box.sc-swirl-checkbox{box-shadow:0 0 0 0.0625rem var(--s-background-default),\n      0 0 0 0.1875rem var(--s-focus-default)}.checkbox--checked.sc-swirl-checkbox .checkbox__control.sc-swirl-checkbox:hover .checkbox__box.sc-swirl-checkbox,.checkbox--indeterminate.sc-swirl-checkbox .checkbox__control.sc-swirl-checkbox:hover .checkbox__box.sc-swirl-checkbox{border-color:var(--s-interactive-primary-hovered);background-color:var(--s-interactive-primary-hovered)}.checkbox--checked.sc-swirl-checkbox .checkbox__box.sc-swirl-checkbox,.checkbox--indeterminate.sc-swirl-checkbox .checkbox__box.sc-swirl-checkbox{border-color:var(--s-icon-highlight);color:var(--s-text-on-status);background-color:var(--s-icon-highlight)}.checkbox--invalid.checkbox--checked.sc-swirl-checkbox .checkbox__box.sc-swirl-checkbox,.checkbox--invalid.checkbox--indeterminate.sc-swirl-checkbox .checkbox__box.sc-swirl-checkbox{background-color:var(--s-icon-critical)}.checkbox--invalid.sc-swirl-checkbox .checkbox__box.sc-swirl-checkbox{border-color:var(--s-icon-critical)}.checkbox--disabled.sc-swirl-checkbox{cursor:default}.checkbox--disabled.checkbox--checked.sc-swirl-checkbox .checkbox__control.sc-swirl-checkbox:hover .checkbox__box.sc-swirl-checkbox,.checkbox--disabled.checkbox--indeterminate.sc-swirl-checkbox .checkbox__control.sc-swirl-checkbox:hover .checkbox__box.sc-swirl-checkbox{border-color:var(--s-icon-disabled);background-color:var(--s-icon-disabled)}.checkbox--disabled.checkbox--checked.sc-swirl-checkbox .checkbox__box.sc-swirl-checkbox,.checkbox--disabled.checkbox--indeterminate.sc-swirl-checkbox .checkbox__box.sc-swirl-checkbox{background-color:var(--s-icon-disabled)}.checkbox--disabled.sc-swirl-checkbox .checkbox__control.sc-swirl-checkbox:hover .checkbox__box.sc-swirl-checkbox{background-color:transparent}.checkbox--disabled.sc-swirl-checkbox .checkbox__box.sc-swirl-checkbox{border-color:var(--s-icon-disabled)}.checkbox--disabled.sc-swirl-checkbox .checkbox__label.sc-swirl-checkbox,.checkbox--disabled.sc-swirl-checkbox .checkbox__description.sc-swirl-checkbox{color:var(--s-text-disabled)}.checkbox__control.sc-swirl-checkbox{position:relative;width:1.5rem;height:1.5rem;padding:var(--s-space-2);flex-shrink:0}.checkbox__control.sc-swirl-checkbox:hover .checkbox__box.sc-swirl-checkbox{background-color:var(--s-action-neutral-hovered)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.checkbox__control.sc-swirl-checkbox{width:1.375rem;height:1.375rem}}.checkbox__box.sc-swirl-checkbox{position:relative;z-index:1;display:flex;width:100%;height:100%;justify-content:center;align-items:center;border:0.125rem solid var(--s-icon-default);border-radius:var(--s-border-radius-s)}.checkbox__icon.sc-swirl-checkbox{display:inline-flex;width:1.0625rem;height:1.0625rem}.checkbox__icon.sc-swirl-checkbox>*.sc-swirl-checkbox::part(icon){width:1.0625rem;height:1.0625rem}.checkbox__indeterminate-icon.sc-swirl-checkbox{position:relative;width:100%;height:100%}.checkbox__indeterminate-icon.sc-swirl-checkbox:after{position:absolute;top:50%;left:50%;width:0.625rem;height:0.125rem;border-radius:0.0625rem;background-color:currentColor;content:\"\";transform:translate3d(-50%, -50%, 0)}.checkbox__label-container.sc-swirl-checkbox{display:inline-flex;margin-left:var(--s-space-8);padding-top:var(--s-space-2);align-items:flex-start;flex-direction:column}.checkbox__label.sc-swirl-checkbox{font-weight:var(--s-font-weight-medium)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.checkbox__label.sc-swirl-checkbox{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.checkbox__description.sc-swirl-checkbox{color:var(--s-text-subdued)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.checkbox__description.sc-swirl-checkbox{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}";

class SwirlCheckbox {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.onChange = () => {
      this.checked =
        this.checked === true || this.checked === "true" ? false : true;
      this.valueChange.emit(this.checked);
    };
    this.checked = false;
    this.description = undefined;
    this.disabled = false;
    this.swirlAriaDescribedby = undefined;
    this.swirlAriaLabel = undefined;
    this.inputId = undefined;
    this.inputName = undefined;
    this.invalid = undefined;
    this.label = undefined;
    this.value = undefined;
  }
  getAriaCheckedLabel(checked, unchecked) {
    if (checked) {
      return "true";
    }
    else if (unchecked) {
      return "false";
    }
    return "mixed";
  }
  render() {
    const unchecked = this.checked === false || this.checked === "false";
    const checked = this.checked === true || this.checked === "true";
    const indeterminate = this.checked === "indeterminate";
    const showLabelContainer = Boolean(this.label) || Boolean(this.description);
    const ariaCheckedLabel = this.getAriaCheckedLabel(checked, unchecked);
    const ariaInvalid = this.invalid === true || this.invalid === false
      ? String(this.invalid)
      : undefined;
    const className = classnames("checkbox", {
      "checkbox--checked": checked,
      "checkbox--disabled": this.disabled,
      "checkbox--indeterminate": indeterminate,
      "checkbox--invalid": this.invalid,
      "checkbox--unchecked": unchecked,
    });
    return (hAsync(Host, null, hAsync("label", { class: className, htmlFor: this.inputId }, hAsync("span", { class: "checkbox__control" }, hAsync("swirl-visually-hidden", null, hAsync("input", { "aria-checked": ariaCheckedLabel, "aria-describedby": this.swirlAriaDescribedby, "aria-invalid": ariaInvalid, "aria-label": this.swirlAriaLabel, checked: checked, class: "checkbox__input", disabled: this.disabled, id: this.inputId, indeterminate: indeterminate, name: this.inputName, onChange: this.onChange, type: "checkbox", value: this.value })), hAsync("span", { "aria-hidden": "true", class: "checkbox__box" }, hAsync("span", { class: "checkbox__icon" }, checked && hAsync("swirl-icon-check-strong", null), indeterminate && (hAsync("span", { class: "checkbox__indeterminate-icon" }))))), showLabelContainer && (hAsync("span", { class: "checkbox__label-container" }, this.label && hAsync("span", { class: "checkbox__label" }, this.label), this.description && (hAsync("span", { class: "checkbox__description" }, this.description)))))));
  }
  static get style() { return swirlCheckboxCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-checkbox",
    "$members$": {
      "checked": [1032],
      "description": [1],
      "disabled": [4],
      "swirlAriaDescribedby": [1, "swirl-aria-describedby"],
      "swirlAriaLabel": [1, "swirl-aria-label"],
      "inputId": [1, "input-id"],
      "inputName": [1, "input-name"],
      "invalid": [4],
      "label": [1],
      "value": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlChipCss = "/*!@:host*/.sc-swirl-chip-h{display:inline-flex;max-width:100%}/*!@:host **/.sc-swirl-chip-h *.sc-swirl-chip{box-sizing:border-box}/*!@.chip*/.chip.sc-swirl-chip{display:inline-flex;max-width:100%;height:2.5rem;padding-right:var(--s-space-16);padding-left:var(--s-space-16);align-items:center;border:0.0625rem solid var(--s-border-default);border-radius:1.25rem;color:var(--s-text-subdued);background-color:var(--s-surface-overlay-default);font:inherit;font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-sm)}/*!@.chip--interactive*/.chip--interactive.sc-swirl-chip{cursor:pointer}/*!@.chip--interactive:hover*/.chip--interactive.sc-swirl-chip:hover{background-color:var(--s-surface-overlay-hovered)}/*!@.chip--interactive:hover ::part(avatar)*/.chip--interactive.sc-swirl-chip:hover .sc-swirl-chip::part(avatar){background-color:var(--s-surface-raised-hovered)}/*!@.chip--interactive:active*/.chip--interactive.sc-swirl-chip:active{background-color:var(--s-surface-overlay-pressed)}/*!@.chip--interactive:active ::part(avatar)*/.chip--interactive.sc-swirl-chip:active .sc-swirl-chip::part(avatar){background-color:var(--s-surface-raised-pressed)}/*!@.chip--intent-critical*/.chip--intent-critical.sc-swirl-chip{border-color:var(--s-border-critical);color:var(--s-text-critical)}/*!@.chip--intent-critical .chip__icon*/.chip--intent-critical.sc-swirl-chip .chip__icon.sc-swirl-chip{color:var(--s-icon-critical)}/*!@.chip--intent-success*/.chip--intent-success.sc-swirl-chip{border-color:var(--s-border-success);color:var(--s-text-success)}/*!@.chip--intent-success .chip__icon*/.chip--intent-success.sc-swirl-chip .chip__icon.sc-swirl-chip{color:var(--s-icon-success)}/*!@.chip--variant-plain*/.chip--variant-plain.sc-swirl-chip{height:auto;padding-right:0;padding-left:0;border:none;border-radius:0;background-color:transparent}/*!@.chip--variant-plain.chip--interactive:hover*/.chip--variant-plain.chip--interactive.sc-swirl-chip:hover{background-color:transparent;text-decoration:underline;text-underline-offset:var(--s-space-4)}/*!@.chip--variant-plain.chip--interactive:hover ::part(avatar)*/.chip--variant-plain.chip--interactive.sc-swirl-chip:hover .sc-swirl-chip::part(avatar){background-color:var(--s-surface-raised-hovered)}/*!@.chip--variant-plain.chip--interactive:active*/.chip--variant-plain.chip--interactive.sc-swirl-chip:active{background-color:transparent}/*!@.chip--variant-plain.chip--interactive:active ::part(avatar)*/.chip--variant-plain.chip--interactive.sc-swirl-chip:active .sc-swirl-chip::part(avatar){background-color:var(--s-surface-raised-pressed)}/*!@.chip__avatar,\n.chip__icon*/.chip__avatar.sc-swirl-chip,.chip__icon.sc-swirl-chip{display:inline-flex;margin-right:var(--s-space-8);flex-shrink:0}/*!@.chip__avatar*/.chip__avatar.sc-swirl-chip{overflow:hidden;width:1.75rem;height:1.75rem;margin-left:-0.625rem}/*!@.chip__icon*/.chip__icon.sc-swirl-chip{margin-left:-0.25rem;color:var(--s-icon-default)}/*!@.chip__label*/.chip__label.sc-swirl-chip{overflow:hidden;flex-grow:1;white-space:nowrap;text-overflow:ellipsis}";

/**
 * @slot avatar - Optional avatar displayed inside the chip. Should have size "xs".
 */
class SwirlChip {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.icon = undefined;
    this.intent = "default";
    this.interactive = false;
    this.label = undefined;
    this.variant = "outline";
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    if (!Boolean(this.iconEl)) {
      return;
    }
    const icon = this.iconEl.children[0];
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", smallIcon ? "20" : "24");
  }
  render() {
    const Tag = this.interactive ? "button" : "span";
    const showAvatar = Boolean(this.el.querySelector('[slot="avatar"]'));
    const showIcon = !showAvatar && Boolean(this.icon);
    const className = classnames("chip", `chip--intent-${this.intent}`, `chip--variant-${this.variant}`, {
      "chip--interactive": this.interactive,
    });
    return (hAsync(Host, null, hAsync(Tag, { class: className, type: this.interactive ? "button" : undefined }, showAvatar && (hAsync("span", { class: "chip__avatar" }, hAsync("slot", { name: "avatar" }))), showIcon && (hAsync("span", { class: "chip__icon", innerHTML: this.icon, ref: (el) => (this.iconEl = el) })), hAsync("span", { class: "chip__label" }, this.label))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlChipCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-chip",
    "$members$": {
      "icon": [1],
      "intent": [1],
      "interactive": [4],
      "label": [1],
      "variant": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlColumnsCss = "/*!@:host*/.sc-swirl-columns-h{display:block}/*!@:host **/.sc-swirl-columns-h *.sc-swirl-columns{box-sizing:border-box}/*!@.columns*/.columns.sc-swirl-columns{display:grid;width:100%}";

class SwirlColumns {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.columns = "repeat(3, minmax(0, 1fr))";
    this.spacing = undefined;
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { class: "columns", style: {
        gridTemplateColumns: this.columns,
        gap: `var(--s-space-${this.spacing})`,
      } }, hAsync("slot", null))));
  }
  static get style() { return swirlColumnsCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-columns",
    "$members$": {
      "columns": [1],
      "spacing": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlConsoleLayoutCss = "/*!@:host*/.sc-swirl-console-layout-h{display:block;width:100%;height:100vh}/*!@:host **/.sc-swirl-console-layout-h *.sc-swirl-console-layout{box-sizing:border-box}/*!@.console-layout*/.console-layout.sc-swirl-console-layout{display:grid;width:100%;height:100%;grid-template-columns:1fr;grid-template-areas:\"main\"}@media (min-width: 768px){/*!@.console-layout*/.console-layout.sc-swirl-console-layout{grid-template-columns:20rem 1fr;grid-template-areas:\"sidebar main\"}}@media (max-width: 767px){/*!@.console-layout--sidebar-active .console-layout__sidebar*/.console-layout--sidebar-active.sc-swirl-console-layout .console-layout__sidebar.sc-swirl-console-layout{transform:translate3d(0, 0, 0);box-shadow:0 0 1rem rgba(0, 0, 0, 0.06)}}@media (min-width: 768px){/*!@.console-layout--empty-app-bar .console-layout__main*/.console-layout--empty-app-bar.sc-swirl-console-layout .console-layout__main.sc-swirl-console-layout{grid-template-areas:\"content\";grid-template-rows:1fr}}@media (min-width: 768px){/*!@.console-layout--empty-app-bar .console-layout__app-bar*/.console-layout--empty-app-bar.sc-swirl-console-layout .console-layout__app-bar.sc-swirl-console-layout{display:none}}/*!@.console-layout__sidebar*/.console-layout__sidebar.sc-swirl-console-layout{position:fixed;z-index:var(--s-z-30);top:4rem;bottom:0;left:0;display:grid;overflow-x:hidden;overflow-y:auto;width:100%;max-width:20rem;border-right:var(--s-border-width-default) solid var(--s-border-default);transition:transform 0.15s, box-shadow 0.15s;transform:translate3d(-100%, 0, 0);grid-template-rows:auto 1fr auto;grid-template-areas:\"header\"\n    \"navigation\"\n    \"user\"}@media (prefers-reduced-motion){/*!@.console-layout__sidebar*/.console-layout__sidebar.sc-swirl-console-layout{transition:none}}@media (min-width: 768px){/*!@.console-layout__sidebar*/.console-layout__sidebar.sc-swirl-console-layout{position:static;top:auto;left:auto;max-width:none;height:100%;transform:none;box-shadow:none;grid-area:sidebar}}/*!@.console-layout__header*/.console-layout__header.sc-swirl-console-layout{overflow:hidden;min-width:0;padding:var(--s-space-20) var(--s-space-24);background-color:var(--s-background-default);grid-area:header}/*!@.console-layout__navigation*/.console-layout__navigation.sc-swirl-console-layout{overflow-x:hidden;overflow-y:auto;padding-top:var(--s-space-8);padding-bottom:var(--s-space-8);background-color:var(--s-background-default);grid-area:navigation}/*!@.console-layout__user*/.console-layout__user.sc-swirl-console-layout{overflow:hidden;margin-top:var(--s-border-width-default);padding:var(--s-space-16) var(--s-space-24) var(--s-space-24);border-top:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-background-default);grid-area:user}/*!@.console-layout__main*/.console-layout__main.sc-swirl-console-layout{display:grid;overflow-x:hidden;overflow-y:auto;width:100%;height:100%;grid-area:main;gap:var(--s-border-width-default);grid-template-rows:4rem 1fr;grid-template-areas:\"app-bar\"\n    \"content\"}/*!@.console-layout__app-bar*/.console-layout__app-bar.sc-swirl-console-layout{position:sticky;z-index:var(--s-z-30);top:0;display:flex;min-width:0;padding-right:var(--s-space-16);padding-left:var(--s-space-16);align-items:center;border-bottom:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-background-default);gap:var(--s-space-12);grid-area:app-bar}@media (min-width: 768px){/*!@.console-layout__app-bar*/.console-layout__app-bar.sc-swirl-console-layout{padding-right:2.5rem;padding-left:2.5rem}}@media (min-width: 768px){/*!@.console-layout__mobile-navigation-button*/.console-layout__mobile-navigation-button.sc-swirl-console-layout{display:none}}/*!@.console-layout__app-name*/.console-layout__app-name.sc-swirl-console-layout{min-width:0;flex-grow:1}/*!@.console-layout__app-name .heading*/.console-layout__app-name.sc-swirl-console-layout .heading.sc-swirl-console-layout{overflow:hidden;font-weight:var(--s-font-weight-regular);white-space:nowrap;text-overflow:ellipsis}/*!@.console-layout__help-button*/.console-layout__help-button.sc-swirl-console-layout{flex-shrink:0}/*!@.console-layout__content*/.console-layout__content.sc-swirl-console-layout{display:flex;min-width:0;padding:var(--s-space-16);background-color:var(--s-background-default);flex-direction:column;grid-area:content}@media (min-width: 768px){/*!@.console-layout__content*/.console-layout__content.sc-swirl-console-layout{padding:2.5rem}}/*!@.console-layout__integration*/.console-layout__integration.sc-swirl-console-layout{flex-grow:1}/*!@.console-layout__logo*/.console-layout__logo.sc-swirl-console-layout{display:flex;min-width:0;align-items:center;gap:var(--s-space-12)}/*!@.console-layout__logo-mark*/.console-layout__logo-mark.sc-swirl-console-layout{flex-shrink:0}/*!@.console-layout__logo-text*/.console-layout__logo-text.sc-swirl-console-layout{min-width:0}/*!@.console-layout__logo-text::part(text)*/.console-layout__logo-text.sc-swirl-console-layout::part(text){overflow:hidden;white-space:nowrap;text-overflow:ellipsis}/*!@.console-layout__content-header*/.console-layout__content-header.sc-swirl-console-layout{display:flex;margin-bottom:var(--s-space-24);flex-shrink:0;gap:var(--s-space-16)}/*!@.console-layout__back-button*/.console-layout__back-button.sc-swirl-console-layout{position:relative;top:calc(-1 * var(--s-space-2));flex-shrink:0}/*!@.console-layout__heading-container*/.console-layout__heading-container.sc-swirl-console-layout{flex-grow:1}/*!@.console-layout__subheading*/.console-layout__subheading.sc-swirl-console-layout{margin-top:var(--s-space-8)}/*!@.console-layout__content-header-tools*/.console-layout__content-header-tools.sc-swirl-console-layout{display:flex;flex-shrink:0}";

class SwirlConsoleLayout {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.backButtonClick = createEvent(this, "backButtonClick", 7);
    this.helpButtonClick = createEvent(this, "helpButtonClick", 7);
    this.onBackButtonClick = (event) => {
      this.backButtonClick.emit(event);
    };
    this.onHelpButtonClick = (event) => {
      this.helpButtonClick.emit(event);
    };
    this.onMobileNavigationToggleClick = () => {
      this.toggleSidebar();
    };
    this.onClick = (event) => {
      var _a;
      const target = event.target;
      const clickOnToggle = Boolean(target.closest(".console-layout__mobile-navigation-button"));
      const clickOnOverlay = ((_a = target.closest("[slot]")) === null || _a === void 0 ? void 0 : _a.slot) === "overlays";
      const clickInsideSidebar = event.composedPath().includes(this.sidebarEl);
      if (!clickInsideSidebar &&
        !clickOnToggle &&
        !clickOnOverlay &&
        this.sidebarActive) {
        this.deactivateSidebar();
      }
    };
    this.onKeyDown = (event) => {
      if (event.code === "Escape" && this.sidebarActive) {
        this.deactivateSidebar();
      }
    };
    this.appName = undefined;
    this.backButonLabel = "Back";
    this.heading = undefined;
    this.helpButonLabel = "Help";
    this.hideNavigationButtonLabel = "Hide main navigation";
    this.logoText = "Admin";
    this.showNavigationButtonLabel = "Show main navigation";
    this.navigationLabel = "Main";
    this.showBackButton = undefined;
    this.showHelpButton = undefined;
    this.subheading = undefined;
    this.sidebarActive = undefined;
  }
  componentDidLoad() {
    queueMicrotask(() => {
      if (!isMobileViewport()) {
        this.activateSidebar();
      }
      else {
        this.deactivateSidebar();
      }
    });
  }
  onWindowResize() {
    const mobileViewport = isMobileViewport();
    if (!mobileViewport && !this.sidebarActive) {
      this.activateSidebar();
    }
    else if (mobileViewport) {
      this.deactivateSidebar();
    }
  }
  /**
   * Toggle the mobile navigation visibility.
   */
  async toggleSidebar() {
    if (this.sidebarActive) {
      this.deactivateSidebar();
    }
    else {
      this.activateSidebar();
    }
  }
  /**
   * Show the mobile navigation.
   */
  async showSidebar() {
    if (!this.sidebarActive) {
      this.activateSidebar();
    }
  }
  /**
   * Hide the mobile navigation.
   */
  async hideSidebar() {
    if (this.sidebarActive) {
      this.deactivateSidebar();
    }
  }
  activateSidebar() {
    var _a;
    this.sidebarActive = true;
    this.sidebarEl.removeAttribute("inert");
    if (isMobileViewport()) {
      (_a = this.el.querySelector("swirl-tree-navigation-item")) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }
  deactivateSidebar() {
    this.sidebarActive = false;
    if (isMobileViewport()) {
      this.sidebarEl.setAttribute("inert", "");
    }
  }
  render() {
    const className = classnames("console-layout", {
      "console-layout--sidebar-active": this.sidebarActive,
      "console-layout--empty-app-bar": !Boolean(this.appName) && !this.showHelpButton,
    });
    return (hAsync(Host, null, hAsync("div", { class: className, onClick: this.onClick, onKeyDown: this.onKeyDown }, hAsync("div", { "aria-hidden": String(!this.sidebarActive), class: "console-layout__sidebar", ref: (el) => (this.sidebarEl = el) }, hAsync("header", { class: "console-layout__header" }, hAsync("div", { class: "console-layout__logo" }, hAsync("svg", { class: "console-layout__logo-mark", fill: "none", height: "26", viewBox: "0 0 16 26", width: "16", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { d: "M0.624238 14.0705C0.326496 13.5353 0.118077 12.9406 0.0287543 12.3161C-0.0307941 11.662 -0.0010199 11.0375 0.147851 10.4428C0.296722 9.84813 0.594464 9.25343 0.951754 8.77767C1.33882 8.27217 1.78543 7.85588 2.35114 7.55853L14.6181 0.362671C14.9159 0.8979 15.1243 1.4926 15.2136 2.11703C15.3029 2.74147 15.2434 3.3659 15.0945 3.99034C14.9456 4.58504 14.6479 5.17974 14.2906 5.6555C13.9035 6.16099 13.4569 6.57728 12.8912 6.87463L0.624238 14.0705Z", fill: "#145AF5" }), hAsync("path", { d: "M3.69214 21.4743C3.3944 20.9391 3.18598 20.3444 3.09666 19.72C3.00733 19.0956 3.06688 18.4711 3.21575 17.8467C3.36462 17.252 3.66237 16.6573 4.01966 16.1815C4.40672 15.676 4.85333 15.2597 5.41904 14.9624L12.2076 10.9779C12.5053 11.5131 12.7137 12.1078 12.803 12.7323C12.8924 13.3567 12.8328 13.9811 12.6839 14.6056C12.5351 15.2003 12.2373 15.795 11.88 16.2707C11.493 16.7762 11.0464 17.1925 10.4807 17.4899L3.69214 21.4743Z", fill: "#145AF5" }), hAsync("path", { d: "M3.69141 21.4739L7.77047 19.0951C8.39573 20.1953 8.5446 21.5036 8.24686 22.7228C7.91934 23.9419 7.14521 24.9826 6.04357 25.6368L3.69141 21.4739Z", fill: "#80A8F4" }), hAsync("path", { d: "M12.2072 10.9785L7.32419 10.1459L0.625 14.0709L5.38887 14.9629L12.2072 10.9785Z", fill: "#80A8F4" })), hAsync("swirl-text", { class: "console-layout__logo-text", weight: "medium" }, this.logoText))), hAsync("nav", { "aria-label": this.navigationLabel, class: "console-layout__navigation" }, hAsync("slot", { name: "navigation" })), hAsync("div", { class: "console-layout__user" }, hAsync("slot", { name: "user" }))), hAsync("main", { "aria-labelledby": Boolean(this.appName) ? "app-name" : undefined, class: "console-layout__main" }, hAsync("header", { class: "console-layout__app-bar" }, hAsync("span", { class: "console-layout__mobile-navigation-button" }, hAsync("swirl-button", { swirlAriaExpanded: String(this.sidebarActive), hideLabel: true, icon: this.sidebarActive
        ? "<swirl-icon-close></swirl-icon-close>"
        : "<swirl-icon-menu></swirl-icon-menu>", label: this.sidebarActive
        ? this.hideNavigationButtonLabel
        : this.showNavigationButtonLabel, onClick: this.onMobileNavigationToggleClick })), hAsync("div", { class: "console-layout__app-name" }, this.appName && (hAsync("swirl-heading", { as: "h1", headingId: "app-name", level: 4, text: this.appName }))), this.showHelpButton && (hAsync("swirl-button", { class: "console-layout__help-button", hideLabel: true, icon: "<swirl-icon-help></swirl-icon-help>", label: this.helpButonLabel, onClick: this.onHelpButtonClick }))), hAsync("section", { "aria-labelledby": "heading", class: "console-layout__content" }, hAsync("header", { class: "console-layout__content-header" }, this.showBackButton && (hAsync("swirl-button", { class: "console-layout__back-button", hideLabel: true, icon: "<swirl-icon-arrow-back></swirl-icon-arrow-back>", label: this.backButonLabel, onClick: this.onBackButtonClick })), hAsync("div", { class: "console-layout__heading-container" }, hAsync("swirl-heading", { as: "h2", class: "console-layout__heading", headingId: "heading", level: 1, text: this.heading }), this.subheading && (hAsync("swirl-text", { class: "console-layout__subheading", color: "subdued" }, this.subheading))), hAsync("div", { class: "console-layout__content-header-tools" }, hAsync("slot", { name: "content-header-tools" }))), hAsync("div", { class: "console-layout__integration" }, hAsync("slot", { name: "content" }))), hAsync("div", { class: "console-layout__overlays" }, hAsync("slot", { name: "overlays" }))))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlConsoleLayoutCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-console-layout",
    "$members$": {
      "appName": [1, "app-name"],
      "backButonLabel": [1, "back-buton-label"],
      "heading": [1],
      "helpButonLabel": [1, "help-buton-label"],
      "hideNavigationButtonLabel": [1, "hide-navigation-button-label"],
      "logoText": [1, "logo-text"],
      "showNavigationButtonLabel": [1, "show-navigation-button-label"],
      "navigationLabel": [1, "navigation-label"],
      "showBackButton": [4, "show-back-button"],
      "showHelpButton": [4, "show-help-button"],
      "subheading": [1],
      "sidebarActive": [32],
      "toggleSidebar": [64],
      "showSidebar": [64],
      "hideSidebar": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

function _typeof$z(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$z = function _typeof(obj) { return typeof obj; }; } else { _typeof$z = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$z(obj); }
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || _typeof$z(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInMinute = 60000;
/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInHour = 3600000;
/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInSecond = 1000;

function _typeof$y(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$y = function _typeof(obj) { return typeof obj; }; } else { _typeof$y = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$y(obj); }
/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof$y(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);

  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

var MILLISECONDS_IN_DAY = 86400000;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters$1 = {
  // Year
  y: function y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};

var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */
var formatters = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function y(date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return formatters$1.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date); // Padding

    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function M(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return formatters$1.M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = getUTCWeek(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = getUTCISOWeek(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d(date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return formatters$1.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function a(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function h(date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return formatters$1.h(date, token);
  },
  // Hour [0-23]
  H: function H(date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return formatters$1.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m(date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return formatters$1.m(date, token);
  },
  // Second
  s: function s(date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return formatters$1.s(date, token);
  },
  // Fraction of second
  S: function S(date, token) {
    return formatters$1.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};

var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};

var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex$1(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex$1(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: formatDistance,
  formatLong: formatLong,
  formatRelative: formatRelative,
  localize: localize,
  match: match,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale$1.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale$1.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = toDate(dirtyDate);

  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale$1,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp$1).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }

    var formatter = formatters[firstCharacter];

    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }

      return formatter(utcDate, substring, locale$1.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString$1(input) {
  var matched = input.match(escapedStringRegExp$1);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp$1, "'");
}

function assign(target, object) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }

  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }

  return target;
}

function _typeof$x(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$x = function _typeof(obj) { return typeof obj; }; } else { _typeof$x = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$x(obj); }

function _inherits$v(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$v(subClass, superClass); }

function _setPrototypeOf$v(o, p) { _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$v(o, p); }

function _createSuper$v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$v(); return function _createSuperInternal() { var Super = _getPrototypeOf$v(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$v(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$v(this, result); }; }

function _possibleConstructorReturn$v(self, call) { if (call && (_typeof$x(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$v(self); }

function _assertThisInitialized$v(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$v(o) { _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$v(o); }

function _classCallCheck$w(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$w(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$w(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$w(Constructor.prototype, protoProps); if (staticProps) _defineProperties$w(Constructor, staticProps); return Constructor; }

function _defineProperty$x(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /*#__PURE__*/function () {
  function Setter() {
    _classCallCheck$w(this, Setter);

    _defineProperty$x(this, "subPriority", 0);
  }

  _createClass$w(Setter, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);

  return Setter;
}();
var ValueSetter = /*#__PURE__*/function (_Setter) {
  _inherits$v(ValueSetter, _Setter);

  var _super = _createSuper$v(ValueSetter);

  function ValueSetter(value, validateValue, setValue, priority, subPriority) {
    var _this;

    _classCallCheck$w(this, ValueSetter);

    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;

    if (subPriority) {
      _this.subPriority = subPriority;
    }

    return _this;
  }

  _createClass$w(ValueSetter, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);

  return ValueSetter;
}(Setter);
var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
  _inherits$v(DateToSystemTimezoneSetter, _Setter2);

  var _super2 = _createSuper$v(DateToSystemTimezoneSetter);

  function DateToSystemTimezoneSetter() {
    var _this2;

    _classCallCheck$w(this, DateToSystemTimezoneSetter);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));

    _defineProperty$x(_assertThisInitialized$v(_this2), "priority", TIMEZONE_UNIT_PRIORITY);

    _defineProperty$x(_assertThisInitialized$v(_this2), "subPriority", -1);

    return _this2;
  }

  _createClass$w(DateToSystemTimezoneSetter, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }

      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);

  return DateToSystemTimezoneSetter;
}(Setter);

function _classCallCheck$v(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$v(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$v(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$v(Constructor.prototype, protoProps); if (staticProps) _defineProperties$v(Constructor, staticProps); return Constructor; }
var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck$v(this, Parser);
  }

  _createClass$v(Parser, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result = this.parse(dateString, token, match, options);

      if (!result) {
        return null;
      }

      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);

  return Parser;
}();

function _typeof$w(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$w = function _typeof(obj) { return typeof obj; }; } else { _typeof$w = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$w(obj); }

function _classCallCheck$u(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$u(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$u(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$u(Constructor.prototype, protoProps); if (staticProps) _defineProperties$u(Constructor, staticProps); return Constructor; }

function _inherits$u(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$u(subClass, superClass); }

function _setPrototypeOf$u(o, p) { _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$u(o, p); }

function _createSuper$u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$u(); return function _createSuperInternal() { var Super = _getPrototypeOf$u(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$u(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$u(this, result); }; }

function _possibleConstructorReturn$u(self, call) { if (call && (_typeof$w(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$u(self); }

function _assertThisInitialized$u(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$u(o) { _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$u(o); }

function _defineProperty$w(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var EraParser = /*#__PURE__*/function (_Parser) {
  _inherits$u(EraParser, _Parser);

  var _super = _createSuper$u(EraParser);

  function EraParser() {
    var _this;

    _classCallCheck$u(this, EraParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$w(_assertThisInitialized$u(_this), "priority", 140);

    _defineProperty$w(_assertThisInitialized$u(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);

    return _this;
  }

  _createClass$u(EraParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(dateString, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(dateString, {
            width: 'wide'
          }) || match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return EraParser;
}(Parser);

var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  } // Input is 'Z'


  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }

  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);

    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);

    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case 'morning':
      return 4;

    case 'evening':
      return 17;

    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;

    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;

  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

function _typeof$v(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$v = function _typeof(obj) { return typeof obj; }; } else { _typeof$v = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$v(obj); }

function _classCallCheck$t(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$t(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$t(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$t(Constructor.prototype, protoProps); if (staticProps) _defineProperties$t(Constructor, staticProps); return Constructor; }

function _inherits$t(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$t(subClass, superClass); }

function _setPrototypeOf$t(o, p) { _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$t(o, p); }

function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = _getPrototypeOf$t(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$t(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$t(this, result); }; }

function _possibleConstructorReturn$t(self, call) { if (call && (_typeof$v(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$t(self); }

function _assertThisInitialized$t(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$t(o) { _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$t(o); }

function _defineProperty$v(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
var YearParser = /*#__PURE__*/function (_Parser) {
  _inherits$t(YearParser, _Parser);

  var _super = _createSuper$t(YearParser);

  function YearParser() {
    var _this;

    _classCallCheck$t(this, YearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$v(_assertThisInitialized$t(_this), "priority", 130);

    _defineProperty$v(_assertThisInitialized$t(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$t(YearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };

      switch (token) {
        case 'y':
          return mapValue(parseNDigits(4, dateString), valueCallback);

        case 'yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);

        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return YearParser;
}(Parser);

function _typeof$u(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$u = function _typeof(obj) { return typeof obj; }; } else { _typeof$u = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$u(obj); }

function _classCallCheck$s(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$s(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$s(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$s(Constructor.prototype, protoProps); if (staticProps) _defineProperties$s(Constructor, staticProps); return Constructor; }

function _inherits$s(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$s(subClass, superClass); }

function _setPrototypeOf$s(o, p) { _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$s(o, p); }

function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf$s(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$s(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$s(this, result); }; }

function _possibleConstructorReturn$s(self, call) { if (call && (_typeof$u(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$s(self); }

function _assertThisInitialized$s(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$s(o) { _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$s(o); }

function _defineProperty$u(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// Local week-numbering year
var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$s(LocalWeekYearParser, _Parser);

  var _super = _createSuper$s(LocalWeekYearParser);

  function LocalWeekYearParser() {
    var _this;

    _classCallCheck$s(this, LocalWeekYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$u(_assertThisInitialized$s(_this), "priority", 130);

    _defineProperty$u(_assertThisInitialized$s(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);

    return _this;
  }

  _createClass$s(LocalWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };

      switch (token) {
        case 'Y':
          return mapValue(parseNDigits(4, dateString), valueCallback);

        case 'Yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);

        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);

  return LocalWeekYearParser;
}(Parser);

function _typeof$t(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$t = function _typeof(obj) { return typeof obj; }; } else { _typeof$t = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$t(obj); }

function _classCallCheck$r(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$r(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$r(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$r(Constructor.prototype, protoProps); if (staticProps) _defineProperties$r(Constructor, staticProps); return Constructor; }

function _inherits$r(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$r(subClass, superClass); }

function _setPrototypeOf$r(o, p) { _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$r(o, p); }

function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf$r(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$r(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$r(this, result); }; }

function _possibleConstructorReturn$r(self, call) { if (call && (_typeof$t(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$r(self); }

function _assertThisInitialized$r(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$r(o) { _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$r(o); }

function _defineProperty$t(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$r(ISOWeekYearParser, _Parser);

  var _super = _createSuper$r(ISOWeekYearParser);

  function ISOWeekYearParser() {
    var _this;

    _classCallCheck$r(this, ISOWeekYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$t(_assertThisInitialized$r(_this), "priority", 130);

    _defineProperty$t(_assertThisInitialized$r(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$r(ISOWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'R') {
        return parseNDigitsSigned(4, dateString);
      }

      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);

  return ISOWeekYearParser;
}(Parser);

function _typeof$s(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$s = function _typeof(obj) { return typeof obj; }; } else { _typeof$s = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$s(obj); }

function _classCallCheck$q(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$q(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$q(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$q(Constructor.prototype, protoProps); if (staticProps) _defineProperties$q(Constructor, staticProps); return Constructor; }

function _inherits$q(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$q(subClass, superClass); }

function _setPrototypeOf$q(o, p) { _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$q(o, p); }

function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf$q(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$q(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$q(this, result); }; }

function _possibleConstructorReturn$q(self, call) { if (call && (_typeof$s(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$q(self); }

function _assertThisInitialized$q(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$q(o) { _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$q(o); }

function _defineProperty$s(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$q(ExtendedYearParser, _Parser);

  var _super = _createSuper$q(ExtendedYearParser);

  function ExtendedYearParser() {
    var _this;

    _classCallCheck$q(this, ExtendedYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$s(_assertThisInitialized$q(_this), "priority", 130);

    _defineProperty$s(_assertThisInitialized$q(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$q(ExtendedYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'u') {
        return parseNDigitsSigned(4, dateString);
      }

      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return ExtendedYearParser;
}(Parser);

function _typeof$r(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$r = function _typeof(obj) { return typeof obj; }; } else { _typeof$r = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$r(obj); }

function _classCallCheck$p(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$p(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$p(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$p(Constructor.prototype, protoProps); if (staticProps) _defineProperties$p(Constructor, staticProps); return Constructor; }

function _inherits$p(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$p(subClass, superClass); }

function _setPrototypeOf$p(o, p) { _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$p(o, p); }

function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf$p(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$p(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$p(this, result); }; }

function _possibleConstructorReturn$p(self, call) { if (call && (_typeof$r(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$p(self); }

function _assertThisInitialized$p(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$p(o) { _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$p(o); }

function _defineProperty$r(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var QuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits$p(QuarterParser, _Parser);

  var _super = _createSuper$p(QuarterParser);

  function QuarterParser() {
    var _this;

    _classCallCheck$p(this, QuarterParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$r(_assertThisInitialized$p(_this), "priority", 120);

    _defineProperty$r(_assertThisInitialized$p(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$p(QuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return QuarterParser;
}(Parser);

function _typeof$q(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$q = function _typeof(obj) { return typeof obj; }; } else { _typeof$q = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$q(obj); }

function _classCallCheck$o(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$o(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$o(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$o(Constructor.prototype, protoProps); if (staticProps) _defineProperties$o(Constructor, staticProps); return Constructor; }

function _inherits$o(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$o(subClass, superClass); }

function _setPrototypeOf$o(o, p) { _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$o(o, p); }

function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf$o(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$o(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$o(this, result); }; }

function _possibleConstructorReturn$o(self, call) { if (call && (_typeof$q(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$o(self); }

function _assertThisInitialized$o(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$o(o) { _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$o(o); }

function _defineProperty$q(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits$o(StandAloneQuarterParser, _Parser);

  var _super = _createSuper$o(StandAloneQuarterParser);

  function StandAloneQuarterParser() {
    var _this;

    _classCallCheck$o(this, StandAloneQuarterParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$q(_assertThisInitialized$o(_this), "priority", 120);

    _defineProperty$q(_assertThisInitialized$o(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$o(StandAloneQuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneQuarterParser;
}(Parser);

function _typeof$p(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$p = function _typeof(obj) { return typeof obj; }; } else { _typeof$p = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$p(obj); }

function _classCallCheck$n(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$n(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$n(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$n(Constructor.prototype, protoProps); if (staticProps) _defineProperties$n(Constructor, staticProps); return Constructor; }

function _inherits$n(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$n(subClass, superClass); }

function _setPrototypeOf$n(o, p) { _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$n(o, p); }

function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf$n(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$n(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$n(this, result); }; }

function _possibleConstructorReturn$n(self, call) { if (call && (_typeof$p(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$n(self); }

function _assertThisInitialized$n(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$n(o) { _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$n(o); }

function _defineProperty$p(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var MonthParser = /*#__PURE__*/function (_Parser) {
  _inherits$n(MonthParser, _Parser);

  var _super = _createSuper$n(MonthParser);

  function MonthParser() {
    var _this;

    _classCallCheck$n(this, MonthParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$p(_assertThisInitialized$n(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    _defineProperty$p(_assertThisInitialized$n(_this), "priority", 110);

    return _this;
  }

  _createClass$n(MonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return MonthParser;
}(Parser);

function _typeof$o(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$o = function _typeof(obj) { return typeof obj; }; } else { _typeof$o = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$o(obj); }

function _classCallCheck$m(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$m(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$m(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$m(Constructor.prototype, protoProps); if (staticProps) _defineProperties$m(Constructor, staticProps); return Constructor; }

function _inherits$m(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$m(subClass, superClass); }

function _setPrototypeOf$m(o, p) { _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$m(o, p); }

function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf$m(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$m(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$m(this, result); }; }

function _possibleConstructorReturn$m(self, call) { if (call && (_typeof$o(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$m(self); }

function _assertThisInitialized$m(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$m(o) { _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$m(o); }

function _defineProperty$o(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
  _inherits$m(StandAloneMonthParser, _Parser);

  var _super = _createSuper$m(StandAloneMonthParser);

  function StandAloneMonthParser() {
    var _this;

    _classCallCheck$m(this, StandAloneMonthParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$o(_assertThisInitialized$m(_this), "priority", 110);

    _defineProperty$o(_assertThisInitialized$m(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$m(StandAloneMonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneMonthParser;
}(Parser);

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function _typeof$n(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$n = function _typeof(obj) { return typeof obj; }; } else { _typeof$n = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$n(obj); }

function _classCallCheck$l(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$l(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$l(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$l(Constructor.prototype, protoProps); if (staticProps) _defineProperties$l(Constructor, staticProps); return Constructor; }

function _inherits$l(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$l(subClass, superClass); }

function _setPrototypeOf$l(o, p) { _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$l(o, p); }

function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf$l(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$l(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$l(this, result); }; }

function _possibleConstructorReturn$l(self, call) { if (call && (_typeof$n(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$l(self); }

function _assertThisInitialized$l(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$l(o) { _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$l(o); }

function _defineProperty$n(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LocalWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits$l(LocalWeekParser, _Parser);

  var _super = _createSuper$l(LocalWeekParser);

  function LocalWeekParser() {
    var _this;

    _classCallCheck$l(this, LocalWeekParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$n(_assertThisInitialized$l(_this), "priority", 100);

    _defineProperty$n(_assertThisInitialized$l(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);

    return _this;
  }

  _createClass$l(LocalWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, dateString);

        case 'wo':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);

  return LocalWeekParser;
}(Parser);

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function _typeof$m(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$m = function _typeof(obj) { return typeof obj; }; } else { _typeof$m = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$m(obj); }

function _classCallCheck$k(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$k(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$k(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$k(Constructor.prototype, protoProps); if (staticProps) _defineProperties$k(Constructor, staticProps); return Constructor; }

function _inherits$k(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$k(subClass, superClass); }

function _setPrototypeOf$k(o, p) { _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$k(o, p); }

function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf$k(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$k(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$k(this, result); }; }

function _possibleConstructorReturn$k(self, call) { if (call && (_typeof$m(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$k(self); }

function _assertThisInitialized$k(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$k(o) { _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$k(o); }

function _defineProperty$m(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits$k(ISOWeekParser, _Parser);

  var _super = _createSuper$k(ISOWeekParser);

  function ISOWeekParser() {
    var _this;

    _classCallCheck$k(this, ISOWeekParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$m(_assertThisInitialized$k(_this), "priority", 100);

    _defineProperty$m(_assertThisInitialized$k(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$k(ISOWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, dateString);

        case 'Io':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);

  return ISOWeekParser;
}(Parser);

function _typeof$l(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$l = function _typeof(obj) { return typeof obj; }; } else { _typeof$l = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$l(obj); }

function _classCallCheck$j(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$j(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$j(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$j(Constructor.prototype, protoProps); if (staticProps) _defineProperties$j(Constructor, staticProps); return Constructor; }

function _inherits$j(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$j(subClass, superClass); }

function _setPrototypeOf$j(o, p) { _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$j(o, p); }

function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf$j(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$j(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$j(this, result); }; }

function _possibleConstructorReturn$j(self, call) { if (call && (_typeof$l(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$j(self); }

function _assertThisInitialized$j(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$j(o) { _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$j(o); }

function _defineProperty$l(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Day of the month

var DateParser = /*#__PURE__*/function (_Parser) {
  _inherits$j(DateParser, _Parser);

  var _super = _createSuper$j(DateParser);

  function DateParser() {
    var _this;

    _classCallCheck$j(this, DateParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$l(_assertThisInitialized$j(_this), "priority", 90);

    _defineProperty$l(_assertThisInitialized$j(_this), "subPriority", 1);

    _defineProperty$l(_assertThisInitialized$j(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$j(DateParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, dateString);

        case 'do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();

      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DateParser;
}(Parser);

function _typeof$k(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$k = function _typeof(obj) { return typeof obj; }; } else { _typeof$k = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$k(obj); }

function _classCallCheck$i(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$i(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$i(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$i(Constructor.prototype, protoProps); if (staticProps) _defineProperties$i(Constructor, staticProps); return Constructor; }

function _inherits$i(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$i(subClass, superClass); }

function _setPrototypeOf$i(o, p) { _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$i(o, p); }

function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf$i(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$i(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$i(this, result); }; }

function _possibleConstructorReturn$i(self, call) { if (call && (_typeof$k(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$i(self); }

function _assertThisInitialized$i(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$i(o) { _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$i(o); }

function _defineProperty$k(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var DayOfYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$i(DayOfYearParser, _Parser);

  var _super = _createSuper$i(DayOfYearParser);

  function DayOfYearParser() {
    var _this;

    _classCallCheck$i(this, DayOfYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$k(_assertThisInitialized$i(_this), "priority", 90);

    _defineProperty$k(_assertThisInitialized$i(_this), "subpriority", 1);

    _defineProperty$k(_assertThisInitialized$i(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$i(DayOfYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);

        case 'Do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);

      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DayOfYearParser;
}(Parser);

function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(2, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function _typeof$j(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$j = function _typeof(obj) { return typeof obj; }; } else { _typeof$j = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$j(obj); }

function _classCallCheck$h(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$h(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$h(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$h(Constructor.prototype, protoProps); if (staticProps) _defineProperties$h(Constructor, staticProps); return Constructor; }

function _inherits$h(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$h(subClass, superClass); }

function _setPrototypeOf$h(o, p) { _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$h(o, p); }

function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf$h(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$h(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$h(this, result); }; }

function _possibleConstructorReturn$h(self, call) { if (call && (_typeof$j(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$h(self); }

function _assertThisInitialized$h(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$h(o) { _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$h(o); }

function _defineProperty$j(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DayParser = /*#__PURE__*/function (_Parser) {
  _inherits$h(DayParser, _Parser);

  var _super = _createSuper$h(DayParser);

  function DayParser() {
    var _this;

    _classCallCheck$h(this, DayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$j(_assertThisInitialized$h(_this), "priority", 90);

    _defineProperty$j(_assertThisInitialized$h(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$h(DayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DayParser;
}(Parser);

function _typeof$i(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$i = function _typeof(obj) { return typeof obj; }; } else { _typeof$i = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$i(obj); }

function _classCallCheck$g(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$g(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$g(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$g(Constructor.prototype, protoProps); if (staticProps) _defineProperties$g(Constructor, staticProps); return Constructor; }

function _inherits$g(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$g(subClass, superClass); }

function _setPrototypeOf$g(o, p) { _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$g(o, p); }

function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf$g(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$g(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$g(this, result); }; }

function _possibleConstructorReturn$g(self, call) { if (call && (_typeof$i(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$g(self); }

function _assertThisInitialized$g(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$g(o) { _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$g(o); }

function _defineProperty$i(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits$g(LocalDayParser, _Parser);

  var _super = _createSuper$g(LocalDayParser);

  function LocalDayParser() {
    var _this;

    _classCallCheck$g(this, LocalDayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$i(_assertThisInitialized$g(_this), "priority", 90);

    _defineProperty$i(_assertThisInitialized$g(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);

    return _this;
  }

  _createClass$g(LocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd

        case 'eo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'eee':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return LocalDayParser;
}(Parser);

function _typeof$h(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$h = function _typeof(obj) { return typeof obj; }; } else { _typeof$h = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$h(obj); }

function _classCallCheck$f(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$f(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$f(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$f(Constructor.prototype, protoProps); if (staticProps) _defineProperties$f(Constructor, staticProps); return Constructor; }

function _inherits$f(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$f(subClass, superClass); }

function _setPrototypeOf$f(o, p) { _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$f(o, p); }

function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf$f(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$f(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$f(this, result); }; }

function _possibleConstructorReturn$f(self, call) { if (call && (_typeof$h(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$f(self); }

function _assertThisInitialized$f(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$f(o) { _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$f(o); }

function _defineProperty$h(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits$f(StandAloneLocalDayParser, _Parser);

  var _super = _createSuper$f(StandAloneLocalDayParser);

  function StandAloneLocalDayParser() {
    var _this;

    _classCallCheck$f(this, StandAloneLocalDayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$h(_assertThisInitialized$f(_this), "priority", 90);

    _defineProperty$h(_assertThisInitialized$f(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);

    return _this;
  }

  _createClass$f(StandAloneLocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd

        case 'co':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'ccc':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneLocalDayParser;
}(Parser);

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function _typeof$g(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$g = function _typeof(obj) { return typeof obj; }; } else { _typeof$g = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$g(obj); }

function _classCallCheck$e(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$e(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$e(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$e(Constructor.prototype, protoProps); if (staticProps) _defineProperties$e(Constructor, staticProps); return Constructor; }

function _inherits$e(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$e(subClass, superClass); }

function _setPrototypeOf$e(o, p) { _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$e(o, p); }

function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf$e(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$e(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$e(this, result); }; }

function _possibleConstructorReturn$e(self, call) { if (call && (_typeof$g(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$e(self); }

function _assertThisInitialized$e(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$e(o) { _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$e(o); }

function _defineProperty$g(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISODayParser = /*#__PURE__*/function (_Parser) {
  _inherits$e(ISODayParser, _Parser);

  var _super = _createSuper$e(ISODayParser);

  function ISODayParser() {
    var _this;

    _classCallCheck$e(this, ISODayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$g(_assertThisInitialized$e(_this), "priority", 90);

    _defineProperty$g(_assertThisInitialized$e(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$e(ISODayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }

        return value;
      };

      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, dateString);
        // 2nd

        case 'io':
          return match.ordinalNumber(dateString, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return mapValue(match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // T

        case 'iiiii':
          return mapValue(match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tu

        case 'iiiiii':
          return mapValue(match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tuesday

        case 'iiii':
        default:
          return mapValue(match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return ISODayParser;
}(Parser);

function _typeof$f(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$f = function _typeof(obj) { return typeof obj; }; } else { _typeof$f = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$f(obj); }

function _classCallCheck$d(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$d(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$d(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$d(Constructor.prototype, protoProps); if (staticProps) _defineProperties$d(Constructor, staticProps); return Constructor; }

function _inherits$d(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$d(subClass, superClass); }

function _setPrototypeOf$d(o, p) { _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$d(o, p); }

function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf$d(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$d(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$d(this, result); }; }

function _possibleConstructorReturn$d(self, call) { if (call && (_typeof$f(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$d(self); }

function _assertThisInitialized$d(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$d(o) { _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$d(o); }

function _defineProperty$f(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var AMPMParser = /*#__PURE__*/function (_Parser) {
  _inherits$d(AMPMParser, _Parser);

  var _super = _createSuper$d(AMPMParser);

  function AMPMParser() {
    var _this;

    _classCallCheck$d(this, AMPMParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$f(_assertThisInitialized$d(_this), "priority", 80);

    _defineProperty$f(_assertThisInitialized$d(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$d(AMPMParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaaa':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);

  return AMPMParser;
}(Parser);

function _typeof$e(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$e = function _typeof(obj) { return typeof obj; }; } else { _typeof$e = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$e(obj); }

function _classCallCheck$c(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$c(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$c(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$c(Constructor.prototype, protoProps); if (staticProps) _defineProperties$c(Constructor, staticProps); return Constructor; }

function _inherits$c(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$c(subClass, superClass); }

function _setPrototypeOf$c(o, p) { _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$c(o, p); }

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf$c(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$c(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$c(this, result); }; }

function _possibleConstructorReturn$c(self, call) { if (call && (_typeof$e(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$c(self); }

function _assertThisInitialized$c(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$c(o) { _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$c(o); }

function _defineProperty$e(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
  _inherits$c(AMPMMidnightParser, _Parser);

  var _super = _createSuper$c(AMPMMidnightParser);

  function AMPMMidnightParser() {
    var _this;

    _classCallCheck$c(this, AMPMMidnightParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$e(_assertThisInitialized$c(_this), "priority", 80);

    _defineProperty$e(_assertThisInitialized$c(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$c(AMPMMidnightParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbbb':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);

  return AMPMMidnightParser;
}(Parser);

function _typeof$d(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$d = function _typeof(obj) { return typeof obj; }; } else { _typeof$d = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$d(obj); }

function _classCallCheck$b(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$b(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$b(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$b(Constructor.prototype, protoProps); if (staticProps) _defineProperties$b(Constructor, staticProps); return Constructor; }

function _inherits$b(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$b(subClass, superClass); }

function _setPrototypeOf$b(o, p) { _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$b(o, p); }

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf$b(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$b(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$b(this, result); }; }

function _possibleConstructorReturn$b(self, call) { if (call && (_typeof$d(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$b(self); }

function _assertThisInitialized$b(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$b(o) { _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$b(o); }

function _defineProperty$d(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DayPeriodParser = /*#__PURE__*/function (_Parser) {
  _inherits$b(DayPeriodParser, _Parser);

  var _super = _createSuper$b(DayPeriodParser);

  function DayPeriodParser() {
    var _this;

    _classCallCheck$b(this, DayPeriodParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$d(_assertThisInitialized$b(_this), "priority", 80);

    _defineProperty$d(_assertThisInitialized$b(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);

    return _this;
  }

  _createClass$b(DayPeriodParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBBB':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);

  return DayPeriodParser;
}(Parser);

function _typeof$c(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$c = function _typeof(obj) { return typeof obj; }; } else { _typeof$c = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$c(obj); }

function _classCallCheck$a(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$a(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$a(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$a(Constructor.prototype, protoProps); if (staticProps) _defineProperties$a(Constructor, staticProps); return Constructor; }

function _inherits$a(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$a(subClass, superClass); }

function _setPrototypeOf$a(o, p) { _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$a(o, p); }

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf$a(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$a(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$a(this, result); }; }

function _possibleConstructorReturn$a(self, call) { if (call && (_typeof$c(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$a(self); }

function _assertThisInitialized$a(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$a(o) { _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$a(o); }

function _defineProperty$c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
  _inherits$a(Hour1to12Parser, _Parser);

  var _super = _createSuper$a(Hour1to12Parser);

  function Hour1to12Parser() {
    var _this;

    _classCallCheck$a(this, Hour1to12Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$c(_assertThisInitialized$a(_this), "priority", 70);

    _defineProperty$c(_assertThisInitialized$a(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);

    return _this;
  }

  _createClass$a(Hour1to12Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, dateString);

        case 'ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    }
  }]);

  return Hour1to12Parser;
}(Parser);

function _typeof$b(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$b = function _typeof(obj) { return typeof obj; }; } else { _typeof$b = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$b(obj); }

function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$9(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$9(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$9(Constructor.prototype, protoProps); if (staticProps) _defineProperties$9(Constructor, staticProps); return Constructor; }

function _inherits$9(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$9(subClass, superClass); }

function _setPrototypeOf$9(o, p) { _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$9(o, p); }

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf$9(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$9(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$9(this, result); }; }

function _possibleConstructorReturn$9(self, call) { if (call && (_typeof$b(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$9(self); }

function _assertThisInitialized$9(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$9(o) { _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$9(o); }

function _defineProperty$b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
  _inherits$9(Hour0to23Parser, _Parser);

  var _super = _createSuper$9(Hour0to23Parser);

  function Hour0to23Parser() {
    var _this;

    _classCallCheck$9(this, Hour0to23Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$b(_assertThisInitialized$9(_this), "priority", 70);

    _defineProperty$b(_assertThisInitialized$9(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);

    return _this;
  }

  _createClass$9(Hour0to23Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, dateString);

        case 'Ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);

  return Hour0to23Parser;
}(Parser);

function _typeof$a(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$a = function _typeof(obj) { return typeof obj; }; } else { _typeof$a = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$a(obj); }

function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); return Constructor; }

function _inherits$8(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$8(subClass, superClass); }

function _setPrototypeOf$8(o, p) { _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$8(o, p); }

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf$8(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$8(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$8(this, result); }; }

function _possibleConstructorReturn$8(self, call) { if (call && (_typeof$a(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$8(self); }

function _assertThisInitialized$8(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$8(o) { _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$8(o); }

function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
  _inherits$8(Hour0To11Parser, _Parser);

  var _super = _createSuper$8(Hour0To11Parser);

  function Hour0To11Parser() {
    var _this;

    _classCallCheck$8(this, Hour0To11Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$a(_assertThisInitialized$8(_this), "priority", 70);

    _defineProperty$a(_assertThisInitialized$8(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$8(Hour0To11Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, dateString);

        case 'Ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    }
  }]);

  return Hour0To11Parser;
}(Parser);

function _typeof$9(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$9 = function _typeof(obj) { return typeof obj; }; } else { _typeof$9 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$9(obj); }

function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }

function _inherits$7(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$7(subClass, superClass); }

function _setPrototypeOf$7(o, p) { _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$7(o, p); }

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf$7(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$7(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$7(this, result); }; }

function _possibleConstructorReturn$7(self, call) { if (call && (_typeof$9(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$7(self); }

function _assertThisInitialized$7(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$7(o) { _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$7(o); }

function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
  _inherits$7(Hour1To24Parser, _Parser);

  var _super = _createSuper$7(Hour1To24Parser);

  function Hour1To24Parser() {
    var _this;

    _classCallCheck$7(this, Hour1To24Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$9(_assertThisInitialized$7(_this), "priority", 70);

    _defineProperty$9(_assertThisInitialized$7(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);

    return _this;
  }

  _createClass$7(Hour1To24Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, dateString);

        case 'ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);

  return Hour1To24Parser;
}(Parser);

function _typeof$8(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$8 = function _typeof(obj) { return typeof obj; }; } else { _typeof$8 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$8(obj); }

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }

function _inherits$6(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$6(subClass, superClass); }

function _setPrototypeOf$6(o, p) { _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$6(o, p); }

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf$6(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$6(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$6(this, result); }; }

function _possibleConstructorReturn$6(self, call) { if (call && (_typeof$8(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$6(self); }

function _assertThisInitialized$6(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$6(o) { _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$6(o); }

function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var MinuteParser = /*#__PURE__*/function (_Parser) {
  _inherits$6(MinuteParser, _Parser);

  var _super = _createSuper$6(MinuteParser);

  function MinuteParser() {
    var _this;

    _classCallCheck$6(this, MinuteParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$8(_assertThisInitialized$6(_this), "priority", 60);

    _defineProperty$8(_assertThisInitialized$6(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$6(MinuteParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, dateString);

        case 'mo':
          return match.ordinalNumber(dateString, {
            unit: 'minute'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);

  return MinuteParser;
}(Parser);

function _typeof$7(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$7 = function _typeof(obj) { return typeof obj; }; } else { _typeof$7 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$7(obj); }

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }

function _inherits$5(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$5(subClass, superClass); }

function _setPrototypeOf$5(o, p) { _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$5(o, p); }

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf$5(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$5(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$5(this, result); }; }

function _possibleConstructorReturn$5(self, call) { if (call && (_typeof$7(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$5(self); }

function _assertThisInitialized$5(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$5(o) { _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$5(o); }

function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var SecondParser = /*#__PURE__*/function (_Parser) {
  _inherits$5(SecondParser, _Parser);

  var _super = _createSuper$5(SecondParser);

  function SecondParser() {
    var _this;

    _classCallCheck$5(this, SecondParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$7(_assertThisInitialized$5(_this), "priority", 50);

    _defineProperty$7(_assertThisInitialized$5(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$5(SecondParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, dateString);

        case 'so':
          return match.ordinalNumber(dateString, {
            unit: 'second'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);

  return SecondParser;
}(Parser);

function _typeof$6(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$6(obj); }

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$4(subClass, superClass); }

function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf$4(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$4(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$4(this, result); }; }

function _possibleConstructorReturn$4(self, call) { if (call && (_typeof$6(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$4(self); }

function _assertThisInitialized$4(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$4(o) { _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$4(o); }

function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
  _inherits$4(FractionOfSecondParser, _Parser);

  var _super = _createSuper$4(FractionOfSecondParser);

  function FractionOfSecondParser() {
    var _this;

    _classCallCheck$4(this, FractionOfSecondParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$6(_assertThisInitialized$4(_this), "priority", 30);

    _defineProperty$6(_assertThisInitialized$4(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$4(FractionOfSecondParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };

      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);

  return FractionOfSecondParser;
}(Parser);

function _typeof$5(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$5(obj); }

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$3(subClass, superClass); }

function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf$3(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$3(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$3(this, result); }; }

function _possibleConstructorReturn$3(self, call) { if (call && (_typeof$5(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$3(self); }

function _assertThisInitialized$3(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$3(o) { _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$3(o); }

function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
  _inherits$3(ISOTimezoneWithZParser, _Parser);

  var _super = _createSuper$3(ISOTimezoneWithZParser);

  function ISOTimezoneWithZParser() {
    var _this;

    _classCallCheck$3(this, ISOTimezoneWithZParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$5(_assertThisInitialized$3(_this), "priority", 10);

    _defineProperty$5(_assertThisInitialized$3(_this), "incompatibleTokens", ['t', 'T', 'x']);

    return _this;
  }

  _createClass$3(ISOTimezoneWithZParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);

        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, dateString);

        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);

        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);

        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    }
  }]);

  return ISOTimezoneWithZParser;
}(Parser);

function _typeof$4(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$2(subClass, superClass); }

function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf$2(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$2(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$2(this, result); }; }

function _possibleConstructorReturn$2(self, call) { if (call && (_typeof$4(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$2(self); }

function _assertThisInitialized$2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$2(o) { _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$2(o); }

function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
  _inherits$2(ISOTimezoneParser, _Parser);

  var _super = _createSuper$2(ISOTimezoneParser);

  function ISOTimezoneParser() {
    var _this;

    _classCallCheck$2(this, ISOTimezoneParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$4(_assertThisInitialized$2(_this), "priority", 10);

    _defineProperty$4(_assertThisInitialized$2(_this), "incompatibleTokens", ['t', 'T', 'X']);

    return _this;
  }

  _createClass$2(ISOTimezoneParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);

        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, dateString);

        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);

        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);

        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    }
  }]);

  return ISOTimezoneParser;
}(Parser);

function _typeof$3(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$1(subClass, superClass); }

function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }

function _possibleConstructorReturn$1(self, call) { if (call && (_typeof$3(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$1(self); }

function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$1(o) { _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$1(o); }

function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits$1(TimestampSecondsParser, _Parser);

  var _super = _createSuper$1(TimestampSecondsParser);

  function TimestampSecondsParser() {
    var _this;

    _classCallCheck$1(this, TimestampSecondsParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$3(_assertThisInitialized$1(_this), "priority", 40);

    _defineProperty$3(_assertThisInitialized$1(_this), "incompatibleTokens", '*');

    return _this;
  }

  _createClass$1(TimestampSecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    }
  }]);

  return TimestampSecondsParser;
}(Parser);

function _typeof$2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof$2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampMillisecondsParser, _Parser);

  var _super = _createSuper(TimestampMillisecondsParser);

  function TimestampMillisecondsParser() {
    var _this;

    _classCallCheck(this, TimestampMillisecondsParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$2(_assertThisInitialized(_this), "priority", 20);

    _defineProperty$2(_assertThisInitialized(_this), "incompatibleTokens", '*');

    return _this;
  }

  _createClass(TimestampMillisecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);

  return TimestampMillisecondsParser;
}(Parser);

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */

var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale;

  if (!locale$1.match) {
    throw new RangeError('locale must contain match property');
  }

  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale$1
  }; // If timezone isn't specified, it will be set to the system timezone

  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter in longFormatters) {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];

  var _iterator = _createForOfIteratorHelper(tokens),
      _step;

  try {
    var _loop = function _loop() {
      var token = _step.value;

      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }

      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];

      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;

        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function (usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });

          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }

        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);

        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }

        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        } // Replace two single quote characters with one single quote character


        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        } // Cut token from string, or, if string doesn't match the token, return Invalid Date


        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_typeof$1(_ret) === "object") return _ret.v;
    } // Check if the remaining input contains something other than whitespace

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);

  if (isNaN(date.getTime())) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.


  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};

  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var setter = _step2.value;

      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }

      var result = setter.set(utcDate, flags, subFnOptions); // Result is tuple (date, flags)

      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]); // Result is date
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return utcDate;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

var maska = createCommonjsModule(function (module, exports) {
/*!
 * maska v1.5.0
 * (c) 2019-2021 Alexander Shabunevich
 * Released under the MIT License.
 */
!function(e,t){t(exports);}(commonjsGlobal,(function(e){var t={"#":{pattern:/[0-9]/},X:{pattern:/[0-9a-zA-Z]/},S:{pattern:/[a-zA-Z]/},A:{pattern:/[a-zA-Z]/,uppercase:!0},a:{pattern:/[a-zA-Z]/,lowercase:!0},"!":{escape:!0},"*":{repeat:!0}};function n(e,n,r=t,o=!0){return s(n).length>1?function(e){const t=s(e).sort(((e,t)=>e.length-t.length));return function(e,s,r,o=!0){const i=t.map((t=>a(e,t,r,!1))).pop();for(const s in t)if(n(i,t[s],r))return a(e,t[s],r,o);return ""};function n(e,t,n){for(const e in n)n[e].escape&&(t=t.replace(new RegExp(e+".{1}","g"),""));return t.split("").filter((e=>n[e]&&n[e].pattern)).length>=e.length}}(n)(e,n,r,o):a(e,n,r,o)}function s(e){try{return JSON.parse(e)}catch{return [e]}}function a(e,t,n,s=!0){let a=0,o=0,i="",u="";for(;a<t.length&&o<e.length;){let u=t[a];const p=e[o],l=n[u];if(l&&l.pattern)l.pattern.test(p)&&(i+=r(p,l),a++,s&&t[a]&&(n[t[a]]?n[t[a]]&&n[t[a]].escape&&(i+=t[a+1],a+=2):(i+=t[a],a++))),o++;else if(l&&l.repeat){const e=n[t[a-1]];e&&!e.pattern.test(p)?a++:a--;}else l&&l.escape&&(a++,u=t[a]),s&&(i+=u),p===u&&o++,a++;}for(;s&&a<t.length;){const e=t[a];if(n[e]){u="";break}u+=e,a++;}return i+u}function r(e,t){return t.transform&&(e=t.transform(e)),t.uppercase?e.toLocaleUpperCase():t.lowercase?e.toLocaleLowerCase():e}function o(e){return e instanceof HTMLInputElement?e:e.querySelector("input")||e}function i(e){return "[object String]"===Object.prototype.toString.call(e)}class u{constructor(e,n={}){if(!e)throw new Error("Maska: no element for mask");if(null!=n.preprocessor&&"function"!=typeof n.preprocessor)throw new Error("Maska: preprocessor must be a function");if(n.tokens)for(const e in n.tokens)n.tokens[e]={...n.tokens[e]},n.tokens[e].pattern&&i(n.tokens[e].pattern)&&(n.tokens[e].pattern=new RegExp(n.tokens[e].pattern));this._opts={mask:n.mask,tokens:{...t,...n.tokens},preprocessor:n.preprocessor},this._el=i(e)?document.querySelectorAll(e):e.length?e:[e],this.inputEvent=e=>this.updateValue(e.target,e),this.init();}init(){for(let e=0;e<this._el.length;e++){const t=o(this._el[e]);!this._opts.mask||t.dataset.mask&&t.dataset.mask===this._opts.mask||(t.dataset.mask=this._opts.mask),setTimeout((()=>this.updateValue(t)),0),t.dataset.maskInited||(t.dataset.maskInited=!0,t.addEventListener("input",this.inputEvent),t.addEventListener("beforeinput",this.beforeInput));}}destroy(){for(let e=0;e<this._el.length;e++){const t=o(this._el[e]);t.removeEventListener("input",this.inputEvent),t.removeEventListener("beforeinput",this.beforeInput),delete t.dataset.mask,delete t.dataset.maskInited;}}updateValue(e,t){if(!e||!e.type)return;const s=e.type.match(/^number$/i)&&e.validity.badInput;if(!e.value&&!s||!e.dataset.mask)return e.dataset.maskRawValue="",void this.dispatch("maska",e,t);let a=e.selectionEnd;const r=e.value,o=r[a-1];e.dataset.maskRawValue=n(e.value,e.dataset.mask,this._opts.tokens,!1);let i=e.value;this._opts.preprocessor&&(i=this._opts.preprocessor(i)),e.value=n(i,e.dataset.mask,this._opts.tokens),t&&"insertText"===t.inputType&&a===r.length&&(a=e.value.length),function(e,t,n){for(;t&&t<e.value.length&&e.value.charAt(t-1)!==n;)t++;(e.type?e.type.match(/^(text|search|password|tel|url)$/i):!e.type)&&e===document.activeElement&&(e.setSelectionRange(t,t),setTimeout((function(){e.setSelectionRange(t,t);}),0));}(e,a,o),this.dispatch("maska",e,t),e.value!==r&&this.dispatch("input",e,t);}beforeInput(e){e&&e.target&&e.target.type&&e.target.type.match(/^number$/i)&&e.data&&isNaN(e.target.value+e.data)&&e.preventDefault();}dispatch(e,t,n){t.dispatchEvent(function(e,t=null){const n=document.createEvent("Event");return n.initEvent(e,!0,!0),t&&(n.inputType=t),n}(e,n&&n.inputType||null));}}var p=(()=>{const e=new WeakMap;return (t,n)=>{n.value&&(e.has(t)&&!function(e){return !(i(e.value)&&e.value===e.oldValue||Array.isArray(e.value)&&JSON.stringify(e.value)===JSON.stringify(e.oldValue)||e.value&&e.value.mask&&e.oldValue&&e.oldValue.mask&&e.value.mask===e.oldValue.mask)}(n)||e.set(t,new u(t,function(e){const t={};return e.mask?(t.mask=Array.isArray(e.mask)?JSON.stringify(e.mask):e.mask,t.tokens=e.tokens?{...e.tokens}:{},t.preprocessor=e.preprocessor):t.mask=Array.isArray(e)?JSON.stringify(e):e,t}(n.value))));}})();function l(e){e.directive("maska",p);}"undefined"!=typeof window&&window.Vue&&window.Vue.use&&window.Vue.use(l),e.create=function(e,t){return new u(e,t)},e.default=l,e.install=l,e.mask=n,e.maska=p,e.tokens=t,Object.defineProperty(e,"__esModule",{value:!0});}));
});

const swirlDateInputCss = ".sc-swirl-date-input-h{display:flex;width:100%}.sc-swirl-date-input-h *.sc-swirl-date-input{box-sizing:border-box}.date-input.sc-swirl-date-input{position:relative;display:flex;width:100%;align-items:center;color:var(--s-text-default);line-height:var(--s-line-height-sm)}.date-input--inline.sc-swirl-date-input .date-input__date-picker-button.sc-swirl-date-input{top:-0.0625rem}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.date-input--inline.sc-swirl-date-input .date-input__date-picker-button.sc-swirl-date-input{top:0}}.date-input__input.sc-swirl-date-input{display:inline-flex;width:calc(100% - 1.25rem - var(--s-space-8));margin:0;padding:0;border:none;color:var(--s-text-default);background-color:transparent;font:inherit;font-size:var(--s-font-size-base);line-height:var(--s-line-height-base);caret-color:var(--s-border-highlight)}.date-input__input.sc-swirl-date-input:focus{outline:none}.date-input__input.sc-swirl-date-input:disabled{color:var(--s-text-disabled);background-color:transparent}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.date-input__input.sc-swirl-date-input{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.date-input__date-picker-button.sc-swirl-date-input{position:absolute;top:calc(-1 * var(--s-space-12));right:0;display:inline-flex;margin:0;padding:0;border:none;color:var(--s-icon-default);background-color:transparent;cursor:pointer}.date-input__date-picker-button.sc-swirl-date-input:focus:not(:focus-visible){outline:none}.date-input__date-picker-button.sc-swirl-date-input:focus-visible{outline-color:var(--s-focus-default);outline-offset:var(--s-space-2)}.date-input__date-picker-button.sc-swirl-date-input:disabled{color:var(--s-icon-disabled);cursor:default}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.date-input__date-picker-button.sc-swirl-date-input{top:-0.625rem}}";

const internalDateFormat = "yyyy-MM-dd";
class SwirlDateInput {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.updateIconSize(event.matches);
    };
    this.onChange = (event) => {
      const value = event.target.value;
      if (value === "") {
        this.value = undefined;
        this.valueChange.emit(undefined);
      }
      const newDate = parse(value, this.format, new Date());
      const formatRegExp = new RegExp(`^${this.format.replace(/[ydM]/g, "\\d")}$`);
      if (!Boolean(value.match(formatRegExp)) || !isValid(newDate)) {
        return;
      }
      const newValue = format(newDate, internalDateFormat);
      this.value = newValue;
      this.valueChange.emit(newValue);
    };
    this.onInput = (event) => {
      this.onChange(event);
    };
    this.onClick = (event) => {
      event.preventDefault();
    };
    this.onFocus = (event) => {
      this.handleAutoSelect(event);
    };
    this.onPickDate = (event) => {
      const newDateValue = event.detail;
      const newValue = format(newDateValue, internalDateFormat);
      this.value = newValue;
      this.valueChange.emit(newValue);
      this.pickerPopover.close();
    };
    this.autoFocus = undefined;
    this.autoSelect = undefined;
    this.datePickerLabel = "Date picker";
    this.datePickerTriggerLabel = "Open date picker";
    this.disabled = undefined;
    this.format = "yyyy-MM-dd";
    this.inline = undefined;
    this.invalid = undefined;
    this.labels = undefined;
    this.locale = "en-US";
    this.placeholder = "yyyy-mm-dd";
    this.required = undefined;
    this.swirlAriaDescribedby = undefined;
    this.value = undefined;
    this.iconSize = 24;
  }
  componentWillLoad() {
    const index = Array.from(document.querySelectorAll("swirl-date-input")).indexOf(this.el);
    this.id = `swirl-date-input-${index}`;
  }
  componentDidLoad() {
    var _a, _b;
    this.setupMask();
    this.updateIconSize(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.mask) === null || _a === void 0 ? void 0 : _a.destroy();
    (_c = (_b = this.desktopMediaQuery).removeEventListener) === null || _c === void 0 ? void 0 : _c.call(_b, "change", this.desktopMediaQueryHandler);
  }
  watchFormat() {
    this.setupMask();
  }
  updateIconSize(smallIcon) {
    this.iconSize = smallIcon ? 20 : 24;
  }
  handleAutoSelect(event) {
    if (!this.autoSelect) {
      return;
    }
    event.target.select();
  }
  setupMask() {
    var _a;
    (_a = this.mask) === null || _a === void 0 ? void 0 : _a.destroy();
    this.mask = maska.create(`#${this.id}`, {
      mask: this.format.replace(/[ydM]/g, "#"),
    });
  }
  render() {
    const ariaInvalid = this.invalid === true || this.invalid === false
      ? String(this.invalid)
      : undefined;
    const dateValue = Boolean(this.value)
      ? parse(this.value, internalDateFormat, new Date())
      : undefined;
    const displayValue = isValid(dateValue)
      ? format(dateValue, this.format)
      : undefined;
    const className = classnames("date-input", {
      "date-input--inline": this.inline,
    });
    return (hAsync(Host, null, hAsync("div", { class: className }, hAsync("input", { "aria-describedby": this.swirlAriaDescribedby, "aria-disabled": this.disabled ? "true" : undefined, "aria-invalid": ariaInvalid, autoFocus: this.autoFocus, class: "date-input__input", disabled: this.disabled, id: this.id, onClick: this.onClick, onFocus: this.onFocus, onInput: this.onInput, placeholder: this.placeholder, required: this.required, type: "text", value: displayValue }), hAsync("button", { "aria-label": this.datePickerTriggerLabel, class: "date-input__date-picker-button", disabled: this.disabled, id: `${this.id}-trigger`, type: "button" }, hAsync("swirl-icon-today", { size: this.iconSize }))), !this.disabled && (hAsync("swirl-popover", { animation: "scale-in-y", label: this.datePickerLabel, placement: "bottom-end", popoverId: `popover-${this.id}`, ref: (el) => (this.pickerPopover = el), trigger: `${this.id}-trigger` }, hAsync("swirl-date-picker", { labels: this.labels, locale: this.locale, onValueChange: this.onPickDate, value: dateValue })))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "format": ["watchFormat"]
  }; }
  static get style() { return swirlDateInputCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-date-input",
    "$members$": {
      "autoFocus": [4, "auto-focus"],
      "autoSelect": [4, "auto-select"],
      "datePickerLabel": [1, "date-picker-label"],
      "datePickerTriggerLabel": [1, "date-picker-trigger-label"],
      "disabled": [4],
      "format": [1],
      "inline": [4],
      "invalid": [4],
      "labels": [16],
      "locale": [1],
      "placeholder": [1],
      "required": [4],
      "swirlAriaDescribedby": [1, "swirl-aria-describedby"],
      "value": [1537],
      "iconSize": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": [["value", "value"]]
  }; }
}

const swirlDatePickerCss = "/*!@:host*/.sc-swirl-date-picker-h{display:block}/*!@:host **/.sc-swirl-date-picker-h *.sc-swirl-date-picker{box-sizing:border-box}/*!@.date-picker*/.date-picker.sc-swirl-date-picker{padding:var(--s-space-8) var(--s-space-16);background-color:var(--s-surface-overlay-default);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm);letter-spacing:var(--s-letter-spacing-tighter)}@media (min-width: 768px){/*!@.date-picker*/.date-picker.sc-swirl-date-picker{max-width:17.5rem}}/*!@.date-picker__header*/.date-picker__header.sc-swirl-date-picker{display:flex;margin-bottom:var(--s-space-8);align-items:center}/*!@.date-picker__current-month*/.date-picker__current-month.sc-swirl-date-picker{display:flex;padding:var(--s-space-8);flex-grow:1;align-items:center;order:1;gap:var(--s-space-4)}/*!@.date-picker__next-month-button,\n.date-picker__previous-month-button*/.date-picker__next-month-button.sc-swirl-date-picker,.date-picker__previous-month-button.sc-swirl-date-picker{position:relative;display:inline-flex;width:2.5rem;height:2.5rem;margin:0;padding:0;flex-shrink:0;justify-content:center;align-items:center;border:none;border-radius:50%;color:var(--s-icon-highlight);background-color:transparent;cursor:pointer}/*!@.date-picker__next-month-button:after, .date-picker__previous-month-button:after*/.date-picker__next-month-button.sc-swirl-date-picker:after,.date-picker__previous-month-button.sc-swirl-date-picker:after{position:absolute;background-color:currentColor;content:\"\";inset:0;-webkit-mask-position:center center;mask-position:center center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat}/*!@.date-picker__next-month-button:hover, .date-picker__previous-month-button:hover*/.date-picker__next-month-button.sc-swirl-date-picker:hover,.date-picker__previous-month-button.sc-swirl-date-picker:hover{background-color:var(--s-surface-overlay-hovered)}/*!@.date-picker__next-month-button:focus:not(:focus-visible), .date-picker__previous-month-button:focus:not(:focus-visible)*/.date-picker__next-month-button.sc-swirl-date-picker:focus:not(:focus-visible),.date-picker__previous-month-button.sc-swirl-date-picker:focus:not(:focus-visible){outline:none}/*!@.date-picker__next-month-button:focus-visible, .date-picker__previous-month-button:focus-visible*/.date-picker__next-month-button.sc-swirl-date-picker:focus-visible,.date-picker__previous-month-button.sc-swirl-date-picker:focus-visible{outline-color:var(--s-focus-default);outline-offset:var(--s-space-2)}/*!@.date-picker__next-month-button > svg, .date-picker__previous-month-button > svg*/.date-picker__next-month-button.sc-swirl-date-picker>svg.sc-swirl-date-picker,.date-picker__previous-month-button.sc-swirl-date-picker>svg.sc-swirl-date-picker{display:none}/*!@.date-picker__next-month-button*/.date-picker__next-month-button.sc-swirl-date-picker{order:3}/*!@.date-picker__next-month-button:after*/.date-picker__next-month-button.sc-swirl-date-picker:after{-webkit-mask-image:url(\"data:image/svg+xml,%3Csvg class='swirl-icon swirl-icon--size-24' fill='none' height='24' part='icon' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M8.59999 17.4C8.38333 17.1834 8.27499 16.9167 8.27499 16.6C8.27499 16.2834 8.38333 16.0167 8.59999 15.8L12.4 12L8.59999 8.20002C8.38333 7.98336 8.27499 7.71669 8.27499 7.40002C8.27499 7.08336 8.38333 6.81669 8.59999 6.60002C8.81666 6.38336 9.08333 6.27502 9.39999 6.27502C9.71666 6.27502 9.98333 6.38336 10.2 6.60002L14.8 11.2C14.9167 11.3167 15 11.4417 15.05 11.575C15.1 11.7084 15.125 11.85 15.125 12C15.125 12.15 15.1 12.2917 15.05 12.425C15 12.5584 14.9167 12.6834 14.8 12.8L10.2 17.4C9.98333 17.6167 9.71666 17.725 9.39999 17.725C9.08333 17.725 8.81666 17.6167 8.59999 17.4Z' fill='currentColor'%3E%3C/path%3E%3C/svg%3E\");mask-image:url(\"data:image/svg+xml,%3Csvg class='swirl-icon swirl-icon--size-24' fill='none' height='24' part='icon' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M8.59999 17.4C8.38333 17.1834 8.27499 16.9167 8.27499 16.6C8.27499 16.2834 8.38333 16.0167 8.59999 15.8L12.4 12L8.59999 8.20002C8.38333 7.98336 8.27499 7.71669 8.27499 7.40002C8.27499 7.08336 8.38333 6.81669 8.59999 6.60002C8.81666 6.38336 9.08333 6.27502 9.39999 6.27502C9.71666 6.27502 9.98333 6.38336 10.2 6.60002L14.8 11.2C14.9167 11.3167 15 11.4417 15.05 11.575C15.1 11.7084 15.125 11.85 15.125 12C15.125 12.15 15.1 12.2917 15.05 12.425C15 12.5584 14.9167 12.6834 14.8 12.8L10.2 17.4C9.98333 17.6167 9.71666 17.725 9.39999 17.725C9.08333 17.725 8.81666 17.6167 8.59999 17.4Z' fill='currentColor'%3E%3C/path%3E%3C/svg%3E\")}/*!@.date-picker__previous-month-button*/.date-picker__previous-month-button.sc-swirl-date-picker{order:2}/*!@.date-picker__previous-month-button:after*/.date-picker__previous-month-button.sc-swirl-date-picker:after{-webkit-mask-image:url(\"data:image/svg+xml,%3Csvg class='swirl-icon swirl-icon--size-24' fill='none' height='24' part='icon' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M13.2 17.4L8.59999 12.8C8.48333 12.6834 8.39999 12.5584 8.34999 12.425C8.29999 12.2917 8.27499 12.15 8.27499 12C8.27499 11.85 8.29999 11.7084 8.34999 11.575C8.39999 11.4417 8.48333 11.3167 8.59999 11.2L13.2 6.60002C13.4167 6.38336 13.6833 6.27502 14 6.27502C14.3167 6.27502 14.5833 6.38336 14.8 6.60002C15.0167 6.81669 15.125 7.08336 15.125 7.40002C15.125 7.71669 15.0167 7.98336 14.8 8.20002L11 12L14.8 15.8C15.0167 16.0167 15.125 16.2834 15.125 16.6C15.125 16.9167 15.0167 17.1834 14.8 17.4C14.5833 17.6167 14.3167 17.725 14 17.725C13.6833 17.725 13.4167 17.6167 13.2 17.4Z' fill='currentColor'%3E%3C/path%3E%3C/svg%3E\");mask-image:url(\"data:image/svg+xml,%3Csvg class='swirl-icon swirl-icon--size-24' fill='none' height='24' part='icon' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M13.2 17.4L8.59999 12.8C8.48333 12.6834 8.39999 12.5584 8.34999 12.425C8.29999 12.2917 8.27499 12.15 8.27499 12C8.27499 11.85 8.29999 11.7084 8.34999 11.575C8.39999 11.4417 8.48333 11.3167 8.59999 11.2L13.2 6.60002C13.4167 6.38336 13.6833 6.27502 14 6.27502C14.3167 6.27502 14.5833 6.38336 14.8 6.60002C15.0167 6.81669 15.125 7.08336 15.125 7.40002C15.125 7.71669 15.0167 7.98336 14.8 8.20002L11 12L14.8 15.8C15.0167 16.0167 15.125 16.2834 15.125 16.6C15.125 16.9167 15.0167 17.1834 14.8 17.4C14.5833 17.6167 14.3167 17.725 14 17.725C13.6833 17.725 13.4167 17.6167 13.2 17.4Z' fill='currentColor'%3E%3C/path%3E%3C/svg%3E\")}/*!@.date-picker__month-select,\n.date-picker__year-select*/.date-picker__month-select.sc-swirl-date-picker,.date-picker__year-select.sc-swirl-date-picker{margin:0;padding:0;border:none;background-color:var(--s-surface-overlay-default);font:inherit;font-size:var(--s-font-size-base);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base);text-align:left;cursor:pointer}/*!@.date-picker__month-select:focus:not(:focus-visible), .date-picker__year-select:focus:not(:focus-visible)*/.date-picker__month-select.sc-swirl-date-picker:focus:not(:focus-visible),.date-picker__year-select.sc-swirl-date-picker:focus:not(:focus-visible){outline:none}/*!@.date-picker__month-select:focus-visible, .date-picker__year-select:focus-visible*/.date-picker__month-select.sc-swirl-date-picker:focus-visible,.date-picker__year-select.sc-swirl-date-picker:focus-visible{outline-color:var(--s-focus-default);outline-offset:var(--s-space-2)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.date-picker__month-select,\n.date-picker__year-select*/.date-picker__month-select.sc-swirl-date-picker,.date-picker__year-select.sc-swirl-date-picker{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.date-picker__month-select*/.date-picker__month-select.sc-swirl-date-picker{-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.date-picker__year-select*/.date-picker__year-select.sc-swirl-date-picker{max-width:4rem}/*!@.date-picker__calendar*/.date-picker__calendar.sc-swirl-date-picker{display:block;width:100%}/*!@.date-picker__calendar tbody*/.date-picker__calendar.sc-swirl-date-picker tbody.sc-swirl-date-picker{display:block}/*!@.date-picker__calendar-header*/.date-picker__calendar-header.sc-swirl-date-picker{display:block}/*!@.date-picker__weekday-row,\n.date-picker__calendar-row*/.date-picker__weekday-row.sc-swirl-date-picker,.date-picker__calendar-row.sc-swirl-date-picker{display:flex}/*!@.date-picker__weekday-row*/.date-picker__weekday-row.sc-swirl-date-picker{margin-bottom:var(--s-space-8)}/*!@.date-picker__weekday*/.date-picker__weekday.sc-swirl-date-picker{display:inline-flex;min-width:2.25rem;flex-basis:calc(100 / 7 * 1%);justify-content:center;align-items:center;color:var(--s-text-subdued);font-weight:var(--s-font-weight-regular);aspect-ratio:1}/*!@.date-picker__date*/.date-picker__date.sc-swirl-date-picker{position:relative;z-index:1;display:inline-flex;min-width:2.25rem;flex-basis:calc(100 / 7 * 1%);justify-content:center;align-items:center;font-weight:var(--s-font-weight-medium);cursor:pointer;aspect-ratio:1}/*!@.date-picker__date:before*/.date-picker__date.sc-swirl-date-picker:before{position:absolute;z-index:-1;border-radius:50%;background-color:transparent;content:\"\";inset:0}/*!@.date-picker__date:hover:before*/.date-picker__date.sc-swirl-date-picker:hover:before{background-color:var(--s-surface-overlay-hovered)}/*!@.date-picker__date--current:before*/.date-picker__date--current.sc-swirl-date-picker:before{background-color:var(--s-surface-overlay-hovered)}/*!@.date-picker__date--current:focus:not(:focus-visible)*/.date-picker__date--current.sc-swirl-date-picker:focus:not(:focus-visible){outline:none}/*!@.date-picker__date--current:focus-visible*/.date-picker__date--current.sc-swirl-date-picker:focus-visible{outline-color:var(--s-focus-default);outline-offset:var(--s-space-2)}/*!@.date-picker__date--selected*/.date-picker__date--selected.sc-swirl-date-picker{color:var(--s-text-on-surface-highlight)}/*!@.date-picker__date--selected:before*/.date-picker__date--selected.sc-swirl-date-picker:before{background-color:var(--s-surface-highlight-default)}/*!@.date-picker__date--selected:hover*/.date-picker__date--selected.sc-swirl-date-picker:hover{color:var(--s-text-on-surface-highlight)}/*!@.date-picker__date--selected:hover:before*/.date-picker__date--selected.sc-swirl-date-picker:hover:before{background-color:var(--s-surface-highlight-default)}/*!@.date-picker__date--selected > strong*/.date-picker__date--selected.sc-swirl-date-picker>strong.sc-swirl-date-picker{font-weight:var(--s-font-weight-medium)}/*!@.date-picker__date--in-range:not(.date-picker__date--selected):after*/.date-picker__date--in-range.sc-swirl-date-picker:not(.date-picker__date--selected):after{position:absolute;border-radius:0px;background-color:var(--s-surface-highlight-default);content:\"\";opacity:0.2;inset:0.0625rem 0px}/*!@.date-picker__date--start:not(.date-picker__date--end)*/.date-picker__date--start.sc-swirl-date-picker:not(.date-picker__date--end){color:var(--s-text-on-surface-highlight)}/*!@.date-picker__date--start:not(.date-picker__date--end):before*/.date-picker__date--start.sc-swirl-date-picker:not(.date-picker__date--end):before{background-color:var(--s-surface-highlight-default)}/*!@.date-picker__date--start:not(.date-picker__date--end):after*/.date-picker__date--start.sc-swirl-date-picker:not(.date-picker__date--end):after{position:absolute;z-index:-1;border-radius:0;background-color:var(--s-surface-highlight-default);content:\"\";opacity:0.2;inset:0.0625rem 0 0.0625rem 50%}/*!@.date-picker__date--end:not(.date-picker__date--start)*/.date-picker__date--end.sc-swirl-date-picker:not(.date-picker__date--start){color:var(--s-text-on-surface-highlight)}/*!@.date-picker__date--end:not(.date-picker__date--start):before*/.date-picker__date--end.sc-swirl-date-picker:not(.date-picker__date--start):before{background-color:var(--s-surface-highlight-default)}/*!@.date-picker__date--end:not(.date-picker__date--start):after*/.date-picker__date--end.sc-swirl-date-picker:not(.date-picker__date--start):after{position:absolute;z-index:-1;border-radius:0;background-color:var(--s-surface-highlight-default);content:\"\";opacity:0.2;inset:0.0625rem 50% 0.0625rem 0}/*!@.date-picker__date--overflowing*/.date-picker__date--overflowing.sc-swirl-date-picker{color:var(--s-text-subdued)}/*!@.date-picker__date--today:before*/.date-picker__date--today.sc-swirl-date-picker:before{box-shadow:inset 0 0 0 var(--s-border-width-default)\n      var(--s-border-highlight)}/*!@.date-picker__date--today > em*/.date-picker__date--today.sc-swirl-date-picker>em.sc-swirl-date-picker{font-style:normal}";

class SwirlDatePicker {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 3);
    this.onClick = (event) => {
      event.stopPropagation();
      event.preventDefault();
    };
    this.onSelectDate = (event) => {
      if (typeof event.detail === "string") {
        this.valueChange.emit(new Date(event.detail));
      }
      else {
        this.valueChange.emit(event.detail.map((date) => new Date(date)));
      }
    };
    this.labels = undefined;
    this.locale = "en-US";
    this.range = undefined;
    this.startDate = undefined;
    this.value = undefined;
  }
  render() {
    const startDate = this.startDate instanceof Date ? this.startDate.toISOString() : undefined;
    return (hAsync(Host, { onClick: this.onClick }, hAsync("wc-datepicker", { elementClassName: "date-picker", labels: this.labels, locale: this.locale, onSelectDate: this.onSelectDate, range: this.range, startDate: startDate, value: this.value })));
  }
  get el() { return getElement(this); }
  static get style() { return swirlDatePickerCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-date-picker",
    "$members$": {
      "labels": [16],
      "locale": [1],
      "range": [4],
      "startDate": [16],
      "value": [1040]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlDescriptionListCss = "/*!@:host*/.sc-swirl-description-list-h{display:block;container-type:inline-size;container-name:description-list}/*!@:host **/.sc-swirl-description-list-h *.sc-swirl-description-list{box-sizing:border-box}/*!@.description-list*/.description-list.sc-swirl-description-list{display:block;max-width:100%;margin:0}";

/**
 * @slot slot - The description list items
 */
class SwirlDescriptionList {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  render() {
    return (hAsync(Host, null, hAsync("dl", { class: "description-list" }, hAsync("slot", null))));
  }
  static get style() { return swirlDescriptionListCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-description-list",
    "$members$": undefined,
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlDescriptionListItemCss = "/*!@:host*/.sc-swirl-description-list-item-h {\n  display: block;\n}\n\n  /*!@:host **/.sc-swirl-description-list-item-h *.sc-swirl-description-list-item {\n    box-sizing: border-box;\n  }\n\n/*!@.description-list-item*/.description-list-item.sc-swirl-description-list-item {\n  display: block;\n  max-width: 100%;\n  padding-top: var(--s-space-8);\n  padding-bottom: var(--s-space-8);\n  color: var(--s-text-default);\n  line-height: var(--s-line-height-base);\n}\n\n@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px) {\n\n/*!@.description-list-item*/.description-list-item.sc-swirl-description-list-item {\n    font-size: var(--s-font-size-sm);\n    line-height: var(--s-line-height-sm)\n}\n  }\n\n/*!@.description-list-item--bordered*/.description-list-item--bordered.sc-swirl-description-list-item {\n  padding-top: var(--s-space-16);\n  padding-bottom: var(--s-space-16);\n  border-bottom: var(--s-border-width-default) solid var(--s-border-default);\n}\n\n/*!@.description-list-item__term*/.description-list-item__term.sc-swirl-description-list-item {\n  display: block;\n  margin-bottom: var(--s-space-4);\n  font-weight: var(--s-font-weight-semibold);\n}\n\n@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px) {\n\n/*!@.description-list-item__term*/.description-list-item__term.sc-swirl-description-list-item {\n    margin-bottom: var(--s-space-2)\n}\n  }\n\n/*!@.description-list-item__description*/.description-list-item__description.sc-swirl-description-list-item {\n  display: block;\n  max-width: 40rem;\n  margin: 0;\n}\n\n@container description-list (min-width: 480px) {\n  .description-list-item--orientation-horizontal {\n    display: flex;\n  }\n\n    .description-list-item--orientation-horizontal .description-list-item__term {\n      margin-right: var(--s-space-16);\n      margin-bottom: 0;\n      flex-basis: 12rem;\n      flex-grow: 0;\n      flex-shrink: 0;\n    }\n\n    .description-list-item--orientation-horizontal .description-list-item__description {\n      flex-grow: 1;\n    }\n}\n\n\n@supports not (container-type: inline-size) {\n  /*!@@media (min-width: 768px)*/@media.sc-swirl-description-list-item (min-width.sc-swirl-description-list-item: 768px).sc-swirl-description-list-item {\n    .description-list-item--orientation-horizontal {\n      display: flex;\n    }\n\n      .description-list-item--orientation-horizontal .description-list-item__term {\n        margin-right: var(--s-space-16);\n        margin-bottom: 0;\n        flex-basis: 12rem;\n        flex-grow: 0;\n        flex-shrink: 0;\n      }\n\n      .description-list-item--orientation-horizontal .description-list-item__description {\n        flex-grow: 1;\n      }\n  }\n}";

/**
 * @slot slot - The description
 */
class SwirlDescriptionListItem {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.bordered = true;
    this.orientation = "horizontal";
    this.term = undefined;
  }
  render() {
    const className = classnames("description-list-item", `description-list-item--orientation-${this.orientation}`, { "description-list-item--bordered": this.bordered });
    return (hAsync(Host, null, hAsync("div", { class: className, part: "description-list-item" }, hAsync("dt", { class: "description-list-item__term", part: "description-list-item__term" }, this.term), hAsync("dd", { class: "description-list-item__description" }, hAsync("slot", null)))));
  }
  static get style() { return swirlDescriptionListItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-description-list-item",
    "$members$": {
      "bordered": [4],
      "orientation": [1],
      "term": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

var focusableSelectors = [
  'a[href]:not([tabindex^="-"])',
  'area[href]:not([tabindex^="-"])',
  'input:not([type="hidden"]):not([type="radio"]):not([disabled]):not([tabindex^="-"])',
  'input[type="radio"]:not([disabled]):not([tabindex^="-"])',
  'select:not([disabled]):not([tabindex^="-"])',
  'textarea:not([disabled]):not([tabindex^="-"])',
  'button:not([disabled]):not([tabindex^="-"])',
  'iframe:not([tabindex^="-"])',
  'audio[controls]:not([tabindex^="-"])',
  'video[controls]:not([tabindex^="-"])',
  '[contenteditable]:not([tabindex^="-"])',
  '[tabindex]:not([tabindex^="-"])',
];

var TAB_KEY = 'Tab';
var ESCAPE_KEY = 'Escape';

/**
 * Define the constructor to instantiate a dialog
 *
 * @constructor
 * @param {Element} element
 */
function A11yDialog(element) {
  // Prebind the functions that will be bound in addEventListener and
  // removeEventListener to avoid losing references
  this._show = this.show.bind(this);
  this._hide = this.hide.bind(this);
  this._maintainFocus = this._maintainFocus.bind(this);
  this._bindKeypress = this._bindKeypress.bind(this);

  this.$el = element;
  this.shown = false;
  this._id = this.$el.getAttribute('data-a11y-dialog') || this.$el.id;
  this._previouslyFocused = null;
  this._listeners = {};

  // Initialise everything needed for the dialog to work properly
  this.create();
}

/**
 * Set up everything necessary for the dialog to be functioning
 *
 * @param {(NodeList | Element | string)} targets
 * @return {this}
 */
A11yDialog.prototype.create = function () {
  this.$el.setAttribute('aria-hidden', true);
  this.$el.setAttribute('aria-modal', true);
  this.$el.setAttribute('tabindex', -1);

  if (!this.$el.hasAttribute('role')) {
    this.$el.setAttribute('role', 'dialog');
  }

  // Keep a collection of dialog openers, each of which will be bound a click
  // event listener to open the dialog
  this._openers = $$('[data-a11y-dialog-show="' + this._id + '"]');
  this._openers.forEach(
    function (opener) {
      opener.addEventListener('click', this._show);
    }.bind(this)
  );

  // Keep a collection of dialog closers, each of which will be bound a click
  // event listener to close the dialog
  const $el = this.$el;

  this._closers = $$('[data-a11y-dialog-hide]', this.$el)
    // This filter is necessary in case there are nested dialogs, so that
    // only closers from the current dialog are retrieved and effective
    .filter(function (closer) {
      // Testing for `[aria-modal="true"]` is not enough since this attribute
      // and the collect of closers is done at instantation time, when nested
      // dialogs might not have yet been instantiated. Note that if the dialogs
      // are manually instantiated, this could still fail because none of these
      // selectors would match; this would cause closers to close all parent
      // dialogs instead of just the current one
      return closer.closest('[aria-modal="true"], [data-a11y-dialog]') === $el
    })
    .concat($$('[data-a11y-dialog-hide="' + this._id + '"]'));

  this._closers.forEach(
    function (closer) {
      closer.addEventListener('click', this._hide);
    }.bind(this)
  );

  // Execute all callbacks registered for the `create` event
  this._fire('create');

  return this
};

/**
 * Show the dialog element, disable all the targets (siblings), trap the
 * current focus within it, listen for some specific key presses and fire all
 * registered callbacks for `show` event
 *
 * @param {CustomEvent} event
 * @return {this}
 */
A11yDialog.prototype.show = function (event) {
  // If the dialog is already open, abort
  if (this.shown) {
    return this
  }

  // Keep a reference to the currently focused element to be able to restore
  // it later
  this._previouslyFocused = document.activeElement;
  this.$el.removeAttribute('aria-hidden');
  this.shown = true;

  // Set the focus to the dialog element
  moveFocusToDialog(this.$el);

  // Bind a focus event listener to the body element to make sure the focus
  // stays trapped inside the dialog while open, and start listening for some
  // specific key presses (TAB and ESC)
  document.body.addEventListener('focus', this._maintainFocus, true);
  document.addEventListener('keydown', this._bindKeypress);

  // Execute all callbacks registered for the `show` event
  this._fire('show', event);

  return this
};

/**
 * Hide the dialog element, enable all the targets (siblings), restore the
 * focus to the previously active element, stop listening for some specific
 * key presses and fire all registered callbacks for `hide` event
 *
 * @param {CustomEvent} event
 * @return {this}
 */
A11yDialog.prototype.hide = function (event) {
  // If the dialog is already closed, abort
  if (!this.shown) {
    return this
  }

  this.shown = false;
  this.$el.setAttribute('aria-hidden', 'true');

  // If there was a focused element before the dialog was opened (and it has a
  // `focus` method), restore the focus back to it
  // See: https://github.com/KittyGiraudel/a11y-dialog/issues/108
  if (this._previouslyFocused && this._previouslyFocused.focus) {
    this._previouslyFocused.focus();
  }

  // Remove the focus event listener to the body element and stop listening
  // for specific key presses
  document.body.removeEventListener('focus', this._maintainFocus, true);
  document.removeEventListener('keydown', this._bindKeypress);

  // Execute all callbacks registered for the `hide` event
  this._fire('hide', event);

  return this
};

/**
 * Destroy the current instance (after making sure the dialog has been hidden)
 * and remove all associated listeners from dialog openers and closers
 *
 * @return {this}
 */
A11yDialog.prototype.destroy = function () {
  // Hide the dialog to avoid destroying an open instance
  this.hide();

  // Remove the click event listener from all dialog openers
  this._openers.forEach(
    function (opener) {
      opener.removeEventListener('click', this._show);
    }.bind(this)
  );

  // Remove the click event listener from all dialog closers
  this._closers.forEach(
    function (closer) {
      closer.removeEventListener('click', this._hide);
    }.bind(this)
  );

  // Execute all callbacks registered for the `destroy` event
  this._fire('destroy');

  // Keep an object of listener types mapped to callback functions
  this._listeners = {};

  return this
};

/**
 * Register a new callback for the given event type
 *
 * @param {string} type
 * @param {Function} handler
 */
A11yDialog.prototype.on = function (type, handler) {
  if (typeof this._listeners[type] === 'undefined') {
    this._listeners[type] = [];
  }

  this._listeners[type].push(handler);

  return this
};

/**
 * Unregister an existing callback for the given event type
 *
 * @param {string} type
 * @param {Function} handler
 */
A11yDialog.prototype.off = function (type, handler) {
  var index = (this._listeners[type] || []).indexOf(handler);

  if (index > -1) {
    this._listeners[type].splice(index, 1);
  }

  return this
};

/**
 * Iterate over all registered handlers for given type and call them all with
 * the dialog element as first argument, event as second argument (if any). Also
 * dispatch a custom event on the DOM element itself to make it possible to
 * react to the lifecycle of auto-instantiated dialogs.
 *
 * @access private
 * @param {string} type
 * @param {CustomEvent} event
 */
A11yDialog.prototype._fire = function (type, event) {
  var listeners = this._listeners[type] || [];
  var domEvent = new CustomEvent(type, { detail: event });

  this.$el.dispatchEvent(domEvent);

  listeners.forEach(
    function (listener) {
      listener(this.$el, event);
    }.bind(this)
  );
};

/**
 * Private event handler used when listening to some specific key presses
 * (namely ESCAPE and TAB)
 *
 * @access private
 * @param {Event} event
 */
A11yDialog.prototype._bindKeypress = function (event) {
  // This is an escape hatch in case there are nested dialogs, so the keypresses
  // are only reacted to for the most recent one
  const focused = document.activeElement;
  if (focused && focused.closest('[aria-modal="true"]') !== this.$el) return

  // If the dialog is shown and the ESCAPE key is being pressed, prevent any
  // further effects from the ESCAPE key and hide the dialog, unless its role
  // is 'alertdialog', which should be modal
  if (
    this.shown &&
    event.key === ESCAPE_KEY &&
    this.$el.getAttribute('role') !== 'alertdialog'
  ) {
    event.preventDefault();
    this.hide(event);
  }

  // If the dialog is shown and the TAB key is being pressed, make sure the
  // focus stays trapped within the dialog element
  if (this.shown && event.key === TAB_KEY) {
    trapTabKey(this.$el, event);
  }
};

/**
 * Private event handler used when making sure the focus stays within the
 * currently open dialog
 *
 * @access private
 * @param {Event} event
 */
A11yDialog.prototype._maintainFocus = function (event) {
  // If the dialog is shown and the focus is not within a dialog element (either
  // this one or another one in case of nested dialogs) or within an element
  // with the `data-a11y-dialog-focus-trap-ignore` attribute, move it back to
  // its first focusable child.
  // See: https://github.com/KittyGiraudel/a11y-dialog/issues/177
  if (
    this.shown &&
    !event.target.closest('[aria-modal="true"]') &&
    !event.target.closest('[data-a11y-dialog-ignore-focus-trap]')
  ) {
    moveFocusToDialog(this.$el);
  }
};

/**
 * Convert a NodeList into an array
 *
 * @param {NodeList} collection
 * @return {Array<Element>}
 */
function toArray(collection) {
  return Array.prototype.slice.call(collection)
}

/**
 * Query the DOM for nodes matching the given selector, scoped to context (or
 * the whole document)
 *
 * @param {String} selector
 * @param {Element} [context = document]
 * @return {Array<Element>}
 */
function $$(selector, context) {
  return toArray((context || document).querySelectorAll(selector))
}

/**
 * Set the focus to the first element with `autofocus` with the element or the
 * element itself
 *
 * @param {Element} node
 */
function moveFocusToDialog(node) {
  var focused = node.querySelector('[autofocus]') || node;

  focused.focus();
}

/**
 * Get the focusable children of the given element
 *
 * @param {Element} node
 * @return {Array<Element>}
 */
function getFocusableChildren(node) {
  return $$(focusableSelectors.join(','), node).filter(function (child) {
    return !!(
      child.offsetWidth ||
      child.offsetHeight ||
      child.getClientRects().length
    )
  })
}

/**
 * Trap the focus inside the given element
 *
 * @param {Element} node
 * @param {Event} event
 */
function trapTabKey(node, event) {
  var focusableChildren = getFocusableChildren(node);
  var focusedItemIndex = focusableChildren.indexOf(document.activeElement);

  // If the SHIFT key is being pressed while tabbing (moving backwards) and
  // the currently focused item is the first one, move the focus to the last
  // focusable item from the dialog element
  if (event.shiftKey && focusedItemIndex === 0) {
    focusableChildren[focusableChildren.length - 1].focus();
    event.preventDefault();
    // If the SHIFT key is not being pressed (moving forwards) and the currently
    // focused item is the last one, move the focus to the first focusable item
    // from the dialog element
  } else if (
    !event.shiftKey &&
    focusedItemIndex === focusableChildren.length - 1
  ) {
    focusableChildren[0].focus();
    event.preventDefault();
  }
}

function instantiateDialogs() {
  $$('[data-a11y-dialog]').forEach(function (node) {
    new A11yDialog(node);
  });
}

if (typeof document !== 'undefined') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', instantiateDialogs);
  } else {
    if (window.requestAnimationFrame) {
      window.requestAnimationFrame(instantiateDialogs);
    } else {
      window.setTimeout(instantiateDialogs, 16);
    }
  }
}

const swirlDialogCss = "/*!@:host*/.sc-swirl-dialog-h{display:block}/*!@:host **/.sc-swirl-dialog-h *.sc-swirl-dialog{box-sizing:border-box}/*!@.dialog*/.dialog.sc-swirl-dialog{--swirl-ghost-button-background-default:var(--s-surface-overlay-default);--swirl-ghost-button-background-hovered:var(--s-surface-overlay-hovered);--swirl-ghost-button-background-pressed:var(--s-surface-overlay-pressed);position:fixed;z-index:var(--s-z-40);display:flex;justify-content:center;align-items:center;inset:0}/*!@.dialog[aria-hidden=\"true\"]*/.dialog[aria-hidden=\"true\"].sc-swirl-dialog{display:none}/*!@.dialog:not(.dialog--closing) .dialog__backdrop*/.dialog.sc-swirl-dialog:not(.dialog--closing) .dialog__backdrop.sc-swirl-dialog{animation:0.15s dialog-backdrop-fade-in}@media (prefers-reduced-motion){/*!@.dialog:not(.dialog--closing) .dialog__backdrop*/.dialog.sc-swirl-dialog:not(.dialog--closing) .dialog__backdrop.sc-swirl-dialog{animation:none}}/*!@.dialog:not(.dialog--closing) .dialog__body*/.dialog.sc-swirl-dialog:not(.dialog--closing) .dialog__body.sc-swirl-dialog{animation:0.15s dialog-scale-in}@media (prefers-reduced-motion){/*!@.dialog:not(.dialog--closing) .dialog__body*/.dialog.sc-swirl-dialog:not(.dialog--closing) .dialog__body.sc-swirl-dialog{animation:none}}/*!@.dialog--closing*/.dialog--closing.sc-swirl-dialog{animation:0.15s dialog-fade-out;animation-fill-mode:forwards}@media (prefers-reduced-motion){/*!@.dialog--closing*/.dialog--closing.sc-swirl-dialog{animation:none}}/*!@.dialog__backdrop*/.dialog__backdrop.sc-swirl-dialog{position:fixed;background-color:rgba(0, 0, 0, 0.2);inset:0}/*!@.dialog__body*/.dialog__body.sc-swirl-dialog{z-index:var(--s-z-40);overflow-x:hidden;overflow-y:auto;width:18.5rem;max-height:90vh;padding-top:var(--s-space-24);padding-right:var(--s-space-8);padding-bottom:var(--s-space-8);padding-left:var(--s-space-8);border-radius:var(--s-border-radius-l);background-color:var(--s-surface-overlay-default);text-align:center;box-shadow:var(--s-shadow-level-3)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.dialog__body*/.dialog__body.sc-swirl-dialog{border-radius:var(--s-border-radius-base)}}/*!@.dialog__heading*/.dialog__heading.sc-swirl-dialog{margin:0;margin-bottom:var(--s-space-8);font-size:var(--s-font-size-lg);font-weight:var(--s-font-weight-semibold);line-height:var(--s-line-height-lg)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.dialog__heading*/.dialog__heading.sc-swirl-dialog{font-size:var(--s-font-size-base);line-height:var(--s-line-height-base)}}/*!@.dialog__content*/.dialog__content.sc-swirl-dialog{margin-bottom:var(--s-space-24);line-height:var(--s-line-height-base)}/*!@.dialog__content ::slotted(*)*/.dialog__content .sc-swirl-dialog-s>*{margin:0}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.dialog__content*/.dialog__content.sc-swirl-dialog{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}@keyframes dialog-scale-in{from{transform:scale(0)}to{transform:scale(1)}}@keyframes dialog-backdrop-fade-in{from{opacity:0}to{opacity:1}}@keyframes dialog-fade-out{from{opacity:1}to{opacity:0}}";

/**
 * @slot slot - The dialog content
 */
class SwirlDialog {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.primaryAction = createEvent(this, "primaryAction", 7);
    this.secondaryAction = createEvent(this, "secondaryAction", 7);
    this.onKeyDown = (event) => {
      if (event.code === "Escape") {
        this.close();
      }
    };
    this.onBackdropClick = () => {
      this.close();
    };
    this.onPrimaryAction = (event) => {
      this.primaryAction.emit(event);
      this.close();
    };
    this.onSecondaryAction = (event) => {
      this.secondaryAction.emit(event);
      this.close();
    };
    this.hideLabel = undefined;
    this.intent = "primary";
    this.label = undefined;
    this.primaryActionLabel = undefined;
    this.secondaryActionLabel = undefined;
    this.closing = false;
  }
  componentDidLoad() {
    this.dialog = new A11yDialog(this.dialogEl);
    this.dialog.on("show", () => {
      var _a;
      (_a = this.controlsContainerEl
        .querySelector("swirl-button button")) === null || _a === void 0 ? void 0 : _a.focus();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.dialog) === null || _a === void 0 ? void 0 : _a.destroy();
  }
  /**
   * Open the dialog.
   */
  async open() {
    this.dialog.show();
  }
  /**
   * Close the dialog.
   */
  async close() {
    if (this.closing) {
      return;
    }
    this.closing = true;
    setTimeout(() => {
      this.dialog.hide();
      this.closing = false;
    }, 150);
  }
  render() {
    const className = classnames("dialog", { "dialog--closing": this.closing });
    return (hAsync(Host, null, hAsync("div", { "aria-describedby": "content", "aria-hidden": "true", "aria-labelledby": this.hideLabel ? undefined : "label", "aria-label": this.hideLabel ? this.label : undefined, "aria-modal": "true", class: className, onKeyDown: this.onKeyDown, ref: (el) => (this.dialogEl = el), role: "alertdialog" }, hAsync("div", { class: "dialog__backdrop", onClick: this.onBackdropClick }), hAsync("div", { class: "dialog__body", part: "dialog__body", role: "document" }, !this.hideLabel && (hAsync("h2", { class: "dialog__heading", part: "dialog__heading", id: "label" }, this.label)), hAsync("div", { class: "dialog__content", part: "dialog__content", id: "content" }, hAsync("slot", null)), hAsync("swirl-button-group", { class: "dialog__controls", ref: (el) => (this.controlsContainerEl = el), stretch: true, wrap: true }, this.secondaryActionLabel && (hAsync("swirl-button", { label: this.secondaryActionLabel, onClick: this.onSecondaryAction })), this.primaryActionLabel && (hAsync("swirl-button", { intent: this.intent, label: this.primaryActionLabel, onClick: this.onPrimaryAction, variant: this.intent === "critical" ? "ghost" : "flat" })))))));
  }
  static get style() { return swirlDialogCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-dialog",
    "$members$": {
      "hideLabel": [4, "hide-label"],
      "intent": [1],
      "label": [1],
      "primaryActionLabel": [1, "primary-action-label"],
      "secondaryActionLabel": [1, "secondary-action-label"],
      "closing": [32],
      "open": [64],
      "close": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlEmptyStateCss = "/*!@:host*/.sc-swirl-empty-state-h{display:block}/*!@:host **/.sc-swirl-empty-state-h *.sc-swirl-empty-state{box-sizing:border-box}/*!@.empty-state*/.empty-state.sc-swirl-empty-state{display:flex;max-width:28rem;align-items:center;flex-direction:column;gap:var(--s-space-16)}/*!@.empty-state__illustration*/.empty-state__illustration.sc-swirl-empty-state{max-width:16rem}/*!@.empty-state__body*/.empty-state__body.sc-swirl-empty-state{display:flex;align-items:center;flex-direction:column;gap:var(--s-space-8)}";

class SwirlEmptyState {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.heading = undefined;
    this.illustration = undefined;
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { class: "empty-state" }, this.illustration && (hAsync("img", { alt: "", class: "empty-state__illustration", src: this.illustration })), hAsync("div", { class: "empty-state__body" }, this.heading && (hAsync("swirl-heading", { align: "center", as: "p", text: this.heading })), hAsync("div", { class: "empty-state__content" }, hAsync("swirl-text", { align: "center", color: "subdued" }, hAsync("slot", null)))))));
  }
  static get style() { return swirlEmptyStateCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-empty-state",
    "$members$": {
      "heading": [1],
      "illustration": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlFileUploaderCss = ".sc-swirl-file-uploader-h{display:block;width:100%}.sc-swirl-file-uploader-h *.sc-swirl-file-uploader{box-sizing:border-box}.file-uploader.sc-swirl-file-uploader{width:100%}.file-uploader--show-dropzone.sc-swirl-file-uploader .file-uploader__dropzone.sc-swirl-file-uploader{position:relative;display:flex;width:100%;height:10rem;margin-top:var(--s-space-16);justify-content:center;align-items:center;border:var(--s-border-width-default) dashed var(--s-border-strong);border-radius:var(--s-border-radius-s);flex-direction:column}.file-uploader--show-dropzone.sc-swirl-file-uploader .file-uploader__dropzone.sc-swirl-file-uploader:focus-within{border-width:0.125rem;border-color:var(--s-focus-default)}.file-uploader--show-dropzone.sc-swirl-file-uploader .file-uploader__input.sc-swirl-file-uploader{position:absolute;z-index:1;display:block;width:100%;cursor:pointer;opacity:0;inset:0}.file-uploader--disabled.sc-swirl-file-uploader .file-uploader__input.sc-swirl-file-uploader{cursor:default}.file-uploader--disabled.sc-swirl-file-uploader .file-uploader__dropzone-cta.sc-swirl-file-uploader,.file-uploader--disabled.sc-swirl-file-uploader .file-uploader__drag-drop-label.sc-swirl-file-uploader{color:var(--s-text-disabled)}.file-uploader--disabled.sc-swirl-file-uploader .file-uploader__dropzone-icon.sc-swirl-file-uploader{color:var(--s-text-disabled)}.file-uploader__label.sc-swirl-file-uploader{display:block;font-weight:var(--s-font-weight-semibold);line-height:var(--s-line-height-base)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.file-uploader__label.sc-swirl-file-uploader{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.file-uploader__description.sc-swirl-file-uploader{display:block;margin-top:var(--s-space-4);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.file-uploader__description.sc-swirl-file-uploader{margin-top:var(--s-space-2)}}.file-uploader__dropzone-icon.sc-swirl-file-uploader{color:var(--s-icon-highlight)}.file-uploader__dropzone-label.sc-swirl-file-uploader{margin-top:var(--s-space-16);line-height:var(--s-line-height-base)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.file-uploader__dropzone-label.sc-swirl-file-uploader{margin-top:var(--s-space-8);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.file-uploader__dropzone-cta.sc-swirl-file-uploader{color:var(--s-interactive-primary-default);font-weight:var(--s-font-weight-medium)}.file-uploader__upload-button.sc-swirl-file-uploader{margin-top:var(--s-space-16)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.file-uploader__upload-button.sc-swirl-file-uploader{margin-top:var(--s-space-12)}}.file-uploader__input.sc-swirl-file-uploader{display:none}";

class SwirlFileUploader {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.onChange = (event) => {
      const fileList = event.target.files;
      this.valueChange.emit(fileList);
    };
    this.onUploadButtonClick = () => {
      this.inputEl.click();
    };
    this.accept = undefined;
    this.ctaLabel = "Click to upload";
    this.description = undefined;
    this.disabled = undefined;
    this.dragDropLabel = "or drag and drop.";
    this.inputId = undefined;
    this.inputName = undefined;
    this.label = undefined;
    this.multiple = undefined;
    this.showDropzone = true;
    this.uploadButtonLabel = "Select file";
  }
  /**
   * Reset the file input.
   */
  async reset() {
    this.inputEl.value = "";
  }
  render() {
    const ariaDescribedby = Boolean(this.description)
      ? `${this.inputId}-description ${this.inputId}-additional-label`
      : `${this.inputId}-additional-label`;
    const tabIndex = this.showDropzone ? 0 : -1;
    const className = classnames("file-uploader", {
      "file-uploader--disabled": this.disabled,
      "file-uploader--show-dropzone": this.showDropzone,
    });
    return (hAsync(Host, null, hAsync("div", { class: className }, hAsync("label", { class: "file-uploader__label", htmlFor: this.inputId, id: `${this.inputEl}-label` }, this.label), this.description && (hAsync("span", { class: "file-uploader__description", id: `${this.inputId}-description` }, this.description)), hAsync("div", { class: "file-uploader__dropzone" }, this.showDropzone ? ([
      hAsync("swirl-icon-cloud-upload", { class: "file-uploader__dropzone-icon" }),
      hAsync("div", { class: "file-uploader__dropzone-label", id: `${this.inputId}-additional-label` }, hAsync("span", { class: "file-uploader__dropzone-cta" }, this.ctaLabel), " ", hAsync("span", { class: "file-uploader__drag-drop-label" }, this.dragDropLabel)),
    ]) : (hAsync("swirl-button", { class: "file-uploader__upload-button", disabled: this.disabled, swirlAriaDescribedby: ariaDescribedby, intent: "primary", label: this.uploadButtonLabel, onClick: this.onUploadButtonClick, variant: "flat" })), hAsync("input", { accept: this.accept, "aria-describedby": ariaDescribedby, "aria-disabled": this.disabled, autoComplete: "off", class: "file-uploader__input", disabled: this.disabled, id: this.inputId, multiple: this.multiple, name: this.inputName, onChange: this.onChange, ref: (el) => (this.inputEl = el), tabIndex: tabIndex, type: "file" })))));
  }
  static get style() { return swirlFileUploaderCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-file-uploader",
    "$members$": {
      "accept": [1],
      "ctaLabel": [1, "cta-label"],
      "description": [1],
      "disabled": [4],
      "dragDropLabel": [1, "drag-drop-label"],
      "inputId": [1, "input-id"],
      "inputName": [1, "input-name"],
      "label": [1],
      "multiple": [4],
      "showDropzone": [4, "show-dropzone"],
      "uploadButtonLabel": [1, "upload-button-label"],
      "reset": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

var FileSaver_min = createCommonjsModule(function (module, exports) {
(function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});

//# sourceMappingURL=FileSaver.min.js.map
});

const swirlFileViewerCss = "/*!@:host*/.sc-swirl-file-viewer-h{display:block;width:100%;height:100%}/*!@:host **/.sc-swirl-file-viewer-h *.sc-swirl-file-viewer{box-sizing:border-box}/*!@.file-viewer*/.file-viewer.sc-swirl-file-viewer{display:flex;width:100%;height:100%;justify-content:center;align-items:center}/*!@.file-viewer__file*/.file-viewer__file.sc-swirl-file-viewer{display:inline-flex;width:100%;height:100%;justify-content:center;align-items:center}";

class SwirlFileViewer {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activate = createEvent(this, "activate", 7);
    this.visiblePagesChange = createEvent(this, "visiblePagesChange", 7);
    this.onActivate = (event) => {
      this.activate.emit(event.detail);
    };
    this.onVisiblePagesChange = (event) => {
      this.visiblePagesChange.emit(event.detail);
    };
    this.active = true;
    this.autoplay = undefined;
    this.description = undefined;
    this.errorMessage = "File could not be loaded.";
    this.file = undefined;
    this.thumbnailUrl = undefined;
    this.type = undefined;
    this.typeUnsupportedMessage = "File type is not supported.";
    this.viewMode = "single";
    this.zoom = 1;
  }
  /**
   * Download the file.
   */
  async download() {
    const fileName = this.file.split("/").pop();
    const file = await fetch(this.file);
    FileSaver_min.saveAs(await file.blob(), fileName);
  }
  /**
   * Print the file. Applicable to PDFs only.
   */
  async print() {
    if (this.type === "application/pdf") {
      this.viewer.print();
    }
  }
  render() {
    const unsupportedType = !Boolean(this.type) ||
      (!this.type.startsWith("image/") &&
        !this.type.startsWith("video/") &&
        !this.type.startsWith("audio/") &&
        this.type !== "text/plain" &&
        this.type !== "text/csv" &&
        this.type !== "application/pdf");
    return (hAsync(Host, null, hAsync("div", { class: "file-viewer" }, this.type && this.active && (hAsync("div", { class: "file-viewer__file" }, this.type.startsWith("image/") && (hAsync("swirl-file-viewer-image", { description: this.description, errorMessage: this.errorMessage, file: this.file, ref: (el) => (this.viewer = el) })), this.type === "text/plain" && (hAsync("swirl-file-viewer-text", { errorMessage: this.errorMessage, file: this.file, ref: (el) => (this.viewer = el) })), this.type === "text/csv" && (hAsync("swirl-file-viewer-csv", { errorMessage: this.errorMessage, file: this.file, ref: (el) => (this.viewer = el) })), this.type === "application/pdf" && (hAsync("swirl-file-viewer-pdf", { errorMessage: this.errorMessage, file: this.file, onActivate: this.onActivate, onVisiblePagesChange: this.onVisiblePagesChange, ref: (el) => (this.viewer = el), viewMode: this.viewMode, zoom: this.zoom })), this.type.startsWith("video/") && (hAsync("swirl-file-viewer-video", { autoplay: this.autoplay, file: this.file, ref: (el) => (this.viewer = el), type: this.type })), this.type.startsWith("audio/") && (hAsync("swirl-file-viewer-audio", { autoplay: this.autoplay, file: this.file, ref: (el) => (this.viewer = el), type: this.type })), unsupportedType && (hAsync("swirl-inline-error", { message: this.typeUnsupportedMessage })))))));
  }
  static get style() { return swirlFileViewerCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-file-viewer",
    "$members$": {
      "active": [4],
      "autoplay": [4],
      "description": [1],
      "errorMessage": [1, "error-message"],
      "file": [1],
      "thumbnailUrl": [1, "thumbnail-url"],
      "type": [1],
      "typeUnsupportedMessage": [1, "type-unsupported-message"],
      "viewMode": [1, "view-mode"],
      "zoom": [8],
      "download": [64],
      "print": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlFileViewerAudioCss = "/*!@:host*/.sc-swirl-file-viewer-audio-h{display:inline-flex;width:100%;height:100%}/*!@:host **/.sc-swirl-file-viewer-audio-h *.sc-swirl-file-viewer-audio{box-sizing:border-box}/*!@.file-viewer-audio__audio*/.file-viewer-audio__audio.sc-swirl-file-viewer-audio{width:100%;height:100%}";

class SwirlFileViewerAudio {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activate = createEvent(this, "activate", 7);
    this.autoplay = undefined;
    this.file = undefined;
    this.type = undefined;
  }
  componentDidLoad() {
    this.activate.emit(this.el);
  }
  render() {
    return (hAsync(Host, { class: "file-viewer-audio" }, hAsync("audio", { autoplay: this.autoplay, class: "file-viewer-audio__audio", controls: true }, hAsync("source", { src: this.file, type: this.type }))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlFileViewerAudioCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-file-viewer-audio",
    "$members$": {
      "autoplay": [4],
      "file": [1],
      "type": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

var papaparse_min = createCommonjsModule(function (module, exports) {
/* @license
Papa Parse
v5.3.2
https://github.com/mholt/PapaParse
License: MIT
*/
!function(e,t){module.exports=t();}(commonjsGlobal,function s(){var f="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=n&&/blob:/i.test((f.location||{}).protocol),a={},h=0,b={parse:function(e,t){var i=(t=t||{}).dynamicTyping||!1;M(i)&&(t.dynamicTypingFunction=i,i={});if(t.dynamicTyping=i,t.transform=!!M(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var r=function(){if(!b.WORKERS_SUPPORTED)return !1;var e=(i=f.URL||f.webkitURL||null,r=s.toString(),b.BLOB_URL||(b.BLOB_URL=i.createObjectURL(new Blob(["(",r,")();"],{type:"text/javascript"})))),t=new f.Worker(e);var i,r;return t.onmessage=_,t.id=h++,a[t.id]=t}();return r.userStep=t.step,r.userChunk=t.chunk,r.userComplete=t.complete,r.userError=t.error,t.step=M(t.step),t.chunk=M(t.chunk),t.complete=M(t.complete),t.error=M(t.error),delete t.worker,void r.postMessage({input:e,config:t,workerId:r.id})}var n=null;"string"==typeof e?n=t.download?new l(t):new p(t):!0===e.readable&&M(e.read)&&M(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=",",y="\r\n",s='"',a=s+s,i=!1,r=null,o=!1;!function(){if("object"!=typeof t)return;"string"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return -1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);("boolean"==typeof t.quotes||"function"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(i=t.skipEmptyLines);"string"==typeof t.newline&&(y=t.newline);"string"==typeof t.quoteChar&&(s=t.quoteChar);"boolean"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");r=t.columns;}void 0!==t.escapeChar&&(a=t.escapeChar+s);("boolean"==typeof t.escapeFormulae||t.escapeFormulae instanceof RegExp)&&(o=t.escapeFormulae instanceof RegExp?t.escapeFormulae:/^[=+\-@\t\r].*$/);}();var h=new RegExp(j(s),"g");"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return u(null,e,i);if("object"==typeof e[0])return u(r||Object.keys(e[0]),e,i)}else if("object"==typeof e)return "string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||r),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:"object"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),u(e.fields||[],e.data||[],i);throw new Error("Unable to serialize unrecognized input");function u(e,t,i){var r="";"string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(r+=m),r+=v(e[a],a);0<t.length&&(r+=y);}for(var o=0;o<t.length;o++){var h=n?e.length:t[o].length,u=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(i&&!n&&(u="greedy"===i?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===i&&n){for(var d=[],l=0;l<h;l++){var c=s?e[l]:l;d.push(t[o][c]);}u=""===d.join("").trim();}if(!u){for(var p=0;p<h;p++){0<p&&!f&&(r+=m);var g=n&&s?e[p]:p;r+=v(t[o][g],p);}o<t.length-1&&(!i||0<h&&!f)&&(r+=y);}}return r}function v(e,t){if(null==e)return "";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var i=!1;o&&"string"==typeof e&&o.test(e)&&(e="'"+e,i=!0);var r=e.toString().replace(h,a);return (i=i||!0===n||"function"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return !0;return !1}(r,b.BAD_DELIMITERS)||-1<r.indexOf(m)||" "===r.charAt(0)||" "===r.charAt(r.length-1))?s+r+s:r}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK="\ufeff",b.BAD_DELIMITERS=["\r","\n",'"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=",",b.Parser=E,b.ParserHandle=i,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var i=o.config||{},h=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return !0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},i)});}),e(),this;function e(){if(0!==h.length){var e,t,i,r,n=h[0];if(M(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,i=n.inputElem,r=s.reason,void(M(o.error)&&o.error({name:e},t,i,r));if("skip"===s.action)return void u();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config));}else if("skip"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){M(a)&&a(e,n.file,n.inputElem),u();},b.parse(n.file,n.instanceConfig);}else M(o.complete)&&o.complete();}function u(){h.splice(0,1),e();}};}function u(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=w(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new i(t),(this._handle.streamer=this)._config=t;}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&M(this._config.beforeFirstChunk)){var i=this._config.beforeFirstChunk(e);void 0!==i&&(e=i);}this.isFirstChunk=!1,this._halted=!1;var r=this._partialLine+e;this._partialLine="";var n=this._handle.parse(r,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=r.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(M(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0;}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!M(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0;},this._sendError=function(e){M(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1});};}function l(e){var r;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),u.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded();}:function(){this._readChunk();},this.stream=function(e){this._input=e,this._nextChunk();},this._readChunk=function(){if(this._finished)this._chunkLoaded();else {if(r=new XMLHttpRequest,this._config.withCredentials&&(r.withCredentials=this._config.withCredentials),n||(r.onload=v(this._chunkLoaded,this),r.onerror=v(this._chunkError,this)),r.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)r.setRequestHeader(t,e[t]);}if(this._config.chunkSize){var i=this._start+this._config.chunkSize-1;r.setRequestHeader("Range","bytes="+this._start+"-"+i);}try{r.send(this._config.downloadRequestBody);}catch(e){this._chunkError(e.message);}n&&0===r.status&&this._chunkError();}},this._chunkLoaded=function(){4===r.readyState&&(r.status<200||400<=r.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:r.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader("Content-Range");if(null===t)return -1;return parseInt(t.substring(t.lastIndexOf("/")+1))}(r),this.parseChunk(r.responseText)));},this._chunkError=function(e){var t=r.statusText||e;this._sendError(new Error(t));};}function c(e){var r,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),u.call(this,e);var s="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((r=new FileReader).onload=v(this._chunkLoaded,this),r.onerror=v(this._chunkError,this)):r=new FileReaderSync,this._nextChunk();},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk();},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t);}var i=r.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:i}});},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result);},this._chunkError=function(){this._sendError(r.error);};}function p(e){var i;u.call(this,e=e||{}),this.stream=function(e){return i=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=i.substring(0,t),i=i.substring(t)):(e=i,i=""),this._finished=!i,this.parseChunk(e)}};}function g(e){u.call(this,e=e||{});var t=[],i=!0,r=!1;this.pause=function(){u.prototype.pause.apply(this,arguments),this._input.pause();},this.resume=function(){u.prototype.resume.apply(this,arguments),this._input.resume();},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError);},this._checkIsFinished=function(){r&&1===t.length&&(this._finished=!0);},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0;},this._streamData=v(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()));}catch(e){this._streamError(e);}},this),this._streamError=v(function(e){this._streamCleanUp(),this._sendError(e);},this),this._streamEnd=v(function(){this._streamCleanUp(),r=!0,this._streamData("");},this),this._streamCleanUp=v(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError);},this);}function i(m){var a,o,h,r=Math.pow(2,53),n=-r,s=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,u=/^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/,t=this,i=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(M(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else {if(g(),0===c.data.length)return;i+=e.data.length,m.preview&&i>m.preview?o.abort():(c.data=c.data[0],p(c,t));}};}function y(e){return "greedy"===m.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function g(){return c&&h&&(k("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+b.DefaultDelimiter+"'"),h=!1),m.skipEmptyLines&&(c.data=c.data.filter(function(e){return !y(e)})),_()&&function(){if(!c)return;function e(e,t){M(m.transformHeader)&&(e=m.transformHeader(e,t)),l.push(e);}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1);}else c.data.forEach(e);}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var i,r=m.header?{}:[];for(i=0;i<e.length;i++){var n=i,s=e[i];m.header&&(n=i>=l.length?"__parsed_extra":l[i]),m.transform&&(s=m.transform(s,n)),s=v(n,s),"__parsed_extra"===n?(r[n]=r[n]||[],r[n].push(s)):r[n]=s;}return m.header&&(i>l.length?k("FieldMismatch","TooManyFields","Too many fields: expected "+l.length+" fields but parsed "+i,f+t):i<l.length&&k("FieldMismatch","TooFewFields","Too few fields: expected "+l.length+" fields but parsed "+i,f+t)),r}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function v(e,t){return i=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[i]&&(m.dynamicTyping[i]=m.dynamicTypingFunction(i)),!0===(m.dynamicTyping[i]||m.dynamicTyping)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<r)return !0}return !1}(t)?parseFloat(t):u.test(t)?new Date(t):""===t?null:t):t;var i;}function k(e,t,i,r){var n={type:e,code:t,message:i};void 0!==r&&(n.row=r),c.errors.push(n);}this.parse=function(e,t,i){var r=m.quoteChar||'"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var i=new RegExp(j(t)+"([^]*?)"+j(t),"gm"),r=(e=e.replace(i,"")).split("\r"),n=e.split("\n"),s=1<n.length&&n[0].length<r[0].length;if(1===r.length||s)return "\n";for(var a=0,o=0;o<r.length;o++)"\n"===r[o][0]&&a++;return a>=r.length/2?"\r\n":"\r"}(e,r)),h=!1,m.delimiter)M(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else {var n=function(e,t,i,r,n){var s,a,o,h;n=n||[",","\t","|",";",b.RECORD_SEP,b.UNIT_SEP];for(var u=0;u<n.length;u++){var f=n[u],d=0,l=0,c=0;o=void 0;for(var p=new E({comments:r,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(i&&y(p.data[g]))c++;else {var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_;}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===h||h<l)&&1.99<l&&(a=d,s=f,h=l);}return {successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(h=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter;}var s=w(m);return m.preview&&m.header&&s.preview++,a=e,o=new E(s),c=o.parse(a,t,i),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=M(m.chunk)?"":a.substring(o.getCharIndex());},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3);},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,M(m.complete)&&m.complete(c),a="";};}function j(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(e){var S,O=(e=e||{}).delimiter,x=e.newline,I=e.comments,T=e.step,D=e.preview,A=e.fastMode,L=S=void 0===e.quoteChar||null===e.quoteChar?'"':e.quoteChar;if(void 0!==e.escapeChar&&(L=e.escapeChar),("string"!=typeof O||-1<b.BAD_DELIMITERS.indexOf(O))&&(O=","),I===O)throw new Error("Comment character same as delimiter");!0===I?I="#":("string"!=typeof I||-1<b.BAD_DELIMITERS.indexOf(I))&&(I=!1),"\n"!==x&&"\r"!==x&&"\r\n"!==x&&(x="\n");var F=0,z=!1;this.parse=function(r,t,i){if("string"!=typeof r)throw new Error("Input must be a string");var n=r.length,e=O.length,s=x.length,a=I.length,o=M(T),h=[],u=[],f=[],d=F=0;if(!r)return C();if(A||!1!==A&&-1===r.indexOf(S)){for(var l=r.split(x),c=0;c<l.length;c++){if(f=l[c],F+=f.length,c!==l.length-1)F+=x.length;else if(i)return C();if(!I||f.substring(0,a)!==I){if(o){if(h=[],k(f.split(O)),R(),z)return C()}else k(f.split(O));if(D&&D<=c)return h=h.slice(0,D),C(!0)}}return C()}for(var p=r.indexOf(O,F),g=r.indexOf(x,F),_=new RegExp(j(L)+j(S),"g"),m=r.indexOf(S,F);;)if(r[F]!==S)if(I&&0===f.length&&r.substring(F,F+a)===I){if(-1===g)return C();F=g+s,g=r.indexOf(x,F),p=r.indexOf(O,F);}else if(-1!==p&&(p<g||-1===g))f.push(r.substring(F,p)),F=p+e,p=r.indexOf(O,F);else {if(-1===g)break;if(f.push(r.substring(F,g)),w(g+s),o&&(R(),z))return C();if(D&&h.length>=D)return C(!0)}else for(m=F,F++;;){if(-1===(m=r.indexOf(S,m+1)))return i||u.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:h.length,index:F}),E();if(m===n-1)return E(r.substring(F,m).replace(_,S));if(S!==L||r[m+1]!==L){if(S===L||0===m||r[m-1]!==L){-1!==p&&p<m+1&&(p=r.indexOf(O,m+1)),-1!==g&&g<m+1&&(g=r.indexOf(x,m+1));var y=b(-1===g?p:Math.min(p,g));if(r.substr(m+1+y,e)===O){f.push(r.substring(F,m).replace(_,S)),r[F=m+1+y+e]!==S&&(m=r.indexOf(S,F)),p=r.indexOf(O,F),g=r.indexOf(x,F);break}var v=b(g);if(r.substring(m+1+v,m+1+v+s)===x){if(f.push(r.substring(F,m).replace(_,S)),w(m+1+v+s),p=r.indexOf(O,F),m=r.indexOf(S,F),o&&(R(),z))return C();if(D&&h.length>=D)return C(!0);break}u.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:h.length,index:F}),m++;}}else m++;}return E();function k(e){h.push(e),d=F;}function b(e){var t=0;if(-1!==e){var i=r.substring(m+1,e);i&&""===i.trim()&&(t=i.length);}return t}function E(e){return i||(void 0===e&&(e=r.substring(F)),f.push(e),F=n,k(f),o&&R()),C()}function w(e){F=e,k(f),f=[],g=r.indexOf(x,F);}function C(e){return {data:h,errors:u,meta:{delimiter:O,linebreak:x,aborted:z,truncated:!!e,cursor:d+(t||0)}}}function R(){T(C()),h=[],u=[];}},this.abort=function(){z=!0;},this.getCharIndex=function(){return F};}function _(e){var t=e.data,i=a[t.workerId],r=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){r=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}});},pause:y,resume:y};if(M(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!r);s++);delete t.results;}else M(i.userChunk)&&(i.userChunk(t.results,n,t.file),delete t.results);}t.finished&&!r&&m(t.workerId,t.results);}function m(e,t){var i=a[e];M(i.userComplete)&&i.userComplete(t),i.terminate(),delete a[e];}function y(){throw new Error("Not implemented.")}function w(e){if("object"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var i in e)t[i]=w(e[i]);return t}function v(e,t){return function(){e.apply(t,arguments);}}function M(e){return "function"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if("string"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var i=b.parse(t.input,t.config);i&&f.postMessage({workerId:b.WORKER_ID,results:i,finished:!0});}}),(l.prototype=Object.create(u.prototype)).constructor=l,(c.prototype=Object.create(u.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(u.prototype)).constructor=g,b});
});

const swirlFileViewerCsvCss = "/*!@:host*/.sc-swirl-file-viewer-csv-h{position:relative;display:inline-flex;width:100%;max-height:100%}/*!@:host **/.sc-swirl-file-viewer-csv-h *.sc-swirl-file-viewer-csv{box-sizing:border-box}/*!@.file-viewer-csv__csv*/.file-viewer-csv__csv.sc-swirl-file-viewer-csv{overflow:auto;width:100%;max-height:100%;padding:var(--s-space-16);background-color:var(--s-background-default)}/*!@.file-viewer-csv__table*/.file-viewer-csv__table.sc-swirl-file-viewer-csv{margin-right:auto;margin-left:auto;border-collapse:collapse;line-height:var(--s-line-height-base)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.file-viewer-csv__table*/.file-viewer-csv__table.sc-swirl-file-viewer-csv{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.file-viewer-csv__cell*/.file-viewer-csv__cell.sc-swirl-file-viewer-csv{padding:var(--s-space-8);border:var(--s-border-width-default) solid var(--s-border-default)}/*!@.file-viewer-csv__spinner*/.file-viewer-csv__spinner.sc-swirl-file-viewer-csv{position:absolute;display:flex;justify-content:center;align-items:center;background-color:rgba(0, 0, 0, 0.2);inset:0}/*!@.file-viewer-csv__error*/.file-viewer-csv__error.sc-swirl-file-viewer-csv{position:absolute;top:50%;left:50%;transform:translate3d(-50%, -50%, 0)}";

class SwirlFileViewerCsv {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activate = createEvent(this, "activate", 7);
    this.errorMessage = "File could not be loaded.";
    this.file = undefined;
    this.data = undefined;
    this.error = undefined;
    this.loading = undefined;
  }
  componentWillLoad() {
    this.updateTable();
  }
  componentDidLoad() {
    this.activate.emit(this.el);
  }
  async updateTable() {
    var _a;
    this.error = false;
    this.loading = true;
    try {
      const response = await fetch(this.file);
      const parsed = papaparse_min.parse(await response.text(), {
        dynamicTyping: true,
        fastMode: false,
        skipEmptyLines: true,
      });
      if (((_a = parsed.errors) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        this.error = true;
        this.loading = false;
        return;
      }
      this.data = parsed.data;
      this.loading = false;
    }
    catch (e) {
      this.loading = false;
      this.error = true;
    }
  }
  render() {
    var _a;
    return (hAsync(Host, { class: "file-viewer-csv", exportparts: "file-viewer-csv__table" }, this.error && (hAsync("swirl-inline-error", { class: "file-viewer-csv__error", message: this.errorMessage })), hAsync("div", { class: "file-viewer-csv__csv", tabIndex: 0 }, hAsync("table", { class: "file-viewer-csv__table", part: "file-viewer-csv__table" }, hAsync("tbody", null, (_a = this.data) === null || _a === void 0 ? void 0 : _a.map((row, index) => (hAsync("tr", { class: "file-viewer-csv__row", key: `row-${index}` }, row.map((cell, i) => (hAsync("td", { class: "file-viewer-csv__cell", key: `cell-${index}-${i}` }, cell))))))))), this.loading && (hAsync("div", { class: "file-viewer-csv__spinner" }, hAsync("swirl-spinner", null)))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "file": ["updateTable"]
  }; }
  static get style() { return swirlFileViewerCsvCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-file-viewer-csv",
    "$members$": {
      "errorMessage": [1, "error-message"],
      "file": [1],
      "data": [32],
      "error": [32],
      "loading": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlFileViewerImageCss = "/*!@:host*/.sc-swirl-file-viewer-image-h{position:relative;display:inline-flex;max-height:100%}/*!@:host **/.sc-swirl-file-viewer-image-h *.sc-swirl-file-viewer-image{box-sizing:border-box}/*!@.file-viewer-image__image*/.file-viewer-image__image.sc-swirl-file-viewer-image{max-width:100%;-o-object-fit:contain;object-fit:contain}/*!@.file-viewer-image__spinner*/.file-viewer-image__spinner.sc-swirl-file-viewer-image{position:absolute;display:flex;justify-content:center;align-items:center;background-color:rgba(0, 0, 0, 0.2);inset:0}/*!@.file-viewer-image__error*/.file-viewer-image__error.sc-swirl-file-viewer-image{position:absolute;top:50%;left:50%;transform:translate3d(-50%, -50%, 0)}";

class SwirlFileViewerImage {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activate = createEvent(this, "activate", 7);
    this.panX = 0;
    this.panY = 0;
    this.zoom = 1;
    this.onError = () => {
      this.error = true;
      this.loading = false;
    };
    this.onLoad = () => {
      this.error = false;
      this.loading = false;
    };
    this.onDblClick = (event) => {
      this.clickToZoom(event);
    };
    this.onWheel = (event) => {
      event.preventDefault();
      const zoom = Math.min(Math.max(1, this.zoom + (-1 * event.deltaY) / 100), this.maxZoom);
      if (zoom === this.zoom) {
        return;
      }
      const centerX = event.offsetX;
      const centerY = event.offsetY;
      this.updateTransformOrigin(centerX, centerY);
      this.updateZoomAndPan(zoom, 0, 0);
    };
    this.onPointerDown = (event) => {
      this.startPan(event);
    };
    this.onPointerMove = (event) => {
      this.pan(event);
    };
    this.onPointerUp = () => {
      this.endPan();
    };
    this.onTouchStart = (event) => {
      event.preventDefault();
      if (event.touches.length === 2) {
        this.startPinchToZoom(event);
      }
    };
    this.onTouchMove = (event) => {
      event.preventDefault();
      if (this.pinching) {
        this.pinchToZoom(event);
      }
    };
    this.onTouchEnd = (event) => {
      event.preventDefault();
      if (this.pinching) {
        this.endPinchToZoom();
      }
    };
    this.startPinchToZoom = (event) => {
      if (!Boolean(this.imageEl)) {
        return;
      }
      this.pinchDistance = this.getPinchDistance(event);
      this.pinching = true;
    };
    this.pinchToZoom = (event) => {
      const distance = this.getPinchDistance(event) - this.pinchDistance;
      const zoom = Math.min(Math.max(1, this.zoom + distance / 100), this.maxZoom);
      if (this.zoom === zoom) {
        return;
      }
      this.pinchDistance = this.getPinchDistance(event);
      this.updateZoomAndPan(zoom);
    };
    this.endPinchToZoom = () => {
      this.pinching = false;
      if (Math.abs(this.zoom - 1) < 0.2) {
        this.zoom = 1;
        this.imageEl.style.transform = "";
      }
    };
    this.getPinchDistance = (event) => {
      return Math.hypot(event.touches[0].pageX - event.touches[1].pageX, event.touches[0].pageY - event.touches[1].pageY);
    };
    this.clickToZoom = (event) => {
      const supportsMultiTouch = navigator.maxTouchPoints > 1;
      if (supportsMultiTouch) {
        return;
      }
      if (this.zoom === 1) {
        const centerX = event.pageX - this.el.getBoundingClientRect().x;
        const centerY = event.pageY - this.el.getBoundingClientRect().y;
        this.updateTransformOrigin(centerX, centerY);
        this.updateZoomAndPan(2);
      }
      else {
        this.updateZoomAndPan(1);
      }
    };
    this.updateZoomAndPan = (zoom, panX, panY) => {
      const newZoom = zoom === undefined ? this.zoom : zoom;
      const zoomDiff = newZoom - this.zoom;
      const newPanX = panX === undefined ? this.panX + this.panX * zoomDiff : panX;
      const newPanY = panX === undefined ? this.panY + this.panY * zoomDiff : panY;
      const previousPanX = this.panX;
      const previousPanY = this.panY;
      this.zoom = newZoom;
      this.panX = newPanX;
      this.panY = newPanY;
      const parentRect = (this.el.parentElement || this.el).getBoundingClientRect();
      const imageRect = this.imageEl.getBoundingClientRect();
      const outOfBoundsX = (imageRect.right < parentRect.right && newPanX < previousPanX) ||
        (imageRect.left > parentRect.left && newPanX > previousPanX);
      const outOfBoundsY = (imageRect.bottom < parentRect.bottom && newPanY < previousPanY) ||
        (imageRect.top > parentRect.top && newPanY > previousPanY);
      if (outOfBoundsX) {
        this.panX = previousPanX;
      }
      if (outOfBoundsY) {
        this.panY = previousPanY;
      }
      if (this.zoom === 1) {
        this.panX = 0;
        this.panY = 0;
      }
      this.imageEl.style.transform = `matrix(${this.zoom}, 0, 0, ${this.zoom}, ${this.panX}, ${this.panY})`;
    };
    this.updateTransformOrigin = (x, y) => {
      this.transformOriginX = x;
      this.transformOriginY = y;
      this.imageEl.style.transformOrigin = `${this.transformOriginX}px ${this.transformOriginY}px`;
    };
    this.startPan = (event) => {
      this.panning = true;
      this.previousScreenX = event.screenX;
      this.previousScreenY = event.screenY;
    };
    this.pan = (event) => {
      const previousScreenX = this.previousScreenX || 0;
      const previousScreenY = this.previousScreenY || 0;
      this.previousScreenX = event.screenX;
      this.previousScreenY = event.screenY;
      if (!this.panning || this.pinching) {
        return;
      }
      event.preventDefault();
      const panX = this.panX + event.screenX - previousScreenX;
      const panY = this.panY + event.screenY - previousScreenY;
      this.updateZoomAndPan(this.zoom, panX, panY);
    };
    this.endPan = () => {
      this.panning = false;
    };
    this.description = "";
    this.errorMessage = "File could not be loaded.";
    this.file = undefined;
    this.maxZoom = 3;
    this.error = undefined;
    this.loading = true;
  }
  componentDidLoad() {
    this.activate.emit(this.el);
  }
  watchFile() {
    this.error = false;
    this.loading = true;
  }
  /**
   * Get the current zoom.
   * @returns
   */
  async getZoom() {
    return this.zoom;
  }
  /**
   * Resets the zoom.
   * @returns
   */
  async resetZoom() {
    return this.updateZoomAndPan(1);
  }
  render() {
    return (hAsync(Host, { class: "file-viewer-image", onDblClick: this.onDblClick, onWheel: this.onWheel, onPointerDown: this.onPointerDown, onPointerMove: this.onPointerMove, onPointerUp: this.onPointerUp, onTouchStart: this.onTouchStart, onTouchMove: this.onTouchMove, onTouchEnd: this.onTouchEnd }, this.error && (hAsync("swirl-inline-error", { class: "file-viewer-image__error", message: this.errorMessage })), hAsync("img", { alt: this.description, class: "file-viewer-image__image", onError: this.onError, onLoad: this.onLoad, ref: (el) => (this.imageEl = el), src: this.file }), this.loading && (hAsync("div", { class: "file-viewer-image__spinner" }, hAsync("swirl-spinner", null)))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "file": ["watchFile"]
  }; }
  static get style() { return swirlFileViewerImageCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-file-viewer-image",
    "$members$": {
      "description": [1],
      "errorMessage": [1, "error-message"],
      "file": [1],
      "maxZoom": [2, "max-zoom"],
      "error": [32],
      "loading": [32],
      "getZoom": [64],
      "resetZoom": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

var dommatrix = createCommonjsModule(function (module, exports) {
/*!
* DOMMatrix v1.0.3 (https://thednp.github.io/dommatrix/)
* Copyright 2022 © thednp
* Licensed under MIT (https://github.com/thednp/DOMMatrix/blob/master/LICENSE)
*/
(function (global, factory) {
  module.exports = factory() ;
})(commonjsGlobal, (function () {
  // DOMMatrix Static methods
  // * `fromArray` is a more simple implementation, should also accept Float[32/64]Array;
  // * `fromMatrix` load values from another CSSMatrix/DOMMatrix instance or JSON object;
  // * `fromString` parses and loads values from any valid CSS transform string (TransformList).

  /**
   * Creates a new mutable `CSSMatrix` instance given an array of 16/6 floating point values.
   * This static method invalidates arrays that contain non-number elements.
   *
   * If the array has six values, the result is a 2D matrix; if the array has 16 values,
   * the result is a 3D matrix. Otherwise, a TypeError exception is thrown.
   *
   * @param {CSSM.matrix | CSSM.matrix3d} array an `Array` to feed values from.
   * @return {CSSMatrix} the resulted matrix.
   */
  function fromArray(array) {
    var m = new CSSMatrix();
    var a = Array.from(array);

    if (!a.every(function (n) { return !Number.isNaN(n); })) {
      throw TypeError(("CSSMatrix: \"" + array + "\" must only have numbers."));
    }
    if (a.length === 16) {
      var m11 = a[0];
      var m12 = a[1];
      var m13 = a[2];
      var m14 = a[3];
      var m21 = a[4];
      var m22 = a[5];
      var m23 = a[6];
      var m24 = a[7];
      var m31 = a[8];
      var m32 = a[9];
      var m33 = a[10];
      var m34 = a[11];
      var m41 = a[12];
      var m42 = a[13];
      var m43 = a[14];
      var m44 = a[15];

      m.m11 = m11;
      m.a = m11;

      m.m21 = m21;
      m.c = m21;

      m.m31 = m31;

      m.m41 = m41;
      m.e = m41;

      m.m12 = m12;
      m.b = m12;

      m.m22 = m22;
      m.d = m22;

      m.m32 = m32;

      m.m42 = m42;
      m.f = m42;

      m.m13 = m13;
      m.m23 = m23;
      m.m33 = m33;
      m.m43 = m43;
      m.m14 = m14;
      m.m24 = m24;
      m.m34 = m34;
      m.m44 = m44;
    } else if (a.length === 6) {
      var M11 = a[0];
      var M12 = a[1];
      var M21 = a[2];
      var M22 = a[3];
      var M41 = a[4];
      var M42 = a[5];

      m.m11 = M11;
      m.a = M11;

      m.m12 = M12;
      m.b = M12;

      m.m21 = M21;
      m.c = M21;

      m.m22 = M22;
      m.d = M22;

      m.m41 = M41;
      m.e = M41;

      m.m42 = M42;
      m.f = M42;
    } else {
      throw new TypeError('CSSMatrix: expecting an Array of 6/16 values.');
    }
    return m;
  }

  /**
   * Creates a new mutable `CSSMatrix` instance given an existing matrix or a
   * `DOMMatrix` instance which provides the values for its properties.
   *
   * @param {CSSMatrix | DOMMatrix | CSSM.JSONMatrix} m the source matrix to feed values from.
   * @return {CSSMatrix} the resulted matrix.
   */
  function fromMatrix(m) {
    var keys = Object.keys(new CSSMatrix());
    if (typeof m === 'object' && keys.every(function (k) { return k in m; })) {
      return fromArray(
        [m.m11, m.m12, m.m13, m.m14,
          m.m21, m.m22, m.m23, m.m24,
          m.m31, m.m32, m.m33, m.m34,
          m.m41, m.m42, m.m43, m.m44]
      );
    }
    throw TypeError(("CSSMatrix: \"" + (JSON.stringify(m)) + "\" is not a DOMMatrix / CSSMatrix / JSON compatible object."));
  }

  /**
   * Creates a new mutable `CSSMatrix` given any valid CSS transform string,
   * or what we call `TransformList`:
   *
   * * `matrix(a, b, c, d, e, f)` - valid matrix() transform function
   * * `matrix3d(m11, m12, m13, ...m44)` - valid matrix3d() transform function
   * * `translate(tx, ty) rotateX(alpha)` - any valid transform function(s)
   *
   * @copyright thednp © 2021
   *
   * @param {string} source valid CSS transform string syntax.
   * @return {CSSMatrix} the resulted matrix.
   */
  function fromString(source) {
    if (typeof source !== 'string') {
      throw TypeError(("CSSMatrix: \"" + source + "\" is not a string."));
    }
    var str = String(source).replace(/\s/g, '');
    var m = new CSSMatrix();
    var invalidStringError = "CSSMatrix: invalid transform string \"" + source + "\"";

    // const px = ['perspective'];
    // const length = ['translate', 'translate3d', 'translateX', 'translateY', 'translateZ'];
    // const deg = ['rotate', 'rotate3d', 'rotateX', 'rotateY', 'rotateZ', 'skew', 'skewX', 'skewY'];
    // const abs = ['scale', 'scale3d', 'matrix', 'matrix3d'];
    // const transformFunctions = px.concat(length, deg, abs);

    str.split(')').filter(function (f) { return f; }).forEach(function (tf) {
      var ref = tf.split('(');
      var prop = ref[0];
      var value = ref[1];

      // invalidate empty string
      if (!value) { throw TypeError(invalidStringError); }

      var components = value.split(',')
        .map(function (n) { return (n.includes('rad') ? parseFloat(n) * (180 / Math.PI) : parseFloat(n)); });

      var x = components[0];
      var y = components[1];
      var z = components[2];
      var a = components[3];
      var xyz = [x, y, z];
      var xyza = [x, y, z, a];

      // single number value expected
      if (prop === 'perspective' && x && [y, z].every(function (n) { return n === undefined; })) {
        m.m34 = -1 / x;
      // 6/16 number values expected
      } else if (prop.includes('matrix') && [6, 16].includes(components.length)
        && components.every(function (n) { return !Number.isNaN(+n); })) {
        var values = components.map(function (n) { return (Math.abs(n) < 1e-6 ? 0 : n); });
        // @ts-ignore -- conditions should suffice
        m = m.multiply(fromArray(values));
      // 3 values expected
      } else if (prop === 'translate3d' && xyz.every(function (n) { return !Number.isNaN(+n); })) {
        m = m.translate(x, y, z);
      // single/double number value(s) expected
      } else if (prop === 'translate' && x && z === undefined) {
        m = m.translate(x, y || 0, 0);
      // all 4 values expected
      } else if (prop === 'rotate3d' && xyza.every(function (n) { return !Number.isNaN(+n); }) && a) {
        m = m.rotateAxisAngle(x, y, z, a);
      // single value expected
      } else if (prop === 'rotate' && x && [y, z].every(function (n) { return n === undefined; })) {
        m = m.rotate(0, 0, x);
      // 3 values expected
      } else if (prop === 'scale3d' && xyz.every(function (n) { return !Number.isNaN(+n); }) && xyz.some(function (n) { return n !== 1; })) {
        m = m.scale(x, y, z);
      // single value expected
      } else if (prop === 'scale' && !Number.isNaN(x) && x !== 1 && z === undefined) {
        var nosy = Number.isNaN(+y);
        var sy = nosy ? x : y;
        m = m.scale(x, sy, 1);
      // single/double value expected
      } else if (prop === 'skew' && (x || (!Number.isNaN(x) && y)) && z === undefined) {
        m = m.skew(x, y || 0);
      } else if (/[XYZ]/.test(prop) && x && [y, z].every(function (n) { return n === undefined; }) // a single value expected
        && ['translate', 'rotate', 'scale', 'skew'].some(function (p) { return prop.includes(p); })) {
        if (['skewX', 'skewY'].includes(prop)) {
          // @ts-ignore unfortunately
          m = m[prop](x);
        } else {
          var fn = prop.replace(/[XYZ]/, '');
          var axis = prop.replace(fn, '');
          var idx = ['X', 'Y', 'Z'].indexOf(axis);
          var def = fn === 'scale' ? 1 : 0;
          var axeValues = [
            idx === 0 ? x : def,
            idx === 1 ? x : def,
            idx === 2 ? x : def];
          // @ts-ignore unfortunately
          m = m[fn].apply(m, axeValues);
        }
      } else {
        throw TypeError(invalidStringError);
      }
    });

    return m;
  }

  /**
   * Returns an *Array* containing elements which comprise the matrix.
   * The method can return either the 16 elements or the 6 elements
   * depending on the value of the `is2D` parameter.
   *
   * @param {CSSMatrix | DOMMatrix | CSSM.JSONMatrix} m the source matrix to feed values from.
   * @param {boolean=} is2D *Array* representation of the matrix
   * @return {CSSM.matrix | CSSM.matrix3d} an *Array* representation of the matrix
   */
  function toArray(m, is2D) {
    if (is2D) {
      return [m.a, m.b, m.c, m.d, m.e, m.f];
    }
    return [m.m11, m.m12, m.m13, m.m14,
      m.m21, m.m22, m.m23, m.m24,
      m.m31, m.m32, m.m33, m.m34,
      m.m41, m.m42, m.m43, m.m44];
  }

  // Transform Functions
  // https://www.w3.org/TR/css-transforms-1/#transform-functions

  /**
   * Creates a new `CSSMatrix` for the translation matrix and returns it.
   * This method is equivalent to the CSS `translate3d()` function.
   *
   * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d
   *
   * @param {number} x the `x-axis` position.
   * @param {number} y the `y-axis` position.
   * @param {number} z the `z-axis` position.
   * @return {CSSMatrix} the resulted matrix.
   */
  function Translate(x, y, z) {
    var m = new CSSMatrix();
    m.m41 = x;
    m.e = x;
    m.m42 = y;
    m.f = y;
    m.m43 = z;
    return m;
  }

  /**
   * Creates a new `CSSMatrix` for the rotation matrix and returns it.
   *
   * http://en.wikipedia.org/wiki/Rotation_matrix
   *
   * @param {number} rx the `x-axis` rotation.
   * @param {number} ry the `y-axis` rotation.
   * @param {number} rz the `z-axis` rotation.
   * @return {CSSMatrix} the resulted matrix.
   */
  function Rotate(rx, ry, rz) {
    var m = new CSSMatrix();
    var degToRad = Math.PI / 180;
    var radX = rx * degToRad;
    var radY = ry * degToRad;
    var radZ = rz * degToRad;

    // minus sin() because of right-handed system
    var cosx = Math.cos(radX);
    var sinx = -Math.sin(radX);
    var cosy = Math.cos(radY);
    var siny = -Math.sin(radY);
    var cosz = Math.cos(radZ);
    var sinz = -Math.sin(radZ);

    var m11 = cosy * cosz;
    var m12 = -cosy * sinz;

    m.m11 = m11;
    m.a = m11;

    m.m12 = m12;
    m.b = m12;

    m.m13 = siny;

    var m21 = sinx * siny * cosz + cosx * sinz;
    m.m21 = m21;
    m.c = m21;

    var m22 = cosx * cosz - sinx * siny * sinz;
    m.m22 = m22;
    m.d = m22;

    m.m23 = -sinx * cosy;

    m.m31 = sinx * sinz - cosx * siny * cosz;
    m.m32 = sinx * cosz + cosx * siny * sinz;
    m.m33 = cosx * cosy;

    return m;
  }

  /**
   * Creates a new `CSSMatrix` for the rotation matrix and returns it.
   * This method is equivalent to the CSS `rotate3d()` function.
   *
   * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d
   *
   * @param {number} x the `x-axis` vector length.
   * @param {number} y the `y-axis` vector length.
   * @param {number} z the `z-axis` vector length.
   * @param {number} alpha the value in degrees of the rotation.
   * @return {CSSMatrix} the resulted matrix.
   */
  function RotateAxisAngle(x, y, z, alpha) {
    var m = new CSSMatrix();
    var length = Math.sqrt(x * x + y * y + z * z);

    if (length === 0) {
      // bad vector length, return identity
      return m;
    }

    var X = x / length;
    var Y = y / length;
    var Z = z / length;

    var angle = alpha * (Math.PI / 360);
    var sinA = Math.sin(angle);
    var cosA = Math.cos(angle);
    var sinA2 = sinA * sinA;
    var x2 = X * X;
    var y2 = Y * Y;
    var z2 = Z * Z;

    var m11 = 1 - 2 * (y2 + z2) * sinA2;
    m.m11 = m11;
    m.a = m11;

    var m12 = 2 * (X * Y * sinA2 + Z * sinA * cosA);
    m.m12 = m12;
    m.b = m12;

    m.m13 = 2 * (X * Z * sinA2 - Y * sinA * cosA);

    var m21 = 2 * (Y * X * sinA2 - Z * sinA * cosA);
    m.m21 = m21;
    m.c = m21;

    var m22 = 1 - 2 * (z2 + x2) * sinA2;
    m.m22 = m22;
    m.d = m22;

    m.m23 = 2 * (Y * Z * sinA2 + X * sinA * cosA);
    m.m31 = 2 * (Z * X * sinA2 + Y * sinA * cosA);
    m.m32 = 2 * (Z * Y * sinA2 - X * sinA * cosA);
    m.m33 = 1 - 2 * (x2 + y2) * sinA2;

    return m;
  }

  /**
   * Creates a new `CSSMatrix` for the scale matrix and returns it.
   * This method is equivalent to the CSS `scale3d()` function, except it doesn't
   * accept {x, y, z} transform origin parameters.
   *
   * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale3d
   *
   * @param {number} x the `x-axis` scale.
   * @param {number} y the `y-axis` scale.
   * @param {number} z the `z-axis` scale.
   * @return {CSSMatrix} the resulted matrix.
   */
  function Scale(x, y, z) {
    var m = new CSSMatrix();
    m.m11 = x;
    m.a = x;

    m.m22 = y;
    m.d = y;

    m.m33 = z;
    return m;
  }

  /**
   * Creates a new `CSSMatrix` for the shear of both the `x-axis` and`y-axis`
   * matrix and returns it. This method is equivalent to the CSS `skew()` function.
   *
   * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew
   *
   * @param {number} angleX the X-angle in degrees.
   * @param {number} angleY the Y-angle in degrees.
   * @return {CSSMatrix} the resulted matrix.
   */
  function Skew(angleX, angleY) {
    var m = new CSSMatrix();
    if (angleX) {
      var radX = (angleX * Math.PI) / 180;
      var tX = Math.tan(radX);
      m.m21 = tX;
      m.c = tX;
    }
    if (angleY) {
      var radY = (angleY * Math.PI) / 180;
      var tY = Math.tan(radY);
      m.m12 = tY;
      m.b = tY;
    }
    return m;
  }

  /**
   * Creates a new `CSSMatrix` for the shear of the `x-axis` rotation matrix and
   * returns it. This method is equivalent to the CSS `skewX()` function.
   *
   * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skewX
   *
   * @param {number} angle the angle in degrees.
   * @return {CSSMatrix} the resulted matrix.
   */
  function SkewX(angle) {
    return Skew(angle, 0);
  }

  /**
   * Creates a new `CSSMatrix` for the shear of the `y-axis` rotation matrix and
   * returns it. This method is equivalent to the CSS `skewY()` function.
   *
   * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skewY
   *
   * @param {number} angle the angle in degrees.
   * @return {CSSMatrix} the resulted matrix.
   */
  function SkewY(angle) {
    return Skew(0, angle);
  }

  /**
   * Creates a new `CSSMatrix` resulted from the multiplication of two matrixes
   * and returns it. Both matrixes are not changed.
   *
   * @param {CSSMatrix | DOMMatrix | CSSM.JSONMatrix} m1 the first matrix.
   * @param {CSSMatrix | DOMMatrix | CSSM.JSONMatrix} m2 the second matrix.
   * @return {CSSMatrix} the resulted matrix.
   */
  function Multiply(m1, m2) {
    var m11 = m2.m11 * m1.m11 + m2.m12 * m1.m21 + m2.m13 * m1.m31 + m2.m14 * m1.m41;
    var m12 = m2.m11 * m1.m12 + m2.m12 * m1.m22 + m2.m13 * m1.m32 + m2.m14 * m1.m42;
    var m13 = m2.m11 * m1.m13 + m2.m12 * m1.m23 + m2.m13 * m1.m33 + m2.m14 * m1.m43;
    var m14 = m2.m11 * m1.m14 + m2.m12 * m1.m24 + m2.m13 * m1.m34 + m2.m14 * m1.m44;

    var m21 = m2.m21 * m1.m11 + m2.m22 * m1.m21 + m2.m23 * m1.m31 + m2.m24 * m1.m41;
    var m22 = m2.m21 * m1.m12 + m2.m22 * m1.m22 + m2.m23 * m1.m32 + m2.m24 * m1.m42;
    var m23 = m2.m21 * m1.m13 + m2.m22 * m1.m23 + m2.m23 * m1.m33 + m2.m24 * m1.m43;
    var m24 = m2.m21 * m1.m14 + m2.m22 * m1.m24 + m2.m23 * m1.m34 + m2.m24 * m1.m44;

    var m31 = m2.m31 * m1.m11 + m2.m32 * m1.m21 + m2.m33 * m1.m31 + m2.m34 * m1.m41;
    var m32 = m2.m31 * m1.m12 + m2.m32 * m1.m22 + m2.m33 * m1.m32 + m2.m34 * m1.m42;
    var m33 = m2.m31 * m1.m13 + m2.m32 * m1.m23 + m2.m33 * m1.m33 + m2.m34 * m1.m43;
    var m34 = m2.m31 * m1.m14 + m2.m32 * m1.m24 + m2.m33 * m1.m34 + m2.m34 * m1.m44;

    var m41 = m2.m41 * m1.m11 + m2.m42 * m1.m21 + m2.m43 * m1.m31 + m2.m44 * m1.m41;
    var m42 = m2.m41 * m1.m12 + m2.m42 * m1.m22 + m2.m43 * m1.m32 + m2.m44 * m1.m42;
    var m43 = m2.m41 * m1.m13 + m2.m42 * m1.m23 + m2.m43 * m1.m33 + m2.m44 * m1.m43;
    var m44 = m2.m41 * m1.m14 + m2.m42 * m1.m24 + m2.m43 * m1.m34 + m2.m44 * m1.m44;

    return fromArray(
      [m11, m12, m13, m14,
        m21, m22, m23, m24,
        m31, m32, m33, m34,
        m41, m42, m43, m44]
    );
  }

  /**
   * Creates and returns a new `DOMMatrix` compatible instance
   * with equivalent instance.
   * @class CSSMatrix
   *
   * @author thednp <https://github.com/thednp/DOMMatrix/>
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix
   */

  var CSSMatrix = function CSSMatrix() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var m = this;
    // array 6
    m.a = 1; m.b = 0;
    m.c = 0; m.d = 1;
    m.e = 0; m.f = 0;
    // array 16
    m.m11 = 1; m.m12 = 0; m.m13 = 0; m.m14 = 0;
    m.m21 = 0; m.m22 = 1; m.m23 = 0; m.m24 = 0;
    m.m31 = 0; m.m32 = 0; m.m33 = 1; m.m34 = 0;
    m.m41 = 0; m.m42 = 0; m.m43 = 0; m.m44 = 1;

    if (args.length) {
      var ARGS = [16, 6].some(function (l) { return l === args.length; }) ? args : args[0];

      return m.setMatrixValue(ARGS);
    }
    return m;
  };

  var prototypeAccessors = { isIdentity: { configurable: true },is2D: { configurable: true } };

  /**
   * A `Boolean` whose value is `true` if the matrix is the identity matrix. The identity
   * matrix is one in which every value is 0 except those on the main diagonal from top-left
   * to bottom-right corner (in other words, where the offsets in each direction are equal).
   *
   * @return {boolean} the current property value
   */
  prototypeAccessors.isIdentity.get = function () {
    var m = this;
    return (m.m11 === 1 && m.m12 === 0 && m.m13 === 0 && m.m14 === 0
            && m.m21 === 0 && m.m22 === 1 && m.m23 === 0 && m.m24 === 0
            && m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0
            && m.m41 === 0 && m.m42 === 0 && m.m43 === 0 && m.m44 === 1);
  };

  /**
   * A `Boolean` flag whose value is `true` if the matrix was initialized as a 2D matrix
   * and `false` if the matrix is 3D.
   *
   * @return {boolean} the current property value
   */
  prototypeAccessors.is2D.get = function () {
    var m = this;
    return (m.m31 === 0 && m.m32 === 0 && m.m33 === 1 && m.m34 === 0 && m.m43 === 0 && m.m44 === 1);
  };

  /**
   * The `setMatrixValue` method replaces the existing matrix with one computed
   * in the browser. EG: `matrix(1,0.25,-0.25,1,0,0)`
   *
   * The method accepts any *Array* values, the result of
   * `DOMMatrix` instance method `toFloat64Array()` / `toFloat32Array()` calls
   *or `CSSMatrix` instance method `toArray()`.
   *
   * This method expects valid *matrix()* / *matrix3d()* string values, as well
   * as other transform functions like *translateX(10px)*.
   *
   * @param {string | CSSM.matrix | CSSM.matrix3d | CSSMatrix | DOMMatrix | CSSM.JSONMatrix} source
   * @return {CSSMatrix} the matrix instance
   */
  CSSMatrix.prototype.setMatrixValue = function setMatrixValue (source) {
    var m = this;

    // CSS transform string source - TransformList first
    if (typeof source === 'string' && source.length && source !== 'none') {
      return fromString(source);
    }
    // [Arguments list | Array] come second
    if ([Array, Float64Array, Float32Array].some(function (a) { return source instanceof a; })) {
      // @ts-ignore
      return fromArray(source);
    }
    // new CSSMatrix(CSSMatrix | DOMMatrix | JSON) last
    if ([CSSMatrix, DOMMatrix, Object].some(function (a) { return source instanceof a; })) {
      // @ts-ignore
      return fromMatrix(source);
    }

    return m;
  };

  /**
   * Returns a *Float32Array* containing elements which comprise the matrix.
   * The method can return either the 16 elements or the 6 elements
   * depending on the value of the `is2D` parameter.
   *
   * @param {boolean=} is2D *Array* representation of the matrix
   * @return {Float32Array} an *Array* representation of the matrix
   */
  CSSMatrix.prototype.toFloat32Array = function toFloat32Array (is2D) {
    return Float32Array.from(toArray(this, is2D));
  };

  /**
   * Returns a *Float64Array* containing elements which comprise the matrix.
   * The method can return either the 16 elements or the 6 elements
   * depending on the value of the `is2D` parameter.
   *
   * @param {boolean=} is2D *Array* representation of the matrix
   * @return {Float64Array} an *Array* representation of the matrix
   */
  CSSMatrix.prototype.toFloat64Array = function toFloat64Array (is2D) {
    return Float64Array.from(toArray(this, is2D));
  };

  /**
   * Creates and returns a string representation of the matrix in `CSS` matrix syntax,
   * using the appropriate `CSS` matrix notation.
   *
   * matrix3d *matrix3d(m11, m12, m13, m14, m21, ...)*
   * matrix *matrix(a, b, c, d, e, f)*
   *
   * @return {string} a string representation of the matrix
   */
  CSSMatrix.prototype.toString = function toString () {
    var m = this;
    var is2D = m.is2D;
    var values = m.toFloat64Array(is2D).join(', ');
    var type = is2D ? 'matrix' : 'matrix3d';
    return (type + "(" + values + ")");
  };

  /**
   * Returns a JSON representation of the `CSSMatrix` instance, a standard *Object*
   * that includes `{a,b,c,d,e,f}` and `{m11,m12,m13,..m44}` properties as well
   * as the `is2D` & `isIdentity` properties.
   *
   * The result can also be used as a second parameter for the `fromMatrix` static method
   * to load values into another matrix instance.
   *
   * @return {CSSM.JSONMatrix} an *Object* with all matrix values.
   */
  CSSMatrix.prototype.toJSON = function toJSON () {
    var m = this;
    var is2D = m.is2D;
      var isIdentity = m.isIdentity;
    return Object.assign({}, m, {is2D: is2D, isIdentity: isIdentity});
  };

  /**
   * The Multiply method returns a new CSSMatrix which is the result of this
   * matrix multiplied by the passed matrix, with the passed matrix to the right.
   * This matrix is not modified.
   *
   * @param {CSSMatrix | DOMMatrix | CSSM.JSONMatrix} m2 CSSMatrix
   * @return {CSSMatrix} The resulted matrix.
   */
  CSSMatrix.prototype.multiply = function multiply (m2) {
    return Multiply(this, m2);
  };

  /**
   * The translate method returns a new matrix which is this matrix post
   * multiplied by a translation matrix containing the passed values. If the z
   * component is undefined, a 0 value is used in its place. This matrix is not
   * modified.
   *
   * @param {number} x X component of the translation value.
   * @param {number=} y Y component of the translation value.
   * @param {number=} z Z component of the translation value.
   * @return {CSSMatrix} The resulted matrix
   */
  CSSMatrix.prototype.translate = function translate (x, y, z) {
    var X = x;
    var Y = y;
    var Z = z;
    if (Y === undefined) { Y = 0; }
    if (Z === undefined) { Z = 0; }
    return Multiply(this, Translate(X, Y, Z));
  };

  /**
   * The scale method returns a new matrix which is this matrix post multiplied by
   * a scale matrix containing the passed values. If the z component is undefined,
   * a 1 value is used in its place. If the y component is undefined, the x
   * component value is used in its place. This matrix is not modified.
   *
   * @param {number} x The X component of the scale value.
   * @param {number=} y The Y component of the scale value.
   * @param {number=} z The Z component of the scale value.
   * @return {CSSMatrix} The resulted matrix
   */
  CSSMatrix.prototype.scale = function scale (x, y, z) {
    var X = x;
    var Y = y;
    var Z = z;
    if (Y === undefined) { Y = x; }
    if (Z === undefined) { Z = 1; } // Z must be 1 if undefined

    return Multiply(this, Scale(X, Y, Z));
  };

  /**
   * The rotate method returns a new matrix which is this matrix post multiplied
   * by each of 3 rotation matrices about the major axes, first X, then Y, then Z.
   * If the y and z components are undefined, the x value is used to rotate the
   * object about the z axis, as though the vector (0,0,x) were passed. All
   * rotation values are in degrees. This matrix is not modified.
   *
   * @param {number} rx The X component of the rotation, or Z if Y and Z are null.
   * @param {number=} ry The (optional) Y component of the rotation value.
   * @param {number=} rz The (optional) Z component of the rotation value.
   * @return {CSSMatrix} The resulted matrix
   */
  CSSMatrix.prototype.rotate = function rotate (rx, ry, rz) {
    var RX = rx;
    var RY = ry || 0;
    var RZ = rz || 0;

    if (typeof rx === 'number' && ry === undefined && rz === undefined) {
      RZ = RX; RX = 0; RY = 0;
    }

    return Multiply(this, Rotate(RX, RY, RZ));
  };

  /**
   * The rotateAxisAngle method returns a new matrix which is this matrix post
   * multiplied by a rotation matrix with the given axis and `angle`. The right-hand
   * rule is used to determine the direction of rotation. All rotation values are
   * in degrees. This matrix is not modified.
   *
   * @param {number} x The X component of the axis vector.
   * @param {number} y The Y component of the axis vector.
   * @param {number} z The Z component of the axis vector.
   * @param {number} angle The angle of rotation about the axis vector, in degrees.
   * @return {CSSMatrix} The resulted matrix
   */
  CSSMatrix.prototype.rotateAxisAngle = function rotateAxisAngle (x, y, z, angle) {
    if ([x, y, z, angle].some(function (n) { return Number.isNaN(+n); })) {
      throw new TypeError('CSSMatrix: expecting 4 values');
    }
    return Multiply(this, RotateAxisAngle(x, y, z, angle));
  };

  /**
   * Specifies a skew transformation along the `x-axis` by the given angle.
   * This matrix is not modified.
   *
   * @param {number} angle The angle amount in degrees to skew.
   * @return {CSSMatrix} The resulted matrix
   */
  CSSMatrix.prototype.skewX = function skewX (angle) {
    return Multiply(this, SkewX(angle));
  };

  /**
   * Specifies a skew transformation along the `y-axis` by the given angle.
   * This matrix is not modified.
   *
   * @param {number} angle The angle amount in degrees to skew.
   * @return {CSSMatrix} The resulted matrix
   */
  CSSMatrix.prototype.skewY = function skewY (angle) {
    return Multiply(this, SkewY(angle));
  };

  /**
   * Specifies a skew transformation along both the `x-axis` and `y-axis`.
   * This matrix is not modified.
   *
   * @param {number} angleX The X-angle amount in degrees to skew.
   * @param {number} angleY The angle amount in degrees to skew.
   * @return {CSSMatrix} The resulted matrix
   */
  CSSMatrix.prototype.skew = function skew (angleX, angleY) {
    return Multiply(this, Skew(angleX, angleY));
  };

  /**
   * Transforms a specified vector using the matrix, returning a new
   * {x,y,z,w} Tuple *Object* comprising the transformed vector.
   * Neither the matrix nor the original vector are altered.
   *
   * The method is equivalent with `transformPoint()` method
   * of the `DOMMatrix` constructor.
   *
   * @param {CSSM.PointTuple | DOMPoint} t Tuple with `{x,y,z,w}` components
   * @return {CSSM.PointTuple | DOMPoint} the resulting Tuple
   */
  CSSMatrix.prototype.transformPoint = function transformPoint (t) {
    var m = this;

    var x = m.m11 * t.x + m.m21 * t.y + m.m31 * t.z + m.m41 * t.w;
    var y = m.m12 * t.x + m.m22 * t.y + m.m32 * t.z + m.m42 * t.w;
    var z = m.m13 * t.x + m.m23 * t.y + m.m33 * t.z + m.m43 * t.w;
    var w = m.m14 * t.x + m.m24 * t.y + m.m34 * t.z + m.m44 * t.w;

    return t instanceof DOMPoint
      ? new DOMPoint(x, y, z, w)
      : {
        x: x, y: y, z: z, w: w,
      };
  };

  Object.defineProperties( CSSMatrix.prototype, prototypeAccessors );

  // Add Transform Functions to CSSMatrix object
  // without creating a TypeScript namespace.
  Object.assign(CSSMatrix, {
    Translate: Translate,
    Rotate: Rotate,
    RotateAxisAngle: RotateAxisAngle,
    Scale: Scale,
    SkewX: SkewX,
    SkewY: SkewY,
    Skew: Skew,
    Multiply: Multiply,
    fromArray: fromArray,
    fromMatrix: fromMatrix,
    fromString: fromString,
    toArray: toArray,
  });

  var version = "1.0.3";

  /**
   * A global namespace for library version.
   * @type {string}
   */
  var Version = version;

  /** @typedef {import('../types/index')} */

  Object.assign(CSSMatrix, { Version: Version });

  return CSSMatrix;

}));
});

var ponyfill = createCommonjsModule(function (module, exports) {
/**
 * web-streams-polyfill v3.2.1
 */
(function (global, factory) {
    factory(exports) ;
}(commonjsGlobal, (function (exports) {
    /// <reference lib="es2015.symbol" />
    var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?
        Symbol :
        function (description) { return "Symbol(" + description + ")"; };

    /// <reference lib="dom" />
    function noop() {
        return undefined;
    }
    function getGlobals() {
        if (typeof self !== 'undefined') {
            return self;
        }
        else if (typeof window !== 'undefined') {
            return window;
        }
        else if (typeof commonjsGlobal !== 'undefined') {
            return commonjsGlobal;
        }
        return undefined;
    }
    var globals = getGlobals();

    function typeIsObject(x) {
        return (typeof x === 'object' && x !== null) || typeof x === 'function';
    }
    var rethrowAssertionErrorRejection = noop;

    var originalPromise = Promise;
    var originalPromiseThen = Promise.prototype.then;
    var originalPromiseResolve = Promise.resolve.bind(originalPromise);
    var originalPromiseReject = Promise.reject.bind(originalPromise);
    function newPromise(executor) {
        return new originalPromise(executor);
    }
    function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
    }
    function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
        // approximation.
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
        uponPromise(promise, undefined, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
    }
    var queueMicrotask = (function () {
        var globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === 'function') {
            return globalQueueMicrotask;
        }
        var resolvedPromise = promiseResolvedWith(undefined);
        return function (fn) { return PerformPromiseThen(resolvedPromise, fn); };
    })();
    function reflectCall(F, V, args) {
        if (typeof F !== 'function') {
            throw new TypeError('Argument is not a function');
        }
        return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
        try {
            return promiseResolvedWith(reflectCall(F, V, args));
        }
        catch (value) {
            return promiseRejectedWith(value);
        }
    }

    // Original from Chromium
    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
    var QUEUE_MAX_ARRAY_SIZE = 16384;
    /**
     * Simple queue structure.
     *
     * Avoids scalability issues with using a packed array directly by using
     * multiple arrays in a linked list and keeping the array size bounded.
     */
    var SimpleQueue = /** @class */ (function () {
        function SimpleQueue() {
            this._cursor = 0;
            this._size = 0;
            // _front and _back are always defined.
            this._front = {
                _elements: [],
                _next: undefined
            };
            this._back = this._front;
            // The cursor is used to avoid calling Array.shift().
            // It contains the index of the front element of the array inside the
            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
            this._cursor = 0;
            // When there is only one node, size === elements.length - cursor.
            this._size = 0;
        }
        Object.defineProperty(SimpleQueue.prototype, "length", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        SimpleQueue.prototype.push = function (element) {
            var oldBack = this._back;
            var newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                newBack = {
                    _elements: [],
                    _next: undefined
                };
            }
            // push() is the mutation most likely to throw an exception, so it
            // goes first.
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
                this._back = newBack;
                oldBack._next = newBack;
            }
            ++this._size;
        };
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        SimpleQueue.prototype.shift = function () { // must not be called on an empty queue
            var oldFront = this._front;
            var newFront = oldFront;
            var oldCursor = this._cursor;
            var newCursor = oldCursor + 1;
            var elements = oldFront._elements;
            var element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                newFront = oldFront._next;
                newCursor = 0;
            }
            // No mutations before this point.
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
                this._front = newFront;
            }
            // Permit shifted element to be garbage collected.
            elements[oldCursor] = undefined;
            return element;
        };
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        SimpleQueue.prototype.forEach = function (callback) {
            var i = this._cursor;
            var node = this._front;
            var elements = node._elements;
            while (i !== elements.length || node._next !== undefined) {
                if (i === elements.length) {
                    node = node._next;
                    elements = node._elements;
                    i = 0;
                    if (elements.length === 0) {
                        break;
                    }
                }
                callback(elements[i]);
                ++i;
            }
        };
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        SimpleQueue.prototype.peek = function () { // must not be called on an empty queue
            var front = this._front;
            var cursor = this._cursor;
            return front._elements[cursor];
        };
        return SimpleQueue;
    }());

    function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === 'readable') {
            defaultReaderClosedPromiseInitialize(reader);
        }
        else if (stream._state === 'closed') {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
        }
        else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
    }
    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
    // check.
    function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === 'readable') {
            defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        }
        else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        }
        reader._ownerReadableStream._reader = undefined;
        reader._ownerReadableStream = undefined;
    }
    // Helper functions for the readers.
    function readerLockException(name) {
        return new TypeError('Cannot ' + name + ' a stream using a released reader');
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function (resolve, reject) {
            reader._closedPromise_resolve = resolve;
            reader._closedPromise_reject = reject;
        });
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }
    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
    }
    function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === undefined) {
            return;
        }
        reader._closedPromise_resolve(undefined);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }

    var AbortSteps = SymbolPolyfill('[[AbortSteps]]');
    var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
    var CancelSteps = SymbolPolyfill('[[CancelSteps]]');
    var PullSteps = SymbolPolyfill('[[PullSteps]]');

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
    var NumberIsFinite = Number.isFinite || function (x) {
        return typeof x === 'number' && isFinite(x);
    };

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
    var MathTrunc = Math.trunc || function (v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
    };

    // https://heycam.github.io/webidl/#idl-dictionaries
    function isDictionary(x) {
        return typeof x === 'object' || typeof x === 'function';
    }
    function assertDictionary(obj, context) {
        if (obj !== undefined && !isDictionary(obj)) {
            throw new TypeError(context + " is not an object.");
        }
    }
    // https://heycam.github.io/webidl/#idl-callback-functions
    function assertFunction(x, context) {
        if (typeof x !== 'function') {
            throw new TypeError(context + " is not a function.");
        }
    }
    // https://heycam.github.io/webidl/#idl-object
    function isObject(x) {
        return (typeof x === 'object' && x !== null) || typeof x === 'function';
    }
    function assertObject(x, context) {
        if (!isObject(x)) {
            throw new TypeError(context + " is not an object.");
        }
    }
    function assertRequiredArgument(x, position, context) {
        if (x === undefined) {
            throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
        }
    }
    function assertRequiredField(x, field, context) {
        if (x === undefined) {
            throw new TypeError(field + " is required in '" + context + "'.");
        }
    }
    // https://heycam.github.io/webidl/#idl-unrestricted-double
    function convertUnrestrictedDouble(value) {
        return Number(value);
    }
    function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
    }
    function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
    }
    // https://heycam.github.io/webidl/#idl-unsigned-long-long
    function convertUnsignedLongLongWithEnforceRange(value, context) {
        var lowerBound = 0;
        var upperBound = Number.MAX_SAFE_INTEGER;
        var x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
            throw new TypeError(context + " is not a finite number");
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
            throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
        }
        if (!NumberIsFinite(x) || x === 0) {
            return 0;
        }
        // TODO Use BigInt if supported?
        // let xBigInt = BigInt(integerPart(x));
        // xBigInt = BigInt.asUintN(64, xBigInt);
        // return Number(xBigInt);
        return x;
    }

    function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
            throw new TypeError(context + " is not a ReadableStream.");
        }
    }

    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        var reader = stream._reader;
        var readRequest = reader._readRequests.shift();
        if (done) {
            readRequest._closeSteps();
        }
        else {
            readRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
        var reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A default reader vended by a {@link ReadableStream}.
     *
     * @public
     */
    var ReadableStreamDefaultReader = /** @class */ (function () {
        function ReadableStreamDefaultReader(stream) {
            assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
            assertReadableStream(stream, 'First parameter');
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
        }
        Object.defineProperty(ReadableStreamDefaultReader.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */
            get: function () {
                if (!IsReadableStreamDefaultReader(this)) {
                    return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
                }
                return this._closedPromise;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        ReadableStreamDefaultReader.prototype.cancel = function (reason) {
            if (reason === void 0) { reason = undefined; }
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('cancel'));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        };
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        ReadableStreamDefaultReader.prototype.read = function () {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('read'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('read from'));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function (resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            var readRequest = {
                _chunkSteps: function (chunk) { return resolvePromise({ value: chunk, done: false }); },
                _closeSteps: function () { return resolvePromise({ value: undefined, done: true }); },
                _errorSteps: function (e) { return rejectPromise(e); }
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
        };
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        ReadableStreamDefaultReader.prototype.releaseLock = function () {
            if (!IsReadableStreamDefaultReader(this)) {
                throw defaultReaderBrandCheckException('releaseLock');
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            if (this._readRequests.length > 0) {
                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
            }
            ReadableStreamReaderGenericRelease(this);
        };
        return ReadableStreamDefaultReader;
    }());
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStreamDefaultReader',
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
            return false;
        }
        return x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === 'closed') {
            readRequest._closeSteps();
        }
        else if (stream._state === 'errored') {
            readRequest._errorSteps(stream._storedError);
        }
        else {
            stream._readableStreamController[PullSteps](readRequest);
        }
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
    }

    /// <reference lib="es2018.asynciterable" />
    var _a;
    var AsyncIteratorPrototype;
    if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
        // We're running inside a ES2018+ environment, but we're compiling to an older syntax.
        // We cannot access %AsyncIteratorPrototype% without non-ES2018 syntax, but we can re-create it.
        AsyncIteratorPrototype = (_a = {},
            // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
            // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
            _a[SymbolPolyfill.asyncIterator] = function () {
                return this;
            },
            _a);
        Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
    }

    /// <reference lib="es2018.asynciterable" />
    var ReadableStreamAsyncIteratorImpl = /** @class */ (function () {
        function ReadableStreamAsyncIteratorImpl(reader, preventCancel) {
            this._ongoingPromise = undefined;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
        }
        ReadableStreamAsyncIteratorImpl.prototype.next = function () {
            var _this = this;
            var nextSteps = function () { return _this._nextSteps(); };
            this._ongoingPromise = this._ongoingPromise ?
                transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :
                nextSteps();
            return this._ongoingPromise;
        };
        ReadableStreamAsyncIteratorImpl.prototype.return = function (value) {
            var _this = this;
            var returnSteps = function () { return _this._returnSteps(value); };
            return this._ongoingPromise ?
                transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :
                returnSteps();
        };
        ReadableStreamAsyncIteratorImpl.prototype._nextSteps = function () {
            var _this = this;
            if (this._isFinished) {
                return Promise.resolve({ value: undefined, done: true });
            }
            var reader = this._reader;
            if (reader._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('iterate'));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function (resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            var readRequest = {
                _chunkSteps: function (chunk) {
                    _this._ongoingPromise = undefined;
                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
                    // FIXME Is this a bug in the specification, or in the test?
                    queueMicrotask(function () { return resolvePromise({ value: chunk, done: false }); });
                },
                _closeSteps: function () {
                    _this._ongoingPromise = undefined;
                    _this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    resolvePromise({ value: undefined, done: true });
                },
                _errorSteps: function (reason) {
                    _this._ongoingPromise = undefined;
                    _this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    rejectPromise(reason);
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
        };
        ReadableStreamAsyncIteratorImpl.prototype._returnSteps = function (value) {
            if (this._isFinished) {
                return Promise.resolve({ value: value, done: true });
            }
            this._isFinished = true;
            var reader = this._reader;
            if (reader._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('finish iterating'));
            }
            if (!this._preventCancel) {
                var result = ReadableStreamReaderGenericCancel(reader, value);
                ReadableStreamReaderGenericRelease(reader);
                return transformPromiseWith(result, function () { return ({ value: value, done: true }); });
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value: value, done: true });
        };
        return ReadableStreamAsyncIteratorImpl;
    }());
    var ReadableStreamAsyncIteratorPrototype = {
        next: function () {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
            }
            return this._asyncIteratorImpl.next();
        },
        return: function (value) {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
            }
            return this._asyncIteratorImpl.return(value);
        }
    };
    if (AsyncIteratorPrototype !== undefined) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    }
    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
    }
    function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
            return false;
        }
        try {
            // noinspection SuspiciousTypeOfGuard
            return x._asyncIteratorImpl instanceof
                ReadableStreamAsyncIteratorImpl;
        }
        catch (_a) {
            return false;
        }
    }
    // Helper functions for the ReadableStream.
    function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
    }

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
    var NumberIsNaN = Number.isNaN || function (x) {
        // eslint-disable-next-line no-self-compare
        return x !== x;
    };

    function CreateArrayFromList(elements) {
        // We use arrays to represent lists, so this is basically a no-op.
        // Do a slice though just in case we happen to depend on the unique-ness.
        return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    // Not implemented correctly
    function TransferArrayBuffer(O) {
        return O;
    }
    function ArrayBufferSlice(buffer, begin, end) {
        // ArrayBuffer.prototype.slice is not available on IE10
        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
        if (buffer.slice) {
            return buffer.slice(begin, end);
        }
        var length = end - begin;
        var slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
    }

    function IsNonNegativeNumber(v) {
        if (typeof v !== 'number') {
            return false;
        }
        if (NumberIsNaN(v)) {
            return false;
        }
        if (v < 0) {
            return false;
        }
        return true;
    }
    function CloneAsUint8Array(O) {
        var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
    }

    function DequeueValue(container) {
        var pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
        }
        return pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
        }
        container._queue.push({ value: value, size: size });
        container._queueTotalSize += size;
    }
    function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
    }
    function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
    }

    /**
     * A pull-into request in a {@link ReadableByteStreamController}.
     *
     * @public
     */
    var ReadableStreamBYOBRequest = /** @class */ (function () {
        function ReadableStreamBYOBRequest() {
            throw new TypeError('Illegal constructor');
        }
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, "view", {
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */
            get: function () {
                if (!IsReadableStreamBYOBRequest(this)) {
                    throw byobRequestBrandCheckException('view');
                }
                return this._view;
            },
            enumerable: false,
            configurable: true
        });
        ReadableStreamBYOBRequest.prototype.respond = function (bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('respond');
            }
            assertRequiredArgument(bytesWritten, 1, 'respond');
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError('This BYOB request has been invalidated');
            }
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        };
        ReadableStreamBYOBRequest.prototype.respondWithNewView = function (view) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('respondWithNewView');
            }
            assertRequiredArgument(view, 1, 'respondWithNewView');
            if (!ArrayBuffer.isView(view)) {
                throw new TypeError('You can only respond with array buffer views');
            }
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError('This BYOB request has been invalidated');
            }
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        };
        return ReadableStreamBYOBRequest;
    }());
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStreamBYOBRequest',
            configurable: true
        });
    }
    /**
     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
     *
     * @public
     */
    var ReadableByteStreamController = /** @class */ (function () {
        function ReadableByteStreamController() {
            throw new TypeError('Illegal constructor');
        }
        Object.defineProperty(ReadableByteStreamController.prototype, "byobRequest", {
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */
            get: function () {
                if (!IsReadableByteStreamController(this)) {
                    throw byteStreamControllerBrandCheckException('byobRequest');
                }
                return ReadableByteStreamControllerGetBYOBRequest(this);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReadableByteStreamController.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */
            get: function () {
                if (!IsReadableByteStreamController(this)) {
                    throw byteStreamControllerBrandCheckException('desiredSize');
                }
                return ReadableByteStreamControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        ReadableByteStreamController.prototype.close = function () {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('close');
            }
            if (this._closeRequested) {
                throw new TypeError('The stream has already been closed; do not close it again!');
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== 'readable') {
                throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
            }
            ReadableByteStreamControllerClose(this);
        };
        ReadableByteStreamController.prototype.enqueue = function (chunk) {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('enqueue');
            }
            assertRequiredArgument(chunk, 1, 'enqueue');
            if (!ArrayBuffer.isView(chunk)) {
                throw new TypeError('chunk must be an array buffer view');
            }
            if (chunk.byteLength === 0) {
                throw new TypeError('chunk must have non-zero byteLength');
            }
            if (chunk.buffer.byteLength === 0) {
                throw new TypeError("chunk's buffer must have non-zero byteLength");
            }
            if (this._closeRequested) {
                throw new TypeError('stream is closed or draining');
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== 'readable') {
                throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
        };
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        ReadableByteStreamController.prototype.error = function (e) {
            if (e === void 0) { e = undefined; }
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('error');
            }
            ReadableByteStreamControllerError(this, e);
        };
        /** @internal */
        ReadableByteStreamController.prototype[CancelSteps] = function (reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
        };
        /** @internal */
        ReadableByteStreamController.prototype[PullSteps] = function (readRequest) {
            var stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
                var entry = this._queue.shift();
                this._queueTotalSize -= entry.byteLength;
                ReadableByteStreamControllerHandleQueueDrain(this);
                var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                readRequest._chunkSteps(view);
                return;
            }
            var autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== undefined) {
                var buffer = void 0;
                try {
                    buffer = new ArrayBuffer(autoAllocateChunkSize);
                }
                catch (bufferE) {
                    readRequest._errorSteps(bufferE);
                    return;
                }
                var pullIntoDescriptor = {
                    buffer: buffer,
                    bufferByteLength: autoAllocateChunkSize,
                    byteOffset: 0,
                    byteLength: autoAllocateChunkSize,
                    bytesFilled: 0,
                    elementSize: 1,
                    viewConstructor: Uint8Array,
                    readerType: 'default'
                };
                this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
        };
        return ReadableByteStreamController;
    }());
    Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableByteStreamController',
            configurable: true
        });
    }
    // Abstract operations for the ReadableByteStreamController.
    function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
            return false;
        }
        return x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
            return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        // TODO: Test controller argument
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function () {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
        }, function (e) {
            ReadableByteStreamControllerError(controller, e);
        });
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        var done = false;
        if (stream._state === 'closed') {
            done = true;
        }
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === 'default') {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
        }
        else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled;
        var elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer: buffer, byteOffset: byteOffset, byteLength: byteLength });
        controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var elementSize = pullIntoDescriptor.elementSize;
        var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        var totalBytesToCopyRemaining = maxBytesToCopy;
        var ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
        }
        var queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
            var headOfQueue = queue.peek();
            var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
                queue.shift();
            }
            else {
                headOfQueue.byteOffset += bytesToCopy;
                headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
        }
        else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
            return;
        }
        controller._byobRequest._associatedReadableByteStreamController = undefined;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
                return;
            }
            var pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        var stream = controller._controlledReadableByteStream;
        var elementSize = 1;
        if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        var ctor = view.constructor;
        // try {
        var buffer = TransferArrayBuffer(view.buffer);
        // } catch (e) {
        //   readIntoRequest._errorSteps(e);
        //   return;
        // }
        var pullIntoDescriptor = {
            buffer: buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize: elementSize,
            viewConstructor: ctor,
            readerType: 'byob'
        };
        if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            // No ReadableByteStreamControllerCallPullIfNeeded() call since:
            // - No change happens on desiredSize
            // - The source has already been notified of that there's at least 1 pending read(view)
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
        }
        if (stream._state === 'closed') {
            var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
        }
        if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                ReadableByteStreamControllerHandleQueueDrain(controller);
                readIntoRequest._chunkSteps(filledView);
                return;
            }
            if (controller._closeRequested) {
                var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
                ReadableByteStreamControllerError(controller, e);
                readIntoRequest._errorSteps(e);
                return;
            }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        var stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
            var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        var state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            ReadableByteStreamControllerRespondInClosedState(controller);
        }
        else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        return descriptor;
    }
    function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== 'readable') {
            return false;
        }
        if (controller._closeRequested) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
        }
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
    }
    // A client of ReadableByteStreamController may use these functions directly to bypass state check.
    function ReadableByteStreamControllerClose(controller) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== 'readable') {
            return;
        }
        if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
        }
        if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
                var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
                ReadableByteStreamControllerError(controller, e);
                throw e;
            }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== 'readable') {
            return;
        }
        var buffer = chunk.buffer;
        var byteOffset = chunk.byteOffset;
        var byteLength = chunk.byteLength;
        var transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            }
            else {
                if (controller._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                }
                var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
        }
        else if (ReadableStreamHasBYOBReader(stream)) {
            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== 'readable') {
            return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            var firstDescriptor = controller._pendingPullIntos.peek();
            var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        if (state === 'errored') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            if (bytesWritten !== 0) {
                throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
            }
        }
        else {
            if (bytesWritten === 0) {
                throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
                throw new RangeError('bytesWritten out of range');
            }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            if (view.byteLength !== 0) {
                throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
            }
        }
        else {
            if (view.byteLength === 0) {
                throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
            }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError('The region specified by view does not match byobRequest');
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError('The buffer of view has different capacity than byobRequest');
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError('The region specified by view is larger than byobRequest');
        }
        var viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function () {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, function (r) {
            ReadableByteStreamControllerError(controller, r);
        });
    }
    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController.prototype);
        var startAlgorithm = function () { return undefined; };
        var pullAlgorithm = function () { return promiseResolvedWith(undefined); };
        var cancelAlgorithm = function () { return promiseResolvedWith(undefined); };
        if (underlyingByteSource.start !== undefined) {
            startAlgorithm = function () { return underlyingByteSource.start(controller); };
        }
        if (underlyingByteSource.pull !== undefined) {
            pullAlgorithm = function () { return underlyingByteSource.pull(controller); };
        }
        if (underlyingByteSource.cancel !== undefined) {
            cancelAlgorithm = function (reason) { return underlyingByteSource.cancel(reason); };
        }
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
            throw new TypeError('autoAllocateChunkSize must be greater than 0');
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
    }
    function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
    }
    // Helper functions for the ReadableStreamBYOBRequest.
    function byobRequestBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
    }
    // Helper functions for the ReadableByteStreamController.
    function byteStreamControllerBrandCheckException(name) {
        return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
    }

    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        var reader = stream._reader;
        var readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
            readIntoRequest._closeSteps(chunk);
        }
        else {
            readIntoRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
        var reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A BYOB reader vended by a {@link ReadableStream}.
     *
     * @public
     */
    var ReadableStreamBYOBReader = /** @class */ (function () {
        function ReadableStreamBYOBReader(stream) {
            assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
            assertReadableStream(stream, 'First parameter');
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
                throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +
                    'source');
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
        }
        Object.defineProperty(ReadableStreamBYOBReader.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */
            get: function () {
                if (!IsReadableStreamBYOBReader(this)) {
                    return promiseRejectedWith(byobReaderBrandCheckException('closed'));
                }
                return this._closedPromise;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        ReadableStreamBYOBReader.prototype.cancel = function (reason) {
            if (reason === void 0) { reason = undefined; }
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('cancel'));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        };
        /**
         * Attempts to reads bytes into view, and returns a promise resolved with the result.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        ReadableStreamBYOBReader.prototype.read = function (view) {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('read'));
            }
            if (!ArrayBuffer.isView(view)) {
                return promiseRejectedWith(new TypeError('view must be an array buffer view'));
            }
            if (view.byteLength === 0) {
                return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
            }
            if (view.buffer.byteLength === 0) {
                return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('read from'));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function (resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            var readIntoRequest = {
                _chunkSteps: function (chunk) { return resolvePromise({ value: chunk, done: false }); },
                _closeSteps: function (chunk) { return resolvePromise({ value: chunk, done: true }); },
                _errorSteps: function (e) { return rejectPromise(e); }
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
        };
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        ReadableStreamBYOBReader.prototype.releaseLock = function () {
            if (!IsReadableStreamBYOBReader(this)) {
                throw byobReaderBrandCheckException('releaseLock');
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            if (this._readIntoRequests.length > 0) {
                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
            }
            ReadableStreamReaderGenericRelease(this);
        };
        return ReadableStreamBYOBReader;
    }());
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStreamBYOBReader',
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
            return false;
        }
        return x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === 'errored') {
            readIntoRequest._errorSteps(stream._storedError);
        }
        else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
    }
    // Helper functions for the ReadableStreamBYOBReader.
    function byobReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
    }

    function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === undefined) {
            return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError('Invalid highWaterMark');
        }
        return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
        var size = strategy.size;
        if (!size) {
            return function () { return 1; };
        }
        return size;
    }

    function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        var size = init === null || init === void 0 ? void 0 : init.size;
        return {
            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
            size: size === undefined ? undefined : convertQueuingStrategySize(size, context + " has member 'size' that")
        };
    }
    function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return function (chunk) { return convertUnrestrictedDouble(fn(chunk)); };
    }

    function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        var abort = original === null || original === void 0 ? void 0 : original.abort;
        var close = original === null || original === void 0 ? void 0 : original.close;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        var write = original === null || original === void 0 ? void 0 : original.write;
        return {
            abort: abort === undefined ?
                undefined :
                convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
            close: close === undefined ?
                undefined :
                convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
            start: start === undefined ?
                undefined :
                convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
            write: write === undefined ?
                undefined :
                convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
            type: type
        };
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (reason) { return promiseCall(fn, original, [reason]); };
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return function () { return promiseCall(fn, original, []); };
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (controller) { return reflectCall(fn, original, [controller]); };
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (chunk, controller) { return promiseCall(fn, original, [chunk, controller]); };
    }

    function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
            throw new TypeError(context + " is not a WritableStream.");
        }
    }

    function isAbortSignal(value) {
        if (typeof value !== 'object' || value === null) {
            return false;
        }
        try {
            return typeof value.aborted === 'boolean';
        }
        catch (_a) {
            // AbortSignal.prototype.aborted throws if its brand check fails
            return false;
        }
    }
    var supportsAbortController = typeof AbortController === 'function';
    /**
     * Construct a new AbortController, if supported by the platform.
     *
     * @internal
     */
    function createAbortController() {
        if (supportsAbortController) {
            return new AbortController();
        }
        return undefined;
    }

    /**
     * A writable stream represents a destination for data, into which you can write.
     *
     * @public
     */
    var WritableStream = /** @class */ (function () {
        function WritableStream(rawUnderlyingSink, rawStrategy) {
            if (rawUnderlyingSink === void 0) { rawUnderlyingSink = {}; }
            if (rawStrategy === void 0) { rawStrategy = {}; }
            if (rawUnderlyingSink === undefined) {
                rawUnderlyingSink = null;
            }
            else {
                assertObject(rawUnderlyingSink, 'First parameter');
            }
            var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
            var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
            InitializeWritableStream(this);
            var type = underlyingSink.type;
            if (type !== undefined) {
                throw new RangeError('Invalid type is specified');
            }
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            var highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        Object.defineProperty(WritableStream.prototype, "locked", {
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */
            get: function () {
                if (!IsWritableStream(this)) {
                    throw streamBrandCheckException$2('locked');
                }
                return IsWritableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        WritableStream.prototype.abort = function (reason) {
            if (reason === void 0) { reason = undefined; }
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2('abort'));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
            }
            return WritableStreamAbort(this, reason);
        };
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        WritableStream.prototype.close = function () {
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2('close'));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
            }
            return WritableStreamClose(this);
        };
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        WritableStream.prototype.getWriter = function () {
            if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2('getWriter');
            }
            return AcquireWritableStreamDefaultWriter(this);
        };
        return WritableStream;
    }());
    Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: 'WritableStream',
            configurable: true
        });
    }
    // Abstract operations for the WritableStream.
    function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
    }
    // Throws if and only if startAlgorithm throws.
    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) { highWaterMark = 1; }
        if (sizeAlgorithm === void 0) { sizeAlgorithm = function () { return 1; }; }
        var stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        var controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    function InitializeWritableStream(stream) {
        stream._state = 'writable';
        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
        // 'erroring' or 'errored'. May be set to an undefined value.
        stream._storedError = undefined;
        stream._writer = undefined;
        // Initialize to undefined first because the constructor of the controller checks this
        // variable to validate the caller.
        stream._writableStreamController = undefined;
        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
        // producer without waiting for the queued writes to finish.
        stream._writeRequests = new SimpleQueue();
        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
        stream._inFlightWriteRequest = undefined;
        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
        // has been detached.
        stream._closeRequest = undefined;
        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
        stream._inFlightCloseRequest = undefined;
        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
        stream._pendingAbortRequest = undefined;
        // The backpressure signal set by the controller.
        stream._backpressure = false;
    }
    function IsWritableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
            return false;
        }
        return x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
        if (stream._writer === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === 'closed' || stream._state === 'errored') {
            return promiseResolvedWith(undefined);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
        // but it doesn't know that signaling abort runs author code that might have changed the state.
        // Widen the type again by casting to WritableStreamState.
        var state = stream._state;
        if (state === 'closed' || state === 'errored') {
            return promiseResolvedWith(undefined);
        }
        if (stream._pendingAbortRequest !== undefined) {
            return stream._pendingAbortRequest._promise;
        }
        var wasAlreadyErroring = false;
        if (state === 'erroring') {
            wasAlreadyErroring = true;
            // reason will not be used, so don't keep a reference to it.
            reason = undefined;
        }
        var promise = newPromise(function (resolve, reject) {
            stream._pendingAbortRequest = {
                _promise: undefined,
                _resolve: resolve,
                _reject: reject,
                _reason: reason,
                _wasAlreadyErroring: wasAlreadyErroring
            };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
        }
        return promise;
    }
    function WritableStreamClose(stream) {
        var state = stream._state;
        if (state === 'closed' || state === 'errored') {
            return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
        }
        var promise = newPromise(function (resolve, reject) {
            var closeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._closeRequest = closeRequest;
        });
        var writer = stream._writer;
        if (writer !== undefined && stream._backpressure && state === 'writable') {
            defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
    }
    // WritableStream API exposed for controllers.
    function WritableStreamAddWriteRequest(stream) {
        var promise = newPromise(function (resolve, reject) {
            var writeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._writeRequests.push(writeRequest);
        });
        return promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
        var state = stream._state;
        if (state === 'writable') {
            WritableStreamStartErroring(stream, error);
            return;
        }
        WritableStreamFinishErroring(stream);
    }
    function WritableStreamStartErroring(stream, reason) {
        var controller = stream._writableStreamController;
        stream._state = 'erroring';
        stream._storedError = reason;
        var writer = stream._writer;
        if (writer !== undefined) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
        }
    }
    function WritableStreamFinishErroring(stream) {
        stream._state = 'errored';
        stream._writableStreamController[ErrorSteps]();
        var storedError = stream._storedError;
        stream._writeRequests.forEach(function (writeRequest) {
            writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === undefined) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        var abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = undefined;
        if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function () {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, function (reason) {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
    }
    function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(undefined);
        stream._inFlightWriteRequest = undefined;
    }
    function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = undefined;
        WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(undefined);
        stream._inFlightCloseRequest = undefined;
        var state = stream._state;
        if (state === 'erroring') {
            // The error was too late to do anything, so it is ignored.
            stream._storedError = undefined;
            if (stream._pendingAbortRequest !== undefined) {
                stream._pendingAbortRequest._resolve();
                stream._pendingAbortRequest = undefined;
            }
        }
        stream._state = 'closed';
        var writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseResolve(writer);
        }
    }
    function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = undefined;
        // Never execute sink abort() after sink close().
        if (stream._pendingAbortRequest !== undefined) {
            stream._pendingAbortRequest._reject(error);
            stream._pendingAbortRequest = undefined;
        }
        WritableStreamDealWithRejection(stream, error);
    }
    // TODO(ricea): Fix alphabetical order.
    function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = undefined;
    }
    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== undefined) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = undefined;
        }
        var writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
        var writer = stream._writer;
        if (writer !== undefined && backpressure !== stream._backpressure) {
            if (backpressure) {
                defaultWriterReadyPromiseReset(writer);
            }
            else {
                defaultWriterReadyPromiseResolve(writer);
            }
        }
        stream._backpressure = backpressure;
    }
    /**
     * A default writer vended by a {@link WritableStream}.
     *
     * @public
     */
    var WritableStreamDefaultWriter = /** @class */ (function () {
        function WritableStreamDefaultWriter(stream) {
            assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
            assertWritableStream(stream, 'First parameter');
            if (IsWritableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive writing by another writer');
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            var state = stream._state;
            if (state === 'writable') {
                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                    defaultWriterReadyPromiseInitialize(this);
                }
                else {
                    defaultWriterReadyPromiseInitializeAsResolved(this);
                }
                defaultWriterClosedPromiseInitialize(this);
            }
            else if (state === 'erroring') {
                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                defaultWriterClosedPromiseInitialize(this);
            }
            else if (state === 'closed') {
                defaultWriterReadyPromiseInitializeAsResolved(this);
                defaultWriterClosedPromiseInitializeAsResolved(this);
            }
            else {
                var storedError = stream._storedError;
                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
        }
        Object.defineProperty(WritableStreamDefaultWriter.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writer’s lock is released before the stream finishes closing.
             */
            get: function () {
                if (!IsWritableStreamDefaultWriter(this)) {
                    return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
                }
                return this._closedPromise;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WritableStreamDefaultWriter.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writer’s lock is released.
             */
            get: function () {
                if (!IsWritableStreamDefaultWriter(this)) {
                    throw defaultWriterBrandCheckException('desiredSize');
                }
                if (this._ownerWritableStream === undefined) {
                    throw defaultWriterLockException('desiredSize');
                }
                return WritableStreamDefaultWriterGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WritableStreamDefaultWriter.prototype, "ready", {
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
             * rejected.
             */
            get: function () {
                if (!IsWritableStreamDefaultWriter(this)) {
                    return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
                }
                return this._readyPromise;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        WritableStreamDefaultWriter.prototype.abort = function (reason) {
            if (reason === void 0) { reason = undefined; }
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('abort'));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
        };
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        WritableStreamDefaultWriter.prototype.close = function () {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('close'));
            }
            var stream = this._ownerWritableStream;
            if (stream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('close'));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
            }
            return WritableStreamDefaultWriterClose(this);
        };
        /**
         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        WritableStreamDefaultWriter.prototype.releaseLock = function () {
            if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException('releaseLock');
            }
            var stream = this._ownerWritableStream;
            if (stream === undefined) {
                return;
            }
            WritableStreamDefaultWriterRelease(this);
        };
        WritableStreamDefaultWriter.prototype.write = function (chunk) {
            if (chunk === void 0) { chunk = undefined; }
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('write'));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('write to'));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
        };
        return WritableStreamDefaultWriter;
    }());
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: 'WritableStreamDefaultWriter',
            configurable: true
        });
    }
    // Abstract operations for the WritableStreamDefaultWriter.
    function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
            return false;
        }
        return x instanceof WritableStreamDefaultWriter;
    }
    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
    function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
    }
    function WritableStreamDefaultWriterClose(writer) {
        var stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
    }
    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
            return promiseResolvedWith(undefined);
        }
        if (state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === 'pending') {
            defaultWriterClosedPromiseReject(writer, error);
        }
        else {
            defaultWriterClosedPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === 'pending') {
            defaultWriterReadyPromiseReject(writer, error);
        }
        else {
            defaultWriterReadyPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (state === 'errored' || state === 'erroring') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
    }
    function WritableStreamDefaultWriterRelease(writer) {
        var stream = writer._ownerWritableStream;
        var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
        // rejected until afterwards. This means that simply testing state will not work.
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = undefined;
        writer._ownerWritableStream = undefined;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream = writer._ownerWritableStream;
        var controller = stream._writableStreamController;
        var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException('write to'));
        }
        var state = stream._state;
        if (state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
            return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
        }
        if (state === 'erroring') {
            return promiseRejectedWith(stream._storedError);
        }
        var promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
    }
    var closeSentinel = {};
    /**
     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
     *
     * @public
     */
    var WritableStreamDefaultController = /** @class */ (function () {
        function WritableStreamDefaultController() {
            throw new TypeError('Illegal constructor');
        }
        Object.defineProperty(WritableStreamDefaultController.prototype, "abortReason", {
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */
            get: function () {
                if (!IsWritableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$2('abortReason');
                }
                return this._abortReason;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WritableStreamDefaultController.prototype, "signal", {
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */
            get: function () {
                if (!IsWritableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$2('signal');
                }
                if (this._abortController === undefined) {
                    // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
                    // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
                    // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
                    throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
                }
                return this._abortController.signal;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        WritableStreamDefaultController.prototype.error = function (e) {
            if (e === void 0) { e = undefined; }
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('error');
            }
            var state = this._controlledWritableStream._state;
            if (state !== 'writable') {
                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
                // just treat it as a no-op.
                return;
            }
            WritableStreamDefaultControllerError(this, e);
        };
        /** @internal */
        WritableStreamDefaultController.prototype[AbortSteps] = function (reason) {
            var result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
        };
        /** @internal */
        WritableStreamDefaultController.prototype[ErrorSteps] = function () {
            ResetQueue(this);
        };
        return WritableStreamDefaultController;
    }());
    Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: 'WritableStreamDefaultController',
            configurable: true
        });
    }
    // Abstract operations implementing interface required by the WritableStream.
    function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
            return false;
        }
        return x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._abortReason = undefined;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        var startResult = startAlgorithm();
        var startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function () {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function (r) {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
        });
    }
    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController.prototype);
        var startAlgorithm = function () { return undefined; };
        var writeAlgorithm = function () { return promiseResolvedWith(undefined); };
        var closeAlgorithm = function () { return promiseResolvedWith(undefined); };
        var abortAlgorithm = function () { return promiseResolvedWith(undefined); };
        if (underlyingSink.start !== undefined) {
            startAlgorithm = function () { return underlyingSink.start(controller); };
        }
        if (underlyingSink.write !== undefined) {
            writeAlgorithm = function (chunk) { return underlyingSink.write(chunk, controller); };
        }
        if (underlyingSink.close !== undefined) {
            closeAlgorithm = function () { return underlyingSink.close(); };
        }
        if (underlyingSink.abort !== undefined) {
            abortAlgorithm = function (reason) { return underlyingSink.abort(reason); };
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = undefined;
        controller._closeAlgorithm = undefined;
        controller._abortAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
            return controller._strategySizeAlgorithm(chunk);
        }
        catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
        }
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
        }
        catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
        }
        var stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    // Abstract operations for the WritableStreamDefaultController.
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream = controller._controlledWritableStream;
        if (!controller._started) {
            return;
        }
        if (stream._inFlightWriteRequest !== undefined) {
            return;
        }
        var state = stream._state;
        if (state === 'erroring') {
            WritableStreamFinishErroring(stream);
            return;
        }
        if (controller._queue.length === 0) {
            return;
        }
        var value = PeekQueueValue(controller);
        if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
        }
        else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
        }
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === 'writable') {
            WritableStreamDefaultControllerError(controller, error);
        }
    }
    function WritableStreamDefaultControllerProcessClose(controller) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, function () {
            WritableStreamFinishInFlightClose(stream);
        }, function (reason) {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
    }
    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function () {
            WritableStreamFinishInFlightWrite(stream);
            var state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
                var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function (reason) {
            if (stream._state === 'writable') {
                WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
    }
    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
    function WritableStreamDefaultControllerError(controller, error) {
        var stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
    }
    // Helper functions for the WritableStream.
    function streamBrandCheckException$2(name) {
        return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
    }
    // Helper functions for the WritableStreamDefaultController.
    function defaultControllerBrandCheckException$2(name) {
        return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
    }
    // Helper functions for the WritableStreamDefaultWriter.
    function defaultWriterBrandCheckException(name) {
        return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
    }
    function defaultWriterLockException(name) {
        return new TypeError('Cannot ' + name + ' a stream using a released writer');
    }
    function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function (resolve, reject) {
            writer._closedPromise_resolve = resolve;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = 'pending';
        });
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = 'rejected';
    }
    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === undefined) {
            return;
        }
        writer._closedPromise_resolve(undefined);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = 'resolved';
    }
    function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function (resolve, reject) {
            writer._readyPromise_resolve = resolve;
            writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = 'pending';
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = 'rejected';
    }
    function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
    }
    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === undefined) {
            return;
        }
        writer._readyPromise_resolve(undefined);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = 'fulfilled';
    }

    /// <reference lib="dom" />
    var NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;

    /// <reference types="node" />
    function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
            return false;
        }
        try {
            new ctor();
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function createDOMExceptionPolyfill() {
        // eslint-disable-next-line no-shadow
        var ctor = function DOMException(message, name) {
            this.message = message || '';
            this.name = name || 'Error';
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });
        return ctor;
    }
    // eslint-disable-next-line no-redeclare
    var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();

    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source);
        var writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        var shuttingDown = false;
        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
        var currentWrite = promiseResolvedWith(undefined);
        return newPromise(function (resolve, reject) {
            var abortAlgorithm;
            if (signal !== undefined) {
                abortAlgorithm = function () {
                    var error = new DOMException$1('Aborted', 'AbortError');
                    var actions = [];
                    if (!preventAbort) {
                        actions.push(function () {
                            if (dest._state === 'writable') {
                                return WritableStreamAbort(dest, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    if (!preventCancel) {
                        actions.push(function () {
                            if (source._state === 'readable') {
                                return ReadableStreamCancel(source, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    shutdownWithAction(function () { return Promise.all(actions.map(function (action) { return action(); })); }, true, error);
                };
                if (signal.aborted) {
                    abortAlgorithm();
                    return;
                }
                signal.addEventListener('abort', abortAlgorithm);
            }
            // Using reader and writer, read all chunks from this and write them to dest
            // - Backpressure must be enforced
            // - Shutdown must stop all activity
            function pipeLoop() {
                return newPromise(function (resolveLoop, rejectLoop) {
                    function next(done) {
                        if (done) {
                            resolveLoop();
                        }
                        else {
                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid
                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
                            PerformPromiseThen(pipeStep(), next, rejectLoop);
                        }
                    }
                    next(false);
                });
            }
            function pipeStep() {
                if (shuttingDown) {
                    return promiseResolvedWith(true);
                }
                return PerformPromiseThen(writer._readyPromise, function () {
                    return newPromise(function (resolveRead, rejectRead) {
                        ReadableStreamDefaultReaderRead(reader, {
                            _chunkSteps: function (chunk) {
                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                                resolveRead(false);
                            },
                            _closeSteps: function () { return resolveRead(true); },
                            _errorSteps: rejectRead
                        });
                    });
                });
            }
            // Errors must be propagated forward
            isOrBecomesErrored(source, reader._closedPromise, function (storedError) {
                if (!preventAbort) {
                    shutdownWithAction(function () { return WritableStreamAbort(dest, storedError); }, true, storedError);
                }
                else {
                    shutdown(true, storedError);
                }
            });
            // Errors must be propagated backward
            isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {
                if (!preventCancel) {
                    shutdownWithAction(function () { return ReadableStreamCancel(source, storedError); }, true, storedError);
                }
                else {
                    shutdown(true, storedError);
                }
            });
            // Closing must be propagated forward
            isOrBecomesClosed(source, reader._closedPromise, function () {
                if (!preventClose) {
                    shutdownWithAction(function () { return WritableStreamDefaultWriterCloseWithErrorPropagation(writer); });
                }
                else {
                    shutdown();
                }
            });
            // Closing must be propagated backward
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
                var destClosed_1 = new TypeError('the destination writable stream closed before all data could be piped to it');
                if (!preventCancel) {
                    shutdownWithAction(function () { return ReadableStreamCancel(source, destClosed_1); }, true, destClosed_1);
                }
                else {
                    shutdown(true, destClosed_1);
                }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
                // for that too.
                var oldCurrentWrite = currentWrite;
                return PerformPromiseThen(currentWrite, function () { return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined; });
            }
            function isOrBecomesErrored(stream, promise, action) {
                if (stream._state === 'errored') {
                    action(stream._storedError);
                }
                else {
                    uponRejection(promise, action);
                }
            }
            function isOrBecomesClosed(stream, promise, action) {
                if (stream._state === 'closed') {
                    action();
                }
                else {
                    uponFulfillment(promise, action);
                }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), doTheRest);
                }
                else {
                    doTheRest();
                }
                function doTheRest() {
                    uponPromise(action(), function () { return finalize(originalIsError, originalError); }, function (newError) { return finalize(true, newError); });
                }
            }
            function shutdown(isError, error) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), function () { return finalize(isError, error); });
                }
                else {
                    finalize(isError, error);
                }
            }
            function finalize(isError, error) {
                WritableStreamDefaultWriterRelease(writer);
                ReadableStreamReaderGenericRelease(reader);
                if (signal !== undefined) {
                    signal.removeEventListener('abort', abortAlgorithm);
                }
                if (isError) {
                    reject(error);
                }
                else {
                    resolve(undefined);
                }
            }
        });
    }

    /**
     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
     *
     * @public
     */
    var ReadableStreamDefaultController = /** @class */ (function () {
        function ReadableStreamDefaultController() {
            throw new TypeError('Illegal constructor');
        }
        Object.defineProperty(ReadableStreamDefaultController.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */
            get: function () {
                if (!IsReadableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$1('desiredSize');
                }
                return ReadableStreamDefaultControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        ReadableStreamDefaultController.prototype.close = function () {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('close');
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError('The stream is not in a state that permits close');
            }
            ReadableStreamDefaultControllerClose(this);
        };
        ReadableStreamDefaultController.prototype.enqueue = function (chunk) {
            if (chunk === void 0) { chunk = undefined; }
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('enqueue');
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError('The stream is not in a state that permits enqueue');
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
        };
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        ReadableStreamDefaultController.prototype.error = function (e) {
            if (e === void 0) { e = undefined; }
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('error');
            }
            ReadableStreamDefaultControllerError(this, e);
        };
        /** @internal */
        ReadableStreamDefaultController.prototype[CancelSteps] = function (reason) {
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
        };
        /** @internal */
        ReadableStreamDefaultController.prototype[PullSteps] = function (readRequest) {
            var stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
                var chunk = DequeueValue(this);
                if (this._closeRequested && this._queue.length === 0) {
                    ReadableStreamDefaultControllerClearAlgorithms(this);
                    ReadableStreamClose(stream);
                }
                else {
                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
                }
                readRequest._chunkSteps(chunk);
            }
            else {
                ReadableStreamAddReadRequest(stream, readRequest);
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
        };
        return ReadableStreamDefaultController;
    }());
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStreamDefaultController',
            configurable: true
        });
    }
    // Abstract operations for the ReadableStreamDefaultController.
    function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
            return false;
        }
        return x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function () {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
        }, function (e) {
            ReadableStreamDefaultControllerError(controller, e);
        });
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
    function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        var stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
        }
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        var stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
        }
        else {
            var chunkSize = void 0;
            try {
                chunkSize = controller._strategySizeAlgorithm(chunk);
            }
            catch (chunkSizeE) {
                ReadableStreamDefaultControllerError(controller, chunkSizeE);
                throw chunkSizeE;
            }
            try {
                EnqueueValueWithSize(controller, chunk, chunkSize);
            }
            catch (enqueueE) {
                ReadableStreamDefaultControllerError(controller, enqueueE);
                throw enqueueE;
            }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
        var stream = controller._controlledReadableStream;
        if (stream._state !== 'readable') {
            return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        if (state === 'errored') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    // This is used in the implementation of TransformStream.
    function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
        }
        return true;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === 'readable') {
            return true;
        }
        return false;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function () {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, function (r) {
            ReadableStreamDefaultControllerError(controller, r);
        });
    }
    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        var startAlgorithm = function () { return undefined; };
        var pullAlgorithm = function () { return promiseResolvedWith(undefined); };
        var cancelAlgorithm = function () { return promiseResolvedWith(undefined); };
        if (underlyingSource.start !== undefined) {
            startAlgorithm = function () { return underlyingSource.start(controller); };
        }
        if (underlyingSource.pull !== undefined) {
            pullAlgorithm = function () { return underlyingSource.pull(controller); };
        }
        if (underlyingSource.cancel !== undefined) {
            cancelAlgorithm = function (reason) { return underlyingSource.cancel(reason); };
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // Helper functions for the ReadableStreamDefaultController.
    function defaultControllerBrandCheckException$1(name) {
        return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
    }

    function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
    }
    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var readAgain = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function (resolve) {
            resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
            if (reading) {
                readAgain = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            var readRequest = {
                _chunkSteps: function (chunk) {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(function () {
                        readAgain = false;
                        var chunk1 = chunk;
                        var chunk2 = chunk;
                        // There is no way to access the cloning code right now in the reference implementation.
                        // If we add one then we'll need an implementation for serializable objects.
                        // if (!canceled2 && cloneForBranch2) {
                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
                        // }
                        if (!canceled1) {
                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgain) {
                            pullAlgorithm();
                        }
                    });
                },
                _closeSteps: function () {
                    reading = false;
                    if (!canceled1) {
                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: function () {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                var compositeReason = CreateArrayFromList([reason1, reason2]);
                var cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                var compositeReason = CreateArrayFromList([reason1, reason2]);
                var cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            // do nothing
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, function (r) {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
                resolveCancelPromise(undefined);
            }
        });
        return [branch1, branch2];
    }
    function ReadableByteStreamTee(stream) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var readAgainForBranch1 = false;
        var readAgainForBranch2 = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function (resolve) {
            resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, function (r) {
                if (thisReader !== reader) {
                    return;
                }
                ReadableByteStreamControllerError(branch1._readableStreamController, r);
                ReadableByteStreamControllerError(branch2._readableStreamController, r);
                if (!canceled1 || !canceled2) {
                    resolveCancelPromise(undefined);
                }
            });
        }
        function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamDefaultReader(stream);
                forwardReaderError(reader);
            }
            var readRequest = {
                _chunkSteps: function (chunk) {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(function () {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        var chunk1 = chunk;
                        var chunk2 = chunk;
                        if (!canceled1 && !canceled2) {
                            try {
                                chunk2 = CloneAsUint8Array(chunk);
                            }
                            catch (cloneE) {
                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                        }
                        if (!canceled1) {
                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        }
                        else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: function () {
                    reading = false;
                    if (!canceled1) {
                        ReadableByteStreamControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableByteStreamControllerClose(branch2._readableStreamController);
                    }
                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                    }
                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: function () {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamBYOBReader(stream);
                forwardReaderError(reader);
            }
            var byobBranch = forBranch2 ? branch2 : branch1;
            var otherBranch = forBranch2 ? branch1 : branch2;
            var readIntoRequest = {
                _chunkSteps: function (chunk) {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(function () {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        var byobCanceled = forBranch2 ? canceled2 : canceled1;
                        var otherCanceled = forBranch2 ? canceled1 : canceled2;
                        if (!otherCanceled) {
                            var clonedChunk = void 0;
                            try {
                                clonedChunk = CloneAsUint8Array(chunk);
                            }
                            catch (cloneE) {
                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                            if (!byobCanceled) {
                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                            }
                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                        }
                        else if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        }
                        else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: function (chunk) {
                    reading = false;
                    var byobCanceled = forBranch2 ? canceled2 : canceled1;
                    var otherCanceled = forBranch2 ? canceled1 : canceled2;
                    if (!byobCanceled) {
                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                    }
                    if (!otherCanceled) {
                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                    }
                    if (chunk !== undefined) {
                        if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                        }
                    }
                    if (!byobCanceled || !otherCanceled) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: function () {
                    reading = false;
                }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
            if (reading) {
                readAgainForBranch1 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            }
            else {
                pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(undefined);
        }
        function pull2Algorithm() {
            if (reading) {
                readAgainForBranch2 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            }
            else {
                pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                var compositeReason = CreateArrayFromList([reason1, reason2]);
                var cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                var compositeReason = CreateArrayFromList([reason1, reason2]);
                var cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
    }

    function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        var original = source;
        var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        var cancel = original === null || original === void 0 ? void 0 : original.cancel;
        var pull = original === null || original === void 0 ? void 0 : original.pull;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        return {
            autoAllocateChunkSize: autoAllocateChunkSize === undefined ?
                undefined :
                convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
            cancel: cancel === undefined ?
                undefined :
                convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
            pull: pull === undefined ?
                undefined :
                convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
            start: start === undefined ?
                undefined :
                convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
            type: type === undefined ? undefined : convertReadableStreamType(type, context + " has member 'type' that")
        };
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (reason) { return promiseCall(fn, original, [reason]); };
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (controller) { return promiseCall(fn, original, [controller]); };
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (controller) { return reflectCall(fn, original, [controller]); };
    }
    function convertReadableStreamType(type, context) {
        type = "" + type;
        if (type !== 'bytes') {
            throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
        }
        return type;
    }

    function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        var mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
        };
    }
    function convertReadableStreamReaderMode(mode, context) {
        mode = "" + mode;
        if (mode !== 'byob') {
            throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
        }
        return mode;
    }

    function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
    }

    function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        var signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== undefined) {
            assertAbortSignal(signal, context + " has member 'signal' that");
        }
        return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal: signal
        };
    }
    function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
            throw new TypeError(context + " is not an AbortSignal.");
        }
    }

    function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, 'readable', 'ReadableWritablePair');
        assertReadableStream(readable, context + " has member 'readable' that");
        var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, 'writable', 'ReadableWritablePair');
        assertWritableStream(writable, context + " has member 'writable' that");
        return { readable: readable, writable: writable };
    }

    /**
     * A readable stream represents a source of data, from which you can read.
     *
     * @public
     */
    var ReadableStream = /** @class */ (function () {
        function ReadableStream(rawUnderlyingSource, rawStrategy) {
            if (rawUnderlyingSource === void 0) { rawUnderlyingSource = {}; }
            if (rawStrategy === void 0) { rawStrategy = {}; }
            if (rawUnderlyingSource === undefined) {
                rawUnderlyingSource = null;
            }
            else {
                assertObject(rawUnderlyingSource, 'First parameter');
            }
            var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
            var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
            InitializeReadableStream(this);
            if (underlyingSource.type === 'bytes') {
                if (strategy.size !== undefined) {
                    throw new RangeError('The strategy for a byte stream cannot have a size function');
                }
                var highWaterMark = ExtractHighWaterMark(strategy, 0);
                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            }
            else {
                var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                var highWaterMark = ExtractHighWaterMark(strategy, 1);
                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
        }
        Object.defineProperty(ReadableStream.prototype, "locked", {
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */
            get: function () {
                if (!IsReadableStream(this)) {
                    throw streamBrandCheckException$1('locked');
                }
                return IsReadableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        ReadableStream.prototype.cancel = function (reason) {
            if (reason === void 0) { reason = undefined; }
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1('cancel'));
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
            }
            return ReadableStreamCancel(this, reason);
        };
        ReadableStream.prototype.getReader = function (rawOptions) {
            if (rawOptions === void 0) { rawOptions = undefined; }
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('getReader');
            }
            var options = convertReaderOptions(rawOptions, 'First parameter');
            if (options.mode === undefined) {
                return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
        };
        ReadableStream.prototype.pipeThrough = function (rawTransform, rawOptions) {
            if (rawOptions === void 0) { rawOptions = {}; }
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('pipeThrough');
            }
            assertRequiredArgument(rawTransform, 1, 'pipeThrough');
            var transform = convertReadableWritablePair(rawTransform, 'First parameter');
            var options = convertPipeOptions(rawOptions, 'Second parameter');
            if (IsReadableStreamLocked(this)) {
                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
            }
            if (IsWritableStreamLocked(transform.writable)) {
                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
            }
            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
        };
        ReadableStream.prototype.pipeTo = function (destination, rawOptions) {
            if (rawOptions === void 0) { rawOptions = {}; }
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
            }
            if (destination === undefined) {
                return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
            }
            if (!IsWritableStream(destination)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            }
            var options;
            try {
                options = convertPipeOptions(rawOptions, 'Second parameter');
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
            }
            if (IsWritableStreamLocked(destination)) {
                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        };
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        ReadableStream.prototype.tee = function () {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('tee');
            }
            var branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
        };
        ReadableStream.prototype.values = function (rawOptions) {
            if (rawOptions === void 0) { rawOptions = undefined; }
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('values');
            }
            var options = convertIteratorOptions(rawOptions, 'First parameter');
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        };
        return ReadableStream;
    }());
    Object.defineProperties(ReadableStream.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStream',
            configurable: true
        });
    }
    if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream.prototype.values,
            writable: true,
            configurable: true
        });
    }
    // Abstract operations for the ReadableStream.
    // Throws if and only if startAlgorithm throws.
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) { highWaterMark = 1; }
        if (sizeAlgorithm === void 0) { sizeAlgorithm = function () { return 1; }; }
        var stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    // Throws if and only if startAlgorithm throws.
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        var stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
        return stream;
    }
    function InitializeReadableStream(stream) {
        stream._state = 'readable';
        stream._reader = undefined;
        stream._storedError = undefined;
        stream._disturbed = false;
    }
    function IsReadableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
            return false;
        }
        return x instanceof ReadableStream;
    }
    function IsReadableStreamLocked(stream) {
        if (stream._reader === undefined) {
            return false;
        }
        return true;
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === 'closed') {
            return promiseResolvedWith(undefined);
        }
        if (stream._state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        var reader = stream._reader;
        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach(function (readIntoRequest) {
                readIntoRequest._closeSteps(undefined);
            });
            reader._readIntoRequests = new SimpleQueue();
        }
        var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
    }
    function ReadableStreamClose(stream) {
        stream._state = 'closed';
        var reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(function (readRequest) {
                readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
        }
    }
    function ReadableStreamError(stream, e) {
        stream._state = 'errored';
        stream._storedError = e;
        var reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(function (readRequest) {
                readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
        }
        else {
            reader._readIntoRequests.forEach(function (readIntoRequest) {
                readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
        }
    }
    // Helper functions for the ReadableStream.
    function streamBrandCheckException$1(name) {
        return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
    }

    function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
        return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
    }

    // The size function must not have a prototype property nor be a constructor
    var byteLengthSizeFunction = function (chunk) {
        return chunk.byteLength;
    };
    try {
        Object.defineProperty(byteLengthSizeFunction, 'name', {
            value: 'size',
            configurable: true
        });
    }
    catch (_a) {
        // This property is non-configurable in older browsers, so ignore if this throws.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
    }
    /**
     * A queuing strategy that counts the number of bytes in each chunk.
     *
     * @public
     */
    var ByteLengthQueuingStrategy = /** @class */ (function () {
        function ByteLengthQueuingStrategy(options) {
            assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
            options = convertQueuingStrategyInit(options, 'First parameter');
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function () {
                if (!IsByteLengthQueuingStrategy(this)) {
                    throw byteLengthBrandCheckException('highWaterMark');
                }
                return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, "size", {
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */
            get: function () {
                if (!IsByteLengthQueuingStrategy(this)) {
                    throw byteLengthBrandCheckException('size');
                }
                return byteLengthSizeFunction;
            },
            enumerable: false,
            configurable: true
        });
        return ByteLengthQueuingStrategy;
    }());
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: 'ByteLengthQueuingStrategy',
            configurable: true
        });
    }
    // Helper functions for the ByteLengthQueuingStrategy.
    function byteLengthBrandCheckException(name) {
        return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
    }
    function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
            return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
    }

    // The size function must not have a prototype property nor be a constructor
    var countSizeFunction = function () {
        return 1;
    };
    try {
        Object.defineProperty(countSizeFunction, 'name', {
            value: 'size',
            configurable: true
        });
    }
    catch (_a) {
        // This property is non-configurable in older browsers, so ignore if this throws.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
    }
    /**
     * A queuing strategy that counts the number of chunks.
     *
     * @public
     */
    var CountQueuingStrategy = /** @class */ (function () {
        function CountQueuingStrategy(options) {
            assertRequiredArgument(options, 1, 'CountQueuingStrategy');
            options = convertQueuingStrategyInit(options, 'First parameter');
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        Object.defineProperty(CountQueuingStrategy.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function () {
                if (!IsCountQueuingStrategy(this)) {
                    throw countBrandCheckException('highWaterMark');
                }
                return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CountQueuingStrategy.prototype, "size", {
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */
            get: function () {
                if (!IsCountQueuingStrategy(this)) {
                    throw countBrandCheckException('size');
                }
                return countSizeFunction;
            },
            enumerable: false,
            configurable: true
        });
        return CountQueuingStrategy;
    }());
    Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: 'CountQueuingStrategy',
            configurable: true
        });
    }
    // Helper functions for the CountQueuingStrategy.
    function countBrandCheckException(name) {
        return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
    }
    function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
            return false;
        }
        return x instanceof CountQueuingStrategy;
    }

    function convertTransformer(original, context) {
        assertDictionary(original, context);
        var flush = original === null || original === void 0 ? void 0 : original.flush;
        var readableType = original === null || original === void 0 ? void 0 : original.readableType;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var transform = original === null || original === void 0 ? void 0 : original.transform;
        var writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
            flush: flush === undefined ?
                undefined :
                convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
            readableType: readableType,
            start: start === undefined ?
                undefined :
                convertTransformerStartCallback(start, original, context + " has member 'start' that"),
            transform: transform === undefined ?
                undefined :
                convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
            writableType: writableType
        };
    }
    function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (controller) { return promiseCall(fn, original, [controller]); };
    }
    function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (controller) { return reflectCall(fn, original, [controller]); };
    }
    function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return function (chunk, controller) { return promiseCall(fn, original, [chunk, controller]); };
    }

    // Class TransformStream
    /**
     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
     * In a manner specific to the transform stream in question, writes to the writable side result in new data being
     * made available for reading from the readable side.
     *
     * @public
     */
    var TransformStream = /** @class */ (function () {
        function TransformStream(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
            if (rawTransformer === void 0) { rawTransformer = {}; }
            if (rawWritableStrategy === void 0) { rawWritableStrategy = {}; }
            if (rawReadableStrategy === void 0) { rawReadableStrategy = {}; }
            if (rawTransformer === undefined) {
                rawTransformer = null;
            }
            var writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
            var readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
            var transformer = convertTransformer(rawTransformer, 'First parameter');
            if (transformer.readableType !== undefined) {
                throw new RangeError('Invalid readableType specified');
            }
            if (transformer.writableType !== undefined) {
                throw new RangeError('Invalid writableType specified');
            }
            var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            var startPromise_resolve;
            var startPromise = newPromise(function (resolve) {
                startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== undefined) {
                startPromise_resolve(transformer.start(this._transformStreamController));
            }
            else {
                startPromise_resolve(undefined);
            }
        }
        Object.defineProperty(TransformStream.prototype, "readable", {
            /**
             * The readable side of the transform stream.
             */
            get: function () {
                if (!IsTransformStream(this)) {
                    throw streamBrandCheckException('readable');
                }
                return this._readable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TransformStream.prototype, "writable", {
            /**
             * The writable side of the transform stream.
             */
            get: function () {
                if (!IsTransformStream(this)) {
                    throw streamBrandCheckException('writable');
                }
                return this._writable;
            },
            enumerable: false,
            configurable: true
        });
        return TransformStream;
    }());
    Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: 'TransformStream',
            configurable: true
        });
    }
    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
            return startPromise;
        }
        function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(undefined);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
        stream._backpressure = undefined;
        stream._backpressureChangePromise = undefined;
        stream._backpressureChangePromise_resolve = undefined;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = undefined;
    }
    function IsTransformStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
            return false;
        }
        return x instanceof TransformStream;
    }
    // This is a no-op if both sides are already errored.
    function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        if (stream._backpressure) {
            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
            // _backpressure is set.
            TransformStreamSetBackpressure(stream, false);
        }
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
        // Passes also when called during construction.
        if (stream._backpressureChangePromise !== undefined) {
            stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise(function (resolve) {
            stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
    }
    // Class TransformStreamDefaultController
    /**
     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
     *
     * @public
     */
    var TransformStreamDefaultController = /** @class */ (function () {
        function TransformStreamDefaultController() {
            throw new TypeError('Illegal constructor');
        }
        Object.defineProperty(TransformStreamDefaultController.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
             */
            get: function () {
                if (!IsTransformStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException('desiredSize');
                }
                var readableController = this._controlledTransformStream._readable._readableStreamController;
                return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            },
            enumerable: false,
            configurable: true
        });
        TransformStreamDefaultController.prototype.enqueue = function (chunk) {
            if (chunk === void 0) { chunk = undefined; }
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('enqueue');
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
        };
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        TransformStreamDefaultController.prototype.error = function (reason) {
            if (reason === void 0) { reason = undefined; }
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('error');
            }
            TransformStreamDefaultControllerError(this, reason);
        };
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        TransformStreamDefaultController.prototype.terminate = function () {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('terminate');
            }
            TransformStreamDefaultControllerTerminate(this);
        };
        return TransformStreamDefaultController;
    }());
    Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: 'TransformStreamDefaultController',
            configurable: true
        });
    }
    // Transform Stream Default Controller Abstract Operations
    function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
            return false;
        }
        return x instanceof TransformStreamDefaultController;
    }
    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
    }
    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        var controller = Object.create(TransformStreamDefaultController.prototype);
        var transformAlgorithm = function (chunk) {
            try {
                TransformStreamDefaultControllerEnqueue(controller, chunk);
                return promiseResolvedWith(undefined);
            }
            catch (transformResultE) {
                return promiseRejectedWith(transformResultE);
            }
        };
        var flushAlgorithm = function () { return promiseResolvedWith(undefined); };
        if (transformer.transform !== undefined) {
            transformAlgorithm = function (chunk) { return transformer.transform(chunk, controller); };
        }
        if (transformer.flush !== undefined) {
            flushAlgorithm = function () { return transformer.flush(controller); };
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = undefined;
        controller._flushAlgorithm = undefined;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError('Readable side is not in a state that permits enqueue');
        }
        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
        // accept TransformStreamDefaultControllerEnqueue() calls.
        try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        }
        catch (e) {
            // This happens when readableStrategy.size() throws.
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
        }
    }
    function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, undefined, function (r) {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
        });
    }
    function TransformStreamDefaultControllerTerminate(controller) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error = new TypeError('TransformStream terminated');
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
    }
    // TransformStreamDefaultSink Algorithms
    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        var controller = stream._transformStreamController;
        if (stream._backpressure) {
            var backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, function () {
                var writable = stream._writable;
                var state = writable._state;
                if (state === 'erroring') {
                    throw writable._storedError;
                }
                return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    }
    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already
        // errored.
        TransformStreamError(stream, reason);
        return promiseResolvedWith(undefined);
    }
    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        var readable = stream._readable;
        var controller = stream._transformStreamController;
        var flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        // Return a promise that is fulfilled with undefined on success.
        return transformPromiseWith(flushPromise, function () {
            if (readable._state === 'errored') {
                throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, function (r) {
            TransformStreamError(stream, r);
            throw readable._storedError;
        });
    }
    // TransformStreamDefaultSource Algorithms
    function TransformStreamDefaultSourcePullAlgorithm(stream) {
        // Invariant. Enforced by the promises returned by start() and pull().
        TransformStreamSetBackpressure(stream, false);
        // Prevent the next pull() call until there is backpressure.
        return stream._backpressureChangePromise;
    }
    // Helper functions for the TransformStreamDefaultController.
    function defaultControllerBrandCheckException(name) {
        return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
    }
    // Helper functions for the TransformStream.
    function streamBrandCheckException(name) {
        return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
    }

    exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
    exports.CountQueuingStrategy = CountQueuingStrategy;
    exports.ReadableByteStreamController = ReadableByteStreamController;
    exports.ReadableStream = ReadableStream;
    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
    exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
    exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
    exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
    exports.TransformStream = TransformStream;
    exports.TransformStreamDefaultController = TransformStreamDefaultController;
    exports.WritableStream = WritableStream;
    exports.WritableStreamDefaultController = WritableStreamDefaultController;
    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ponyfill.js.map
});

var _nodeResolve_empty = {};

var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': _nodeResolve_empty
});

var require$$3 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

var pdf = createCommonjsModule(function (module, exports) {
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(globalThis, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createPromiseCapability = createPromiseCapability;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.escapeString = escapeString;
exports.getModificationDate = getModificationDate;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isArrayEqual = isArrayEqual;
exports.isAscii = isAscii;
exports.objectFromMap = objectFromMap;
exports.objectSize = objectSize;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF16BEString = stringToUTF16BEString;
exports.stringToUTF8String = stringToUTF8String;
exports.unreachable = unreachable;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;

__w_pdfjs_require__(2);

const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
const LINE_FACTOR = 1.35;
exports.LINE_FACTOR = LINE_FACTOR;
const LINE_DESCENT_FACTOR = 0.35;
exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
const RenderingIntentFlag = {
  ANY: 0x01,
  DISPLAY: 0x02,
  PRINT: 0x04,
  ANNOTATIONS_FORMS: 0x10,
  ANNOTATIONS_STORAGE: 0x20,
  ANNOTATIONS_DISABLE: 0x40,
  OPLIST: 0x100
};
exports.RenderingIntentFlag = RenderingIntentFlag;
const AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
exports.AnnotationMode = AnnotationMode;
const AnnotationEditorPrefix = "pdfjs_internal_editor_";
exports.AnnotationEditorPrefix = AnnotationEditorPrefix;
const AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  INK: 15
};
exports.AnnotationEditorType = AnnotationEditorType;
const AnnotationEditorParamsType = {
  FREETEXT_SIZE: 1,
  FREETEXT_COLOR: 2,
  FREETEXT_OPACITY: 3,
  INK_COLOR: 11,
  INK_THICKNESS: 12,
  INK_OPACITY: 13
};
exports.AnnotationEditorParamsType = AnnotationEditorParamsType;
const PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
const ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
const AnnotationStateModelType = {
  MARKED: "Marked",
  REVIEW: "Review"
};
exports.AnnotationStateModelType = AnnotationStateModelType;
const AnnotationMarkedState = {
  MARKED: "Marked",
  UNMARKED: "Unmarked"
};
exports.AnnotationMarkedState = AnnotationMarkedState;
const AnnotationReviewState = {
  ACCEPTED: "Accepted",
  REJECTED: "Rejected",
  CANCELLED: "Cancelled",
  COMPLETED: "Completed",
  NONE: "None"
};
exports.AnnotationReviewState = AnnotationReviewState;
const AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
exports.AnnotationReplyType = AnnotationReplyType;
const AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
const AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
const AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
exports.AnnotationActionEventType = AnnotationActionEventType;
const DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
exports.DocumentActionEventType = DocumentActionEventType;
const PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
exports.PageActionEventType = PageActionEventType;
const StreamType = {
  UNKNOWN: "UNKNOWN",
  FLATE: "FLATE",
  LZW: "LZW",
  DCT: "DCT",
  JPX: "JPX",
  JBIG: "JBIG",
  A85: "A85",
  AHX: "AHX",
  CCF: "CCF",
  RLX: "RLX"
};
exports.StreamType = StreamType;
const FontType = {
  UNKNOWN: "UNKNOWN",
  TYPE1: "TYPE1",
  TYPE1STANDARD: "TYPE1STANDARD",
  TYPE1C: "TYPE1C",
  CIDFONTTYPE0: "CIDFONTTYPE0",
  CIDFONTTYPE0C: "CIDFONTTYPE0C",
  TRUETYPE: "TRUETYPE",
  CIDFONTTYPE2: "CIDFONTTYPE2",
  TYPE3: "TYPE3",
  OPENTYPE: "OPENTYPE",
  TYPE0: "TYPE0",
  MMTYPE1: "MMTYPE1"
};
exports.FontType = FontType;
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
const CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
exports.CMapCompressionType = CMapCompressionType;
const OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
const UNSUPPORTED_FEATURES = {
  unknown: "unknown",
  forms: "forms",
  javaScript: "javaScript",
  signatures: "signatures",
  smask: "smask",
  shadingPattern: "shadingPattern",
  font: "font",
  errorTilingPattern: "errorTilingPattern",
  errorExtGState: "errorExtGState",
  errorXObject: "errorXObject",
  errorFontLoadType3: "errorFontLoadType3",
  errorFontState: "errorFontState",
  errorFontMissing: "errorFontMissing",
  errorFontTranslate: "errorFontTranslate",
  errorColorSpace: "errorColorSpace",
  errorOperatorList: "errorOperatorList",
  errorFontToUnicode: "errorFontToUnicode",
  errorFontLoadNative: "errorFontLoadNative",
  errorFontBuildPath: "errorFontBuildPath",
  errorFontGetPath: "errorFontGetPath",
  errorMarkedContent: "errorMarkedContent",
  errorContentSubStream: "errorContentSubStream"
};
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
let verbosity = VerbosityLevel.WARNINGS;

function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}

function getVerbosityLevel() {
  return verbosity;
}

function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}

function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}

function unreachable(msg) {
  throw new Error(msg);
}

function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}

function _isValidProtocol(url) {
  if (!url) {
    return false;
  }

  switch (url.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;

    default:
      return false;
  }
}

function createValidAbsoluteUrl(url) {
  let baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!url) {
    return null;
  }

  try {
    if (options && typeof url === "string") {
      if (options.addDefaultProtocol && url.startsWith("www.")) {
        const dots = url.match(/\./g);

        if (dots && dots.length >= 2) {
          url = `http://${url}`;
        }
      }

      if (options.tryConvertEncoding) {
        try {
          url = stringToUTF8String(url);
        } catch (ex) {}
      }
    }

    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}

  return null;
}

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}

const BaseException = function BaseExceptionClosure() {
  function BaseException(message, name) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }

    this.message = message;
    this.name = name;
  }

  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();

exports.BaseException = BaseException;

class PasswordException extends BaseException {
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }

}

exports.PasswordException = PasswordException;

class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }

}

exports.UnknownErrorException = UnknownErrorException;

class InvalidPDFException extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }

}

exports.InvalidPDFException = InvalidPDFException;

class MissingPDFException extends BaseException {
  constructor(msg) {
    super(msg, "MissingPDFException");
  }

}

exports.MissingPDFException = MissingPDFException;

class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg, "UnexpectedResponseException");
    this.status = status;
  }

}

exports.UnexpectedResponseException = UnexpectedResponseException;

class FormatError extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }

}

exports.FormatError = FormatError;

class AbortException extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }

}

exports.AbortException = AbortException;

function bytesToString(bytes) {
  if (typeof bytes !== "object" || bytes === null || bytes.length === undefined) {
    unreachable("Invalid argument for bytesToString");
  }

  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;

  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }

  const strBuf = [];

  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }

  return strBuf.join("");
}

function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }

  const length = str.length;
  const bytes = new Uint8Array(length);

  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }

  return bytes;
}

function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }

  if (arr.byteLength !== undefined) {
    return arr.byteLength;
  }

  unreachable("Invalid argument for arrayByteLength");
}

function arraysToBytes(arr) {
  const length = arr.length;

  if (length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }

  let resultLength = 0;

  for (let i = 0; i < length; i++) {
    resultLength += arrayByteLength(arr[i]);
  }

  let pos = 0;
  const data = new Uint8Array(resultLength);

  for (let i = 0; i < length; i++) {
    let item = arr[i];

    if (!(item instanceof Uint8Array)) {
      if (typeof item === "string") {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }

    const itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }

  return data;
}

function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}

function objectSize(obj) {
  return Object.keys(obj).length;
}

function objectFromMap(map) {
  const obj = Object.create(null);

  for (const [key, value] of map) {
    obj[key] = value;
  }

  return obj;
}

function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}

function isEvalSupported() {
  return false;
}

class FeatureTest {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", isLittleEndian());
  }

  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", isEvalSupported());
  }

  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }

}

exports.FeatureTest = FeatureTest;
const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));

class Util {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }

  static scaleMinMax(transform, minMax) {
    let temp;

    if (transform[0]) {
      if (transform[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
      }

      minMax[0] *= transform[0];
      minMax[1] *= transform[0];

      if (transform[3] < 0) {
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
      }

      minMax[2] *= transform[3];
      minMax[3] *= transform[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[2];
      minMax[2] = temp;
      temp = minMax[1];
      minMax[1] = minMax[3];
      minMax[3] = temp;

      if (transform[1] < 0) {
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
      }

      minMax[2] *= transform[1];
      minMax[3] *= transform[1];

      if (transform[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
      }

      minMax[0] *= transform[2];
      minMax[1] *= transform[2];
    }

    minMax[0] += transform[4];
    minMax[1] += transform[4];
    minMax[2] += transform[5];
    minMax[3] += transform[5];
  }

  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }

  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }

  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }

  static getAxialAlignedBoundingBox(r, m) {
    const p1 = Util.applyTransform(r, m);
    const p2 = Util.applyTransform(r.slice(2, 4), m);
    const p3 = Util.applyTransform([r[0], r[3]], m);
    const p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }

  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }

  static apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  }

  static singularValueDecompose2dScale(m) {
    const transpose = [m[0], m[2], m[1], m[3]];
    const a = m[0] * transpose[0] + m[1] * transpose[2];
    const b = m[0] * transpose[1] + m[1] * transpose[3];
    const c = m[2] * transpose[0] + m[3] * transpose[2];
    const d = m[2] * transpose[1] + m[3] * transpose[3];
    const first = (a + d) / 2;
    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }

  static normalizeRect(rect) {
    const r = rect.slice(0);

    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }

    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }

    return r;
  }

  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));

    if (xLow > xHigh) {
      return null;
    }

    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));

    if (yLow > yHigh) {
      return null;
    }

    return [xLow, yLow, xHigh, yHigh];
  }

  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    const tvalues = [],
          bounds = [[], []];
    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    for (let i = 0; i < 2; ++i) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }

        t = -c / b;

        if (0 < t && t < 1) {
          tvalues.push(t);
        }

        continue;
      }

      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);

      if (b2ac < 0) {
        continue;
      }

      t1 = (-b + sqrtb2ac) / (2 * a);

      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }

      t2 = (-b - sqrtb2ac) / (2 * a);

      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    let j = tvalues.length,
        mt;
    const jlen = j;

    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
  }

}

exports.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];

function stringToPDFString(str) {
  if (str[0] >= "\xEF") {
    let encoding;

    if (str[0] === "\xFE" && str[1] === "\xFF") {
      encoding = "utf-16be";
    } else if (str[0] === "\xFF" && str[1] === "\xFE") {
      encoding = "utf-16le";
    } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
      encoding = "utf-8";
    }

    if (encoding) {
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(str);
        return decoder.decode(buffer);
      } catch (ex) {
        warn(`stringToPDFString: "${ex}".`);
      }
    }
  }

  const strBuf = [];

  for (let i = 0, ii = str.length; i < ii; i++) {
    const code = PDFStringTranslateTable[str.charCodeAt(i)];
    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
  }

  return strBuf.join("");
}

function escapeString(str) {
  return str.replace(/([()\\\n\r])/g, match => {
    if (match === "\n") {
      return "\\n";
    } else if (match === "\r") {
      return "\\r";
    }

    return `\\${match}`;
  });
}

function isAscii(str) {
  return /^[\x00-\x7F]*$/.test(str);
}

function stringToUTF16BEString(str) {
  const buf = ["\xFE\xFF"];

  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));
  }

  return buf.join("");
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}

function isArrayBuffer(v) {
  return typeof v === "object" && v !== null && v.byteLength !== undefined;
}

function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0, ii = arr1.length; i < ii; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}

function getModificationDate() {
  let date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}

function createPromiseCapability() {
  const capability = Object.create(null);
  let isSettled = false;
  Object.defineProperty(capability, "settled", {
    get() {
      return isSettled;
    }

  });
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = function (data) {
      isSettled = true;
      resolve(data);
    };

    capability.reject = function (reason) {
      isSettled = true;
      reject(reason);
    };
  });
  return capability;
}

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {


var _is_node = __w_pdfjs_require__(3);

if (!globalThis._pdfjsCompatibilityChecked) {
  globalThis._pdfjsCompatibilityChecked = true;

  (function checkNodeBtoa() {
    if (globalThis.btoa || !_is_node.isNodeJS) {
      return;
    }

    globalThis.btoa = function (chars) {
      return Buffer.from(chars, "binary").toString("base64");
    };
  })();

  (function checkNodeAtob() {
    if (globalThis.atob || !_is_node.isNodeJS) {
      return;
    }

    globalThis.atob = function (input) {
      return Buffer.from(input, "base64").toString("binary");
    };
  })();

  (function checkDOMMatrix() {
    if (globalThis.DOMMatrix || !_is_node.isNodeJS) {
      return;
    }

    globalThis.DOMMatrix = dommatrix;
  })();

  (function checkReadableStream() {
    if (globalThis.ReadableStream || !_is_node.isNodeJS) {
      return;
    }

    globalThis.ReadableStream = ponyfill.ReadableStream;
  })();

  (function checkArrayAt() {
    if (Array.prototype.at) {
      return;
    }

    __w_pdfjs_require__(4);
  })();

  (function checkTypedArrayAt() {
    if (Uint8Array.prototype.at) {
      return;
    }

    __w_pdfjs_require__(76);
  })();

  (function checkStructuredClone() {
    if (globalThis.structuredClone) {
      return;
    }

    __w_pdfjs_require__(86);
  })();
}

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNodeJS = void 0;
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
exports.isNodeJS = isNodeJS;

/***/ }),
/* 4 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(5);
var entryUnbind = __w_pdfjs_require__(75);
module.exports = entryUnbind('Array', 'at');

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var $ = __w_pdfjs_require__(6);
var toObject = __w_pdfjs_require__(41);
var lengthOfArrayLike = __w_pdfjs_require__(65);
var toIntegerOrInfinity = __w_pdfjs_require__(63);
var addToUnscopables = __w_pdfjs_require__(70);
$({
 target: 'Array',
 proto: true
}, {
 at: function at(index) {
  var O = toObject(this);
  var len = lengthOfArrayLike(O);
  var relativeIndex = toIntegerOrInfinity(index);
  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
  return k < 0 || k >= len ? undefined : O[k];
 }
});
addToUnscopables('at');

/***/ }),
/* 6 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var getOwnPropertyDescriptor = (__w_pdfjs_require__(8).f);
var createNonEnumerableProperty = __w_pdfjs_require__(45);
var defineBuiltIn = __w_pdfjs_require__(49);
var defineGlobalProperty = __w_pdfjs_require__(39);
var copyConstructorProperties = __w_pdfjs_require__(57);
var isForced = __w_pdfjs_require__(69);
module.exports = function (options, source) {
 var TARGET = options.target;
 var GLOBAL = options.global;
 var STATIC = options.stat;
 var FORCED, target, key, targetProperty, sourceProperty, descriptor;
 if (GLOBAL) {
  target = global;
 } else if (STATIC) {
  target = global[TARGET] || defineGlobalProperty(TARGET, {});
 } else {
  target = (global[TARGET] || {}).prototype;
 }
 if (target)
  for (key in source) {
   sourceProperty = source[key];
   if (options.dontCallGetSet) {
    descriptor = getOwnPropertyDescriptor(target, key);
    targetProperty = descriptor && descriptor.value;
   } else
    targetProperty = target[key];
   FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
   if (!FORCED && targetProperty !== undefined) {
    if (typeof sourceProperty == typeof targetProperty)
     continue;
    copyConstructorProperties(sourceProperty, targetProperty);
   }
   if (options.sham || targetProperty && targetProperty.sham) {
    createNonEnumerableProperty(sourceProperty, 'sham', true);
   }
   defineBuiltIn(target, key, sourceProperty, options);
  }
};

/***/ }),
/* 7 */
/***/ ((module) => {

var check = function (it) {
 return it && it.Math == Math && it;
};
module.exports = check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || (function () {
 return this;
}());

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(9);
var call = __w_pdfjs_require__(11);
var propertyIsEnumerableModule = __w_pdfjs_require__(13);
var createPropertyDescriptor = __w_pdfjs_require__(14);
var toIndexedObject = __w_pdfjs_require__(15);
var toPropertyKey = __w_pdfjs_require__(20);
var hasOwn = __w_pdfjs_require__(40);
var IE8_DOM_DEFINE = __w_pdfjs_require__(43);
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
 O = toIndexedObject(O);
 P = toPropertyKey(P);
 if (IE8_DOM_DEFINE)
  try {
   return $getOwnPropertyDescriptor(O, P);
  } catch (error) {
  }
 if (hasOwn(O, P))
  return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};

/***/ }),
/* 9 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
module.exports = !fails(function () {
 return Object.defineProperty({}, 1, {
  get: function () {
   return 7;
  }
 })[1] != 7;
});

/***/ }),
/* 10 */
/***/ ((module) => {

module.exports = function (exec) {
 try {
  return !!exec();
 } catch (error) {
  return true;
 }
};

/***/ }),
/* 11 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var NATIVE_BIND = __w_pdfjs_require__(12);
var call = Function.prototype.call;
module.exports = NATIVE_BIND ? call.bind(call) : function () {
 return call.apply(call, arguments);
};

/***/ }),
/* 12 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
module.exports = !fails(function () {
 var test = function () {
 }.bind();
 return typeof test != 'function' || test.hasOwnProperty('prototype');
});

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports) => {

var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
 var descriptor = getOwnPropertyDescriptor(this, V);
 return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

/***/ }),
/* 14 */
/***/ ((module) => {

module.exports = function (bitmap, value) {
 return {
  enumerable: !(bitmap & 1),
  configurable: !(bitmap & 2),
  writable: !(bitmap & 4),
  value: value
 };
};

/***/ }),
/* 15 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var IndexedObject = __w_pdfjs_require__(16);
var requireObjectCoercible = __w_pdfjs_require__(19);
module.exports = function (it) {
 return IndexedObject(requireObjectCoercible(it));
};

/***/ }),
/* 16 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var fails = __w_pdfjs_require__(10);
var classof = __w_pdfjs_require__(18);
var $Object = Object;
var split = uncurryThis(''.split);
module.exports = fails(function () {
 return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
 return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;

/***/ }),
/* 17 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var NATIVE_BIND = __w_pdfjs_require__(12);
var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);
module.exports = NATIVE_BIND ? function (fn) {
 return fn && uncurryThis(fn);
} : function (fn) {
 return fn && function () {
  return call.apply(fn, arguments);
 };
};

/***/ }),
/* 18 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);
module.exports = function (it) {
 return stringSlice(toString(it), 8, -1);
};

/***/ }),
/* 19 */
/***/ ((module) => {

var $TypeError = TypeError;
module.exports = function (it) {
 if (it == undefined)
  throw $TypeError("Can't call method on " + it);
 return it;
};

/***/ }),
/* 20 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toPrimitive = __w_pdfjs_require__(21);
var isSymbol = __w_pdfjs_require__(24);
module.exports = function (argument) {
 var key = toPrimitive(argument, 'string');
 return isSymbol(key) ? key : key + '';
};

/***/ }),
/* 21 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var call = __w_pdfjs_require__(11);
var isObject = __w_pdfjs_require__(22);
var isSymbol = __w_pdfjs_require__(24);
var getMethod = __w_pdfjs_require__(31);
var ordinaryToPrimitive = __w_pdfjs_require__(34);
var wellKnownSymbol = __w_pdfjs_require__(35);
var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
module.exports = function (input, pref) {
 if (!isObject(input) || isSymbol(input))
  return input;
 var exoticToPrim = getMethod(input, TO_PRIMITIVE);
 var result;
 if (exoticToPrim) {
  if (pref === undefined)
   pref = 'default';
  result = call(exoticToPrim, input, pref);
  if (!isObject(result) || isSymbol(result))
   return result;
  throw $TypeError("Can't convert object to primitive value");
 }
 if (pref === undefined)
  pref = 'number';
 return ordinaryToPrimitive(input, pref);
};

/***/ }),
/* 22 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isCallable = __w_pdfjs_require__(23);
module.exports = function (it) {
 return typeof it == 'object' ? it !== null : isCallable(it);
};

/***/ }),
/* 23 */
/***/ ((module) => {

module.exports = function (argument) {
 return typeof argument == 'function';
};

/***/ }),
/* 24 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var getBuiltIn = __w_pdfjs_require__(25);
var isCallable = __w_pdfjs_require__(23);
var isPrototypeOf = __w_pdfjs_require__(26);
var USE_SYMBOL_AS_UID = __w_pdfjs_require__(27);
var $Object = Object;
module.exports = USE_SYMBOL_AS_UID ? function (it) {
 return typeof it == 'symbol';
} : function (it) {
 var $Symbol = getBuiltIn('Symbol');
 return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};

/***/ }),
/* 25 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var isCallable = __w_pdfjs_require__(23);
var aFunction = function (argument) {
 return isCallable(argument) ? argument : undefined;
};
module.exports = function (namespace, method) {
 return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};

/***/ }),
/* 26 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
module.exports = uncurryThis({}.isPrototypeOf);

/***/ }),
/* 27 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var NATIVE_SYMBOL = __w_pdfjs_require__(28);
module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';

/***/ }),
/* 28 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var V8_VERSION = __w_pdfjs_require__(29);
var fails = __w_pdfjs_require__(10);
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
 var symbol = Symbol();
 return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var userAgent = __w_pdfjs_require__(30);
var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
 match = v8.split('.');
 version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent) {
 match = userAgent.match(/Edge\/(\d+)/);
 if (!match || match[1] >= 74) {
  match = userAgent.match(/Chrome\/(\d+)/);
  if (match)
   version = +match[1];
 }
}
module.exports = version;

/***/ }),
/* 30 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var getBuiltIn = __w_pdfjs_require__(25);
module.exports = getBuiltIn('navigator', 'userAgent') || '';

/***/ }),
/* 31 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var aCallable = __w_pdfjs_require__(32);
module.exports = function (V, P) {
 var func = V[P];
 return func == null ? undefined : aCallable(func);
};

/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isCallable = __w_pdfjs_require__(23);
var tryToString = __w_pdfjs_require__(33);
var $TypeError = TypeError;
module.exports = function (argument) {
 if (isCallable(argument))
  return argument;
 throw $TypeError(tryToString(argument) + ' is not a function');
};

/***/ }),
/* 33 */
/***/ ((module) => {

var $String = String;
module.exports = function (argument) {
 try {
  return $String(argument);
 } catch (error) {
  return 'Object';
 }
};

/***/ }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var call = __w_pdfjs_require__(11);
var isCallable = __w_pdfjs_require__(23);
var isObject = __w_pdfjs_require__(22);
var $TypeError = TypeError;
module.exports = function (input, pref) {
 var fn, val;
 if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
  return val;
 if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
  return val;
 if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
  return val;
 throw $TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 35 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var shared = __w_pdfjs_require__(36);
var hasOwn = __w_pdfjs_require__(40);
var uid = __w_pdfjs_require__(42);
var NATIVE_SYMBOL = __w_pdfjs_require__(28);
var USE_SYMBOL_AS_UID = __w_pdfjs_require__(27);
var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
module.exports = function (name) {
 if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
  var description = 'Symbol.' + name;
  if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
   WellKnownSymbolsStore[name] = Symbol[name];
  } else if (USE_SYMBOL_AS_UID && symbolFor) {
   WellKnownSymbolsStore[name] = symbolFor(description);
  } else {
   WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
  }
 }
 return WellKnownSymbolsStore[name];
};

/***/ }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var IS_PURE = __w_pdfjs_require__(37);
var store = __w_pdfjs_require__(38);
(module.exports = function (key, value) {
 return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
 version: '3.24.1',
 mode: IS_PURE ? 'pure' : 'global',
 copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
 license: 'https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE',
 source: 'https://github.com/zloirock/core-js'
});

/***/ }),
/* 37 */
/***/ ((module) => {

module.exports = false;

/***/ }),
/* 38 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var defineGlobalProperty = __w_pdfjs_require__(39);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});
module.exports = store;

/***/ }),
/* 39 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var defineProperty = Object.defineProperty;
module.exports = function (key, value) {
 try {
  defineProperty(global, key, {
   value: value,
   configurable: true,
   writable: true
  });
 } catch (error) {
  global[key] = value;
 }
 return value;
};

/***/ }),
/* 40 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var toObject = __w_pdfjs_require__(41);
var hasOwnProperty = uncurryThis({}.hasOwnProperty);
module.exports = Object.hasOwn || function hasOwn(it, key) {
 return hasOwnProperty(toObject(it), key);
};

/***/ }),
/* 41 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var requireObjectCoercible = __w_pdfjs_require__(19);
var $Object = Object;
module.exports = function (argument) {
 return $Object(requireObjectCoercible(argument));
};

/***/ }),
/* 42 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);
module.exports = function (key) {
 return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};

/***/ }),
/* 43 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(9);
var fails = __w_pdfjs_require__(10);
var createElement = __w_pdfjs_require__(44);
module.exports = !DESCRIPTORS && !fails(function () {
 return Object.defineProperty(createElement('div'), 'a', {
  get: function () {
   return 7;
  }
 }).a != 7;
});

/***/ }),
/* 44 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var isObject = __w_pdfjs_require__(22);
var document = global.document;
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
 return EXISTS ? document.createElement(it) : {};
};

/***/ }),
/* 45 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(9);
var definePropertyModule = __w_pdfjs_require__(46);
var createPropertyDescriptor = __w_pdfjs_require__(14);
module.exports = DESCRIPTORS ? function (object, key, value) {
 return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
 object[key] = value;
 return object;
};

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(9);
var IE8_DOM_DEFINE = __w_pdfjs_require__(43);
var V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__(47);
var anObject = __w_pdfjs_require__(48);
var toPropertyKey = __w_pdfjs_require__(20);
var $TypeError = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
 anObject(O);
 P = toPropertyKey(P);
 anObject(Attributes);
 if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
  var current = $getOwnPropertyDescriptor(O, P);
  if (current && current[WRITABLE]) {
   O[P] = Attributes.value;
   Attributes = {
    configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
    enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
    writable: false
   };
  }
 }
 return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
 anObject(O);
 P = toPropertyKey(P);
 anObject(Attributes);
 if (IE8_DOM_DEFINE)
  try {
   return $defineProperty(O, P, Attributes);
  } catch (error) {
  }
 if ('get' in Attributes || 'set' in Attributes)
  throw $TypeError('Accessors not supported');
 if ('value' in Attributes)
  O[P] = Attributes.value;
 return O;
};

/***/ }),
/* 47 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(9);
var fails = __w_pdfjs_require__(10);
module.exports = DESCRIPTORS && fails(function () {
 return Object.defineProperty(function () {
 }, 'prototype', {
  value: 42,
  writable: false
 }).prototype != 42;
});

/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isObject = __w_pdfjs_require__(22);
var $String = String;
var $TypeError = TypeError;
module.exports = function (argument) {
 if (isObject(argument))
  return argument;
 throw $TypeError($String(argument) + ' is not an object');
};

/***/ }),
/* 49 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isCallable = __w_pdfjs_require__(23);
var definePropertyModule = __w_pdfjs_require__(46);
var makeBuiltIn = __w_pdfjs_require__(50);
var defineGlobalProperty = __w_pdfjs_require__(39);
module.exports = function (O, key, value, options) {
 if (!options)
  options = {};
 var simple = options.enumerable;
 var name = options.name !== undefined ? options.name : key;
 if (isCallable(value))
  makeBuiltIn(value, name, options);
 if (options.global) {
  if (simple)
   O[key] = value;
  else
   defineGlobalProperty(key, value);
 } else {
  try {
   if (!options.unsafe)
    delete O[key];
   else if (O[key])
    simple = true;
  } catch (error) {
  }
  if (simple)
   O[key] = value;
  else
   definePropertyModule.f(O, key, {
    value: value,
    enumerable: false,
    configurable: !options.nonConfigurable,
    writable: !options.nonWritable
   });
 }
 return O;
};

/***/ }),
/* 50 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
var isCallable = __w_pdfjs_require__(23);
var hasOwn = __w_pdfjs_require__(40);
var DESCRIPTORS = __w_pdfjs_require__(9);
var CONFIGURABLE_FUNCTION_NAME = (__w_pdfjs_require__(51).CONFIGURABLE);
var inspectSource = __w_pdfjs_require__(52);
var InternalStateModule = __w_pdfjs_require__(53);
var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var defineProperty = Object.defineProperty;
var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
 return defineProperty(function () {
 }, 'length', { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split('String');
var makeBuiltIn = module.exports = function (value, name, options) {
 if (String(name).slice(0, 7) === 'Symbol(') {
  name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
 }
 if (options && options.getter)
  name = 'get ' + name;
 if (options && options.setter)
  name = 'set ' + name;
 if (!hasOwn(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
  if (DESCRIPTORS)
   defineProperty(value, 'name', {
    value: name,
    configurable: true
   });
  else
   value.name = name;
 }
 if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
  defineProperty(value, 'length', { value: options.arity });
 }
 try {
  if (options && hasOwn(options, 'constructor') && options.constructor) {
   if (DESCRIPTORS)
    defineProperty(value, 'prototype', { writable: false });
  } else if (value.prototype)
   value.prototype = undefined;
 } catch (error) {
 }
 var state = enforceInternalState(value);
 if (!hasOwn(state, 'source')) {
  state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
 }
 return value;
};
Function.prototype.toString = makeBuiltIn(function toString() {
 return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');

/***/ }),
/* 51 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(9);
var hasOwn = __w_pdfjs_require__(40);
var FunctionPrototype = Function.prototype;
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn(FunctionPrototype, 'name');
var PROPER = EXISTS && function something() {
}.name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable);
module.exports = {
 EXISTS: EXISTS,
 PROPER: PROPER,
 CONFIGURABLE: CONFIGURABLE
};

/***/ }),
/* 52 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var isCallable = __w_pdfjs_require__(23);
var store = __w_pdfjs_require__(38);
var functionToString = uncurryThis(Function.toString);
if (!isCallable(store.inspectSource)) {
 store.inspectSource = function (it) {
  return functionToString(it);
 };
}
module.exports = store.inspectSource;

/***/ }),
/* 53 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var NATIVE_WEAK_MAP = __w_pdfjs_require__(54);
var global = __w_pdfjs_require__(7);
var uncurryThis = __w_pdfjs_require__(17);
var isObject = __w_pdfjs_require__(22);
var createNonEnumerableProperty = __w_pdfjs_require__(45);
var hasOwn = __w_pdfjs_require__(40);
var shared = __w_pdfjs_require__(38);
var sharedKey = __w_pdfjs_require__(55);
var hiddenKeys = __w_pdfjs_require__(56);
var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;
var enforce = function (it) {
 return has(it) ? get(it) : set(it, {});
};
var getterFor = function (TYPE) {
 return function (it) {
  var state;
  if (!isObject(it) || (state = get(it)).type !== TYPE) {
   throw TypeError('Incompatible receiver, ' + TYPE + ' required');
  }
  return state;
 };
};
if (NATIVE_WEAK_MAP || shared.state) {
 var store = shared.state || (shared.state = new WeakMap());
 var wmget = uncurryThis(store.get);
 var wmhas = uncurryThis(store.has);
 var wmset = uncurryThis(store.set);
 set = function (it, metadata) {
  if (wmhas(store, it))
   throw new TypeError(OBJECT_ALREADY_INITIALIZED);
  metadata.facade = it;
  wmset(store, it, metadata);
  return metadata;
 };
 get = function (it) {
  return wmget(store, it) || {};
 };
 has = function (it) {
  return wmhas(store, it);
 };
} else {
 var STATE = sharedKey('state');
 hiddenKeys[STATE] = true;
 set = function (it, metadata) {
  if (hasOwn(it, STATE))
   throw new TypeError(OBJECT_ALREADY_INITIALIZED);
  metadata.facade = it;
  createNonEnumerableProperty(it, STATE, metadata);
  return metadata;
 };
 get = function (it) {
  return hasOwn(it, STATE) ? it[STATE] : {};
 };
 has = function (it) {
  return hasOwn(it, STATE);
 };
}
module.exports = {
 set: set,
 get: get,
 has: has,
 enforce: enforce,
 getterFor: getterFor
};

/***/ }),
/* 54 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var isCallable = __w_pdfjs_require__(23);
var inspectSource = __w_pdfjs_require__(52);
var WeakMap = global.WeakMap;
module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));

/***/ }),
/* 55 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var shared = __w_pdfjs_require__(36);
var uid = __w_pdfjs_require__(42);
var keys = shared('keys');
module.exports = function (key) {
 return keys[key] || (keys[key] = uid(key));
};

/***/ }),
/* 56 */
/***/ ((module) => {

module.exports = {};

/***/ }),
/* 57 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var hasOwn = __w_pdfjs_require__(40);
var ownKeys = __w_pdfjs_require__(58);
var getOwnPropertyDescriptorModule = __w_pdfjs_require__(8);
var definePropertyModule = __w_pdfjs_require__(46);
module.exports = function (target, source, exceptions) {
 var keys = ownKeys(source);
 var defineProperty = definePropertyModule.f;
 var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
 for (var i = 0; i < keys.length; i++) {
  var key = keys[i];
  if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
   defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
 }
};

/***/ }),
/* 58 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var getBuiltIn = __w_pdfjs_require__(25);
var uncurryThis = __w_pdfjs_require__(17);
var getOwnPropertyNamesModule = __w_pdfjs_require__(59);
var getOwnPropertySymbolsModule = __w_pdfjs_require__(68);
var anObject = __w_pdfjs_require__(48);
var concat = uncurryThis([].concat);
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
 var keys = getOwnPropertyNamesModule.f(anObject(it));
 var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
 return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

var internalObjectKeys = __w_pdfjs_require__(60);
var enumBugKeys = __w_pdfjs_require__(67);
var hiddenKeys = enumBugKeys.concat('length', 'prototype');
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
 return internalObjectKeys(O, hiddenKeys);
};

/***/ }),
/* 60 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var hasOwn = __w_pdfjs_require__(40);
var toIndexedObject = __w_pdfjs_require__(15);
var indexOf = (__w_pdfjs_require__(61).indexOf);
var hiddenKeys = __w_pdfjs_require__(56);
var push = uncurryThis([].push);
module.exports = function (object, names) {
 var O = toIndexedObject(object);
 var i = 0;
 var result = [];
 var key;
 for (key in O)
  !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
 while (names.length > i)
  if (hasOwn(O, key = names[i++])) {
   ~indexOf(result, key) || push(result, key);
  }
 return result;
};

/***/ }),
/* 61 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toIndexedObject = __w_pdfjs_require__(15);
var toAbsoluteIndex = __w_pdfjs_require__(62);
var lengthOfArrayLike = __w_pdfjs_require__(65);
var createMethod = function (IS_INCLUDES) {
 return function ($this, el, fromIndex) {
  var O = toIndexedObject($this);
  var length = lengthOfArrayLike(O);
  var index = toAbsoluteIndex(fromIndex, length);
  var value;
  if (IS_INCLUDES && el != el)
   while (length > index) {
    value = O[index++];
    if (value != value)
     return true;
   }
  else
   for (; length > index; index++) {
    if ((IS_INCLUDES || index in O) && O[index] === el)
     return IS_INCLUDES || index || 0;
   }
  return !IS_INCLUDES && -1;
 };
};
module.exports = {
 includes: createMethod(true),
 indexOf: createMethod(false)
};

/***/ }),
/* 62 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toIntegerOrInfinity = __w_pdfjs_require__(63);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
 var integer = toIntegerOrInfinity(index);
 return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

/***/ }),
/* 63 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var trunc = __w_pdfjs_require__(64);
module.exports = function (argument) {
 var number = +argument;
 return number !== number || number === 0 ? 0 : trunc(number);
};

/***/ }),
/* 64 */
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;
module.exports = Math.trunc || function trunc(x) {
 var n = +x;
 return (n > 0 ? floor : ceil)(n);
};

/***/ }),
/* 65 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toLength = __w_pdfjs_require__(66);
module.exports = function (obj) {
 return toLength(obj.length);
};

/***/ }),
/* 66 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toIntegerOrInfinity = __w_pdfjs_require__(63);
var min = Math.min;
module.exports = function (argument) {
 return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0;
};

/***/ }),
/* 67 */
/***/ ((module) => {

module.exports = [
 'constructor',
 'hasOwnProperty',
 'isPrototypeOf',
 'propertyIsEnumerable',
 'toLocaleString',
 'toString',
 'valueOf'
];

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, exports) => {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 69 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
var isCallable = __w_pdfjs_require__(23);
var replacement = /#|\.prototype\./;
var isForced = function (feature, detection) {
 var value = data[normalize(feature)];
 return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function (string) {
 return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

/***/ }),
/* 70 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var wellKnownSymbol = __w_pdfjs_require__(35);
var create = __w_pdfjs_require__(71);
var defineProperty = (__w_pdfjs_require__(46).f);
var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] == undefined) {
 defineProperty(ArrayPrototype, UNSCOPABLES, {
  configurable: true,
  value: create(null)
 });
}
module.exports = function (key) {
 ArrayPrototype[UNSCOPABLES][key] = true;
};

/***/ }),
/* 71 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(48);
var definePropertiesModule = __w_pdfjs_require__(72);
var enumBugKeys = __w_pdfjs_require__(67);
var hiddenKeys = __w_pdfjs_require__(56);
var html = __w_pdfjs_require__(74);
var documentCreateElement = __w_pdfjs_require__(44);
var sharedKey = __w_pdfjs_require__(55);
var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');
var EmptyConstructor = function () {
};
var scriptTag = function (content) {
 return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function (activeXDocument) {
 activeXDocument.write(scriptTag(''));
 activeXDocument.close();
 var temp = activeXDocument.parentWindow.Object;
 activeXDocument = null;
 return temp;
};
var NullProtoObjectViaIFrame = function () {
 var iframe = documentCreateElement('iframe');
 var JS = 'java' + SCRIPT + ':';
 var iframeDocument;
 iframe.style.display = 'none';
 html.appendChild(iframe);
 iframe.src = String(JS);
 iframeDocument = iframe.contentWindow.document;
 iframeDocument.open();
 iframeDocument.write(scriptTag('document.F=Object'));
 iframeDocument.close();
 return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function () {
 try {
  activeXDocument = new ActiveXObject('htmlfile');
 } catch (error) {
 }
 NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
 var length = enumBugKeys.length;
 while (length--)
  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
 return NullProtoObject();
};
hiddenKeys[IE_PROTO] = true;
module.exports = Object.create || function create(O, Properties) {
 var result;
 if (O !== null) {
  EmptyConstructor[PROTOTYPE] = anObject(O);
  result = new EmptyConstructor();
  EmptyConstructor[PROTOTYPE] = null;
  result[IE_PROTO] = O;
 } else
  result = NullProtoObject();
 return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {

var DESCRIPTORS = __w_pdfjs_require__(9);
var V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__(47);
var definePropertyModule = __w_pdfjs_require__(46);
var anObject = __w_pdfjs_require__(48);
var toIndexedObject = __w_pdfjs_require__(15);
var objectKeys = __w_pdfjs_require__(73);
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
 anObject(O);
 var props = toIndexedObject(Properties);
 var keys = objectKeys(Properties);
 var length = keys.length;
 var index = 0;
 var key;
 while (length > index)
  definePropertyModule.f(O, key = keys[index++], props[key]);
 return O;
};

/***/ }),
/* 73 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var internalObjectKeys = __w_pdfjs_require__(60);
var enumBugKeys = __w_pdfjs_require__(67);
module.exports = Object.keys || function keys(O) {
 return internalObjectKeys(O, enumBugKeys);
};

/***/ }),
/* 74 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var getBuiltIn = __w_pdfjs_require__(25);
module.exports = getBuiltIn('document', 'documentElement');

/***/ }),
/* 75 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
var uncurryThis = __w_pdfjs_require__(17);
module.exports = function (CONSTRUCTOR, METHOD) {
 return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);
};

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(77);

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var ArrayBufferViewCore = __w_pdfjs_require__(78);
var lengthOfArrayLike = __w_pdfjs_require__(65);
var toIntegerOrInfinity = __w_pdfjs_require__(63);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
exportTypedArrayMethod('at', function at(index) {
 var O = aTypedArray(this);
 var len = lengthOfArrayLike(O);
 var relativeIndex = toIntegerOrInfinity(index);
 var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
 return k < 0 || k >= len ? undefined : O[k];
});

/***/ }),
/* 78 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var NATIVE_ARRAY_BUFFER = __w_pdfjs_require__(79);
var DESCRIPTORS = __w_pdfjs_require__(9);
var global = __w_pdfjs_require__(7);
var isCallable = __w_pdfjs_require__(23);
var isObject = __w_pdfjs_require__(22);
var hasOwn = __w_pdfjs_require__(40);
var classof = __w_pdfjs_require__(80);
var tryToString = __w_pdfjs_require__(33);
var createNonEnumerableProperty = __w_pdfjs_require__(45);
var defineBuiltIn = __w_pdfjs_require__(49);
var defineProperty = (__w_pdfjs_require__(46).f);
var isPrototypeOf = __w_pdfjs_require__(26);
var getPrototypeOf = __w_pdfjs_require__(82);
var setPrototypeOf = __w_pdfjs_require__(84);
var wellKnownSymbol = __w_pdfjs_require__(35);
var uid = __w_pdfjs_require__(42);
var InternalStateModule = __w_pdfjs_require__(53);
var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = global.TypeError;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;
var TypedArrayConstructorsList = {
 Int8Array: 1,
 Uint8Array: 1,
 Uint8ClampedArray: 1,
 Int16Array: 2,
 Uint16Array: 2,
 Int32Array: 4,
 Uint32Array: 4,
 Float32Array: 4,
 Float64Array: 8
};
var BigIntArrayConstructorsList = {
 BigInt64Array: 8,
 BigUint64Array: 8
};
var isView = function isView(it) {
 if (!isObject(it))
  return false;
 var klass = classof(it);
 return klass === 'DataView' || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
};
var getTypedArrayConstructor = function (it) {
 var proto = getPrototypeOf(it);
 if (!isObject(proto))
  return;
 var state = getInternalState(proto);
 return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};
var isTypedArray = function (it) {
 if (!isObject(it))
  return false;
 var klass = classof(it);
 return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
};
var aTypedArray = function (it) {
 if (isTypedArray(it))
  return it;
 throw TypeError('Target is not a typed array');
};
var aTypedArrayConstructor = function (C) {
 if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))
  return C;
 throw TypeError(tryToString(C) + ' is not a typed array constructor');
};
var exportTypedArrayMethod = function (KEY, property, forced, options) {
 if (!DESCRIPTORS)
  return;
 if (forced)
  for (var ARRAY in TypedArrayConstructorsList) {
   var TypedArrayConstructor = global[ARRAY];
   if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
    try {
     delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
     try {
      TypedArrayConstructor.prototype[KEY] = property;
     } catch (error2) {
     }
    }
  }
 if (!TypedArrayPrototype[KEY] || forced) {
  defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
 }
};
var exportTypedArrayStaticMethod = function (KEY, property, forced) {
 var ARRAY, TypedArrayConstructor;
 if (!DESCRIPTORS)
  return;
 if (setPrototypeOf) {
  if (forced)
   for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
     try {
      delete TypedArrayConstructor[KEY];
     } catch (error) {
     }
   }
  if (!TypedArray[KEY] || forced) {
   try {
    return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
   } catch (error) {
   }
  } else
   return;
 }
 for (ARRAY in TypedArrayConstructorsList) {
  TypedArrayConstructor = global[ARRAY];
  if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
   defineBuiltIn(TypedArrayConstructor, KEY, property);
  }
 }
};
for (NAME in TypedArrayConstructorsList) {
 Constructor = global[NAME];
 Prototype = Constructor && Constructor.prototype;
 if (Prototype)
  enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
 else
  NATIVE_ARRAY_BUFFER_VIEWS = false;
}
for (NAME in BigIntArrayConstructorsList) {
 Constructor = global[NAME];
 Prototype = Constructor && Constructor.prototype;
 if (Prototype)
  enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
 TypedArray = function TypedArray() {
  throw TypeError('Incorrect invocation');
 };
 if (NATIVE_ARRAY_BUFFER_VIEWS)
  for (NAME in TypedArrayConstructorsList) {
   if (global[NAME])
    setPrototypeOf(global[NAME], TypedArray);
  }
}
if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
 TypedArrayPrototype = TypedArray.prototype;
 if (NATIVE_ARRAY_BUFFER_VIEWS)
  for (NAME in TypedArrayConstructorsList) {
   if (global[NAME])
    setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
 setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}
if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
 TYPED_ARRAY_TAG_REQUIRED = true;
 defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
  get: function () {
   return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  }
 });
 for (NAME in TypedArrayConstructorsList)
  if (global[NAME]) {
   createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}
module.exports = {
 NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
 TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
 aTypedArray: aTypedArray,
 aTypedArrayConstructor: aTypedArrayConstructor,
 exportTypedArrayMethod: exportTypedArrayMethod,
 exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
 getTypedArrayConstructor: getTypedArrayConstructor,
 isView: isView,
 isTypedArray: isTypedArray,
 TypedArray: TypedArray,
 TypedArrayPrototype: TypedArrayPrototype
};

/***/ }),
/* 79 */
/***/ ((module) => {

module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

/***/ }),
/* 80 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(81);
var isCallable = __w_pdfjs_require__(23);
var classofRaw = __w_pdfjs_require__(18);
var wellKnownSymbol = __w_pdfjs_require__(35);
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;
var CORRECT_ARGUMENTS = classofRaw((function () {
 return arguments;
}())) == 'Arguments';
var tryGet = function (it, key) {
 try {
  return it[key];
 } catch (error) {
 }
};
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
 var O, tag, result;
 return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};

/***/ }),
/* 81 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var wellKnownSymbol = __w_pdfjs_require__(35);
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';

/***/ }),
/* 82 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var hasOwn = __w_pdfjs_require__(40);
var isCallable = __w_pdfjs_require__(23);
var toObject = __w_pdfjs_require__(41);
var sharedKey = __w_pdfjs_require__(55);
var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__(83);
var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
 var object = toObject(O);
 if (hasOwn(object, IE_PROTO))
  return object[IE_PROTO];
 var constructor = object.constructor;
 if (isCallable(constructor) && object instanceof constructor) {
  return constructor.prototype;
 }
 return object instanceof $Object ? ObjectPrototype : null;
};

/***/ }),
/* 83 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
module.exports = !fails(function () {
 function F() {
 }
 F.prototype.constructor = null;
 return Object.getPrototypeOf(new F()) !== F.prototype;
});

/***/ }),
/* 84 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var anObject = __w_pdfjs_require__(48);
var aPossiblePrototype = __w_pdfjs_require__(85);
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? (function () {
 var CORRECT_SETTER = false;
 var test = {};
 var setter;
 try {
  setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
  setter(test, []);
  CORRECT_SETTER = test instanceof Array;
 } catch (error) {
 }
 return function setPrototypeOf(O, proto) {
  anObject(O);
  aPossiblePrototype(proto);
  if (CORRECT_SETTER)
   setter(O, proto);
  else
   O.__proto__ = proto;
  return O;
 };
}()) : undefined);

/***/ }),
/* 85 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isCallable = __w_pdfjs_require__(23);
var $String = String;
var $TypeError = TypeError;
module.exports = function (argument) {
 if (typeof argument == 'object' || isCallable(argument))
  return argument;
 throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};

/***/ }),
/* 86 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(87);
__w_pdfjs_require__(93);
__w_pdfjs_require__(95);
__w_pdfjs_require__(117);
__w_pdfjs_require__(119);
var path = __w_pdfjs_require__(128);
module.exports = path.structuredClone;

/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toIndexedObject = __w_pdfjs_require__(15);
var addToUnscopables = __w_pdfjs_require__(70);
var Iterators = __w_pdfjs_require__(88);
var InternalStateModule = __w_pdfjs_require__(53);
var defineProperty = (__w_pdfjs_require__(46).f);
var defineIterator = __w_pdfjs_require__(89);
var IS_PURE = __w_pdfjs_require__(37);
var DESCRIPTORS = __w_pdfjs_require__(9);
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
 setInternalState(this, {
  type: ARRAY_ITERATOR,
  target: toIndexedObject(iterated),
  index: 0,
  kind: kind
 });
}, function () {
 var state = getInternalState(this);
 var target = state.target;
 var kind = state.kind;
 var index = state.index++;
 if (!target || index >= target.length) {
  state.target = undefined;
  return {
   value: undefined,
   done: true
  };
 }
 if (kind == 'keys')
  return {
   value: index,
   done: false
  };
 if (kind == 'values')
  return {
   value: target[index],
   done: false
  };
 return {
  value: [
   index,
   target[index]
  ],
  done: false
 };
}, 'values');
var values = Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
if (!IS_PURE && DESCRIPTORS && values.name !== 'values')
 try {
  defineProperty(values, 'name', { value: 'values' });
 } catch (error) {
 }

/***/ }),
/* 88 */
/***/ ((module) => {

module.exports = {};

/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var $ = __w_pdfjs_require__(6);
var call = __w_pdfjs_require__(11);
var IS_PURE = __w_pdfjs_require__(37);
var FunctionName = __w_pdfjs_require__(51);
var isCallable = __w_pdfjs_require__(23);
var createIteratorConstructor = __w_pdfjs_require__(90);
var getPrototypeOf = __w_pdfjs_require__(82);
var setPrototypeOf = __w_pdfjs_require__(84);
var setToStringTag = __w_pdfjs_require__(92);
var createNonEnumerableProperty = __w_pdfjs_require__(45);
var defineBuiltIn = __w_pdfjs_require__(49);
var wellKnownSymbol = __w_pdfjs_require__(35);
var Iterators = __w_pdfjs_require__(88);
var IteratorsCore = __w_pdfjs_require__(91);
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';
var returnThis = function () {
 return this;
};
module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
 createIteratorConstructor(IteratorConstructor, NAME, next);
 var getIterationMethod = function (KIND) {
  if (KIND === DEFAULT && defaultIterator)
   return defaultIterator;
  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
   return IterablePrototype[KIND];
  switch (KIND) {
  case KEYS:
   return function keys() {
    return new IteratorConstructor(this, KIND);
   };
  case VALUES:
   return function values() {
    return new IteratorConstructor(this, KIND);
   };
  case ENTRIES:
   return function entries() {
    return new IteratorConstructor(this, KIND);
   };
  }
  return function () {
   return new IteratorConstructor(this);
  };
 };
 var TO_STRING_TAG = NAME + ' Iterator';
 var INCORRECT_VALUES_NAME = false;
 var IterablePrototype = Iterable.prototype;
 var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
 var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
 var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
 var CurrentIteratorPrototype, methods, KEY;
 if (anyNativeIterator) {
  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
  if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
   if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
    if (setPrototypeOf) {
     setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
    } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
     defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
    }
   }
   setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
   if (IS_PURE)
    Iterators[TO_STRING_TAG] = returnThis;
  }
 }
 if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
  if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
   createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
  } else {
   INCORRECT_VALUES_NAME = true;
   defaultIterator = function values() {
    return call(nativeIterator, this);
   };
  }
 }
 if (DEFAULT) {
  methods = {
   values: getIterationMethod(VALUES),
   keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
   entries: getIterationMethod(ENTRIES)
  };
  if (FORCED)
   for (KEY in methods) {
    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
     defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
    }
   }
  else
   $({
    target: NAME,
    proto: true,
    forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
   }, methods);
 }
 if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
  defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
 }
 Iterators[NAME] = defaultIterator;
 return methods;
};

/***/ }),
/* 90 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var IteratorPrototype = (__w_pdfjs_require__(91).IteratorPrototype);
var create = __w_pdfjs_require__(71);
var createPropertyDescriptor = __w_pdfjs_require__(14);
var setToStringTag = __w_pdfjs_require__(92);
var Iterators = __w_pdfjs_require__(88);
var returnThis = function () {
 return this;
};
module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
 var TO_STRING_TAG = NAME + ' Iterator';
 IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
 setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
 Iterators[TO_STRING_TAG] = returnThis;
 return IteratorConstructor;
};

/***/ }),
/* 91 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
var isCallable = __w_pdfjs_require__(23);
var create = __w_pdfjs_require__(71);
var getPrototypeOf = __w_pdfjs_require__(82);
var defineBuiltIn = __w_pdfjs_require__(49);
var wellKnownSymbol = __w_pdfjs_require__(35);
var IS_PURE = __w_pdfjs_require__(37);
var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
if ([].keys) {
 arrayIterator = [].keys();
 if (!('next' in arrayIterator))
  BUGGY_SAFARI_ITERATORS = true;
 else {
  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
   IteratorPrototype = PrototypeOfArrayIteratorPrototype;
 }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
 var test = {};
 return IteratorPrototype[ITERATOR].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE)
 IteratorPrototype = {};
else if (IS_PURE)
 IteratorPrototype = create(IteratorPrototype);
if (!isCallable(IteratorPrototype[ITERATOR])) {
 defineBuiltIn(IteratorPrototype, ITERATOR, function () {
  return this;
 });
}
module.exports = {
 IteratorPrototype: IteratorPrototype,
 BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

/***/ }),
/* 92 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var defineProperty = (__w_pdfjs_require__(46).f);
var hasOwn = __w_pdfjs_require__(40);
var wellKnownSymbol = __w_pdfjs_require__(35);
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
module.exports = function (target, TAG, STATIC) {
 if (target && !STATIC)
  target = target.prototype;
 if (target && !hasOwn(target, TO_STRING_TAG)) {
  defineProperty(target, TO_STRING_TAG, {
   configurable: true,
   value: TAG
  });
 }
};

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(81);
var defineBuiltIn = __w_pdfjs_require__(49);
var toString = __w_pdfjs_require__(94);
if (!TO_STRING_TAG_SUPPORT) {
 defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
}

/***/ }),
/* 94 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(81);
var classof = __w_pdfjs_require__(80);
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
 return '[object ' + classof(this) + ']';
};

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(96);

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var collection = __w_pdfjs_require__(97);
var collectionStrong = __w_pdfjs_require__(114);
collection('Map', function (init) {
 return function Map() {
  return init(this, arguments.length ? arguments[0] : undefined);
 };
}, collectionStrong);

/***/ }),
/* 97 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var $ = __w_pdfjs_require__(6);
var global = __w_pdfjs_require__(7);
var uncurryThis = __w_pdfjs_require__(17);
var isForced = __w_pdfjs_require__(69);
var defineBuiltIn = __w_pdfjs_require__(49);
var InternalMetadataModule = __w_pdfjs_require__(98);
var iterate = __w_pdfjs_require__(105);
var anInstance = __w_pdfjs_require__(111);
var isCallable = __w_pdfjs_require__(23);
var isObject = __w_pdfjs_require__(22);
var fails = __w_pdfjs_require__(10);
var checkCorrectnessOfIteration = __w_pdfjs_require__(112);
var setToStringTag = __w_pdfjs_require__(92);
var inheritIfRequired = __w_pdfjs_require__(113);
module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
 var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
 var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
 var ADDER = IS_MAP ? 'set' : 'add';
 var NativeConstructor = global[CONSTRUCTOR_NAME];
 var NativePrototype = NativeConstructor && NativeConstructor.prototype;
 var Constructor = NativeConstructor;
 var exported = {};
 var fixMethod = function (KEY) {
  var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
  defineBuiltIn(NativePrototype, KEY, KEY == 'add' ? function add(value) {
   uncurriedNativeMethod(this, value === 0 ? 0 : value);
   return this;
  } : KEY == 'delete' ? function (key) {
   return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
  } : KEY == 'get' ? function get(key) {
   return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
  } : KEY == 'has' ? function has(key) {
   return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
  } : function set(key, value) {
   uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
   return this;
  });
 };
 var REPLACE = isForced(CONSTRUCTOR_NAME, !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
  new NativeConstructor().entries().next();
 })));
 if (REPLACE) {
  Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
  InternalMetadataModule.enable();
 } else if (isForced(CONSTRUCTOR_NAME, true)) {
  var instance = new Constructor();
  var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
  var THROWS_ON_PRIMITIVES = fails(function () {
   instance.has(1);
  });
  var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
   new NativeConstructor(iterable);
  });
  var BUGGY_ZERO = !IS_WEAK && fails(function () {
   var $instance = new NativeConstructor();
   var index = 5;
   while (index--)
    $instance[ADDER](index, index);
   return !$instance.has(-0);
  });
  if (!ACCEPT_ITERABLES) {
   Constructor = wrapper(function (dummy, iterable) {
    anInstance(dummy, NativePrototype);
    var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
    if (iterable != undefined)
     iterate(iterable, that[ADDER], {
      that: that,
      AS_ENTRIES: IS_MAP
     });
    return that;
   });
   Constructor.prototype = NativePrototype;
   NativePrototype.constructor = Constructor;
  }
  if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
   fixMethod('delete');
   fixMethod('has');
   IS_MAP && fixMethod('get');
  }
  if (BUGGY_ZERO || HASNT_CHAINING)
   fixMethod(ADDER);
  if (IS_WEAK && NativePrototype.clear)
   delete NativePrototype.clear;
 }
 exported[CONSTRUCTOR_NAME] = Constructor;
 $({
  global: true,
  constructor: true,
  forced: Constructor != NativeConstructor
 }, exported);
 setToStringTag(Constructor, CONSTRUCTOR_NAME);
 if (!IS_WEAK)
  common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
 return Constructor;
};

/***/ }),
/* 98 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var $ = __w_pdfjs_require__(6);
var uncurryThis = __w_pdfjs_require__(17);
var hiddenKeys = __w_pdfjs_require__(56);
var isObject = __w_pdfjs_require__(22);
var hasOwn = __w_pdfjs_require__(40);
var defineProperty = (__w_pdfjs_require__(46).f);
var getOwnPropertyNamesModule = __w_pdfjs_require__(59);
var getOwnPropertyNamesExternalModule = __w_pdfjs_require__(99);
var isExtensible = __w_pdfjs_require__(102);
var uid = __w_pdfjs_require__(42);
var FREEZING = __w_pdfjs_require__(104);
var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;
var setMetadata = function (it) {
 defineProperty(it, METADATA, {
  value: {
   objectID: 'O' + id++,
   weakData: {}
  }
 });
};
var fastKey = function (it, create) {
 if (!isObject(it))
  return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
 if (!hasOwn(it, METADATA)) {
  if (!isExtensible(it))
   return 'F';
  if (!create)
   return 'E';
  setMetadata(it);
 }
 return it[METADATA].objectID;
};
var getWeakData = function (it, create) {
 if (!hasOwn(it, METADATA)) {
  if (!isExtensible(it))
   return true;
  if (!create)
   return false;
  setMetadata(it);
 }
 return it[METADATA].weakData;
};
var onFreeze = function (it) {
 if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA))
  setMetadata(it);
 return it;
};
var enable = function () {
 meta.enable = function () {
 };
 REQUIRED = true;
 var getOwnPropertyNames = getOwnPropertyNamesModule.f;
 var splice = uncurryThis([].splice);
 var test = {};
 test[METADATA] = 1;
 if (getOwnPropertyNames(test).length) {
  getOwnPropertyNamesModule.f = function (it) {
   var result = getOwnPropertyNames(it);
   for (var i = 0, length = result.length; i < length; i++) {
    if (result[i] === METADATA) {
     splice(result, i, 1);
     break;
    }
   }
   return result;
  };
  $({
   target: 'Object',
   stat: true,
   forced: true
  }, { getOwnPropertyNames: getOwnPropertyNamesExternalModule.f });
 }
};
var meta = module.exports = {
 enable: enable,
 fastKey: fastKey,
 getWeakData: getWeakData,
 onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

/***/ }),
/* 99 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var classof = __w_pdfjs_require__(18);
var toIndexedObject = __w_pdfjs_require__(15);
var $getOwnPropertyNames = (__w_pdfjs_require__(59).f);
var arraySlice = __w_pdfjs_require__(100);
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function (it) {
 try {
  return $getOwnPropertyNames(it);
 } catch (error) {
  return arraySlice(windowNames);
 }
};
module.exports.f = function getOwnPropertyNames(it) {
 return windowNames && classof(it) == 'Window' ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
};

/***/ }),
/* 100 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toAbsoluteIndex = __w_pdfjs_require__(62);
var lengthOfArrayLike = __w_pdfjs_require__(65);
var createProperty = __w_pdfjs_require__(101);
var $Array = Array;
var max = Math.max;
module.exports = function (O, start, end) {
 var length = lengthOfArrayLike(O);
 var k = toAbsoluteIndex(start, length);
 var fin = toAbsoluteIndex(end === undefined ? length : end, length);
 var result = $Array(max(fin - k, 0));
 for (var n = 0; k < fin; k++, n++)
  createProperty(result, n, O[k]);
 result.length = n;
 return result;
};

/***/ }),
/* 101 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var toPropertyKey = __w_pdfjs_require__(20);
var definePropertyModule = __w_pdfjs_require__(46);
var createPropertyDescriptor = __w_pdfjs_require__(14);
module.exports = function (object, key, value) {
 var propertyKey = toPropertyKey(key);
 if (propertyKey in object)
  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
 else
  object[propertyKey] = value;
};

/***/ }),
/* 102 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
var isObject = __w_pdfjs_require__(22);
var classof = __w_pdfjs_require__(18);
var ARRAY_BUFFER_NON_EXTENSIBLE = __w_pdfjs_require__(103);
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () {
});
module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
 if (!isObject(it))
  return false;
 if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer')
  return false;
 return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;

/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
module.exports = fails(function () {
 if (typeof ArrayBuffer == 'function') {
  var buffer = new ArrayBuffer(8);
  if (Object.isExtensible(buffer))
   Object.defineProperty(buffer, 'a', { value: 8 });
 }
});

/***/ }),
/* 104 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
module.exports = !fails(function () {
 return Object.isExtensible(Object.preventExtensions({}));
});

/***/ }),
/* 105 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var bind = __w_pdfjs_require__(106);
var call = __w_pdfjs_require__(11);
var anObject = __w_pdfjs_require__(48);
var tryToString = __w_pdfjs_require__(33);
var isArrayIteratorMethod = __w_pdfjs_require__(107);
var lengthOfArrayLike = __w_pdfjs_require__(65);
var isPrototypeOf = __w_pdfjs_require__(26);
var getIterator = __w_pdfjs_require__(108);
var getIteratorMethod = __w_pdfjs_require__(109);
var iteratorClose = __w_pdfjs_require__(110);
var $TypeError = TypeError;
var Result = function (stopped, result) {
 this.stopped = stopped;
 this.result = result;
};
var ResultPrototype = Result.prototype;
module.exports = function (iterable, unboundFunction, options) {
 var that = options && options.that;
 var AS_ENTRIES = !!(options && options.AS_ENTRIES);
 var IS_RECORD = !!(options && options.IS_RECORD);
 var IS_ITERATOR = !!(options && options.IS_ITERATOR);
 var INTERRUPTED = !!(options && options.INTERRUPTED);
 var fn = bind(unboundFunction, that);
 var iterator, iterFn, index, length, result, next, step;
 var stop = function (condition) {
  if (iterator)
   iteratorClose(iterator, 'normal', condition);
  return new Result(true, condition);
 };
 var callFn = function (value) {
  if (AS_ENTRIES) {
   anObject(value);
   return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
  }
  return INTERRUPTED ? fn(value, stop) : fn(value);
 };
 if (IS_RECORD) {
  iterator = iterable.iterator;
 } else if (IS_ITERATOR) {
  iterator = iterable;
 } else {
  iterFn = getIteratorMethod(iterable);
  if (!iterFn)
   throw $TypeError(tryToString(iterable) + ' is not iterable');
  if (isArrayIteratorMethod(iterFn)) {
   for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
    result = callFn(iterable[index]);
    if (result && isPrototypeOf(ResultPrototype, result))
     return result;
   }
   return new Result(false);
  }
  iterator = getIterator(iterable, iterFn);
 }
 next = IS_RECORD ? iterable.next : iterator.next;
 while (!(step = call(next, iterator)).done) {
  try {
   result = callFn(step.value);
  } catch (error) {
   iteratorClose(iterator, 'throw', error);
  }
  if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result))
   return result;
 }
 return new Result(false);
};

/***/ }),
/* 106 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var aCallable = __w_pdfjs_require__(32);
var NATIVE_BIND = __w_pdfjs_require__(12);
var bind = uncurryThis(uncurryThis.bind);
module.exports = function (fn, that) {
 aCallable(fn);
 return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function () {
  return fn.apply(that, arguments);
 };
};

/***/ }),
/* 107 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var wellKnownSymbol = __w_pdfjs_require__(35);
var Iterators = __w_pdfjs_require__(88);
var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;
module.exports = function (it) {
 return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var call = __w_pdfjs_require__(11);
var aCallable = __w_pdfjs_require__(32);
var anObject = __w_pdfjs_require__(48);
var tryToString = __w_pdfjs_require__(33);
var getIteratorMethod = __w_pdfjs_require__(109);
var $TypeError = TypeError;
module.exports = function (argument, usingIterator) {
 var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
 if (aCallable(iteratorMethod))
  return anObject(call(iteratorMethod, argument));
 throw $TypeError(tryToString(argument) + ' is not iterable');
};

/***/ }),
/* 109 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var classof = __w_pdfjs_require__(80);
var getMethod = __w_pdfjs_require__(31);
var Iterators = __w_pdfjs_require__(88);
var wellKnownSymbol = __w_pdfjs_require__(35);
var ITERATOR = wellKnownSymbol('iterator');
module.exports = function (it) {
 if (it != undefined)
  return getMethod(it, ITERATOR) || getMethod(it, '@@iterator') || Iterators[classof(it)];
};

/***/ }),
/* 110 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var call = __w_pdfjs_require__(11);
var anObject = __w_pdfjs_require__(48);
var getMethod = __w_pdfjs_require__(31);
module.exports = function (iterator, kind, value) {
 var innerResult, innerError;
 anObject(iterator);
 try {
  innerResult = getMethod(iterator, 'return');
  if (!innerResult) {
   if (kind === 'throw')
    throw value;
   return value;
  }
  innerResult = call(innerResult, iterator);
 } catch (error) {
  innerError = true;
  innerResult = error;
 }
 if (kind === 'throw')
  throw value;
 if (innerError)
  throw innerResult;
 anObject(innerResult);
 return value;
};

/***/ }),
/* 111 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isPrototypeOf = __w_pdfjs_require__(26);
var $TypeError = TypeError;
module.exports = function (it, Prototype) {
 if (isPrototypeOf(Prototype, it))
  return it;
 throw $TypeError('Incorrect invocation');
};

/***/ }),
/* 112 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var wellKnownSymbol = __w_pdfjs_require__(35);
var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;
try {
 var called = 0;
 var iteratorWithReturn = {
  next: function () {
   return { done: !!called++ };
  },
  'return': function () {
   SAFE_CLOSING = true;
  }
 };
 iteratorWithReturn[ITERATOR] = function () {
  return this;
 };
 Array.from(iteratorWithReturn, function () {
  throw 2;
 });
} catch (error) {
}
module.exports = function (exec, SKIP_CLOSING) {
 if (!SKIP_CLOSING && !SAFE_CLOSING)
  return false;
 var ITERATION_SUPPORT = false;
 try {
  var object = {};
  object[ITERATOR] = function () {
   return {
    next: function () {
     return { done: ITERATION_SUPPORT = true };
    }
   };
  };
  exec(object);
 } catch (error) {
 }
 return ITERATION_SUPPORT;
};

/***/ }),
/* 113 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var isCallable = __w_pdfjs_require__(23);
var isObject = __w_pdfjs_require__(22);
var setPrototypeOf = __w_pdfjs_require__(84);
module.exports = function ($this, dummy, Wrapper) {
 var NewTarget, NewTargetPrototype;
 if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
  setPrototypeOf($this, NewTargetPrototype);
 return $this;
};

/***/ }),
/* 114 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var defineProperty = (__w_pdfjs_require__(46).f);
var create = __w_pdfjs_require__(71);
var defineBuiltIns = __w_pdfjs_require__(115);
var bind = __w_pdfjs_require__(106);
var anInstance = __w_pdfjs_require__(111);
var iterate = __w_pdfjs_require__(105);
var defineIterator = __w_pdfjs_require__(89);
var setSpecies = __w_pdfjs_require__(116);
var DESCRIPTORS = __w_pdfjs_require__(9);
var fastKey = (__w_pdfjs_require__(98).fastKey);
var InternalStateModule = __w_pdfjs_require__(53);
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
module.exports = {
 getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
  var Constructor = wrapper(function (that, iterable) {
   anInstance(that, Prototype);
   setInternalState(that, {
    type: CONSTRUCTOR_NAME,
    index: create(null),
    first: undefined,
    last: undefined,
    size: 0
   });
   if (!DESCRIPTORS)
    that.size = 0;
   if (iterable != undefined)
    iterate(iterable, that[ADDER], {
     that: that,
     AS_ENTRIES: IS_MAP
    });
  });
  var Prototype = Constructor.prototype;
  var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
  var define = function (that, key, value) {
   var state = getInternalState(that);
   var entry = getEntry(that, key);
   var previous, index;
   if (entry) {
    entry.value = value;
   } else {
    state.last = entry = {
     index: index = fastKey(key, true),
     key: key,
     value: value,
     previous: previous = state.last,
     next: undefined,
     removed: false
    };
    if (!state.first)
     state.first = entry;
    if (previous)
     previous.next = entry;
    if (DESCRIPTORS)
     state.size++;
    else
     that.size++;
    if (index !== 'F')
     state.index[index] = entry;
   }
   return that;
  };
  var getEntry = function (that, key) {
   var state = getInternalState(that);
   var index = fastKey(key);
   var entry;
   if (index !== 'F')
    return state.index[index];
   for (entry = state.first; entry; entry = entry.next) {
    if (entry.key == key)
     return entry;
   }
  };
  defineBuiltIns(Prototype, {
   clear: function clear() {
    var that = this;
    var state = getInternalState(that);
    var data = state.index;
    var entry = state.first;
    while (entry) {
     entry.removed = true;
     if (entry.previous)
      entry.previous = entry.previous.next = undefined;
     delete data[entry.index];
     entry = entry.next;
    }
    state.first = state.last = undefined;
    if (DESCRIPTORS)
     state.size = 0;
    else
     that.size = 0;
   },
   'delete': function (key) {
    var that = this;
    var state = getInternalState(that);
    var entry = getEntry(that, key);
    if (entry) {
     var next = entry.next;
     var prev = entry.previous;
     delete state.index[entry.index];
     entry.removed = true;
     if (prev)
      prev.next = next;
     if (next)
      next.previous = prev;
     if (state.first == entry)
      state.first = next;
     if (state.last == entry)
      state.last = prev;
     if (DESCRIPTORS)
      state.size--;
     else
      that.size--;
    }
    return !!entry;
   },
   forEach: function forEach(callbackfn) {
    var state = getInternalState(this);
    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var entry;
    while (entry = entry ? entry.next : state.first) {
     boundFunction(entry.value, entry.key, this);
     while (entry && entry.removed)
      entry = entry.previous;
    }
   },
   has: function has(key) {
    return !!getEntry(this, key);
   }
  });
  defineBuiltIns(Prototype, IS_MAP ? {
   get: function get(key) {
    var entry = getEntry(this, key);
    return entry && entry.value;
   },
   set: function set(key, value) {
    return define(this, key === 0 ? 0 : key, value);
   }
  } : {
   add: function add(value) {
    return define(this, value = value === 0 ? 0 : value, value);
   }
  });
  if (DESCRIPTORS)
   defineProperty(Prototype, 'size', {
    get: function () {
     return getInternalState(this).size;
    }
   });
  return Constructor;
 },
 setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
  var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
  var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
  var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
  defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
   setInternalState(this, {
    type: ITERATOR_NAME,
    target: iterated,
    state: getInternalCollectionState(iterated),
    kind: kind,
    last: undefined
   });
  }, function () {
   var state = getInternalIteratorState(this);
   var kind = state.kind;
   var entry = state.last;
   while (entry && entry.removed)
    entry = entry.previous;
   if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
    state.target = undefined;
    return {
     value: undefined,
     done: true
    };
   }
   if (kind == 'keys')
    return {
     value: entry.key,
     done: false
    };
   if (kind == 'values')
    return {
     value: entry.value,
     done: false
    };
   return {
    value: [
     entry.key,
     entry.value
    ],
    done: false
   };
  }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
  setSpecies(CONSTRUCTOR_NAME);
 }
};

/***/ }),
/* 115 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var defineBuiltIn = __w_pdfjs_require__(49);
module.exports = function (target, src, options) {
 for (var key in src)
  defineBuiltIn(target, key, src[key], options);
 return target;
};

/***/ }),
/* 116 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var getBuiltIn = __w_pdfjs_require__(25);
var definePropertyModule = __w_pdfjs_require__(46);
var wellKnownSymbol = __w_pdfjs_require__(35);
var DESCRIPTORS = __w_pdfjs_require__(9);
var SPECIES = wellKnownSymbol('species');
module.exports = function (CONSTRUCTOR_NAME) {
 var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
 var defineProperty = definePropertyModule.f;
 if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
  defineProperty(Constructor, SPECIES, {
   configurable: true,
   get: function () {
    return this;
   }
  });
 }
};

/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

__w_pdfjs_require__(118);

/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var collection = __w_pdfjs_require__(97);
var collectionStrong = __w_pdfjs_require__(114);
collection('Set', function (init) {
 return function Set() {
  return init(this, arguments.length ? arguments[0] : undefined);
 };
}, collectionStrong);

/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {

var IS_PURE = __w_pdfjs_require__(37);
var $ = __w_pdfjs_require__(6);
var global = __w_pdfjs_require__(7);
var getBuiltin = __w_pdfjs_require__(25);
var uncurryThis = __w_pdfjs_require__(17);
var fails = __w_pdfjs_require__(10);
var uid = __w_pdfjs_require__(42);
var isCallable = __w_pdfjs_require__(23);
var isConstructor = __w_pdfjs_require__(120);
var isObject = __w_pdfjs_require__(22);
var isSymbol = __w_pdfjs_require__(24);
var iterate = __w_pdfjs_require__(105);
var anObject = __w_pdfjs_require__(48);
var classof = __w_pdfjs_require__(80);
var hasOwn = __w_pdfjs_require__(40);
var createProperty = __w_pdfjs_require__(101);
var createNonEnumerableProperty = __w_pdfjs_require__(45);
var lengthOfArrayLike = __w_pdfjs_require__(65);
var validateArgumentsLength = __w_pdfjs_require__(121);
var getRegExpFlags = __w_pdfjs_require__(122);
var ERROR_STACK_INSTALLABLE = __w_pdfjs_require__(124);
var V8 = __w_pdfjs_require__(29);
var IS_BROWSER = __w_pdfjs_require__(125);
var IS_DENO = __w_pdfjs_require__(126);
var IS_NODE = __w_pdfjs_require__(127);
var Object = global.Object;
var Date = global.Date;
var Error = global.Error;
var EvalError = global.EvalError;
var RangeError = global.RangeError;
var ReferenceError = global.ReferenceError;
var SyntaxError = global.SyntaxError;
var TypeError = global.TypeError;
var URIError = global.URIError;
var PerformanceMark = global.PerformanceMark;
var WebAssembly = global.WebAssembly;
var CompileError = WebAssembly && WebAssembly.CompileError || Error;
var LinkError = WebAssembly && WebAssembly.LinkError || Error;
var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error;
var DOMException = getBuiltin('DOMException');
var Set = getBuiltin('Set');
var Map = getBuiltin('Map');
var MapPrototype = Map.prototype;
var mapHas = uncurryThis(MapPrototype.has);
var mapGet = uncurryThis(MapPrototype.get);
var mapSet = uncurryThis(MapPrototype.set);
var setAdd = uncurryThis(Set.prototype.add);
var objectKeys = getBuiltin('Object', 'keys');
var push = uncurryThis([].push);
var booleanValueOf = uncurryThis(true.valueOf);
var numberValueOf = uncurryThis(1.0.valueOf);
var stringValueOf = uncurryThis(''.valueOf);
var getTime = uncurryThis(Date.prototype.getTime);
var PERFORMANCE_MARK = uid('structuredClone');
var DATA_CLONE_ERROR = 'DataCloneError';
var TRANSFERRING = 'Transferring';
var checkBasicSemantic = function (structuredCloneImplementation) {
 return !fails(function () {
  var set1 = new global.Set([7]);
  var set2 = structuredCloneImplementation(set1);
  var number = structuredCloneImplementation(Object(7));
  return set2 == set1 || !set2.has(7) || typeof number != 'object' || number != 7;
 }) && structuredCloneImplementation;
};
var checkErrorsCloning = function (structuredCloneImplementation, $Error) {
 return !fails(function () {
  var error = new $Error();
  var test = structuredCloneImplementation({
   a: error,
   b: error
  });
  return !(test && test.a === test.b && test.a instanceof $Error && test.a.stack === error.stack);
 });
};
var checkNewErrorsCloningSemantic = function (structuredCloneImplementation) {
 return !fails(function () {
  var test = structuredCloneImplementation(new global.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
  return test.name != 'AggregateError' || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
 });
};
var nativeStructuredClone = global.structuredClone;
var FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error) || !checkErrorsCloning(nativeStructuredClone, DOMException) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function (value) {
 return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
});
var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
var throwUncloneable = function (type) {
 throw new DOMException('Uncloneable type: ' + type, DATA_CLONE_ERROR);
};
var throwUnpolyfillable = function (type, kind) {
 throw new DOMException((kind || 'Cloning') + ' of ' + type + ' cannot be properly polyfilled in this engine', DATA_CLONE_ERROR);
};
var structuredCloneInternal = function (value, map) {
 if (isSymbol(value))
  throwUncloneable('Symbol');
 if (!isObject(value))
  return value;
 if (map) {
  if (mapHas(map, value))
   return mapGet(map, value);
 } else
  map = new Map();
 var type = classof(value);
 var deep = false;
 var C, name, cloned, dataTransfer, i, length, keys, key, source, target;
 switch (type) {
 case 'Array':
  cloned = [];
  deep = true;
  break;
 case 'Object':
  cloned = {};
  deep = true;
  break;
 case 'Map':
  cloned = new Map();
  deep = true;
  break;
 case 'Set':
  cloned = new Set();
  deep = true;
  break;
 case 'RegExp':
  cloned = new RegExp(value.source, getRegExpFlags(value));
  break;
 case 'Error':
  name = value.name;
  switch (name) {
  case 'AggregateError':
   cloned = getBuiltin('AggregateError')([]);
   break;
  case 'EvalError':
   cloned = EvalError();
   break;
  case 'RangeError':
   cloned = RangeError();
   break;
  case 'ReferenceError':
   cloned = ReferenceError();
   break;
  case 'SyntaxError':
   cloned = SyntaxError();
   break;
  case 'TypeError':
   cloned = TypeError();
   break;
  case 'URIError':
   cloned = URIError();
   break;
  case 'CompileError':
   cloned = CompileError();
   break;
  case 'LinkError':
   cloned = LinkError();
   break;
  case 'RuntimeError':
   cloned = RuntimeError();
   break;
  default:
   cloned = Error();
  }
  deep = true;
  break;
 case 'DOMException':
  cloned = new DOMException(value.message, value.name);
  deep = true;
  break;
 case 'DataView':
 case 'Int8Array':
 case 'Uint8Array':
 case 'Uint8ClampedArray':
 case 'Int16Array':
 case 'Uint16Array':
 case 'Int32Array':
 case 'Uint32Array':
 case 'Float32Array':
 case 'Float64Array':
 case 'BigInt64Array':
 case 'BigUint64Array':
  C = global[type];
  if (!isObject(C))
   throwUnpolyfillable(type);
  cloned = new C(structuredCloneInternal(value.buffer, map), value.byteOffset, type === 'DataView' ? value.byteLength : value.length);
  break;
 case 'DOMQuad':
  try {
   cloned = new DOMQuad(structuredCloneInternal(value.p1, map), structuredCloneInternal(value.p2, map), structuredCloneInternal(value.p3, map), structuredCloneInternal(value.p4, map));
  } catch (error) {
   if (nativeRestrictedStructuredClone) {
    cloned = nativeRestrictedStructuredClone(value);
   } else
    throwUnpolyfillable(type);
  }
  break;
 case 'FileList':
  C = global.DataTransfer;
  if (isConstructor(C)) {
   dataTransfer = new C();
   for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
    dataTransfer.items.add(structuredCloneInternal(value[i], map));
   }
   cloned = dataTransfer.files;
  } else if (nativeRestrictedStructuredClone) {
   cloned = nativeRestrictedStructuredClone(value);
  } else
   throwUnpolyfillable(type);
  break;
 case 'ImageData':
  try {
   cloned = new ImageData(structuredCloneInternal(value.data, map), value.width, value.height, { colorSpace: value.colorSpace });
  } catch (error) {
   if (nativeRestrictedStructuredClone) {
    cloned = nativeRestrictedStructuredClone(value);
   } else
    throwUnpolyfillable(type);
  }
  break;
 default:
  if (nativeRestrictedStructuredClone) {
   cloned = nativeRestrictedStructuredClone(value);
  } else
   switch (type) {
   case 'BigInt':
    cloned = Object(value.valueOf());
    break;
   case 'Boolean':
    cloned = Object(booleanValueOf(value));
    break;
   case 'Number':
    cloned = Object(numberValueOf(value));
    break;
   case 'String':
    cloned = Object(stringValueOf(value));
    break;
   case 'Date':
    cloned = new Date(getTime(value));
    break;
   case 'ArrayBuffer':
    C = global.DataView;
    if (!C && typeof value.slice != 'function')
     throwUnpolyfillable(type);
    try {
     if (typeof value.slice == 'function') {
      cloned = value.slice(0);
     } else {
      length = value.byteLength;
      cloned = new ArrayBuffer(length);
      source = new C(value);
      target = new C(cloned);
      for (i = 0; i < length; i++) {
       target.setUint8(i, source.getUint8(i));
      }
     }
    } catch (error) {
     throw new DOMException('ArrayBuffer is detached', DATA_CLONE_ERROR);
    }
    break;
   case 'SharedArrayBuffer':
    cloned = value;
    break;
   case 'Blob':
    try {
     cloned = value.slice(0, value.size, value.type);
    } catch (error) {
     throwUnpolyfillable(type);
    }
    break;
   case 'DOMPoint':
   case 'DOMPointReadOnly':
    C = global[type];
    try {
     cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
    } catch (error) {
     throwUnpolyfillable(type);
    }
    break;
   case 'DOMRect':
   case 'DOMRectReadOnly':
    C = global[type];
    try {
     cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
    } catch (error) {
     throwUnpolyfillable(type);
    }
    break;
   case 'DOMMatrix':
   case 'DOMMatrixReadOnly':
    C = global[type];
    try {
     cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
    } catch (error) {
     throwUnpolyfillable(type);
    }
    break;
   case 'AudioData':
   case 'VideoFrame':
    if (!isCallable(value.clone))
     throwUnpolyfillable(type);
    try {
     cloned = value.clone();
    } catch (error) {
     throwUncloneable(type);
    }
    break;
   case 'File':
    try {
     cloned = new File([value], value.name, value);
    } catch (error) {
     throwUnpolyfillable(type);
    }
    break;
   case 'CryptoKey':
   case 'GPUCompilationMessage':
   case 'GPUCompilationInfo':
   case 'ImageBitmap':
   case 'RTCCertificate':
   case 'WebAssembly.Module':
    throwUnpolyfillable(type);
   default:
    throwUncloneable(type);
   }
 }
 mapSet(map, value, cloned);
 if (deep)
  switch (type) {
  case 'Array':
  case 'Object':
   keys = objectKeys(value);
   for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
    key = keys[i];
    createProperty(cloned, key, structuredCloneInternal(value[key], map));
   }
   break;
  case 'Map':
   value.forEach(function (v, k) {
    mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
   });
   break;
  case 'Set':
   value.forEach(function (v) {
    setAdd(cloned, structuredCloneInternal(v, map));
   });
   break;
  case 'Error':
   createNonEnumerableProperty(cloned, 'message', structuredCloneInternal(value.message, map));
   if (hasOwn(value, 'cause')) {
    createNonEnumerableProperty(cloned, 'cause', structuredCloneInternal(value.cause, map));
   }
   if (name == 'AggregateError') {
    cloned.errors = structuredCloneInternal(value.errors, map);
   }
  case 'DOMException':
   if (ERROR_STACK_INSTALLABLE) {
    createNonEnumerableProperty(cloned, 'stack', structuredCloneInternal(value.stack, map));
   }
  }
 return cloned;
};
var PROPER_TRANSFER = nativeStructuredClone && !fails(function () {
 if (IS_DENO && V8 > 92 || IS_NODE && V8 > 94 || IS_BROWSER && V8 > 97)
  return false;
 var buffer = new ArrayBuffer(8);
 var clone = nativeStructuredClone(buffer, { transfer: [buffer] });
 return buffer.byteLength != 0 || clone.byteLength != 8;
});
var tryToTransfer = function (rawTransfer, map) {
 if (!isObject(rawTransfer))
  throw TypeError('Transfer option cannot be converted to a sequence');
 var transfer = [];
 iterate(rawTransfer, function (value) {
  push(transfer, anObject(value));
 });
 var i = 0;
 var length = lengthOfArrayLike(transfer);
 var value, type, C, transferredArray, transferred, canvas, context;
 if (PROPER_TRANSFER) {
  transferredArray = nativeStructuredClone(transfer, { transfer: transfer });
  while (i < length)
   mapSet(map, transfer[i], transferredArray[i++]);
 } else
  while (i < length) {
   value = transfer[i++];
   if (mapHas(map, value))
    throw new DOMException('Duplicate transferable', DATA_CLONE_ERROR);
   type = classof(value);
   switch (type) {
   case 'ImageBitmap':
    C = global.OffscreenCanvas;
    if (!isConstructor(C))
     throwUnpolyfillable(type, TRANSFERRING);
    try {
     canvas = new C(value.width, value.height);
     context = canvas.getContext('bitmaprenderer');
     context.transferFromImageBitmap(value);
     transferred = canvas.transferToImageBitmap();
    } catch (error) {
    }
    break;
   case 'AudioData':
   case 'VideoFrame':
    if (!isCallable(value.clone) || !isCallable(value.close))
     throwUnpolyfillable(type, TRANSFERRING);
    try {
     transferred = value.clone();
     value.close();
    } catch (error) {
    }
    break;
   case 'ArrayBuffer':
   case 'MessagePort':
   case 'OffscreenCanvas':
   case 'ReadableStream':
   case 'TransformStream':
   case 'WritableStream':
    throwUnpolyfillable(type, TRANSFERRING);
   }
   if (transferred === undefined)
    throw new DOMException('This object cannot be transferred: ' + type, DATA_CLONE_ERROR);
   mapSet(map, value, transferred);
  }
};
$({
 global: true,
 enumerable: true,
 sham: !PROPER_TRANSFER,
 forced: FORCED_REPLACEMENT
}, {
 structuredClone: function structuredClone(value) {
  var options = validateArgumentsLength(arguments.length, 1) > 1 && arguments[1] != null ? anObject(arguments[1]) : undefined;
  var transfer = options ? options.transfer : undefined;
  var map;
  if (transfer !== undefined) {
   map = new Map();
   tryToTransfer(transfer, map);
  }
  return structuredCloneInternal(value, map);
 }
});

/***/ }),
/* 120 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var uncurryThis = __w_pdfjs_require__(17);
var fails = __w_pdfjs_require__(10);
var isCallable = __w_pdfjs_require__(23);
var classof = __w_pdfjs_require__(80);
var getBuiltIn = __w_pdfjs_require__(25);
var inspectSource = __w_pdfjs_require__(52);
var noop = function () {
};
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
var isConstructorModern = function isConstructor(argument) {
 if (!isCallable(argument))
  return false;
 try {
  construct(noop, empty, argument);
  return true;
 } catch (error) {
  return false;
 }
};
var isConstructorLegacy = function isConstructor(argument) {
 if (!isCallable(argument))
  return false;
 switch (classof(argument)) {
 case 'AsyncFunction':
 case 'GeneratorFunction':
 case 'AsyncGeneratorFunction':
  return false;
 }
 try {
  return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
 } catch (error) {
  return true;
 }
};
isConstructorLegacy.sham = true;
module.exports = !construct || fails(function () {
 var called;
 return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
  called = true;
 }) || called;
}) ? isConstructorLegacy : isConstructorModern;

/***/ }),
/* 121 */
/***/ ((module) => {

var $TypeError = TypeError;
module.exports = function (passed, required) {
 if (passed < required)
  throw $TypeError('Not enough arguments');
 return passed;
};

/***/ }),
/* 122 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var call = __w_pdfjs_require__(11);
var hasOwn = __w_pdfjs_require__(40);
var isPrototypeOf = __w_pdfjs_require__(26);
var regExpFlags = __w_pdfjs_require__(123);
var RegExpPrototype = RegExp.prototype;
module.exports = function (R) {
 var flags = R.flags;
 return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
};

/***/ }),
/* 123 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var anObject = __w_pdfjs_require__(48);
module.exports = function () {
 var that = anObject(this);
 var result = '';
 if (that.hasIndices)
  result += 'd';
 if (that.global)
  result += 'g';
 if (that.ignoreCase)
  result += 'i';
 if (that.multiline)
  result += 'm';
 if (that.dotAll)
  result += 's';
 if (that.unicode)
  result += 'u';
 if (that.unicodeSets)
  result += 'v';
 if (that.sticky)
  result += 'y';
 return result;
};

/***/ }),
/* 124 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var fails = __w_pdfjs_require__(10);
var createPropertyDescriptor = __w_pdfjs_require__(14);
module.exports = !fails(function () {
 var error = Error('a');
 if (!('stack' in error))
  return true;
 Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
 return error.stack !== 7;
});

/***/ }),
/* 125 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var IS_DENO = __w_pdfjs_require__(126);
var IS_NODE = __w_pdfjs_require__(127);
module.exports = !IS_DENO && !IS_NODE && typeof window == 'object' && typeof document == 'object';

/***/ }),
/* 126 */
/***/ ((module) => {

module.exports = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';

/***/ }),
/* 127 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var classof = __w_pdfjs_require__(18);
var global = __w_pdfjs_require__(7);
module.exports = classof(global.process) == 'process';

/***/ }),
/* 128 */
/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {

var global = __w_pdfjs_require__(7);
module.exports = global;

/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
exports.getDocument = getDocument;
exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
exports.version = void 0;

var _util = __w_pdfjs_require__(1);

var _annotation_storage = __w_pdfjs_require__(130);

var _display_utils = __w_pdfjs_require__(133);

var _font_loader = __w_pdfjs_require__(136);

var _canvas = __w_pdfjs_require__(137);

var _worker_options = __w_pdfjs_require__(140);

var _is_node = __w_pdfjs_require__(3);

var _message_handler = __w_pdfjs_require__(141);

var _metadata = __w_pdfjs_require__(142);

var _optional_content_config = __w_pdfjs_require__(143);

var _transport_stream = __w_pdfjs_require__(144);

var _xfa_text = __w_pdfjs_require__(145);

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) { _classCheckPrivateStaticAccess(receiver, classConstructor); _classCheckPrivateStaticFieldDescriptor(descriptor, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) { _classCheckPrivateStaticAccess(receiver, classConstructor); _classCheckPrivateStaticFieldDescriptor(descriptor, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classCheckPrivateStaticFieldDescriptor(descriptor, action) { if (descriptor === undefined) { throw new TypeError("attempted to " + action + " private static field before its declaration"); } }

function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

const DEFAULT_RANGE_CHUNK_SIZE = 65536;
const RENDERING_CANCELLED_TIMEOUT = 100;
let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
exports.DefaultCanvasFactory = DefaultCanvasFactory;
let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;

if (_is_node.isNodeJS) {
  const {
    NodeCanvasFactory,
    NodeCMapReaderFactory,
    NodeStandardFontDataFactory
  } = __w_pdfjs_require__(146);

  exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
  exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
  exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
}

let createPDFNetworkStream;

function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
  createPDFNetworkStream = pdfNetworkStreamFactory;
}

function getDocument(src) {
  const task = new PDFDocumentLoadingTask();
  let source;

  if (typeof src === "string" || src instanceof URL) {
    source = {
      url: src
    };
  } else if ((0, _util.isArrayBuffer)(src)) {
    source = {
      data: src
    };
  } else if (src instanceof PDFDataRangeTransport) {
    source = {
      range: src
    };
  } else {
    if (typeof src !== "object") {
      throw new Error("Invalid parameter in getDocument, " + "need either string, URL, TypedArray, or parameter object.");
    }

    if (!src.url && !src.data && !src.range) {
      throw new Error("Invalid parameter object: need either .data, .range or .url");
    }

    source = src;
  }

  const params = Object.create(null);
  let rangeTransport = null,
      worker = null;

  for (const key in source) {
    const value = source[key];

    switch (key) {
      case "url":
        if (typeof window !== "undefined") {
          try {
            params[key] = new URL(value, window.location).href;
            continue;
          } catch (ex) {
            (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
          }
        } else if (typeof value === "string" || value instanceof URL) {
          params[key] = value.toString();
          continue;
        }

        throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");

      case "range":
        rangeTransport = value;
        continue;

      case "worker":
        worker = value;
        continue;

      case "data":
        if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
          params[key] = new Uint8Array(value);
        } else if (value instanceof Uint8Array) {
          break;
        } else if (typeof value === "string") {
          params[key] = (0, _util.stringToBytes)(value);
        } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
          params[key] = new Uint8Array(value);
        } else if ((0, _util.isArrayBuffer)(value)) {
          params[key] = new Uint8Array(value);
        } else {
          throw new Error("Invalid PDF binary data: either TypedArray, " + "string, or array-like object is expected in the data property.");
        }

        continue;
    }

    params[key] = value;
  }

  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
  params.ignoreErrors = params.stopAtErrors !== true;
  params.fontExtraProperties = params.fontExtraProperties === true;
  params.pdfBug = params.pdfBug === true;
  params.enableXfa = params.enableXfa === true;

  if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
    params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
  }

  if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
    params.docBaseUrl = null;
  }

  if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
    params.maxImageSize = -1;
  }

  if (typeof params.cMapUrl !== "string") {
    params.cMapUrl = null;
  }

  if (typeof params.standardFontDataUrl !== "string") {
    params.standardFontDataUrl = null;
  }

  if (typeof params.useWorkerFetch !== "boolean") {
    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
  }

  if (typeof params.isEvalSupported !== "boolean") {
    params.isEvalSupported = true;
  }

  if (typeof params.disableFontFace !== "boolean") {
    params.disableFontFace = _is_node.isNodeJS;
  }

  if (typeof params.useSystemFonts !== "boolean") {
    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
  }

  if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
    params.ownerDocument = globalThis.document;
  }

  if (typeof params.disableRange !== "boolean") {
    params.disableRange = false;
  }

  if (typeof params.disableStream !== "boolean") {
    params.disableStream = false;
  }

  if (typeof params.disableAutoFetch !== "boolean") {
    params.disableAutoFetch = false;
  }

  (0, _util.setVerbosityLevel)(params.verbosity);

  if (!worker) {
    const workerParams = {
      verbosity: params.verbosity,
      port: _worker_options.GlobalWorkerOptions.workerPort
    };
    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
    task._worker = worker;
  }

  const docId = task.docId;
  worker.promise.then(function () {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }

    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

    const networkStreamPromise = new Promise(function (resolve) {
      let networkStream;

      if (rangeTransport) {
        networkStream = new _transport_stream.PDFDataTransportStream({
          length: params.length,
          initialData: params.initialData,
          progressiveDone: params.progressiveDone,
          contentDispositionFilename: params.contentDispositionFilename,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        }, rangeTransport);
      } else if (!params.data) {
        networkStream = createPDFNetworkStream({
          url: params.url,
          length: params.length,
          httpHeaders: params.httpHeaders,
          withCredentials: params.withCredentials,
          rangeChunkSize: params.rangeChunkSize,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        });
      }

      resolve(networkStream);
    });
    return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) {
      let [workerId, networkStream] = _ref;

      if (task.destroyed) {
        throw new Error("Loading aborted");
      }

      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, params);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}

async function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
  if (worker.destroyed) {
    throw new Error("Worker was destroyed");
  }

  if (pdfDataRangeTransport) {
    source.length = pdfDataRangeTransport.length;
    source.initialData = pdfDataRangeTransport.initialData;
    source.progressiveDone = pdfDataRangeTransport.progressiveDone;
    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
  }

  const workerId = await worker.messageHandler.sendWithPromise("GetDocRequest", {
    docId,
    apiVersion: '2.16.105',
    source: {
      data: source.data,
      url: source.url,
      password: source.password,
      disableAutoFetch: source.disableAutoFetch,
      rangeChunkSize: source.rangeChunkSize,
      length: source.length
    },
    maxImageSize: source.maxImageSize,
    disableFontFace: source.disableFontFace,
    docBaseUrl: source.docBaseUrl,
    ignoreErrors: source.ignoreErrors,
    isEvalSupported: source.isEvalSupported,
    fontExtraProperties: source.fontExtraProperties,
    enableXfa: source.enableXfa,
    useSystemFonts: source.useSystemFonts,
    cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
    standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
  });

  if (source.data) {
    source.data = null;
  }

  if (worker.destroyed) {
    throw new Error("Worker was destroyed");
  }

  return workerId;
}

class PDFDocumentLoadingTask {
  constructor() {
    var _PDFDocumentLoadingTa, _PDFDocumentLoadingTa2;

    this._capability = (0, _util.createPromiseCapability)();
    this._transport = null;
    this._worker = null;
    this.docId = `d${(_classStaticPrivateFieldSpecSet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId, (_PDFDocumentLoadingTa = _classStaticPrivateFieldSpecGet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId), _PDFDocumentLoadingTa2 = _PDFDocumentLoadingTa++, _PDFDocumentLoadingTa)), _PDFDocumentLoadingTa2)}`;
    this.destroyed = false;
    this.onPassword = null;
    this.onProgress = null;
    this.onUnsupportedFeature = null;
  }

  get promise() {
    return this._capability.promise;
  }

  async destroy() {
    var _this$_transport;

    this.destroyed = true;
    await ((_this$_transport = this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy());
    this._transport = null;

    if (this._worker) {
      this._worker.destroy();

      this._worker = null;
    }
  }

}

exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
var _docId = {
  writable: true,
  value: 0
};

class PDFDataRangeTransport {
  constructor(length, initialData) {
    let progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._progressiveDoneListeners = [];
    this._readyCapability = (0, _util.createPromiseCapability)();
  }

  addRangeListener(listener) {
    this._rangeListeners.push(listener);
  }

  addProgressListener(listener) {
    this._progressListeners.push(listener);
  }

  addProgressiveReadListener(listener) {
    this._progressiveReadListeners.push(listener);
  }

  addProgressiveDoneListener(listener) {
    this._progressiveDoneListeners.push(listener);
  }

  onDataRange(begin, chunk) {
    for (const listener of this._rangeListeners) {
      listener(begin, chunk);
    }
  }

  onDataProgress(loaded, total) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressListeners) {
        listener(loaded, total);
      }
    });
  }

  onDataProgressiveRead(chunk) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveReadListeners) {
        listener(chunk);
      }
    });
  }

  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveDoneListeners) {
        listener();
      }
    });
  }

  transportReady() {
    this._readyCapability.resolve();
  }

  requestDataRange(begin, end) {
    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
  }

  abort() {}

}

exports.PDFDataRangeTransport = PDFDataRangeTransport;

class PDFDocumentProxy {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
    Object.defineProperty(this, "fingerprint", {
      get() {
        (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, " + "please use `PDFDocumentProxy.fingerprints` instead.");
        return this.fingerprints[0];
      }

    });
    Object.defineProperty(this, "getStats", {
      value: async () => {
        (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, " + "please use the `PDFDocumentProxy.stats`-getter instead.");
        return this.stats || {
          streamTypes: {},
          fontTypes: {}
        };
      }
    });
  }

  get annotationStorage() {
    return this._transport.annotationStorage;
  }

  get numPages() {
    return this._pdfInfo.numPages;
  }

  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }

  get stats() {
    return this._transport.stats;
  }

  get isPureXfa() {
    return !!this._transport._htmlForXfa;
  }

  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }

  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }

  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }

  getDestinations() {
    return this._transport.getDestinations();
  }

  getDestination(id) {
    return this._transport.getDestination(id);
  }

  getPageLabels() {
    return this._transport.getPageLabels();
  }

  getPageLayout() {
    return this._transport.getPageLayout();
  }

  getPageMode() {
    return this._transport.getPageMode();
  }

  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }

  getOpenAction() {
    return this._transport.getOpenAction();
  }

  getAttachments() {
    return this._transport.getAttachments();
  }

  getJavaScript() {
    return this._transport.getJavaScript();
  }

  getJSActions() {
    return this._transport.getDocJSActions();
  }

  getOutline() {
    return this._transport.getOutline();
  }

  getOptionalContentConfig() {
    return this._transport.getOptionalContentConfig();
  }

  getPermissions() {
    return this._transport.getPermissions();
  }

  getMetadata() {
    return this._transport.getMetadata();
  }

  getMarkInfo() {
    return this._transport.getMarkInfo();
  }

  getData() {
    return this._transport.getData();
  }

  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }

  cleanup() {
    let keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }

  destroy() {
    return this.loadingTask.destroy();
  }

  get loadingParams() {
    return this._transport.loadingParams;
  }

  get loadingTask() {
    return this._transport.loadingTask;
  }

  saveDocument() {
    if (this._transport.annotationStorage.size <= 0) {
      (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
    }

    return this._transport.saveDocument();
  }

  getFieldObjects() {
    return this._transport.getFieldObjects();
  }

  hasJSActions() {
    return this._transport.hasJSActions();
  }

  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }

}

exports.PDFDocumentProxy = PDFDocumentProxy;

class PDFPageProxy {
  constructor(pageIndex, pageInfo, transport, ownerDocument) {
    let pdfBug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._ownerDocument = ownerDocument;
    this._transport = transport;
    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this._bitmaps = new Set();
    this.cleanupAfterRender = false;
    this.pendingCleanup = false;
    this._intentStates = new Map();
    this._annotationPromises = new Map();
    this.destroyed = false;
  }

  get pageNumber() {
    return this._pageIndex + 1;
  }

  get rotate() {
    return this._pageInfo.rotate;
  }

  get ref() {
    return this._pageInfo.ref;
  }

  get userUnit() {
    return this._pageInfo.userUnit;
  }

  get view() {
    return this._pageInfo.view;
  }

  getViewport() {
    let {
      scale,
      rotation = this.rotate,
      offsetX = 0,
      offsetY = 0,
      dontFlip = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new _display_utils.PageViewport({
      viewBox: this.view,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }

  getAnnotations() {
    let {
      intent = "display"
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    const intentArgs = this._transport.getRenderingIntent(intent);

    let promise = this._annotationPromises.get(intentArgs.cacheKey);

    if (!promise) {
      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);

      this._annotationPromises.set(intentArgs.cacheKey, promise);

      promise = promise.then(annotations => {
        for (const annotation of annotations) {
          if (annotation.titleObj !== undefined) {
            Object.defineProperty(annotation, "title", {
              get() {
                (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                return annotation.titleObj.str;
              }

            });
          }

          if (annotation.contentsObj !== undefined) {
            Object.defineProperty(annotation, "contents", {
              get() {
                (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                return annotation.contentsObj.str;
              }

            });
          }
        }

        return annotations;
      });
    }

    return promise;
  }

  getJSActions() {
    return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
  }

  async getXfa() {
    var _this$_transport$_htm;

    return ((_this$_transport$_htm = this._transport._htmlForXfa) === null || _this$_transport$_htm === void 0 ? void 0 : _this$_transport$_htm.children[this._pageIndex]) || null;
  }

  render(_ref2) {
    var _arguments$, _arguments$2, _intentState;

    let {
      canvasContext,
      viewport,
      intent = "display",
      annotationMode = _util.AnnotationMode.ENABLE,
      transform = null,
      imageLayer = null,
      canvasFactory = null,
      background = null,
      optionalContentConfigPromise = null,
      annotationCanvasMap = null,
      pageColors = null,
      printAnnotationStorage = null
    } = _ref2;

    if (((_arguments$ = arguments[0]) === null || _arguments$ === void 0 ? void 0 : _arguments$.renderInteractiveForms) !== undefined) {
      (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, " + "please use the `annotationMode`-option instead.");

      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
        annotationMode = _util.AnnotationMode.ENABLE_FORMS;
      }
    }

    if (((_arguments$2 = arguments[0]) === null || _arguments$2 === void 0 ? void 0 : _arguments$2.includeAnnotationStorage) !== undefined) {
      (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, " + "please use the `annotationMode`-option instead.");

      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
      }
    }

    if (this._stats) {
      this._stats.time("Overall");
    }

    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);

    this.pendingCleanup = false;

    if (!optionalContentConfigPromise) {
      optionalContentConfigPromise = this._transport.getOptionalContentConfig();
    }

    let intentState = this._intentStates.get(intentArgs.cacheKey);

    if (!intentState) {
      intentState = Object.create(null);

      this._intentStates.set(intentArgs.cacheKey, intentState);
    }

    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }

    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
      ownerDocument: this._ownerDocument
    });
    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);

    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };

      if (this._stats) {
        this._stats.time("Page Request");
      }

      this._pumpOperatorList(intentArgs);
    }

    const complete = error => {
      intentState.renderTasks.delete(internalRenderTask);

      if (this.cleanupAfterRender || intentPrint) {
        this.pendingCleanup = true;
      }

      this._tryCleanup();

      if (error) {
        internalRenderTask.capability.reject(error);

        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }

      if (this._stats) {
        this._stats.timeEnd("Rendering");

        this._stats.timeEnd("Overall");
      }
    };

    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvasContext,
        viewport,
        transform,
        imageLayer,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: canvasFactoryInstance,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug,
      pageColors
    });
    ((_intentState = intentState).renderTasks || (_intentState.renderTasks = new Set())).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(_ref3 => {
      let [transparency, optionalContentConfig] = _ref3;

      if (this.pendingCleanup) {
        complete();
        return;
      }

      if (this._stats) {
        this._stats.time("Rendering");
      }

      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }

  getOperatorList() {
    let {
      intent = "display",
      annotationMode = _util.AnnotationMode.ENABLE,
      printAnnotationStorage = null
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }

    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);

    let intentState = this._intentStates.get(intentArgs.cacheKey);

    if (!intentState) {
      intentState = Object.create(null);

      this._intentStates.set(intentArgs.cacheKey, intentState);
    }

    let opListTask;

    if (!intentState.opListReadCapability) {
      var _intentState2;

      opListTask = Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = (0, _util.createPromiseCapability)();
      ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = new Set())).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };

      if (this._stats) {
        this._stats.time("Page Request");
      }

      this._pumpOperatorList(intentArgs);
    }

    return intentState.opListReadCapability.promise;
  }

  streamTextContent() {
    let {
      disableCombineTextItems = false,
      includeMarkedContent = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      combineTextItems: disableCombineTextItems !== true,
      includeMarkedContent: includeMarkedContent === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,

      size(textContent) {
        return textContent.items.length;
      }

    });
  }

  getTextContent() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (this._transport._htmlForXfa) {
      return this.getXfa().then(xfa => {
        return _xfa_text.XfaText.textContent(xfa);
      });
    }

    const readableStream = this.streamTextContent(params);
    return new Promise(function (resolve, reject) {
      function pump() {
        reader.read().then(function (_ref4) {
          let {
            value,
            done
          } = _ref4;

          if (done) {
            resolve(textContent);
            return;
          }

          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }

      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: Object.create(null)
      };
      pump();
    });
  }

  getStructTree() {
    return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
  }

  _destroy() {
    this.destroyed = true;
    const waitOn = [];

    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });

      if (intentState.opListReadCapability) {
        continue;
      }

      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }

    this.objs.clear();

    for (const bitmap of this._bitmaps) {
      bitmap.close();
    }

    this._bitmaps.clear();

    this._annotationPromises.clear();

    this._jsActionsPromise = null;
    this._structTreePromise = null;
    this.pendingCleanup = false;
    return Promise.all(waitOn);
  }

  cleanup() {
    let resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.pendingCleanup = true;
    return this._tryCleanup(resetStats);
  }

  _tryCleanup() {
    let resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (!this.pendingCleanup) {
      return false;
    }

    for (const {
      renderTasks,
      operatorList
    } of this._intentStates.values()) {
      if (renderTasks.size > 0 || !operatorList.lastChunk) {
        return false;
      }
    }

    this._intentStates.clear();

    this.objs.clear();

    this._annotationPromises.clear();

    this._jsActionsPromise = null;
    this._structTreePromise = null;

    if (resetStats && this._stats) {
      this._stats = new _display_utils.StatTimer();
    }

    for (const bitmap of this._bitmaps) {
      bitmap.close();
    }

    this._bitmaps.clear();

    this.pendingCleanup = false;
    return true;
  }

  _startRenderPage(transparency, cacheKey) {
    const intentState = this._intentStates.get(cacheKey);

    if (!intentState) {
      return;
    }

    if (this._stats) {
      this._stats.timeEnd("Page Request");
    }

    if (intentState.displayReadyCapability) {
      intentState.displayReadyCapability.resolve(transparency);
    }
  }

  _renderPageChunk(operatorListChunk, intentState) {
    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
    }

    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;

    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }

    if (operatorListChunk.lastChunk) {
      this._tryCleanup();
    }
  }

  _pumpOperatorList(_ref5) {
    let {
      renderingIntent,
      cacheKey,
      annotationStorageMap
    } = _ref5;

    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: annotationStorageMap
    });

    const reader = readableStream.getReader();

    const intentState = this._intentStates.get(cacheKey);

    intentState.streamReader = reader;

    const pump = () => {
      reader.read().then(_ref6 => {
        let {
          value,
          done
        } = _ref6;

        if (done) {
          intentState.streamReader = null;
          return;
        }

        if (this._transport.destroyed) {
          return;
        }

        this._renderPageChunk(value, intentState);

        pump();
      }, reason => {
        intentState.streamReader = null;

        if (this._transport.destroyed) {
          return;
        }

        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;

          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }

          this._tryCleanup();
        }

        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };

    pump();
  }

  _abortOperatorList(_ref7) {
    let {
      intentState,
      reason,
      force = false
    } = _ref7;

    if (!intentState.streamReader) {
      return;
    }

    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }

      if (reason instanceof _display_utils.RenderingCancelledException) {
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });

          intentState.streamReaderCancelTimeout = null;
        }, RENDERING_CANCELLED_TIMEOUT);
        return;
      }
    }

    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});
    intentState.streamReader = null;

    if (this._transport.destroyed) {
      return;
    }

    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);

        break;
      }
    }

    this.cleanup();
  }

  get stats() {
    return this._stats;
  }

}

exports.PDFPageProxy = PDFPageProxy;

class LoopbackPort {
  constructor() {
    this._listeners = [];
    this._deferred = Promise.resolve();
  }

  postMessage(obj, transfers) {
    const event = {
      data: structuredClone(obj, transfers)
    };

    this._deferred.then(() => {
      for (const listener of this._listeners) {
        listener.call(this, event);
      }
    });
  }

  addEventListener(name, listener) {
    this._listeners.push(listener);
  }

  removeEventListener(name, listener) {
    const i = this._listeners.indexOf(listener);

    this._listeners.splice(i, 1);
  }

  terminate() {
    this._listeners.length = 0;
  }

}

exports.LoopbackPort = LoopbackPort;
const PDFWorkerUtil = {
  isWorkerDisabled: false,
  fallbackWorkerSrc: null,
  fakeWorkerId: 0
};
exports.PDFWorkerUtil = PDFWorkerUtil;
{
  if (_is_node.isNodeJS && typeof commonjsRequire === "function") {
    PDFWorkerUtil.isWorkerDisabled = true;
    PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
  } else if (typeof document === "object") {
    var _document, _document$currentScri;

    const pdfjsFilePath = (_document = document) === null || _document === void 0 ? void 0 : (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;

    if (pdfjsFilePath) {
      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
    }
  }

  PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {
    let base;

    try {
      base = new URL(baseUrl);

      if (!base.origin || base.origin === "null") {
        return false;
      }
    } catch (e) {
      return false;
    }

    const other = new URL(otherUrl, base);
    return base.origin === other.origin;
  };

  PDFWorkerUtil.createCDNWrapper = function (url) {
    const wrapper = `importScripts("${url}");`;
    return URL.createObjectURL(new Blob([wrapper]));
  };
}

class PDFWorker {
  constructor() {
    let {
      name = null,
      port = null,
      verbosity = (0, _util.getVerbosityLevel)()
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (port && _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).has(port)) {
      throw new Error("Cannot use more than one PDFWorker per port.");
    }

    this.name = name;
    this.destroyed = false;
    this.verbosity = verbosity;
    this._readyCapability = (0, _util.createPromiseCapability)();
    this._port = null;
    this._webWorker = null;
    this._messageHandler = null;

    if (port) {
      _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).set(port, this);

      this._initializeFromPort(port);

      return;
    }

    this._initialize();
  }

  get promise() {
    return this._readyCapability.promise;
  }

  get port() {
    return this._port;
  }

  get messageHandler() {
    return this._messageHandler;
  }

  _initializeFromPort(port) {
    this._port = port;
    this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

    this._messageHandler.on("ready", function () {});

    this._readyCapability.resolve();
  }

  _initialize() {
    if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
      let {
        workerSrc
      } = PDFWorker;

      try {
        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
        }

        const worker = new Worker(workerSrc);
        const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

        const terminateEarly = () => {
          worker.removeEventListener("error", onWorkerError);
          messageHandler.destroy();
          worker.terminate();

          if (this.destroyed) {
            this._readyCapability.reject(new Error("Worker was destroyed"));
          } else {
            this._setupFakeWorker();
          }
        };

        const onWorkerError = () => {
          if (!this._webWorker) {
            terminateEarly();
          }
        };

        worker.addEventListener("error", onWorkerError);
        messageHandler.on("test", data => {
          worker.removeEventListener("error", onWorkerError);

          if (this.destroyed) {
            terminateEarly();
            return;
          }

          if (data) {
            this._messageHandler = messageHandler;
            this._port = worker;
            this._webWorker = worker;

            this._readyCapability.resolve();

            messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          } else {
            this._setupFakeWorker();

            messageHandler.destroy();
            worker.terminate();
          }
        });
        messageHandler.on("ready", data => {
          worker.removeEventListener("error", onWorkerError);

          if (this.destroyed) {
            terminateEarly();
            return;
          }

          try {
            sendTest();
          } catch (e) {
            this._setupFakeWorker();
          }
        });

        const sendTest = () => {
          const testObj = new Uint8Array();
          messageHandler.send("test", testObj, [testObj.buffer]);
        };

        sendTest();
        return;
      } catch (e) {
        (0, _util.info)("The worker has been disabled.");
      }
    }

    this._setupFakeWorker();
  }

  _setupFakeWorker() {
    if (!PDFWorkerUtil.isWorkerDisabled) {
      (0, _util.warn)("Setting up fake worker.");
      PDFWorkerUtil.isWorkerDisabled = true;
    }

    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));

        return;
      }

      const port = new LoopbackPort();
      this._port = port;
      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
      const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
      WorkerMessageHandler.setup(workerHandler, port);
      const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
      this._messageHandler = messageHandler;

      this._readyCapability.resolve();

      messageHandler.send("configure", {
        verbosity: this.verbosity
      });
    }).catch(reason => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
    });
  }

  destroy() {
    this.destroyed = true;

    if (this._webWorker) {
      this._webWorker.terminate();

      this._webWorker = null;
    }

    _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).delete(this._port);

    this._port = null;

    if (this._messageHandler) {
      this._messageHandler.destroy();

      this._messageHandler = null;
    }
  }

  static fromPort(params) {
    if (!(params !== null && params !== void 0 && params.port)) {
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    }

    if (_classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).has(params.port)) {
      return _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).get(params.port);
    }

    return new PDFWorker(params);
  }

  static get workerSrc() {
    if (_worker_options.GlobalWorkerOptions.workerSrc) {
      return _worker_options.GlobalWorkerOptions.workerSrc;
    }

    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
      if (!_is_node.isNodeJS) {
        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
      }

      return PDFWorkerUtil.fallbackWorkerSrc;
    }

    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }

  static get _mainThreadWorkerMessageHandler() {
    try {
      var _globalThis$pdfjsWork;

      return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;
    } catch (ex) {
      return null;
    }
  }

  static get _setupFakeWorkerGlobal() {
    const loader = async () => {
      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;

      if (mainWorkerMessageHandler) {
        return mainWorkerMessageHandler;
      }

      if (_is_node.isNodeJS && typeof commonjsRequire === "function") {
        const worker = commonjsRequire();
        return worker.WorkerMessageHandler;
      }

      await (0, _display_utils.loadScript)(this.workerSrc);
      return window.pdfjsWorker.WorkerMessageHandler;
    };

    return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
  }

}

exports.PDFWorker = PDFWorker;
var _workerPorts = {
  writable: true,
  value: new WeakMap()
};
{
  PDFWorker.getWorkerSrc = function () {
    (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
    return this.workerSrc;
  };
}

var _docStats = /*#__PURE__*/new WeakMap();

var _pageCache = /*#__PURE__*/new WeakMap();

var _pagePromises = /*#__PURE__*/new WeakMap();

var _metadataPromise = /*#__PURE__*/new WeakMap();

class WorkerTransport {
  constructor(messageHandler, loadingTask, networkStream, params) {
    _classPrivateFieldInitSpec(this, _docStats, {
      writable: true,
      value: null
    });

    _classPrivateFieldInitSpec(this, _pageCache, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _pagePromises, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _metadataPromise, {
      writable: true,
      value: null
    });

    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new _font_loader.FontLoader({
      docId: loadingTask.docId,
      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this._params = params;

    if (!params.useWorkerFetch) {
      this.CMapReaderFactory = new params.CMapReaderFactory({
        baseUrl: params.cMapUrl,
        isCompressed: params.cMapPacked
      });
      this.StandardFontDataFactory = new params.StandardFontDataFactory({
        baseUrl: params.standardFontDataUrl
      });
    }

    this.destroyed = false;
    this.destroyCapability = null;
    this._passwordCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
    this.setupMessageHandler();
  }

  get annotationStorage() {
    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
  }

  get stats() {
    return _classPrivateFieldGet(this, _docStats);
  }

  getRenderingIntent(intent) {
    let annotationMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _util.AnnotationMode.ENABLE;
    let printAnnotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let isOpList = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
    let annotationMap = null;

    switch (intent) {
      case "any":
        renderingIntent = _util.RenderingIntentFlag.ANY;
        break;

      case "display":
        break;

      case "print":
        renderingIntent = _util.RenderingIntentFlag.PRINT;
        break;

      default:
        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
    }

    switch (annotationMode) {
      case _util.AnnotationMode.DISABLE:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;

      case _util.AnnotationMode.ENABLE:
        break;

      case _util.AnnotationMode.ENABLE_FORMS:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;

      case _util.AnnotationMode.ENABLE_STORAGE:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
        const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
        annotationMap = annotationStorage.serializable;
        break;

      default:
        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }

    if (isOpList) {
      renderingIntent += _util.RenderingIntentFlag.OPLIST;
    }

    return {
      renderingIntent,
      cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`,
      annotationStorageMap: annotationMap
    };
  }

  destroy() {
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }

    this.destroyed = true;
    this.destroyCapability = (0, _util.createPromiseCapability)();

    if (this._passwordCapability) {
      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
    }

    const waitOn = [];

    for (const page of _classPrivateFieldGet(this, _pageCache).values()) {
      waitOn.push(page._destroy());
    }

    _classPrivateFieldGet(this, _pageCache).clear();

    _classPrivateFieldGet(this, _pagePromises).clear();

    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }

    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      this.commonObjs.clear();
      this.fontLoader.clear();

      _classPrivateFieldSet(this, _metadataPromise, null);

      this._getFieldObjectsPromise = null;
      this._hasJSActionsPromise = null;

      if (this._networkStream) {
        this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
      }

      if (this.messageHandler) {
        this.messageHandler.destroy();
        this.messageHandler = null;
      }

      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }

  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();

      this._fullReader.onProgress = evt => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };

      sink.onPull = () => {
        this._fullReader.read().then(function (_ref8) {
          let {
            value,
            done
          } = _ref8;

          if (done) {
            sink.close();
            return;
          }

          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };

      sink.onCancel = reason => {
        this._fullReader.cancel(reason);

        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }

          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", data => {
      const headersCapability = (0, _util.createPromiseCapability)();
      const fullReader = this._fullReader;
      fullReader.headersReady.then(() => {
        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
          if (this._lastProgress) {
            var _loadingTask$onProgre;

            (_loadingTask$onProgre = loadingTask.onProgress) === null || _loadingTask$onProgre === void 0 ? void 0 : _loadingTask$onProgre.call(loadingTask, this._lastProgress);
          }

          fullReader.onProgress = evt => {
            var _loadingTask$onProgre2;

            (_loadingTask$onProgre2 = loadingTask.onProgress) === null || _loadingTask$onProgre2 === void 0 ? void 0 : _loadingTask$onProgre2.call(loadingTask, {
              loaded: evt.loaded,
              total: evt.total
            });
          };
        }

        headersCapability.resolve({
          isStreamingSupported: fullReader.isStreamingSupported,
          isRangeSupported: fullReader.isRangeSupported,
          contentLength: fullReader.contentLength
        });
      }, headersCapability.reject);
      return headersCapability.promise;
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);

      if (!rangeReader) {
        sink.close();
        return;
      }

      sink.onPull = () => {
        rangeReader.read().then(function (_ref9) {
          let {
            value,
            done
          } = _ref9;

          if (done) {
            sink.close();
            return;
          }

          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };

      sink.onCancel = reason => {
        rangeReader.cancel(reason);
        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }

          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", _ref10 => {
      let {
        pdfInfo
      } = _ref10;
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;

      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", function (ex) {
      let reason;

      switch (ex.name) {
        case "PasswordException":
          reason = new _util.PasswordException(ex.message, ex.code);
          break;

        case "InvalidPDFException":
          reason = new _util.InvalidPDFException(ex.message);
          break;

        case "MissingPDFException":
          reason = new _util.MissingPDFException(ex.message);
          break;

        case "UnexpectedResponseException":
          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
          break;

        case "UnknownErrorException":
          reason = new _util.UnknownErrorException(ex.message, ex.details);
          break;

        default:
          (0, _util.unreachable)("DocException - expected a valid Error.");
      }

      loadingTask._capability.reject(reason);
    });
    messageHandler.on("PasswordRequest", exception => {
      this._passwordCapability = (0, _util.createPromiseCapability)();

      if (loadingTask.onPassword) {
        const updatePassword = password => {
          if (password instanceof Error) {
            this._passwordCapability.reject(password);
          } else {
            this._passwordCapability.resolve({
              password
            });
          }
        };

        try {
          loadingTask.onPassword(updatePassword, exception.code);
        } catch (ex) {
          this._passwordCapability.reject(ex);
        }
      } else {
        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
      }

      return this._passwordCapability.promise;
    });
    messageHandler.on("DataLoaded", data => {
      var _loadingTask$onProgre3;

      (_loadingTask$onProgre3 = loadingTask.onProgress) === null || _loadingTask$onProgre3 === void 0 ? void 0 : _loadingTask$onProgre3.call(loadingTask, {
        loaded: data.length,
        total: data.length
      });
      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", data => {
      if (this.destroyed) {
        return;
      }

      const page = _classPrivateFieldGet(this, _pageCache).get(data.pageIndex);

      page._startRenderPage(data.transparency, data.cacheKey);
    });
    messageHandler.on("commonobj", _ref11 => {
      var _globalThis$FontInspe;

      let [id, type, exportedData] = _ref11;

      if (this.destroyed) {
        return;
      }

      if (this.commonObjs.has(id)) {
        return;
      }

      switch (type) {
        case "Font":
          const params = this._params;

          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            (0, _util.warn)(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }

          let fontRegistry = null;

          if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {
            fontRegistry = {
              registerFont(font, url) {
                globalThis.FontInspector.fontAdded(font, url);
              }

            };
          }

          const font = new _font_loader.FontFaceObject(exportedData, {
            isEvalSupported: params.isEvalSupported,
            disableFontFace: params.disableFontFace,
            ignoreErrors: params.ignoreErrors,
            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
            fontRegistry
          });
          this.fontLoader.bind(font).catch(reason => {
            return messageHandler.sendWithPromise("FontFallback", {
              id
            });
          }).finally(() => {
            if (!params.fontExtraProperties && font.data) {
              font.data = null;
            }

            this.commonObjs.resolve(id, font);
          });
          break;

        case "FontPath":
        case "Image":
          this.commonObjs.resolve(id, exportedData);
          break;

        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
    });
    messageHandler.on("obj", _ref12 => {
      let [id, pageIndex, type, imageData] = _ref12;

      if (this.destroyed) {
        return;
      }

      const pageProxy = _classPrivateFieldGet(this, _pageCache).get(pageIndex);

      if (pageProxy.objs.has(id)) {
        return;
      }

      switch (type) {
        case "Image":
          pageProxy.objs.resolve(id, imageData);
          const MAX_IMAGE_SIZE_TO_STORE = 8000000;

          if (imageData) {
            let length;

            if (imageData.bitmap) {
              const {
                bitmap,
                width,
                height
              } = imageData;
              length = width * height * 4;

              pageProxy._bitmaps.add(bitmap);
            } else {
              var _imageData$data;

              length = ((_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) || 0;
            }

            if (length > MAX_IMAGE_SIZE_TO_STORE) {
              pageProxy.cleanupAfterRender = true;
            }
          }

          break;

        case "Pattern":
          pageProxy.objs.resolve(id, imageData);
          break;

        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", data => {
      var _loadingTask$onProgre4;

      if (this.destroyed) {
        return;
      }

      (_loadingTask$onProgre4 = loadingTask.onProgress) === null || _loadingTask$onProgre4 === void 0 ? void 0 : _loadingTask$onProgre4.call(loadingTask, {
        loaded: data.loaded,
        total: data.total
      });
    });
    messageHandler.on("DocStats", data => {
      if (this.destroyed) {
        return;
      }

      _classPrivateFieldSet(this, _docStats, Object.freeze({
        streamTypes: Object.freeze(data.streamTypes),
        fontTypes: Object.freeze(data.fontTypes)
      }));
    });
    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
    messageHandler.on("FetchBuiltInCMap", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }

      if (!this.CMapReaderFactory) {
        return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
      }

      return this.CMapReaderFactory.fetch(data);
    });
    messageHandler.on("FetchStandardFontData", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }

      if (!this.StandardFontDataFactory) {
        return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
      }

      return this.StandardFontDataFactory.fetch(data);
    });
  }

  _onUnsupportedFeature(_ref13) {
    var _this$loadingTask$onU, _this$loadingTask;

    let {
      featureId
    } = _ref13;

    if (this.destroyed) {
      return;
    }

    (_this$loadingTask$onU = (_this$loadingTask = this.loadingTask).onUnsupportedFeature) === null || _this$loadingTask$onU === void 0 ? void 0 : _this$loadingTask$onU.call(_this$loadingTask, featureId);
  }

  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }

  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request."));
    }

    const pageIndex = pageNumber - 1,
          cachedPromise = _classPrivateFieldGet(this, _pagePromises).get(pageIndex);

    if (cachedPromise) {
      return cachedPromise;
    }

    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then(pageInfo => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }

      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);

      _classPrivateFieldGet(this, _pageCache).set(pageIndex, page);

      return page;
    });

    _classPrivateFieldGet(this, _pagePromises).set(pageIndex, promise);

    return promise;
  }

  getPageIndex(ref) {
    if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
      return Promise.reject(new Error("Invalid pageIndex request."));
    }

    return this.messageHandler.sendWithPromise("GetPageIndex", {
      num: ref.num,
      gen: ref.gen
    });
  }

  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }

  saveDocument() {
    var _this$_fullReader$fil, _this$_fullReader;

    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: this.annotationStorage.serializable,
      filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
    }).finally(() => {
      this.annotationStorage.resetModified();
    });
  }

  getFieldObjects() {
    return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
  }

  hasJSActions() {
    return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
  }

  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }

  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }

  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }

    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }

  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }

  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }

  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }

  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }

  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }

  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }

  getJavaScript() {
    return this.messageHandler.sendWithPromise("GetJavaScript", null);
  }

  getDocJSActions() {
    return this.messageHandler.sendWithPromise("GetDocJSActions", null);
  }

  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }

  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }

  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }

  getOptionalContentConfig() {
    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
      return new _optional_content_config.OptionalContentConfig(results);
    });
  }

  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }

  getMetadata() {
    return _classPrivateFieldGet(this, _metadataPromise) || _classPrivateFieldSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {
      var _this$_fullReader$fil2, _this$_fullReader2, _this$_fullReader$con, _this$_fullReader3;

      return {
        info: results[0],
        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
        contentDispositionFilename: (_this$_fullReader$fil2 = (_this$_fullReader2 = this._fullReader) === null || _this$_fullReader2 === void 0 ? void 0 : _this$_fullReader2.filename) !== null && _this$_fullReader$fil2 !== void 0 ? _this$_fullReader$fil2 : null,
        contentLength: (_this$_fullReader$con = (_this$_fullReader3 = this._fullReader) === null || _this$_fullReader3 === void 0 ? void 0 : _this$_fullReader3.contentLength) !== null && _this$_fullReader$con !== void 0 ? _this$_fullReader$con : null
      };
    }));
  }

  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }

  async startCleanup() {
    let keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    await this.messageHandler.sendWithPromise("Cleanup", null);

    if (this.destroyed) {
      return;
    }

    for (const page of _classPrivateFieldGet(this, _pageCache).values()) {
      const cleanupSuccessful = page.cleanup();

      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }

    this.commonObjs.clear();

    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }

    _classPrivateFieldSet(this, _metadataPromise, null);

    this._getFieldObjectsPromise = null;
    this._hasJSActionsPromise = null;
  }

  get loadingParams() {
    const params = this._params;
    return (0, _util.shadow)(this, "loadingParams", {
      disableAutoFetch: params.disableAutoFetch,
      enableXfa: params.enableXfa
    });
  }

}

var _objs = /*#__PURE__*/new WeakMap();

var _ensureObj = /*#__PURE__*/new WeakSet();

class PDFObjects {
  constructor() {
    _classPrivateMethodInitSpec(this, _ensureObj);

    _classPrivateFieldInitSpec(this, _objs, {
      writable: true,
      value: Object.create(null)
    });
  }

  get(objId) {
    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (callback) {
      const obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);

      obj.capability.promise.then(() => callback(obj.data));
      return null;
    }

    const obj = _classPrivateFieldGet(this, _objs)[objId];

    if (!(obj !== null && obj !== void 0 && obj.capability.settled)) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }

    return obj.data;
  }

  has(objId) {
    const obj = _classPrivateFieldGet(this, _objs)[objId];

    return (obj === null || obj === void 0 ? void 0 : obj.capability.settled) || false;
  }

  resolve(objId) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    const obj = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, objId);

    obj.data = data;
    obj.capability.resolve();
  }

  clear() {
    _classPrivateFieldSet(this, _objs, Object.create(null));
  }

}

function _ensureObj2(objId) {
  const obj = _classPrivateFieldGet(this, _objs)[objId];

  if (obj) {
    return obj;
  }

  return _classPrivateFieldGet(this, _objs)[objId] = {
    capability: (0, _util.createPromiseCapability)(),
    data: null
  };
}

var _internalRenderTask = /*#__PURE__*/new WeakMap();

class RenderTask {
  constructor(internalRenderTask) {
    _classPrivateFieldInitSpec(this, _internalRenderTask, {
      writable: true,
      value: null
    });

    _classPrivateFieldSet(this, _internalRenderTask, internalRenderTask);

    this.onContinue = null;
  }

  get promise() {
    return _classPrivateFieldGet(this, _internalRenderTask).capability.promise;
  }

  cancel() {
    _classPrivateFieldGet(this, _internalRenderTask).cancel();
  }

  get separateAnnots() {
    const {
      separateAnnots
    } = _classPrivateFieldGet(this, _internalRenderTask).operatorList;

    if (!separateAnnots) {
      return false;
    }

    const {
      annotationCanvasMap
    } = _classPrivateFieldGet(this, _internalRenderTask);

    return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap === null || annotationCanvasMap === void 0 ? void 0 : annotationCanvasMap.size) > 0;
  }

}

exports.RenderTask = RenderTask;

class InternalRenderTask {
  constructor(_ref14) {
    let {
      callback,
      params,
      objs,
      commonObjs,
      annotationCanvasMap,
      operatorList,
      pageIndex,
      canvasFactory,
      useRequestAnimationFrame = false,
      pdfBug = false,
      pageColors = null
    } = _ref14;
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this._pdfBug = pdfBug;
    this.pageColors = pageColors;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = (0, _util.createPromiseCapability)();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvasContext.canvas;
  }

  get completed() {
    return this.capability.promise.catch(function () {});
  }

  initializeGraphics(_ref15) {
    var _globalThis$StepperMa;

    let {
      transparency = false,
      optionalContentConfig
    } = _ref15;

    if (this.cancelled) {
      return;
    }

    if (this._canvas) {
      if (_classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
      }

      _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).add(this._canvas);
    }

    if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }

    const {
      canvasContext,
      viewport,
      transform,
      imageLayer,
      background
    } = this.params;
    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
    this.gfx.beginDrawing({
      transform,
      viewport,
      transparency,
      background
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;

    if (this.graphicsReadyCallback) {
      this.graphicsReadyCallback();
    }
  }

  cancel() {
    let error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    this.running = false;
    this.cancelled = true;

    if (this.gfx) {
      this.gfx.endDrawing();
    }

    if (this._canvas) {
      _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas);
    }

    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
  }

  operatorListChanged() {
    if (!this.graphicsReady) {
      if (!this.graphicsReadyCallback) {
        this.graphicsReadyCallback = this._continueBound;
      }

      return;
    }

    if (this.stepper) {
      this.stepper.updateOperatorList(this.operatorList);
    }

    if (this.running) {
      return;
    }

    this._continue();
  }

  _continue() {
    this.running = true;

    if (this.cancelled) {
      return;
    }

    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }

  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      window.requestAnimationFrame(() => {
        this._nextBound().catch(this._cancelBound);
      });
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }

  async _next() {
    if (this.cancelled) {
      return;
    }

    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;

      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();

        if (this._canvas) {
          _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas);
        }

        this.callback();
      }
    }
  }

}

var _canvasInUse = {
  writable: true,
  value: new WeakSet()
};
const version = '2.16.105';
exports.version = version;
const build = '172ccdbe5';
exports.build = build;

/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;

var _util = __w_pdfjs_require__(1);

var _editor = __w_pdfjs_require__(131);

var _murmurhash = __w_pdfjs_require__(135);

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

var _setModified = /*#__PURE__*/new WeakSet();

class AnnotationStorage {
  constructor() {
    _classPrivateMethodInitSpec(this, _setModified);

    this._storage = new Map();
    this._modified = false;
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }

  getValue(key, defaultValue) {
    const value = this._storage.get(key);

    if (value === undefined) {
      return defaultValue;
    }

    return Object.assign(defaultValue, value);
  }

  getRawValue(key) {
    return this._storage.get(key);
  }

  remove(key) {
    this._storage.delete(key);

    if (this._storage.size === 0) {
      this.resetModified();
    }

    if (typeof this.onAnnotationEditor === "function") {
      for (const value of this._storage.values()) {
        if (value instanceof _editor.AnnotationEditor) {
          return;
        }
      }

      this.onAnnotationEditor(null);
    }
  }

  setValue(key, value) {
    const obj = this._storage.get(key);

    let modified = false;

    if (obj !== undefined) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;

      this._storage.set(key, value);
    }

    if (modified) {
      _classPrivateMethodGet(this, _setModified, _setModified2).call(this);
    }

    if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
      this.onAnnotationEditor(value.constructor._type);
    }
  }

  has(key) {
    return this._storage.has(key);
  }

  getAll() {
    return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;
  }

  get size() {
    return this._storage.size;
  }

  resetModified() {
    if (this._modified) {
      this._modified = false;

      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }

  get print() {
    return new PrintAnnotationStorage(this);
  }

  get serializable() {
    if (this._storage.size === 0) {
      return null;
    }

    const clone = new Map();

    for (const [key, val] of this._storage) {
      const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;

      if (serialized) {
        clone.set(key, serialized);
      }
    }

    return clone;
  }

  static getHash(map) {
    if (!map) {
      return "";
    }

    const hash = new _murmurhash.MurmurHash3_64();

    for (const [key, val] of map) {
      hash.update(`${key}:${JSON.stringify(val)}`);
    }

    return hash.hexdigest();
  }

}

exports.AnnotationStorage = AnnotationStorage;

function _setModified2() {
  if (!this._modified) {
    this._modified = true;

    if (typeof this.onSetModified === "function") {
      this.onSetModified();
    }
  }
}

var _serializable = /*#__PURE__*/new WeakMap();

class PrintAnnotationStorage extends AnnotationStorage {
  constructor(parent) {
    super();

    _classPrivateFieldInitSpec(this, _serializable, {
      writable: true,
      value: null
    });

    _classPrivateFieldSet(this, _serializable, structuredClone(parent.serializable));
  }

  get print() {
    (0, _util.unreachable)("Should not call PrintAnnotationStorage.print");
  }

  get serializable() {
    return _classPrivateFieldGet(this, _serializable);
  }

}

exports.PrintAnnotationStorage = PrintAnnotationStorage;

/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationEditor = void 0;

var _tools = __w_pdfjs_require__(132);

var _util = __w_pdfjs_require__(1);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _boundFocusin = /*#__PURE__*/new WeakMap();

var _boundFocusout = /*#__PURE__*/new WeakMap();

var _hasBeenSelected = /*#__PURE__*/new WeakMap();

var _isEditing = /*#__PURE__*/new WeakMap();

var _isInEditMode = /*#__PURE__*/new WeakMap();

var _zIndex = /*#__PURE__*/new WeakMap();

class AnnotationEditor {
  constructor(parameters) {
    _classPrivateFieldInitSpec(this, _boundFocusin, {
      writable: true,
      value: this.focusin.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundFocusout, {
      writable: true,
      value: this.focusout.bind(this)
    });

    _classPrivateFieldInitSpec(this, _hasBeenSelected, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _isEditing, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _isInEditMode, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _zIndex, {
      writable: true,
      value: AnnotationEditor._zIndex++
    });

    if (this.constructor === AnnotationEditor) {
      (0, _util.unreachable)("Cannot initialize AnnotationEditor.");
    }

    this.parent = parameters.parent;
    this.id = parameters.id;
    this.width = this.height = null;
    this.pageIndex = parameters.parent.pageIndex;
    this.name = parameters.name;
    this.div = null;
    const [width, height] = this.parent.viewportBaseDimensions;
    this.x = parameters.x / width;
    this.y = parameters.y / height;
    this.rotation = this.parent.viewport.rotation;
    this.isAttachedToDOM = false;
  }

  static get _defaultLineColor() {
    return (0, _util.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }

  setInBackground() {
    this.div.style.zIndex = 0;
  }

  setInForeground() {
    this.div.style.zIndex = _classPrivateFieldGet(this, _zIndex);
  }

  focusin(event) {
    if (!_classPrivateFieldGet(this, _hasBeenSelected)) {
      this.parent.setSelected(this);
    } else {
      _classPrivateFieldSet(this, _hasBeenSelected, false);
    }
  }

  focusout(event) {
    if (!this.isAttachedToDOM) {
      return;
    }

    const target = event.relatedTarget;

    if (target !== null && target !== void 0 && target.closest(`#${this.id}`)) {
      return;
    }

    event.preventDefault();

    if (!this.parent.isMultipleSelection) {
      this.commitOrRemove();
    }
  }

  commitOrRemove() {
    if (this.isEmpty()) {
      this.remove();
    } else {
      this.commit();
    }
  }

  commit() {
    this.parent.addToAnnotationStorage(this);
  }

  dragstart(event) {
    const rect = this.parent.div.getBoundingClientRect();
    this.startX = event.clientX - rect.x;
    this.startY = event.clientY - rect.y;
    event.dataTransfer.setData("text/plain", this.id);
    event.dataTransfer.effectAllowed = "move";
  }

  setAt(x, y, tx, ty) {
    const [width, height] = this.parent.viewportBaseDimensions;
    [tx, ty] = this.screenToPageTranslation(tx, ty);
    this.x = (x + tx) / width;
    this.y = (y + ty) / height;
    this.div.style.left = `${100 * this.x}%`;
    this.div.style.top = `${100 * this.y}%`;
  }

  translate(x, y) {
    const [width, height] = this.parent.viewportBaseDimensions;
    [x, y] = this.screenToPageTranslation(x, y);
    this.x += x / width;
    this.y += y / height;
    this.div.style.left = `${100 * this.x}%`;
    this.div.style.top = `${100 * this.y}%`;
  }

  screenToPageTranslation(x, y) {
    const {
      rotation
    } = this.parent.viewport;

    switch (rotation) {
      case 90:
        return [y, -x];

      case 180:
        return [-x, -y];

      case 270:
        return [-y, x];

      default:
        return [x, y];
    }
  }

  setDims(width, height) {
    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    this.div.style.width = `${100 * width / parentWidth}%`;
    this.div.style.height = `${100 * height / parentHeight}%`;
  }

  getInitialTranslation() {
    return [0, 0];
  }

  render() {
    this.div = document.createElement("div");
    this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    this.div.className = this.name;
    this.div.setAttribute("id", this.id);
    this.div.setAttribute("tabIndex", 0);
    this.setInForeground();
    this.div.addEventListener("focusin", _classPrivateFieldGet(this, _boundFocusin));
    this.div.addEventListener("focusout", _classPrivateFieldGet(this, _boundFocusout));
    const [tx, ty] = this.getInitialTranslation();
    this.translate(tx, ty);
    (0, _tools.bindEvents)(this, this.div, ["dragstart", "pointerdown"]);
    return this.div;
  }

  pointerdown(event) {
    const isMac = _tools.KeyboardManager.platform.isMac;

    if (event.button !== 0 || event.ctrlKey && isMac) {
      event.preventDefault();
      return;
    }

    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
      this.parent.toggleSelected(this);
    } else {
      this.parent.setSelected(this);
    }

    _classPrivateFieldSet(this, _hasBeenSelected, true);
  }

  getRect(tx, ty) {
    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    const [pageWidth, pageHeight] = this.parent.pageDimensions;
    const shiftX = pageWidth * tx / parentWidth;
    const shiftY = pageHeight * ty / parentHeight;
    const x = this.x * pageWidth;
    const y = this.y * pageHeight;
    const width = this.width * pageWidth;
    const height = this.height * pageHeight;

    switch (this.rotation) {
      case 0:
        return [x + shiftX, pageHeight - y - shiftY - height, x + shiftX + width, pageHeight - y - shiftY];

      case 90:
        return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height, pageHeight - y + shiftX + width];

      case 180:
        return [x - shiftX - width, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height];

      case 270:
        return [x - shiftY - height, pageHeight - y - shiftX - width, x - shiftY, pageHeight - y - shiftX];

      default:
        throw new Error("Invalid rotation");
    }
  }

  getRectInCurrentCoords(rect, pageHeight) {
    const [x1, y1, x2, y2] = rect;
    const width = x2 - x1;
    const height = y2 - y1;

    switch (this.rotation) {
      case 0:
        return [x1, pageHeight - y2, width, height];

      case 90:
        return [x1, pageHeight - y1, height, width];

      case 180:
        return [x2, pageHeight - y1, width, height];

      case 270:
        return [x2, pageHeight - y2, height, width];

      default:
        throw new Error("Invalid rotation");
    }
  }

  onceAdded() {}

  isEmpty() {
    return false;
  }

  enableEditMode() {
    _classPrivateFieldSet(this, _isInEditMode, true);
  }

  disableEditMode() {
    _classPrivateFieldSet(this, _isInEditMode, false);
  }

  isInEditMode() {
    return _classPrivateFieldGet(this, _isInEditMode);
  }

  shouldGetKeyboardEvents() {
    return false;
  }

  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }

  rebuild() {
    var _this$div;

    (_this$div = this.div) === null || _this$div === void 0 ? void 0 : _this$div.addEventListener("focusin", _classPrivateFieldGet(this, _boundFocusin));
  }

  serialize() {
    (0, _util.unreachable)("An editor must be serializable");
  }

  static deserialize(data, parent) {
    const editor = new this.prototype.constructor({
      parent,
      id: parent.getNextId()
    });
    editor.rotation = data.rotation;
    const [pageWidth, pageHeight] = parent.pageDimensions;
    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
    editor.x = x / pageWidth;
    editor.y = y / pageHeight;
    editor.width = width / pageWidth;
    editor.height = height / pageHeight;
    return editor;
  }

  remove() {
    this.div.removeEventListener("focusin", _classPrivateFieldGet(this, _boundFocusin));
    this.div.removeEventListener("focusout", _classPrivateFieldGet(this, _boundFocusout));

    if (!this.isEmpty()) {
      this.commit();
    }

    this.parent.remove(this);
  }

  select() {
    var _this$div2;

    (_this$div2 = this.div) === null || _this$div2 === void 0 ? void 0 : _this$div2.classList.add("selectedEditor");
  }

  unselect() {
    var _this$div3;

    (_this$div3 = this.div) === null || _this$div3 === void 0 ? void 0 : _this$div3.classList.remove("selectedEditor");
  }

  updateParams(type, value) {}

  disableEditing() {}

  enableEditing() {}

  get propertiesToUpdate() {
    return {};
  }

  get contentDiv() {
    return this.div;
  }

  get isEditing() {
    return _classPrivateFieldGet(this, _isEditing);
  }

  set isEditing(value) {
    _classPrivateFieldSet(this, _isEditing, value);

    if (value) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else {
      this.parent.setActiveEditor(null);
    }
  }

}

exports.AnnotationEditor = AnnotationEditor;

_defineProperty(AnnotationEditor, "_colorManager", new _tools.ColorManager());

_defineProperty(AnnotationEditor, "_zIndex", 1);

/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;
exports.bindEvents = bindEvents;
exports.opacityToHex = opacityToHex;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(133);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function bindEvents(obj, element, names) {
  for (const name of names) {
    element.addEventListener(name, obj[name].bind(obj));
  }
}

function opacityToHex(opacity) {
  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
}

var _id = /*#__PURE__*/new WeakMap();

class IdManager {
  constructor() {
    _classPrivateFieldInitSpec(this, _id, {
      writable: true,
      value: 0
    });
  }

  getId() {
    var _this$id, _this$id2;

    return `${_util.AnnotationEditorPrefix}${(_classPrivateFieldSet(this, _id, (_this$id = _classPrivateFieldGet(this, _id), _this$id2 = _this$id++, _this$id)), _this$id2)}`;
  }

}

var _commands = /*#__PURE__*/new WeakMap();

var _locked = /*#__PURE__*/new WeakMap();

var _maxSize = /*#__PURE__*/new WeakMap();

var _position = /*#__PURE__*/new WeakMap();

class CommandManager {
  constructor() {
    let maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;

    _classPrivateFieldInitSpec(this, _commands, {
      writable: true,
      value: []
    });

    _classPrivateFieldInitSpec(this, _locked, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _maxSize, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _position, {
      writable: true,
      value: -1
    });

    _classPrivateFieldSet(this, _maxSize, maxSize);
  }

  add(_ref) {
    let {
      cmd,
      undo,
      mustExec,
      type = NaN,
      overwriteIfSameType = false,
      keepUndo = false
    } = _ref;

    if (mustExec) {
      cmd();
    }

    if (_classPrivateFieldGet(this, _locked)) {
      return;
    }

    const save = {
      cmd,
      undo,
      type
    };

    if (_classPrivateFieldGet(this, _position) === -1) {
      if (_classPrivateFieldGet(this, _commands).length > 0) {
        _classPrivateFieldGet(this, _commands).length = 0;
      }

      _classPrivateFieldSet(this, _position, 0);

      _classPrivateFieldGet(this, _commands).push(save);

      return;
    }

    if (overwriteIfSameType && _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)].type === type) {
      if (keepUndo) {
        save.undo = _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)].undo;
      }

      _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)] = save;
      return;
    }

    const next = _classPrivateFieldGet(this, _position) + 1;

    if (next === _classPrivateFieldGet(this, _maxSize)) {
      _classPrivateFieldGet(this, _commands).splice(0, 1);
    } else {
      _classPrivateFieldSet(this, _position, next);

      if (next < _classPrivateFieldGet(this, _commands).length) {
        _classPrivateFieldGet(this, _commands).splice(next);
      }
    }

    _classPrivateFieldGet(this, _commands).push(save);
  }

  undo() {
    if (_classPrivateFieldGet(this, _position) === -1) {
      return;
    }

    _classPrivateFieldSet(this, _locked, true);

    _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)].undo();

    _classPrivateFieldSet(this, _locked, false);

    _classPrivateFieldSet(this, _position, _classPrivateFieldGet(this, _position) - 1);
  }

  redo() {
    if (_classPrivateFieldGet(this, _position) < _classPrivateFieldGet(this, _commands).length - 1) {
      _classPrivateFieldSet(this, _position, _classPrivateFieldGet(this, _position) + 1);

      _classPrivateFieldSet(this, _locked, true);

      _classPrivateFieldGet(this, _commands)[_classPrivateFieldGet(this, _position)].cmd();

      _classPrivateFieldSet(this, _locked, false);
    }
  }

  hasSomethingToUndo() {
    return _classPrivateFieldGet(this, _position) !== -1;
  }

  hasSomethingToRedo() {
    return _classPrivateFieldGet(this, _position) < _classPrivateFieldGet(this, _commands).length - 1;
  }

  destroy() {
    _classPrivateFieldSet(this, _commands, null);
  }

}

exports.CommandManager = CommandManager;

var _serialize = /*#__PURE__*/new WeakSet();

class KeyboardManager {
  constructor(callbacks) {
    _classPrivateMethodInitSpec(this, _serialize);

    this.buffer = [];
    this.callbacks = new Map();
    this.allKeys = new Set();
    const isMac = KeyboardManager.platform.isMac;

    for (const [keys, callback] of callbacks) {
      for (const key of keys) {
        const isMacKey = key.startsWith("mac+");

        if (isMac && isMacKey) {
          this.callbacks.set(key.slice(4), callback);
          this.allKeys.add(key.split("+").at(-1));
        } else if (!isMac && !isMacKey) {
          this.callbacks.set(key, callback);
          this.allKeys.add(key.split("+").at(-1));
        }
      }
    }
  }

  static get platform() {
    const platform = typeof navigator !== "undefined" ? navigator.platform : "";
    return (0, _util.shadow)(this, "platform", {
      isWin: platform.includes("Win"),
      isMac: platform.includes("Mac")
    });
  }

  exec(self, event) {
    if (!this.allKeys.has(event.key)) {
      return;
    }

    const callback = this.callbacks.get(_classPrivateMethodGet(this, _serialize, _serialize2).call(this, event));

    if (!callback) {
      return;
    }

    callback.bind(self)();
    event.stopPropagation();
    event.preventDefault();
  }

}

exports.KeyboardManager = KeyboardManager;

function _serialize2(event) {
  if (event.altKey) {
    this.buffer.push("alt");
  }

  if (event.ctrlKey) {
    this.buffer.push("ctrl");
  }

  if (event.metaKey) {
    this.buffer.push("meta");
  }

  if (event.shiftKey) {
    this.buffer.push("shift");
  }

  this.buffer.push(event.key);
  const str = this.buffer.join("+");
  this.buffer.length = 0;
  return str;
}

var _elements = /*#__PURE__*/new WeakMap();

class ClipboardManager {
  constructor() {
    _classPrivateFieldInitSpec(this, _elements, {
      writable: true,
      value: null
    });
  }

  copy(element) {
    if (!element) {
      return;
    }

    if (Array.isArray(element)) {
      _classPrivateFieldSet(this, _elements, element.map(el => el.serialize()));
    } else {
      _classPrivateFieldSet(this, _elements, [element.serialize()]);
    }

    _classPrivateFieldSet(this, _elements, _classPrivateFieldGet(this, _elements).filter(el => !!el));

    if (_classPrivateFieldGet(this, _elements).length === 0) {
      _classPrivateFieldSet(this, _elements, null);
    }
  }

  paste() {
    return _classPrivateFieldGet(this, _elements);
  }

  isEmpty() {
    return _classPrivateFieldGet(this, _elements) === null;
  }

  destroy() {
    _classPrivateFieldSet(this, _elements, null);
  }

}

class ColorManager {
  get _colors() {
    const colors = new Map([["CanvasText", null], ["Canvas", null]]);
    (0, _display_utils.getColorValues)(colors);
    return (0, _util.shadow)(this, "_colors", colors);
  }

  convert(color) {
    const rgb = (0, _display_utils.getRGB)(color);

    if (!window.matchMedia("(forced-colors: active)").matches) {
      return rgb;
    }

    for (const [name, RGB] of this._colors) {
      if (RGB.every((x, i) => x === rgb[i])) {
        return ColorManager._colorsMapping.get(name);
      }
    }

    return rgb;
  }

  getHexCode(name) {
    const rgb = this._colors.get(name);

    if (!rgb) {
      return name;
    }

    return _util.Util.makeHexColor(...rgb);
  }

}

exports.ColorManager = ColorManager;

_defineProperty(ColorManager, "_colorsMapping", new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));

var _activeEditor = /*#__PURE__*/new WeakMap();

var _allEditors = /*#__PURE__*/new WeakMap();

var _allLayers = /*#__PURE__*/new WeakMap();

var _clipboardManager = /*#__PURE__*/new WeakMap();

var _commandManager = /*#__PURE__*/new WeakMap();

var _currentPageIndex = /*#__PURE__*/new WeakMap();

var _editorTypes = /*#__PURE__*/new WeakMap();

var _eventBus = /*#__PURE__*/new WeakMap();

var _idManager = /*#__PURE__*/new WeakMap();

var _isEnabled = /*#__PURE__*/new WeakMap();

var _mode = /*#__PURE__*/new WeakMap();

var _selectedEditors = /*#__PURE__*/new WeakMap();

var _boundKeydown = /*#__PURE__*/new WeakMap();

var _boundOnEditingAction = /*#__PURE__*/new WeakMap();

var _boundOnPageChanging = /*#__PURE__*/new WeakMap();

var _previousStates = /*#__PURE__*/new WeakMap();

var _container = /*#__PURE__*/new WeakMap();

var _addKeyboardManager = /*#__PURE__*/new WeakSet();

var _removeKeyboardManager = /*#__PURE__*/new WeakSet();

var _dispatchUpdateStates = /*#__PURE__*/new WeakSet();

var _dispatchUpdateUI = /*#__PURE__*/new WeakSet();

var _enableAll = /*#__PURE__*/new WeakSet();

var _disableAll = /*#__PURE__*/new WeakSet();

var _addEditorToLayer = /*#__PURE__*/new WeakSet();

var _isEmpty = /*#__PURE__*/new WeakSet();

var _selectEditors = /*#__PURE__*/new WeakSet();

class AnnotationEditorUIManager {
  constructor(container, eventBus) {
    _classPrivateMethodInitSpec(this, _selectEditors);

    _classPrivateMethodInitSpec(this, _isEmpty);

    _classPrivateMethodInitSpec(this, _addEditorToLayer);

    _classPrivateMethodInitSpec(this, _disableAll);

    _classPrivateMethodInitSpec(this, _enableAll);

    _classPrivateMethodInitSpec(this, _dispatchUpdateUI);

    _classPrivateMethodInitSpec(this, _dispatchUpdateStates);

    _classPrivateMethodInitSpec(this, _removeKeyboardManager);

    _classPrivateMethodInitSpec(this, _addKeyboardManager);

    _classPrivateFieldInitSpec(this, _activeEditor, {
      writable: true,
      value: null
    });

    _classPrivateFieldInitSpec(this, _allEditors, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _allLayers, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _clipboardManager, {
      writable: true,
      value: new ClipboardManager()
    });

    _classPrivateFieldInitSpec(this, _commandManager, {
      writable: true,
      value: new CommandManager()
    });

    _classPrivateFieldInitSpec(this, _currentPageIndex, {
      writable: true,
      value: 0
    });

    _classPrivateFieldInitSpec(this, _editorTypes, {
      writable: true,
      value: null
    });

    _classPrivateFieldInitSpec(this, _eventBus, {
      writable: true,
      value: null
    });

    _classPrivateFieldInitSpec(this, _idManager, {
      writable: true,
      value: new IdManager()
    });

    _classPrivateFieldInitSpec(this, _isEnabled, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _mode, {
      writable: true,
      value: _util.AnnotationEditorType.NONE
    });

    _classPrivateFieldInitSpec(this, _selectedEditors, {
      writable: true,
      value: new Set()
    });

    _classPrivateFieldInitSpec(this, _boundKeydown, {
      writable: true,
      value: this.keydown.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundOnEditingAction, {
      writable: true,
      value: this.onEditingAction.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundOnPageChanging, {
      writable: true,
      value: this.onPageChanging.bind(this)
    });

    _classPrivateFieldInitSpec(this, _previousStates, {
      writable: true,
      value: {
        isEditing: false,
        isEmpty: true,
        hasEmptyClipboard: true,
        hasSomethingToUndo: false,
        hasSomethingToRedo: false,
        hasSelectedEditor: false
      }
    });

    _classPrivateFieldInitSpec(this, _container, {
      writable: true,
      value: null
    });

    _classPrivateFieldSet(this, _container, container);

    _classPrivateFieldSet(this, _eventBus, eventBus);

    _classPrivateFieldGet(this, _eventBus)._on("editingaction", _classPrivateFieldGet(this, _boundOnEditingAction));

    _classPrivateFieldGet(this, _eventBus)._on("pagechanging", _classPrivateFieldGet(this, _boundOnPageChanging));
  }

  destroy() {
    _classPrivateMethodGet(this, _removeKeyboardManager, _removeKeyboardManager2).call(this);

    _classPrivateFieldGet(this, _eventBus)._off("editingaction", _classPrivateFieldGet(this, _boundOnEditingAction));

    _classPrivateFieldGet(this, _eventBus)._off("pagechanging", _classPrivateFieldGet(this, _boundOnPageChanging));

    for (const layer of _classPrivateFieldGet(this, _allLayers).values()) {
      layer.destroy();
    }

    _classPrivateFieldGet(this, _allLayers).clear();

    _classPrivateFieldGet(this, _allEditors).clear();

    _classPrivateFieldSet(this, _activeEditor, null);

    _classPrivateFieldGet(this, _selectedEditors).clear();

    _classPrivateFieldGet(this, _clipboardManager).destroy();

    _classPrivateFieldGet(this, _commandManager).destroy();
  }

  onPageChanging(_ref2) {
    let {
      pageNumber
    } = _ref2;

    _classPrivateFieldSet(this, _currentPageIndex, pageNumber - 1);
  }

  focusMainContainer() {
    _classPrivateFieldGet(this, _container).focus();
  }

  keydown(event) {
    var _this$getActive;

    if (!((_this$getActive = this.getActive()) !== null && _this$getActive !== void 0 && _this$getActive.shouldGetKeyboardEvents())) {
      AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
  }

  onEditingAction(details) {
    if (["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(details.name)) {
      this[details.name]();
    }
  }

  setEditingState(isEditing) {
    if (isEditing) {
      _classPrivateMethodGet(this, _addKeyboardManager, _addKeyboardManager2).call(this);

      _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
        isEditing: _classPrivateFieldGet(this, _mode) !== _util.AnnotationEditorType.NONE,
        isEmpty: _classPrivateMethodGet(this, _isEmpty, _isEmpty2).call(this),
        hasSomethingToUndo: _classPrivateFieldGet(this, _commandManager).hasSomethingToUndo(),
        hasSomethingToRedo: _classPrivateFieldGet(this, _commandManager).hasSomethingToRedo(),
        hasSelectedEditor: false,
        hasEmptyClipboard: _classPrivateFieldGet(this, _clipboardManager).isEmpty()
      });
    } else {
      _classPrivateMethodGet(this, _removeKeyboardManager, _removeKeyboardManager2).call(this);

      _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
        isEditing: false
      });
    }
  }

  registerEditorTypes(types) {
    _classPrivateFieldSet(this, _editorTypes, types);

    for (const editorType of _classPrivateFieldGet(this, _editorTypes)) {
      _classPrivateMethodGet(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editorType.defaultPropertiesToUpdate);
    }
  }

  getId() {
    return _classPrivateFieldGet(this, _idManager).getId();
  }

  addLayer(layer) {
    _classPrivateFieldGet(this, _allLayers).set(layer.pageIndex, layer);

    if (_classPrivateFieldGet(this, _isEnabled)) {
      layer.enable();
    } else {
      layer.disable();
    }
  }

  removeLayer(layer) {
    _classPrivateFieldGet(this, _allLayers).delete(layer.pageIndex);
  }

  updateMode(mode) {
    _classPrivateFieldSet(this, _mode, mode);

    if (mode === _util.AnnotationEditorType.NONE) {
      this.setEditingState(false);

      _classPrivateMethodGet(this, _disableAll, _disableAll2).call(this);
    } else {
      this.setEditingState(true);

      _classPrivateMethodGet(this, _enableAll, _enableAll2).call(this);

      for (const layer of _classPrivateFieldGet(this, _allLayers).values()) {
        layer.updateMode(mode);
      }
    }
  }

  updateToolbar(mode) {
    if (mode === _classPrivateFieldGet(this, _mode)) {
      return;
    }

    _classPrivateFieldGet(this, _eventBus).dispatch("switchannotationeditormode", {
      source: this,
      mode
    });
  }

  updateParams(type, value) {
    for (const editor of _classPrivateFieldGet(this, _selectedEditors)) {
      editor.updateParams(type, value);
    }

    for (const editorType of _classPrivateFieldGet(this, _editorTypes)) {
      editorType.updateDefaultParams(type, value);
    }
  }

  getEditors(pageIndex) {
    const editors = [];

    for (const editor of _classPrivateFieldGet(this, _allEditors).values()) {
      if (editor.pageIndex === pageIndex) {
        editors.push(editor);
      }
    }

    return editors;
  }

  getEditor(id) {
    return _classPrivateFieldGet(this, _allEditors).get(id);
  }

  addEditor(editor) {
    _classPrivateFieldGet(this, _allEditors).set(editor.id, editor);
  }

  removeEditor(editor) {
    _classPrivateFieldGet(this, _allEditors).delete(editor.id);

    this.unselect(editor);
  }

  setActiveEditor(editor) {
    if (_classPrivateFieldGet(this, _activeEditor) === editor) {
      return;
    }

    _classPrivateFieldSet(this, _activeEditor, editor);

    if (editor) {
      _classPrivateMethodGet(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);
    }
  }

  toggleSelected(editor) {
    if (_classPrivateFieldGet(this, _selectedEditors).has(editor)) {
      _classPrivateFieldGet(this, _selectedEditors).delete(editor);

      editor.unselect();

      _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
        hasSelectedEditor: this.hasSelection
      });

      return;
    }

    _classPrivateFieldGet(this, _selectedEditors).add(editor);

    editor.select();

    _classPrivateMethodGet(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);

    _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
      hasSelectedEditor: true
    });
  }

  setSelected(editor) {
    for (const ed of _classPrivateFieldGet(this, _selectedEditors)) {
      if (ed !== editor) {
        ed.unselect();
      }
    }

    _classPrivateFieldGet(this, _selectedEditors).clear();

    _classPrivateFieldGet(this, _selectedEditors).add(editor);

    editor.select();

    _classPrivateMethodGet(this, _dispatchUpdateUI, _dispatchUpdateUI2).call(this, editor.propertiesToUpdate);

    _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
      hasSelectedEditor: true
    });
  }

  isSelected(editor) {
    return _classPrivateFieldGet(this, _selectedEditors).has(editor);
  }

  unselect(editor) {
    editor.unselect();

    _classPrivateFieldGet(this, _selectedEditors).delete(editor);

    _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }

  get hasSelection() {
    return _classPrivateFieldGet(this, _selectedEditors).size !== 0;
  }

  undo() {
    _classPrivateFieldGet(this, _commandManager).undo();

    _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
      hasSomethingToUndo: _classPrivateFieldGet(this, _commandManager).hasSomethingToUndo(),
      hasSomethingToRedo: true,
      isEmpty: _classPrivateMethodGet(this, _isEmpty, _isEmpty2).call(this)
    });
  }

  redo() {
    _classPrivateFieldGet(this, _commandManager).redo();

    _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
      hasSomethingToUndo: true,
      hasSomethingToRedo: _classPrivateFieldGet(this, _commandManager).hasSomethingToRedo(),
      isEmpty: _classPrivateMethodGet(this, _isEmpty, _isEmpty2).call(this)
    });
  }

  addCommands(params) {
    _classPrivateFieldGet(this, _commandManager).add(params);

    _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
      hasSomethingToUndo: true,
      hasSomethingToRedo: false,
      isEmpty: _classPrivateMethodGet(this, _isEmpty, _isEmpty2).call(this)
    });
  }

  delete() {
    if (_classPrivateFieldGet(this, _activeEditor)) {
      _classPrivateFieldGet(this, _activeEditor).commitOrRemove();
    }

    if (!this.hasSelection) {
      return;
    }

    const editors = [..._classPrivateFieldGet(this, _selectedEditors)];

    const cmd = () => {
      for (const editor of editors) {
        editor.remove();
      }
    };

    const undo = () => {
      for (const editor of editors) {
        _classPrivateMethodGet(this, _addEditorToLayer, _addEditorToLayer2).call(this, editor);
      }
    };

    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }

  copy() {
    if (_classPrivateFieldGet(this, _activeEditor)) {
      _classPrivateFieldGet(this, _activeEditor).commitOrRemove();
    }

    if (this.hasSelection) {
      const editors = [];

      for (const editor of _classPrivateFieldGet(this, _selectedEditors)) {
        if (!editor.isEmpty()) {
          editors.push(editor);
        }
      }

      if (editors.length === 0) {
        return;
      }

      _classPrivateFieldGet(this, _clipboardManager).copy(editors);

      _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
        hasEmptyClipboard: false
      });
    }
  }

  cut() {
    this.copy();
    this.delete();
  }

  paste() {
    if (_classPrivateFieldGet(this, _clipboardManager).isEmpty()) {
      return;
    }

    this.unselectAll();

    const layer = _classPrivateFieldGet(this, _allLayers).get(_classPrivateFieldGet(this, _currentPageIndex));

    const newEditors = _classPrivateFieldGet(this, _clipboardManager).paste().map(data => layer.deserialize(data));

    const cmd = () => {
      for (const editor of newEditors) {
        _classPrivateMethodGet(this, _addEditorToLayer, _addEditorToLayer2).call(this, editor);
      }

      _classPrivateMethodGet(this, _selectEditors, _selectEditors2).call(this, newEditors);
    };

    const undo = () => {
      for (const editor of newEditors) {
        editor.remove();
      }
    };

    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }

  selectAll() {
    for (const editor of _classPrivateFieldGet(this, _selectedEditors)) {
      editor.commit();
    }

    _classPrivateMethodGet(this, _selectEditors, _selectEditors2).call(this, _classPrivateFieldGet(this, _allEditors).values());
  }

  unselectAll() {
    if (_classPrivateFieldGet(this, _activeEditor)) {
      _classPrivateFieldGet(this, _activeEditor).commitOrRemove();

      return;
    }

    if (_classPrivateMethodGet(this, _selectEditors, _selectEditors2).size === 0) {
      return;
    }

    for (const editor of _classPrivateFieldGet(this, _selectedEditors)) {
      editor.unselect();
    }

    _classPrivateFieldGet(this, _selectedEditors).clear();

    _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
      hasSelectedEditor: false
    });
  }

  isActive(editor) {
    return _classPrivateFieldGet(this, _activeEditor) === editor;
  }

  getActive() {
    return _classPrivateFieldGet(this, _activeEditor);
  }

  getMode() {
    return _classPrivateFieldGet(this, _mode);
  }

}

exports.AnnotationEditorUIManager = AnnotationEditorUIManager;

function _addKeyboardManager2() {
  _classPrivateFieldGet(this, _container).addEventListener("keydown", _classPrivateFieldGet(this, _boundKeydown));
}

function _removeKeyboardManager2() {
  _classPrivateFieldGet(this, _container).removeEventListener("keydown", _classPrivateFieldGet(this, _boundKeydown));
}

function _dispatchUpdateStates2(details) {
  const hasChanged = Object.entries(details).some(_ref3 => {
    let [key, value] = _ref3;
    return _classPrivateFieldGet(this, _previousStates)[key] !== value;
  });

  if (hasChanged) {
    _classPrivateFieldGet(this, _eventBus).dispatch("annotationeditorstateschanged", {
      source: this,
      details: Object.assign(_classPrivateFieldGet(this, _previousStates), details)
    });
  }
}

function _dispatchUpdateUI2(details) {
  _classPrivateFieldGet(this, _eventBus).dispatch("annotationeditorparamschanged", {
    source: this,
    details
  });
}

function _enableAll2() {
  if (!_classPrivateFieldGet(this, _isEnabled)) {
    _classPrivateFieldSet(this, _isEnabled, true);

    for (const layer of _classPrivateFieldGet(this, _allLayers).values()) {
      layer.enable();
    }
  }
}

function _disableAll2() {
  this.unselectAll();

  if (_classPrivateFieldGet(this, _isEnabled)) {
    _classPrivateFieldSet(this, _isEnabled, false);

    for (const layer of _classPrivateFieldGet(this, _allLayers).values()) {
      layer.disable();
    }
  }
}

function _addEditorToLayer2(editor) {
  const layer = _classPrivateFieldGet(this, _allLayers).get(editor.pageIndex);

  if (layer) {
    layer.addOrRebuild(editor);
  } else {
    this.addEditor(editor);
  }
}

function _isEmpty2() {
  if (_classPrivateFieldGet(this, _allEditors).size === 0) {
    return true;
  }

  if (_classPrivateFieldGet(this, _allEditors).size === 1) {
    for (const editor of _classPrivateFieldGet(this, _allEditors).values()) {
      return editor.isEmpty();
    }
  }

  return false;
}

function _selectEditors2(editors) {
  _classPrivateFieldGet(this, _selectedEditors).clear();

  for (const editor of editors) {
    if (editor.isEmpty()) {
      continue;
    }

    _classPrivateFieldGet(this, _selectedEditors).add(editor);

    editor.select();
  }

  _classPrivateMethodGet(this, _dispatchUpdateStates, _dispatchUpdateStates2).call(this, {
    hasSelectedEditor: true
  });
}

_defineProperty(AnnotationEditorUIManager, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], AnnotationEditorUIManager.prototype.selectAll], [["ctrl+c", "mac+meta+c"], AnnotationEditorUIManager.prototype.copy], [["ctrl+v", "mac+meta+v"], AnnotationEditorUIManager.prototype.paste], [["ctrl+x", "mac+meta+x"], AnnotationEditorUIManager.prototype.cut], [["ctrl+z", "mac+meta+z"], AnnotationEditorUIManager.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], AnnotationEditorUIManager.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], AnnotationEditorUIManager.prototype.delete], [["Escape", "mac+Escape"], AnnotationEditorUIManager.prototype.unselectAll]]));

/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = exports.AnnotationPrefix = void 0;
exports.deprecated = deprecated;
exports.getColorValues = getColorValues;
exports.getCurrentTransform = getCurrentTransform;
exports.getCurrentTransformInverse = getCurrentTransformInverse;
exports.getFilenameFromUrl = getFilenameFromUrl;
exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
exports.getRGB = getRGB;
exports.getXfaPageViewport = getXfaPageViewport;
exports.isDataScheme = isDataScheme;
exports.isPdfFile = isPdfFile;
exports.isValidFetchUrl = isValidFetchUrl;
exports.loadScript = loadScript;

var _base_factory = __w_pdfjs_require__(134);

var _util = __w_pdfjs_require__(1);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const SVG_NS = "http://www.w3.org/2000/svg";
const AnnotationPrefix = "pdfjs_internal_id_";
exports.AnnotationPrefix = AnnotationPrefix;

class PixelsPerInch {}

exports.PixelsPerInch = PixelsPerInch;

_defineProperty(PixelsPerInch, "CSS", 96.0);

_defineProperty(PixelsPerInch, "PDF", 72.0);

_defineProperty(PixelsPerInch, "PDF_TO_CSS_UNITS", PixelsPerInch.CSS / PixelsPerInch.PDF);

class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
  constructor() {
    let {
      ownerDocument = globalThis.document
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super();
    this._document = ownerDocument;
  }

  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");

    canvas.width = width;
    canvas.height = height;
    return canvas;
  }

}

exports.DOMCanvasFactory = DOMCanvasFactory;

async function fetchData(url) {
  let asTypedArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(response.statusText);
    }

    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());
  }

  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);

    if (asTypedArray) {
      request.responseType = "arraybuffer";
    }

    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }

      if (request.status === 200 || request.status === 0) {
        let data;

        if (asTypedArray && request.response) {
          data = new Uint8Array(request.response);
        } else if (!asTypedArray && request.responseText) {
          data = (0, _util.stringToBytes)(request.responseText);
        }

        if (data) {
          resolve(data);
          return;
        }
      }

      reject(new Error(request.statusText));
    };

    request.send(null);
  });
}

class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData(url, this.isCompressed).then(data => {
      return {
        cMapData: data,
        compressionType
      };
    });
  }

}

exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData(url, true);
  }

}

exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;

class DOMSVGFactory extends _base_factory.BaseSVGFactory {
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }

}

exports.DOMSVGFactory = DOMSVGFactory;

class PageViewport {
  constructor(_ref) {
    let {
      viewBox,
      scale,
      rotation,
      offsetX = 0,
      offsetY = 0,
      dontFlip = false
    } = _ref;
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;

    if (rotation < 0) {
      rotation += 360;
    }

    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;

      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;

      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;

      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;

      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }

    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }

    let offsetCanvasX, offsetCanvasY;
    let width, height;

    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }

    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }

  clone() {
    let {
      scale = this.scale,
      rotation = this.rotation,
      offsetX = this.offsetX,
      offsetY = this.offsetY,
      dontFlip = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new PageViewport({
      viewBox: this.viewBox.slice(),
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }

  convertToViewportPoint(x, y) {
    return _util.Util.applyTransform([x, y], this.transform);
  }

  convertToViewportRectangle(rect) {
    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }

  convertToPdfPoint(x, y) {
    return _util.Util.applyInverseTransform([x, y], this.transform);
  }

}

exports.PageViewport = PageViewport;

class RenderingCancelledException extends _util.BaseException {
  constructor(msg, type) {
    super(msg, "RenderingCancelledException");
    this.type = type;
  }

}

exports.RenderingCancelledException = RenderingCancelledException;

function isDataScheme(url) {
  const ii = url.length;
  let i = 0;

  while (i < ii && url[i].trim() === "") {
    i++;
  }

  return url.substring(i, i + 5).toLowerCase() === "data:";
}

function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}

function getFilenameFromUrl(url) {
  const anchor = url.indexOf("#");
  const query = url.indexOf("?");
  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
  return url.substring(url.lastIndexOf("/", end) + 1, end);
}

function getPdfFilenameFromUrl(url) {
  let defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "document.pdf";

  if (typeof url !== "string") {
    return defaultFilename;
  }

  if (isDataScheme(url)) {
    (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }

  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];

    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch (ex) {}
    }
  }

  return suggestedFilename || defaultFilename;
}

class StatTimer {
  constructor() {
    this.started = Object.create(null);
    this.times = [];
  }

  time(name) {
    if (name in this.started) {
      (0, _util.warn)(`Timer is already running for ${name}`);
    }

    this.started[name] = Date.now();
  }

  timeEnd(name) {
    if (!(name in this.started)) {
      (0, _util.warn)(`Timer has not been started for ${name}`);
    }

    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }

  toString() {
    const outBuf = [];
    let longest = 0;

    for (const time of this.times) {
      const name = time.name;

      if (name.length > longest) {
        longest = name.length;
      }
    }

    for (const time of this.times) {
      const duration = time.end - time.start;
      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\n`);
    }

    return outBuf.join("");
  }

}

exports.StatTimer = StatTimer;

function isValidFetchUrl(url, baseUrl) {
  try {
    const {
      protocol
    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
    return protocol === "http:" || protocol === "https:";
  } catch (ex) {
    return false;
  }
}

function loadScript(src) {
  let removeScriptElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;

    script.onload = function (evt) {
      if (removeScriptElement) {
        script.remove();
      }

      resolve(evt);
    };

    script.onerror = function () {
      reject(new Error(`Cannot load script at: ${script.src}`));
    };

    (document.head || document.documentElement).append(script);
  });
}

function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}

let pdfDateStringRegex;

class PDFDateString {
  static toDateObject(input) {
    if (!input || typeof input !== "string") {
      return null;
    }

    if (!pdfDateStringRegex) {
      pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
    }

    const matches = pdfDateStringRegex.exec(input);

    if (!matches) {
      return null;
    }

    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }

    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }

}

exports.PDFDateString = PDFDateString;

function getXfaPageViewport(xfaPage, _ref2) {
  let {
    scale = 1,
    rotation = 0
  } = _ref2;
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    scale,
    rotation
  });
}

function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];
  }

  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map(x => parseInt(x));
  }

  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map(x => parseInt(x)).slice(0, 3);
  }

  (0, _util.warn)(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}

function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  document.body.append(span);

  for (const name of colors.keys()) {
    span.style.color = name;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name, getRGB(computedColor));
  }

  span.remove();
}

function getCurrentTransform(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform();
  return [a, b, c, d, e, f];
}

function getCurrentTransformInverse(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform().invertSelf();
  return [a, b, c, d, e, f];
}

/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;

var _util = __w_pdfjs_require__(1);

class BaseCanvasFactory {
  constructor() {
    if (this.constructor === BaseCanvasFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
    }
  }

  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }

    const canvas = this._createCanvas(width, height);

    return {
      canvas,
      context: canvas.getContext("2d")
    };
  }

  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }

    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }

    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }

  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }

    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }

  _createCanvas(width, height) {
    (0, _util.unreachable)("Abstract method `_createCanvas` called.");
  }

}

exports.BaseCanvasFactory = BaseCanvasFactory;

class BaseCMapReaderFactory {
  constructor(_ref) {
    let {
      baseUrl = null,
      isCompressed = false
    } = _ref;

    if (this.constructor === BaseCMapReaderFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
    }

    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }

  async fetch(_ref2) {
    let {
      name
    } = _ref2;

    if (!this.baseUrl) {
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
    }

    if (!name) {
      throw new Error("CMap name must be specified.");
    }

    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
    return this._fetchData(url, compressionType).catch(reason => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }

  _fetchData(url, compressionType) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }

}

exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

class BaseStandardFontDataFactory {
  constructor(_ref3) {
    let {
      baseUrl = null
    } = _ref3;

    if (this.constructor === BaseStandardFontDataFactory) {
      (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
    }

    this.baseUrl = baseUrl;
  }

  async fetch(_ref4) {
    let {
      filename
    } = _ref4;

    if (!this.baseUrl) {
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');
    }

    if (!filename) {
      throw new Error("Font filename must be specified.");
    }

    const url = `${this.baseUrl}${filename}`;
    return this._fetchData(url).catch(reason => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }

  _fetchData(url) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }

}

exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;

class BaseSVGFactory {
  constructor() {
    if (this.constructor === BaseSVGFactory) {
      (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
    }
  }

  create(width, height) {
    let skipDimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }

    const svg = this._createSVG("svg:svg");

    svg.setAttribute("version", "1.1");

    if (!skipDimensions) {
      svg.setAttribute("width", `${width}px`);
      svg.setAttribute("height", `${height}px`);
    }

    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }

  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }

    return this._createSVG(type);
  }

  _createSVG(type) {
    (0, _util.unreachable)("Abstract method `_createSVG` called.");
  }

}

exports.BaseSVGFactory = BaseSVGFactory;

/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MurmurHash3_64 = void 0;

var _util = __w_pdfjs_require__(1);

const SEED = 0xc3d2e1f0;
const MASK_HIGH = 0xffff0000;
const MASK_LOW = 0xffff;

class MurmurHash3_64 {
  constructor(seed) {
    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }

  update(input) {
    let data, length;

    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;

      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);

        if (code <= 0xff) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 0xff;
        }
      }
    } else if ((0, _util.isArrayBuffer)(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
    }

    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0,
        k2 = 0;
    let h1 = this.h1,
        h2 = this.h2;
    const C1 = 0xcc9e2d51,
          C2 = 0x1b873593;
    const C1_LOW = C1 & MASK_LOW,
          C2_LOW = C2 & MASK_LOW;

    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 0xe6546b64;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 0xe6546b64;
      }
    }

    k1 = 0;

    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;

      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;

      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;

        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }

    }

    this.h1 = h1;
    this.h2 = h2;
  }

  hexdigest() {
    let h1 = this.h1,
        h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    const hex1 = (h1 >>> 0).toString(16),
          hex2 = (h2 >>> 0).toString(16);
    return hex1.padStart(8, "0") + hex2.padStart(8, "0");
  }

}

exports.MurmurHash3_64 = MurmurHash3_64;

/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontLoader = exports.FontFaceObject = void 0;

var _util = __w_pdfjs_require__(1);

class BaseFontLoader {
  constructor(_ref) {
    let {
      docId,
      onUnsupportedFeature,
      ownerDocument = globalThis.document,
      styleElement = null
    } = _ref;

    if (this.constructor === BaseFontLoader) {
      (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
    }

    this.docId = docId;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this._document = ownerDocument;
    this.nativeFontFaces = [];
    this.styleElement = null;
  }

  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.push(nativeFontFace);

    this._document.fonts.add(nativeFontFace);
  }

  insertRule(rule) {
    let styleElement = this.styleElement;

    if (!styleElement) {
      styleElement = this.styleElement = this._document.createElement("style");
      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;

      this._document.documentElement.getElementsByTagName("head")[0].append(styleElement);
    }

    const styleSheet = styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }

  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }

    this.nativeFontFaces.length = 0;

    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }

  async bind(font) {
    if (font.attached || font.missingFile) {
      return;
    }

    font.attached = true;

    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();

      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);

        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          this._onUnsupportedFeature({
            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
          });

          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }

      return;
    }

    const rule = font.createFontFaceRule();

    if (rule) {
      this.insertRule(rule);

      if (this.isSyncFontLoadingSupported) {
        return;
      }

      await new Promise(resolve => {
        const request = this._queueLoadingCallback(resolve);

        this._prepareFontLoadEvent([rule], [font], request);
      });
    }
  }

  _queueLoadingCallback(callback) {
    (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
  }

  get isFontLoadingAPISupported() {
    var _this$_document;

    const hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);
    return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
  }

  get isSyncFontLoadingSupported() {
    (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
  }

  get _loadTestFont() {
    (0, _util.unreachable)("Abstract method `_loadTestFont`.");
  }

  _prepareFontLoadEvent(rules, fontsToLoad, request) {
    (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
  }

}

let FontLoader;
exports.FontLoader = FontLoader;
{
  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
    constructor(params) {
      super(params);
      this.loadingContext = {
        requests: [],
        nextRequestId: 0
      };
      this.loadTestFontId = 0;
    }

    get isSyncFontLoadingSupported() {
      let supported = false;

      if (typeof navigator === "undefined") {
        supported = true;
      } else {
        const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

        if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {
          supported = true;
        }
      }

      return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
    }

    _queueLoadingCallback(callback) {
      function completeRequest() {
        (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
        request.done = true;

        while (context.requests.length > 0 && context.requests[0].done) {
          const otherRequest = context.requests.shift();
          setTimeout(otherRequest.callback, 0);
        }
      }

      const context = this.loadingContext;
      const request = {
        id: `pdfjs-font-loading-${context.nextRequestId++}`,
        done: false,
        complete: completeRequest,
        callback
      };
      context.requests.push(request);
      return request;
    }

    get _loadTestFont() {
      const getLoadTestFont = function () {
        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
      };

      return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
    }

    _prepareFontLoadEvent(rules, fonts, request) {
      function int32(data, offset) {
        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
      }

      function spliceString(s, offset, remove, insert) {
        const chunk1 = s.substring(0, offset);
        const chunk2 = s.substring(offset + remove);
        return chunk1 + insert + chunk2;
      }

      let i, ii;

      const canvas = this._document.createElement("canvas");

      canvas.width = 1;
      canvas.height = 1;
      const ctx = canvas.getContext("2d");
      let called = 0;

      function isFontReady(name, callback) {
        called++;

        if (called > 30) {
          (0, _util.warn)("Load test font never loaded.");
          callback();
          return;
        }

        ctx.font = "30px " + name;
        ctx.fillText(".", 0, 20);
        const imageData = ctx.getImageData(0, 0, 1, 1);

        if (imageData.data[3] > 0) {
          callback();
          return;
        }

        setTimeout(isFontReady.bind(null, name, callback));
      }

      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
      let data = this._loadTestFont;
      const COMMENT_OFFSET = 976;
      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
      const CFF_CHECKSUM_OFFSET = 16;
      const XXXX_VALUE = 0x58585858;
      let checksum = int32(data, CFF_CHECKSUM_OFFSET);

      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
      }

      if (i < loadTestFontId.length) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
      }

      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
      const url = `url(data:font/opentype;base64,${btoa(data)});`;
      const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
      this.insertRule(rule);
      const names = [];

      for (const font of fonts) {
        names.push(font.loadedName);
      }

      names.push(loadTestFontId);

      const div = this._document.createElement("div");

      div.style.visibility = "hidden";
      div.style.width = div.style.height = "10px";
      div.style.position = "absolute";
      div.style.top = div.style.left = "0px";

      for (const name of names) {
        const span = this._document.createElement("span");

        span.textContent = "Hi";
        span.style.fontFamily = name;
        div.append(span);
      }

      this._document.body.append(div);

      isFontReady(loadTestFontId, () => {
        div.remove();
        request.complete();
      });
    }

  };
}

class FontFaceObject {
  constructor(translatedData, _ref2) {
    let {
      isEvalSupported = true,
      disableFontFace = false,
      ignoreErrors = false,
      onUnsupportedFeature,
      fontRegistry = null
    } = _ref2;
    this.compiledGlyphs = Object.create(null);

    for (const i in translatedData) {
      this[i] = translatedData[i];
    }

    this.isEvalSupported = isEvalSupported !== false;
    this.disableFontFace = disableFontFace === true;
    this.ignoreErrors = ignoreErrors === true;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this.fontRegistry = fontRegistry;
  }

  createNativeFontFace() {
    if (!this.data || this.disableFontFace) {
      return null;
    }

    let nativeFontFace;

    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };

      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }

      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }

    if (this.fontRegistry) {
      this.fontRegistry.registerFont(this);
    }

    return nativeFontFace;
  }

  createFontFaceRule() {
    if (!this.data || this.disableFontFace) {
      return null;
    }

    const data = (0, _util.bytesToString)(this.data);
    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
    let rule;

    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;

      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }

      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }

    if (this.fontRegistry) {
      this.fontRegistry.registerFont(this, url);
    }

    return rule;
  }

  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== undefined) {
      return this.compiledGlyphs[character];
    }

    let cmds;

    try {
      cmds = objs.get(this.loadedName + "_path_" + character);
    } catch (ex) {
      if (!this.ignoreErrors) {
        throw ex;
      }

      this._onUnsupportedFeature({
        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
      });

      (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);
      return this.compiledGlyphs[character] = function (c, size) {};
    }

    return this.compiledGlyphs[character] = function (c, size) {
      for (const current of cmds) {
        if (current.cmd === "scale") {
          current.args = [size, -size];
        }

        c[current.cmd].apply(c, current.args);
      }
    };
  }

}

exports.FontFaceObject = FontFaceObject;

/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CanvasGraphics = void 0;

var _display_utils = __w_pdfjs_require__(133);

var _util = __w_pdfjs_require__(1);

var _pattern_helper = __w_pdfjs_require__(138);

var _image_utils = __w_pdfjs_require__(139);

var _is_node = __w_pdfjs_require__(3);

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

const MIN_FONT_SIZE = 16;
const MAX_FONT_SIZE = 100;
const MAX_GROUP_SIZE = 4096;
const EXECUTION_TIME = 15;
const EXECUTION_STEPS = 10;
const MAX_SIZE_TO_COMPILE = _is_node.isNodeJS && typeof Path2D === "undefined" ? -1 : 1000;
const FULL_CHUNK_HEIGHT = 16;

function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }

  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;

  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };

  ctx.save = function ctxSave() {
    destCtx.save();

    this.__originalSave();
  };

  ctx.restore = function ctxRestore() {
    destCtx.restore();

    this.__originalRestore();
  };

  ctx.translate = function ctxTranslate(x, y) {
    destCtx.translate(x, y);

    this.__originalTranslate(x, y);
  };

  ctx.scale = function ctxScale(x, y) {
    destCtx.scale(x, y);

    this.__originalScale(x, y);
  };

  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
    destCtx.transform(a, b, c, d, e, f);

    this.__originalTransform(a, b, c, d, e, f);
  };

  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
    destCtx.setTransform(a, b, c, d, e, f);

    this.__originalSetTransform(a, b, c, d, e, f);
  };

  ctx.resetTransform = function ctxResetTransform() {
    destCtx.resetTransform();

    this.__originalResetTransform();
  };

  ctx.rotate = function ctxRotate(angle) {
    destCtx.rotate(angle);

    this.__originalRotate(angle);
  };

  ctx.clip = function ctxRotate(rule) {
    destCtx.clip(rule);

    this.__originalClip(rule);
  };

  ctx.moveTo = function (x, y) {
    destCtx.moveTo(x, y);

    this.__originalMoveTo(x, y);
  };

  ctx.lineTo = function (x, y) {
    destCtx.lineTo(x, y);

    this.__originalLineTo(x, y);
  };

  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);

    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };

  ctx.rect = function (x, y, width, height) {
    destCtx.rect(x, y, width, height);

    this.__originalRect(x, y, width, height);
  };

  ctx.closePath = function () {
    destCtx.closePath();

    this.__originalClosePath();
  };

  ctx.beginPath = function () {
    destCtx.beginPath();

    this.__originalBeginPath();
  };
}

class CachedCanvases {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = Object.create(null);
  }

  getCanvas(id, width, height) {
    let canvasEntry;

    if (this.cache[id] !== undefined) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }

    return canvasEntry;
  }

  delete(id) {
    delete this.cache[id];
  }

  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }

}

function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);

  if (b === 0 && c === 0) {
    const tlX = destX * a + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rWidth, rHeight];
  }

  if (a === 0 && d === 0) {
    const tlX = destY * c + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rHeight, rWidth];
  }

  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a, b);
  const scaleY = Math.hypot(c, d);
  return [scaleX * destW, scaleY * destH];
}

function compileType3Glyph(imgData) {
  const {
    width,
    height
  } = imgData;

  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
    return null;
  }

  const POINT_TO_PROCESS_LIMIT = 1000;
  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  const width1 = width + 1;
  let points = new Uint8Array(width1 * (height + 1));
  let i, j, j0;
  const lineSize = width + 7 & ~7;
  let data = new Uint8Array(lineSize * height),
      pos = 0;

  for (const elem of imgData.data) {
    let mask = 128;

    while (mask > 0) {
      data[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }

  let count = 0;
  pos = 0;

  if (data[pos] !== 0) {
    points[0] = 1;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j] = data[pos] ? 2 : 1;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j] = 2;
    ++count;
  }

  for (i = 1; i < height; i++) {
    pos = i * lineSize;
    j0 = i * width1;

    if (data[pos - lineSize] !== data[pos]) {
      points[j0] = data[pos] ? 1 : 8;
      ++count;
    }

    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }

      pos++;
    }

    if (data[pos - lineSize] !== data[pos]) {
      points[j0 + j] = data[pos] ? 2 : 4;
      ++count;
    }

    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }

  pos = lineSize * (height - 1);
  j0 = i * width1;

  if (data[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j0 + j] = data[pos] ? 4 : 8;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }

  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }

  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  const path = new Path2D();

  for (i = 0; count && i <= height; i++) {
    let p = i * width1;
    const end = p + width;

    while (p < end && !points[p]) {
      p++;
    }

    if (p === end) {
      continue;
    }

    path.moveTo(p % width1, i);
    const p0 = p;
    let type = points[p];

    do {
      const step = steps[type];

      do {
        p += step;
      } while (!points[p]);

      const pp = points[p];

      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p] = 0;
      } else {
        type = pp & 0x33 * type >> 4;
        points[p] &= type >> 2 | type << 2;
      }

      path.lineTo(p % width1, p / width1 | 0);

      if (!points[p]) {
        --count;
      }
    } while (p0 !== p);

    --i;
  }

  data = null;
  points = null;

  const drawOutline = function (c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.fill(path);
    c.beginPath();
    c.restore();
  };

  return drawOutline;
}

class CanvasExtraState {
  constructor(width, height) {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = _util.IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = "#000000";
    this.strokeColor = "#000000";
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.transferMaps = null;
    this.startNewPathAndClipBox([0, 0, width, height]);
  }

  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    return clone;
  }

  setCurrentPoint(x, y) {
    this.x = x;
    this.y = y;
  }

  updatePathMinMax(transform, x, y) {
    [x, y] = _util.Util.applyTransform([x, y], transform);
    this.minX = Math.min(this.minX, x);
    this.minY = Math.min(this.minY, y);
    this.maxX = Math.max(this.maxX, x);
    this.maxY = Math.max(this.maxY, y);
  }

  updateRectMinMax(transform, rect) {
    const p1 = _util.Util.applyTransform(rect, transform);

    const p2 = _util.Util.applyTransform(rect.slice(2), transform);

    this.minX = Math.min(this.minX, p1[0], p2[0]);
    this.minY = Math.min(this.minY, p1[1], p2[1]);
    this.maxX = Math.max(this.maxX, p1[0], p2[0]);
    this.maxY = Math.max(this.maxY, p1[1], p2[1]);
  }

  updateScalingPathMinMax(transform, minMax) {
    _util.Util.scaleMinMax(transform, minMax);

    this.minX = Math.min(this.minX, minMax[0]);
    this.maxX = Math.max(this.maxX, minMax[1]);
    this.minY = Math.min(this.minY, minMax[2]);
    this.maxY = Math.max(this.maxY, minMax[3]);
  }

  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);

    if (minMax) {
      minMax[0] = Math.min(minMax[0], box[0], box[2]);
      minMax[1] = Math.max(minMax[1], box[0], box[2]);
      minMax[2] = Math.min(minMax[2], box[1], box[3]);
      minMax[3] = Math.max(minMax[3], box[1], box[3]);
      return;
    }

    this.updateRectMinMax(transform, box);
  }

  getPathBoundingBox() {
    let pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;
    let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const box = [this.minX, this.minY, this.maxX, this.maxY];

    if (pathType === _pattern_helper.PathType.STROKE) {
      if (!transform) {
        (0, _util.unreachable)("Stroke bounding box must include transform.");
      }

      const scale = _util.Util.singularValueDecompose2dScale(transform);

      const xStrokePad = scale[0] * this.lineWidth / 2;
      const yStrokePad = scale[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }

    return box;
  }

  updateClipFromPath() {
    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());

    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }

  isEmptyClip() {
    return this.minX === Infinity;
  }

  startNewPathAndClipBox(box) {
    this.clipBox = box;
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = 0;
    this.maxY = 0;
  }

  getClippedPathBoundingBox() {
    let pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;
    let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
  }

}

function putBinaryImageData(ctx, imgData) {
  let transferMaps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }

  const height = imgData.height,
        width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0,
      destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i, j, thisChunkHeight, elemsInThisChunk;
  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

  if (transferMaps) {
    switch (transferMaps.length) {
      case 1:
        transferMapRed = transferMaps[0];
        transferMapGreen = transferMaps[0];
        transferMapBlue = transferMaps[0];
        transferMapGray = transferMaps[0];
        break;

      case 4:
        transferMapRed = transferMaps[0];
        transferMapGreen = transferMaps[1];
        transferMapBlue = transferMaps[2];
        transferMapGray = transferMaps[3];
        break;
    }
  }

  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    let white = 0xffffffff;
    let black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;

    if (transferMapGray) {
      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
        [white, black] = [black, white];
      }
    }

    for (i = 0; i < totalChunks; i++) {
      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;

      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;

        for (; k < kEndUnrolled; k += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }

        for (; k < kEnd; k++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }

          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }

      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }

      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

    for (i = 0; i < fullChunks; i++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;

      if (hasTransferMaps) {
        for (let k = 0; k < elemsInThisChunk; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }

    if (i < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

      if (hasTransferMaps) {
        for (let k = 0; k < elemsInThisChunk; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;

    for (i = 0; i < totalChunks; i++) {
      if (i >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }

      destPos = 0;

      for (j = elemsInThisChunk; j--;) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }

      if (hasTransferMaps) {
        for (let k = 0; k < destPos; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}

function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }

  const height = imgData.height,
        width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;

  for (let i = 0; i < totalChunks; i++) {
    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = (0, _image_utils.applyMaskImageData)({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight
    }));
    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
  }
}

function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

  for (let i = 0, ii = properties.length; i < ii; i++) {
    const property = properties[i];

    if (sourceCtx[property] !== undefined) {
      destCtx[property] = sourceCtx[property];
    }
  }

  if (sourceCtx.setLineDash !== undefined) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}

function resetCtxToDefault(ctx, foregroundColor) {
  ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";

  if (ctx.setLineDash !== undefined) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
}

function composeSMaskBackdrop(bytes, r0, g0, b0) {
  const length = bytes.length;

  for (let i = 3; i < length; i += 4) {
    const alpha = bytes[i];

    if (alpha === 0) {
      bytes[i - 3] = r0;
      bytes[i - 2] = g0;
      bytes[i - 1] = b0;
    } else if (alpha < 255) {
      const alpha_ = 255 - alpha;
      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
    }
  }
}

function composeSMaskAlpha(maskData, layerData, transferMap) {
  const length = maskData.length;
  const scale = 1 / 255;

  for (let i = 3; i < length; i += 4) {
    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
    layerData[i] = layerData[i] * alpha * scale | 0;
  }
}

function composeSMaskLuminosity(maskData, layerData, transferMap) {
  const length = maskData.length;

  for (let i = 3; i < length; i += 4) {
    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
  }
}

function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
  const hasBackdrop = !!backdrop;
  const r0 = hasBackdrop ? backdrop[0] : 0;
  const g0 = hasBackdrop ? backdrop[1] : 0;
  const b0 = hasBackdrop ? backdrop[2] : 0;
  let composeFn;

  if (subtype === "Luminosity") {
    composeFn = composeSMaskLuminosity;
  } else {
    composeFn = composeSMaskAlpha;
  }

  const PIXELS_TO_PROCESS = 1048576;
  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

  for (let row = 0; row < height; row += chunkSize) {
    const chunkHeight = Math.min(chunkSize, height - row);
    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);

    if (hasBackdrop) {
      composeSMaskBackdrop(maskData.data, r0, g0, b0);
    }

    composeFn(maskData.data, layerData.data, transferMap);
    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
  }
}

function composeSMask(ctx, smask, layerCtx, layerBox) {
  const layerOffsetX = layerBox[0];
  const layerOffsetY = layerBox[1];
  const layerWidth = layerBox[2] - layerOffsetX;
  const layerHeight = layerBox[3] - layerOffsetY;

  if (layerWidth === 0 || layerHeight === 0) {
    return;
  }

  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.drawImage(layerCtx.canvas, 0, 0);
  ctx.restore();
}

function getImageSmoothingEnabled(transform, interpolate) {
  const scale = _util.Util.singularValueDecompose2dScale(transform);

  scale[0] = Math.fround(scale[0]);
  scale[1] = Math.fround(scale[1]);
  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);

  if (interpolate !== undefined) {
    return interpolate;
  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
    return true;
  }

  return false;
}

const LINE_CAP_STYLES = ["butt", "round", "square"];
const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
const NORMAL_CLIP = {};
const EO_CLIP = {};

var _restoreInitialState = /*#__PURE__*/new WeakSet();

class CanvasGraphics {
  constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
    _classPrivateMethodInitSpec(this, _restoreInitialState);

    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.imageLayer = imageLayer;
    this.groupStack = [];
    this.processingType3 = null;
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.backgroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.background) || null;
    this.foregroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.foreground) || null;
    this._cachedScaleForStroking = null;
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = new Map();
  }

  getObject(data) {
    let fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (typeof data === "string") {
      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
    }

    return fallback;
  }

  beginDrawing(_ref) {
    let {
      transform,
      viewport,
      transparency = false,
      background = null
    } = _ref;
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const defaultBackgroundColor = background || "#ffffff";
    this.ctx.save();

    if (this.foregroundColor && this.backgroundColor) {
      this.ctx.fillStyle = this.foregroundColor;
      const fg = this.foregroundColor = this.ctx.fillStyle;
      this.ctx.fillStyle = this.backgroundColor;
      const bg = this.backgroundColor = this.ctx.fillStyle;
      let isValidDefaultBg = true;
      let defaultBg = defaultBackgroundColor;
      this.ctx.fillStyle = defaultBackgroundColor;
      defaultBg = this.ctx.fillStyle;
      isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);

      if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
        this.foregroundColor = this.backgroundColor = null;
      } else {
        const [rB, gB, bB] = (0, _display_utils.getRGB)(defaultBg);

        const newComp = x => {
          x /= 255;
          return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
        };

        const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));

        this.selectColor = (r, g, b) => {
          const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
          return Math.round(lumC) === lumB ? bg : fg;
        };
      }
    }

    this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.restore();

    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));
    }

    this.ctx.save();
    resetCtxToDefault(this.ctx, this.foregroundColor);

    if (transform) {
      this.ctx.transform(...transform);
      this.outputScaleX = transform[0];
      this.outputScaleY = transform[0];
    }

    this.ctx.transform(...viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);

    if (this.imageLayer) {
      (0, _display_utils.deprecated)("The `imageLayer` functionality will be removed in the future.");
      this.imageLayer.beginLayout();
    }
  }

  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;

    if (argsArrayLen === i) {
      return i;
    }

    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId;

    while (true) {
      if (stepper !== undefined && i === stepper.nextBreakPoint) {
        stepper.breakIt(i, continueCallback);
        return i;
      }

      fnId = fnArray[i];

      if (fnId !== _util.OPS.dependency) {
        this[fnId].apply(this, argsArray[i]);
      } else {
        for (const depObjId of argsArray[i]) {
          const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

          if (!objsPool.has(depObjId)) {
            objsPool.get(depObjId, continueCallback);
            return i;
          }
        }
      }

      i++;

      if (i === argsArrayLen) {
        return i;
      }

      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i;
        }

        steps = 0;
      }
    }
  }

  endDrawing() {
    _classPrivateMethodGet(this, _restoreInitialState, _restoreInitialState2).call(this);

    this.cachedCanvases.clear();
    this.cachedPatterns.clear();

    for (const cache of this._cachedBitmapsMap.values()) {
      for (const canvas of cache.values()) {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          canvas.width = canvas.height = 0;
        }
      }

      cache.clear();
    }

    this._cachedBitmapsMap.clear();

    if (this.imageLayer) {
      this.imageLayer.endLayout();
    }
  }

  _scaleImage(img, inverseTransform) {
    const width = img.width;
    const height = img.height;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width,
        paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;

    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth,
          newHeight = paintHeight;

      if (widthScale > 2 && paintWidth > 1) {
        newWidth = Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }

      if (heightScale > 2 && paintHeight > 1) {
        newHeight = Math.ceil(paintHeight / 2);
        heightScale /= paintHeight / newHeight;
      }

      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }

    return {
      img,
      paintWidth,
      paintHeight
    };
  }

  _createMaskCanvas(img) {
    const ctx = this.ctx;
    const {
      width,
      height
    } = img;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    let cache, cacheKey, scaled, maskCanvas;

    if ((img.bitmap || img.data) && img.count > 1) {
      const mainKey = img.bitmap || img.data.buffer;
      const withoutTranslation = currentTransform.slice(0, 4);
      cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
      cache = this._cachedBitmapsMap.get(mainKey);

      if (!cache) {
        cache = new Map();

        this._cachedBitmapsMap.set(mainKey, cache);
      }

      const cachedImage = cache.get(cacheKey);

      if (cachedImage && !isPatternFill) {
        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
        return {
          canvas: cachedImage,
          offsetX,
          offsetY
        };
      }

      scaled = cachedImage;
    }

    if (!scaled) {
      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      putBinaryImageMask(maskCanvas.context, img);
    }

    let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);

    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);

    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);

    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);

    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);

    const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
    const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
    const fillCtx = fillCanvas.context;
    const offsetX = Math.min(cord1[0], cord2[0]);
    const offsetY = Math.min(cord1[1], cord2[1]);
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform(...maskToCanvas);

    if (!scaled) {
      scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));
      scaled = scaled.img;

      if (cache && isPatternFill) {
        cache.set(cacheKey, scaled);
      }
    }

    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);
    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";

    const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);

    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
    fillCtx.fillRect(0, 0, width, height);

    if (cache && !isPatternFill) {
      this.cachedCanvases.delete("fillCanvas");
      cache.set(cacheKey, fillCanvas.canvas);
    }

    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }

  setLineWidth(width) {
    if (width !== this.current.lineWidth) {
      this._cachedScaleForStroking = null;
    }

    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }

  setLineCap(style) {
    this.ctx.lineCap = LINE_CAP_STYLES[style];
  }

  setLineJoin(style) {
    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
  }

  setMiterLimit(limit) {
    this.ctx.miterLimit = limit;
  }

  setDash(dashArray, dashPhase) {
    const ctx = this.ctx;

    if (ctx.setLineDash !== undefined) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }

  setRenderingIntent(intent) {}

  setFlatness(flatness) {}

  setGState(states) {
    for (let i = 0, ii = states.length; i < ii; i++) {
      const state = states[i];
      const key = state[0];
      const value = state[1];

      switch (key) {
        case "LW":
          this.setLineWidth(value);
          break;

        case "LC":
          this.setLineCap(value);
          break;

        case "LJ":
          this.setLineJoin(value);
          break;

        case "ML":
          this.setMiterLimit(value);
          break;

        case "D":
          this.setDash(value[0], value[1]);
          break;

        case "RI":
          this.setRenderingIntent(value);
          break;

        case "FL":
          this.setFlatness(value);
          break;

        case "Font":
          this.setFont(value[0], value[1]);
          break;

        case "CA":
          this.current.strokeAlpha = state[1];
          break;

        case "ca":
          this.current.fillAlpha = state[1];
          this.ctx.globalAlpha = state[1];
          break;

        case "BM":
          this.ctx.globalCompositeOperation = value;
          break;

        case "SMask":
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;

        case "TR":
          this.current.transferMaps = value;
      }
    }
  }

  get inSMaskMode() {
    return !!this.suspendedCtx;
  }

  checkSMaskState() {
    const inSMaskMode = this.inSMaskMode;

    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }

  beginSMaskMode() {
    if (this.inSMaskMode) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }

    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    this.suspendedCtx = this.ctx;
    this.ctx = scratchCanvas.context;
    const ctx = this.ctx;
    ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }

  endSMaskMode() {
    if (!this.inSMaskMode) {
      throw new Error("endSMaskMode called while not in smask mode");
    }

    this.ctx._removeMirroring();

    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }

  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }

    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }

    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }

  save() {
    if (this.inSMaskMode) {
      copyCtxState(this.ctx, this.suspendedCtx);
      this.suspendedCtx.save();
    } else {
      this.ctx.save();
    }

    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
  }

  restore() {
    if (this.stateStack.length === 0 && this.inSMaskMode) {
      this.endSMaskMode();
    }

    if (this.stateStack.length !== 0) {
      this.current = this.stateStack.pop();

      if (this.inSMaskMode) {
        this.suspendedCtx.restore();
        copyCtxState(this.suspendedCtx, this.ctx);
      } else {
        this.ctx.restore();
      }

      this.checkSMaskState();
      this.pendingClip = null;
      this._cachedScaleForStroking = null;
      this._cachedGetSinglePixelWidth = null;
    }
  }

  transform(a, b, c, d, e, f) {
    this.ctx.transform(a, b, c, d, e, f);
    this._cachedScaleForStroking = null;
    this._cachedGetSinglePixelWidth = null;
  }

  constructPath(ops, args, minMax) {
    const ctx = this.ctx;
    const current = this.current;
    let x = current.x,
        y = current.y;
    let startX, startY;
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;

    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
      switch (ops[i] | 0) {
        case _util.OPS.rectangle:
          x = args[j++];
          y = args[j++];
          const width = args[j++];
          const height = args[j++];
          const xw = x + width;
          const yh = y + height;
          ctx.moveTo(x, y);

          if (width === 0 || height === 0) {
            ctx.lineTo(xw, yh);
          } else {
            ctx.lineTo(xw, y);
            ctx.lineTo(xw, yh);
            ctx.lineTo(x, yh);
          }

          if (!isScalingMatrix) {
            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
          }

          ctx.closePath();
          break;

        case _util.OPS.moveTo:
          x = args[j++];
          y = args[j++];
          ctx.moveTo(x, y);

          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x, y);
          }

          break;

        case _util.OPS.lineTo:
          x = args[j++];
          y = args[j++];
          ctx.lineTo(x, y);

          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x, y);
          }

          break;

        case _util.OPS.curveTo:
          startX = x;
          startY = y;
          x = args[j + 4];
          y = args[j + 5];
          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
          j += 6;
          break;

        case _util.OPS.curveTo2:
          startX = x;
          startY = y;
          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
          x = args[j + 2];
          y = args[j + 3];
          j += 4;
          break;

        case _util.OPS.curveTo3:
          startX = x;
          startY = y;
          x = args[j + 2];
          y = args[j + 3];
          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
          j += 4;
          break;

        case _util.OPS.closePath:
          ctx.closePath();
          break;
      }
    }

    if (isScalingMatrix) {
      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
    }

    current.setCurrentPoint(x, y);
  }

  closePath() {
    this.ctx.closePath();
  }

  stroke(consumePath) {
    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;

    if (this.contentVisible) {
      if (typeof strokeColor === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
        this.rescaleAndStroke(false);
        ctx.restore();
      } else {
        this.rescaleAndStroke(true);
      }
    }

    if (consumePath) {
      this.consumePath(this.current.getClippedPathBoundingBox());
    }

    ctx.globalAlpha = this.current.fillAlpha;
  }

  closeStroke() {
    this.closePath();
    this.stroke();
  }

  fill(consumePath) {
    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;

    if (isPatternFill) {
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
      needRestore = true;
    }

    const intersect = this.current.getClippedPathBoundingBox();

    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill("evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill();
      }
    }

    if (needRestore) {
      ctx.restore();
    }

    if (consumePath) {
      this.consumePath(intersect);
    }
  }

  eoFill() {
    this.pendingEOFill = true;
    this.fill();
  }

  fillStroke() {
    this.fill(false);
    this.stroke(false);
    this.consumePath();
  }

  eoFillStroke() {
    this.pendingEOFill = true;
    this.fillStroke();
  }

  closeFillStroke() {
    this.closePath();
    this.fillStroke();
  }

  closeEOFillStroke() {
    this.pendingEOFill = true;
    this.closePath();
    this.fillStroke();
  }

  endPath() {
    this.consumePath();
  }

  clip() {
    this.pendingClip = NORMAL_CLIP;
  }

  eoClip() {
    this.pendingClip = EO_CLIP;
  }

  beginText() {
    this.current.textMatrix = _util.IDENTITY_MATRIX;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }

  endText() {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;

    if (paths === undefined) {
      ctx.beginPath();
      return;
    }

    ctx.save();
    ctx.beginPath();

    for (const path of paths) {
      ctx.setTransform(...path.transform);
      ctx.translate(path.x, path.y);
      path.addToPath(ctx, path.fontSize);
    }

    ctx.restore();
    ctx.clip();
    ctx.beginPath();
    delete this.pendingTextPaths;
  }

  setCharSpacing(spacing) {
    this.current.charSpacing = spacing;
  }

  setWordSpacing(spacing) {
    this.current.wordSpacing = spacing;
  }

  setHScale(scale) {
    this.current.textHScale = scale / 100;
  }

  setLeading(leading) {
    this.current.leading = -leading;
  }

  setFont(fontRefName, size) {
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;

    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }

    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      (0, _util.warn)("Invalid font matrix for font " + fontRefName);
    }

    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }

    this.current.font = fontObj;
    this.current.fontSize = size;

    if (fontObj.isType3Font) {
      return;
    }

    const name = fontObj.loadedName || "sans-serif";
    let bold = "normal";

    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }

    const italic = fontObj.italic ? "italic" : "normal";
    const typeface = `"${name}", ${fontObj.fallbackName}`;
    let browserFontSize = size;

    if (size < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }

    this.current.fontSizeScale = size / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }

  setTextRenderingMode(mode) {
    this.current.textRenderingMode = mode;
  }

  setTextRise(rise) {
    this.current.textRise = rise;
  }

  moveText(x, y) {
    this.current.x = this.current.lineX += x;
    this.current.y = this.current.lineY += y;
  }

  setLeadingMoveText(x, y) {
    this.setLeading(-y);
    this.moveText(x, y);
  }

  setTextMatrix(a, b, c, d, e, f) {
    this.current.textMatrix = [a, b, c, d, e, f];
    this.current.textMatrixScale = Math.hypot(a, b);
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }

  nextLine() {
    this.moveText(0, this.current.leading);
  }

  paintChar(character, x, y, patternTransform) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    let addToPath;

    if (font.disableFontFace || isAddToPathSet || patternFill) {
      addToPath = font.getPathGenerator(this.commonObjs, character);
    }

    if (font.disableFontFace || patternFill) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      addToPath(ctx, fontSize);

      if (patternTransform) {
        ctx.setTransform(...patternTransform);
      }

      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.fill();
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.stroke();
      }

      ctx.restore();
    } else {
      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x, y);
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.strokeText(character, x, y);
      }
    }

    if (isAddToPathSet) {
      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
      paths.push({
        transform: (0, _display_utils.getCurrentTransform)(ctx),
        x,
        y,
        fontSize,
        addToPath
      });
    }
  }

  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;

    for (let i = 3; i < data.length; i += 4) {
      if (data[i] > 0 && data[i] < 255) {
        enabled = true;
        break;
      }
    }

    return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
  }

  showText(glyphs) {
    const current = this.current;
    const font = current.font;

    if (font.isType3Font) {
      return this.showType3Text(glyphs);
    }

    const fontSize = current.fontSize;

    if (fontSize === 0) {
      return undefined;
    }

    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y + current.textRise);

    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }

    let patternTransform;

    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
      patternTransform = (0, _display_utils.getCurrentTransform)(ctx);
      ctx.restore();
      ctx.fillStyle = pattern;
    }

    let lineWidth = current.lineWidth;
    const scale = current.textMatrixScale;

    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        lineWidth = this.getSinglePixelWidth();
      }
    } else {
      lineWidth /= scale;
    }

    if (fontSizeScale !== 1.0) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }

    ctx.lineWidth = lineWidth;
    let x = 0,
        i;

    for (i = 0; i < glyphsLength; ++i) {
      const glyph = glyphs[i];

      if (typeof glyph === "number") {
        x += spacingDir * glyph * fontSize / 1000;
        continue;
      }

      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;

      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x + vy) / fontSizeScale;
      } else {
        scaledX = x / fontSizeScale;
        scaledY = 0;
      }

      if (font.remeasure && width > 0) {
        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
        }
      }

      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
        } else {
          this.paintChar(character, scaledX, scaledY, patternTransform);

          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
          }
        }
      }

      let charWidth;

      if (vertical) {
        charWidth = width * widthAdvanceScale - spacing * fontDirection;
      } else {
        charWidth = width * widthAdvanceScale + spacing * fontDirection;
      }

      x += charWidth;

      if (restoreNeeded) {
        ctx.restore();
      }
    }

    if (vertical) {
      current.y -= x;
    } else {
      current.x += x * textHScale;
    }

    ctx.restore();
    this.compose();
    return undefined;
  }

  showType3Text(glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
    let i, glyph, width, spacingLength;

    if (isTextInvisible || fontSize === 0) {
      return;
    }

    this._cachedScaleForStroking = null;
    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y);
    ctx.scale(textHScale, fontDirection);

    for (i = 0; i < glyphsLength; ++i) {
      glyph = glyphs[i];

      if (typeof glyph === "number") {
        spacingLength = spacingDir * glyph * fontSize / 1000;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }

      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];

      if (!operatorList) {
        (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
        continue;
      }

      if (this.contentVisible) {
        this.processingType3 = glyph;
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform(...fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }

      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

      width = transformed[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }

    ctx.restore();
    this.processingType3 = null;
  }

  setCharWidth(xWidth, yWidth) {}

  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
    this.ctx.rect(llx, lly, urx - llx, ury - lly);
    this.ctx.clip();
    this.endPath();
  }

  getColorN_Pattern(IR) {
    let pattern;

    if (IR[0] === "TilingPattern") {
      const color = IR[1];
      const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);
      const canvasGraphicsFactory = {
        createCanvasGraphics: ctx => {
          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
        }
      };
      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(IR[1], IR[2]);
    }

    return pattern;
  }

  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }

  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments);
    this.current.patternFill = true;
  }

  setStrokeRGBColor(r, g, b) {
    var _this$selectColor;

    const color = ((_this$selectColor = this.selectColor) === null || _this$selectColor === void 0 ? void 0 : _this$selectColor.call(this, r, g, b)) || _util.Util.makeHexColor(r, g, b);

    this.ctx.strokeStyle = color;
    this.current.strokeColor = color;
  }

  setFillRGBColor(r, g, b) {
    var _this$selectColor2;

    const color = ((_this$selectColor2 = this.selectColor) === null || _this$selectColor2 === void 0 ? void 0 : _this$selectColor2.call(this, r, g, b)) || _util.Util.makeHexColor(r, g, b);

    this.ctx.fillStyle = color;
    this.current.fillColor = color;
    this.current.patternFill = false;
  }

  _getPattern(objId) {
    let matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let pattern;

    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
      this.cachedPatterns.set(objId, pattern);
    }

    if (matrix) {
      pattern.matrix = matrix;
    }

    return pattern;
  }

  shadingFill(objId) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    this.save();

    const pattern = this._getPattern(objId);

    ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
    const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);

    if (inv) {
      const canvas = ctx.canvas;
      const width = canvas.width;
      const height = canvas.height;

      const bl = _util.Util.applyTransform([0, 0], inv);

      const br = _util.Util.applyTransform([0, height], inv);

      const ul = _util.Util.applyTransform([width, 0], inv);

      const ur = _util.Util.applyTransform([width, height], inv);

      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }

    this.compose(this.current.getClippedPathBoundingBox());
    this.restore();
  }

  beginInlineImage() {
    (0, _util.unreachable)("Should not call beginInlineImage");
  }

  beginImageData() {
    (0, _util.unreachable)("Should not call beginImageData");
  }

  paintFormXObjectBegin(matrix, bbox) {
    if (!this.contentVisible) {
      return;
    }

    this.save();
    this.baseTransformStack.push(this.baseTransform);

    if (Array.isArray(matrix) && matrix.length === 6) {
      this.transform(...matrix);
    }

    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);

    if (bbox) {
      const width = bbox[2] - bbox[0];
      const height = bbox[3] - bbox[1];
      this.ctx.rect(bbox[0], bbox[1], width, height);
      this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);
      this.clip();
      this.endPath();
    }
  }

  paintFormXObjectEnd() {
    if (!this.contentVisible) {
      return;
    }

    this.restore();
    this.baseTransform = this.baseTransformStack.pop();
  }

  beginGroup(group) {
    if (!this.contentVisible) {
      return;
    }

    this.save();

    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }

    const currentCtx = this.ctx;

    if (!group.isolated) {
      (0, _util.info)("TODO: Support non-isolated groups.");
    }

    if (group.knockout) {
      (0, _util.warn)("Knockout groups not supported.");
    }

    const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);

    if (group.matrix) {
      currentCtx.transform(...group.matrix);
    }

    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }

    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));

    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    let scaleX = 1,
        scaleY = 1;

    if (drawnWidth > MAX_GROUP_SIZE) {
      scaleX = drawnWidth / MAX_GROUP_SIZE;
      drawnWidth = MAX_GROUP_SIZE;
    }

    if (drawnHeight > MAX_GROUP_SIZE) {
      scaleY = drawnHeight / MAX_GROUP_SIZE;
      drawnHeight = MAX_GROUP_SIZE;
    }

    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;

    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }

    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    const groupCtx = scratchCanvas.context;
    groupCtx.scale(1 / scaleX, 1 / scaleY);
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform(...currentTransform);

    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        scaleX,
        scaleY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    } else {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.scale(scaleX, scaleY);
      currentCtx.save();
    }

    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(currentCtx);
    this.groupLevel++;
  }

  endGroup(group) {
    if (!this.contentVisible) {
      return;
    }

    this.groupLevel--;
    const groupCtx = this.ctx;
    const ctx = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;

    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore();
    } else {
      this.ctx.restore();
      const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);
      this.restore();
      this.ctx.save();
      this.ctx.setTransform(...currentMtx);

      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);

      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }

  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
    _classPrivateMethodGet(this, _restoreInitialState, _restoreInitialState2).call(this);

    resetCtxToDefault(this.ctx, this.foregroundColor);
    this.ctx.save();
    this.save();

    if (this.baseTransform) {
      this.ctx.setTransform(...this.baseTransform);
    }

    if (Array.isArray(rect) && rect.length === 4) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];

      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform = transform.slice();
        transform[4] -= rect[0];
        transform[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;

        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));

        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(id, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context;
        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
        resetCtxToDefault(this.ctx, this.foregroundColor);
      } else {
        resetCtxToDefault(this.ctx, this.foregroundColor);
        this.ctx.rect(rect[0], rect[1], width, height);
        this.ctx.clip();
        this.endPath();
      }
    }

    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(...transform);
    this.transform(...matrix);
  }

  endAnnotation() {
    if (this.annotationCanvas) {
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }

  paintImageMaskXObject(img) {
    if (!this.contentVisible) {
      return;
    }

    const count = img.count;
    img = this.getObject(img.data, img);
    img.count = count;
    const ctx = this.ctx;
    const glyph = this.processingType3;

    if (glyph) {
      if (glyph.compiled === undefined) {
        glyph.compiled = compileType3Glyph(img);
      }

      if (glyph.compiled) {
        glyph.compiled(ctx);
        return;
      }
    }

    const mask = this._createMaskCanvas(img);

    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    ctx.restore();
    this.compose();
  }

  paintImageMaskXObjectRepeat(img, scaleX) {
    let skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let scaleY = arguments.length > 4 ? arguments[4] : undefined;
    let positions = arguments.length > 5 ? arguments[5] : undefined;

    if (!this.contentVisible) {
      return;
    }

    img = this.getObject(img.data, img);
    const ctx = this.ctx;
    ctx.save();
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);

    const mask = this._createMaskCanvas(img);

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);

      const [x, y] = _util.Util.applyTransform([0, 0], trans);

      ctx.drawImage(mask.canvas, x, y);
    }

    ctx.restore();
    this.compose();
  }

  paintImageMaskXObjectGroup(images) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;

    for (const image of images) {
      const {
        data,
        width,
        height,
        transform
      } = image;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      const img = this.getObject(data, image);
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform(...transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      ctx.restore();
    }

    this.compose();
  }

  paintImageXObject(objId) {
    if (!this.contentVisible) {
      return;
    }

    const imgData = this.getObject(objId);

    if (!imgData) {
      (0, _util.warn)("Dependent image isn't ready yet");
      return;
    }

    this.paintInlineImageXObject(imgData);
  }

  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }

    const imgData = this.getObject(objId);

    if (!imgData) {
      (0, _util.warn)("Dependent image isn't ready yet");
      return;
    }

    const width = imgData.width;
    const height = imgData.height;
    const map = [];

    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      map.push({
        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }

    this.paintInlineImageXObjectGroup(imgData, map);
  }

  paintInlineImageXObject(imgData) {
    if (!this.contentVisible) {
      return;
    }

    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save();
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;

    if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
      imgToPaint = tmpCanvas.canvas;
    }

    const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));

    ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);
    const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);

    if (this.imageLayer) {
      const [left, top] = _util.Util.applyTransform([0, -height], (0, _display_utils.getCurrentTransform)(this.ctx));

      this.imageLayer.appendImage({
        imgData,
        left,
        top,
        width: rWidth,
        height: rHeight
      });
    }

    this.compose();
    this.restore();
  }

  paintInlineImageXObjectGroup(imgData, map) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    const w = imgData.width;
    const h = imgData.height;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
    const tmpCtx = tmpCanvas.context;
    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

    for (const entry of map) {
      ctx.save();
      ctx.transform(...entry.transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

      if (this.imageLayer) {
        const [left, top] = _util.Util.applyTransform([entry.x, entry.y], (0, _display_utils.getCurrentTransform)(this.ctx));

        this.imageLayer.appendImage({
          imgData,
          left,
          top,
          width: w,
          height: h
        });
      }

      ctx.restore();
    }

    this.compose();
  }

  paintSolidColorImageMask() {
    if (!this.contentVisible) {
      return;
    }

    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }

  markPoint(tag) {}

  markPointProps(tag, properties) {}

  beginMarkedContent(tag) {
    this.markedContentStack.push({
      visible: true
    });
  }

  beginMarkedContentProps(tag, properties) {
    if (tag === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }

    this.contentVisible = this.isContentVisible();
  }

  endMarkedContent() {
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }

  beginCompat() {}

  endCompat() {}

  consumePath(clipBox) {
    const isEmpty = this.current.isEmptyClip();

    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }

    if (!this.pendingClip) {
      this.compose(clipBox);
    }

    const ctx = this.ctx;

    if (this.pendingClip) {
      if (!isEmpty) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip("evenodd");
        } else {
          ctx.clip();
        }
      }

      this.pendingClip = null;
    }

    this.current.startNewPathAndClipBox(this.current.clipBox);
    ctx.beginPath();
  }

  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const m = (0, _display_utils.getCurrentTransform)(this.ctx);

      if (m[1] === 0 && m[2] === 0) {
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
      } else {
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const normX = Math.hypot(m[0], m[2]);
        const normY = Math.hypot(m[1], m[3]);
        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
      }
    }

    return this._cachedGetSinglePixelWidth;
  }

  getScaleForStroking() {
    if (!this._cachedScaleForStroking) {
      const {
        lineWidth
      } = this.current;
      const m = (0, _display_utils.getCurrentTransform)(this.ctx);
      let scaleX, scaleY;

      if (m[1] === 0 && m[2] === 0) {
        const normX = Math.abs(m[0]);
        const normY = Math.abs(m[3]);

        if (lineWidth === 0) {
          scaleX = 1 / normX;
          scaleY = 1 / normY;
        } else {
          const scaledXLineWidth = normX * lineWidth;
          const scaledYLineWidth = normY * lineWidth;
          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
        }
      } else {
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const normX = Math.hypot(m[0], m[1]);
        const normY = Math.hypot(m[2], m[3]);

        if (lineWidth === 0) {
          scaleX = normY / absDet;
          scaleY = normX / absDet;
        } else {
          const baseArea = lineWidth * absDet;
          scaleX = normY > baseArea ? normY / baseArea : 1;
          scaleY = normX > baseArea ? normX / baseArea : 1;
        }
      }

      this._cachedScaleForStroking = [scaleX, scaleY];
    }

    return this._cachedScaleForStroking;
  }

  rescaleAndStroke(saveRestore) {
    const {
      ctx
    } = this;
    const {
      lineWidth
    } = this.current;
    const [scaleX, scaleY] = this.getScaleForStroking();
    ctx.lineWidth = lineWidth || 1;

    if (scaleX === 1 && scaleY === 1) {
      ctx.stroke();
      return;
    }

    let savedMatrix, savedDashes, savedDashOffset;

    if (saveRestore) {
      savedMatrix = (0, _display_utils.getCurrentTransform)(ctx);
      savedDashes = ctx.getLineDash().slice();
      savedDashOffset = ctx.lineDashOffset;
    }

    ctx.scale(scaleX, scaleY);
    const scale = Math.max(scaleX, scaleY);
    ctx.setLineDash(ctx.getLineDash().map(x => x / scale));
    ctx.lineDashOffset /= scale;
    ctx.stroke();

    if (saveRestore) {
      ctx.setTransform(...savedMatrix);
      ctx.setLineDash(savedDashes);
      ctx.lineDashOffset = savedDashOffset;
    }
  }

  isContentVisible() {
    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
      if (!this.markedContentStack[i].visible) {
        return false;
      }
    }

    return true;
  }

}

exports.CanvasGraphics = CanvasGraphics;

function _restoreInitialState2() {
  while (this.stateStack.length || this.inSMaskMode) {
    this.restore();
  }

  this.ctx.restore();

  if (this.transparentCanvas) {
    this.ctx = this.compositeCtx;
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.drawImage(this.transparentCanvas, 0, 0);
    this.ctx.restore();
    this.transparentCanvas = null;
  }
}

for (const op in _util.OPS) {
  if (CanvasGraphics.prototype[op] !== undefined) {
    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
  }
}

/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TilingPattern = exports.PathType = void 0;
exports.getShadingPattern = getShadingPattern;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(133);

var _is_node = __w_pdfjs_require__(3);

const PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
exports.PathType = PathType;

function applyBoundingBox(ctx, bbox) {
  if (!bbox || _is_node.isNodeJS) {
    return;
  }

  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}

class BaseShadingPattern {
  constructor() {
    if (this.constructor === BaseShadingPattern) {
      (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
    }
  }

  getPattern() {
    (0, _util.unreachable)("Abstract method `getPattern` called.");
  }

}

class RadialAxialShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }

  _createGradient(ctx) {
    let grad;

    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }

    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }

    return grad;
  }

  getPattern(ctx, owner, inverse, pathType) {
    let pattern;

    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform(...owner.baseTransform);

      if (this.matrix) {
        tmpCtx.transform(...this.matrix);
      }

      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);

      try {
        pattern.setTransform(domMatrix);
      } catch (ex) {
        (0, _util.warn)(`RadialAxialShadingPattern.getPattern: "${ex === null || ex === void 0 ? void 0 : ex.message}".`);
      }
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }

    return pattern;
  }

}

function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords,
        colors = context.colors;
  const bytes = data.data,
        rowSize = data.width * 4;
  let tmp;

  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }

  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

  if (y1 >= y3) {
    return;
  }

  const c1r = colors[c1],
        c1g = colors[c1 + 1],
        c1b = colors[c1 + 2];
  const c2r = colors[c2],
        c2g = colors[c2 + 1],
        c2b = colors[c2 + 2];
  const c3r = colors[c3],
        c3g = colors[c3 + 1],
        c3b = colors[c3 + 2];
  const minY = Math.round(y1),
        maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;

  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      let k;

      if (y < y1) {
        k = 0;
      } else {
        k = (y1 - y) / (y1 - y2);
      }

      xa = x1 - (x1 - x2) * k;
      car = c1r - (c1r - c2r) * k;
      cag = c1g - (c1g - c2g) * k;
      cab = c1b - (c1b - c2b) * k;
    } else {
      let k;

      if (y > y3) {
        k = 1;
      } else if (y2 === y3) {
        k = 0;
      } else {
        k = (y2 - y) / (y2 - y3);
      }

      xa = x2 - (x2 - x3) * k;
      car = c2r - (c2r - c3r) * k;
      cag = c2g - (c2g - c3g) * k;
      cab = c2b - (c2b - c3b) * k;
    }

    let k;

    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }

    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;

    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);

      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }

      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}

function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;

  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;

      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;

        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }

      break;

    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }

      break;

    default:
      throw new Error("illegal figure");
  }
}

class MeshShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[7];
    this._background = IR[8];
    this.matrix = null;
  }

  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3000;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);

    if (backgroundColor) {
      const bytes = data.data;

      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
        bytes[i] = backgroundColor[0];
        bytes[i + 1] = backgroundColor[1];
        bytes[i + 2] = backgroundColor[2];
        bytes[i + 3] = 255;
      }
    }

    for (const figure of this._figures) {
      drawFigure(data, figure, context);
    }

    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }

  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    let scale;

    if (pathType === PathType.SHADING) {
      scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));
    } else {
      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

      if (this.matrix) {
        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
      }
    }

    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);

    if (pathType !== PathType.SHADING) {
      ctx.setTransform(...owner.baseTransform);

      if (this.matrix) {
        ctx.transform(...this.matrix);
      }
    }

    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }

}

class DummyShadingPattern extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }

}

function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);

    case "Mesh":
      return new MeshShadingPattern(IR);

    case "Dummy":
      return new DummyShadingPattern();
  }

  throw new Error(`Unknown IR type: ${IR[0]}`);
}

const PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};

class TilingPattern {
  static get MAX_PATTERN_SIZE() {
    return (0, _util.shadow)(this, "MAX_PATTERN_SIZE", 3000);
  }

  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }

  createPatternCanvas(owner) {
    const operatorList = this.operatorList;
    const bbox = this.bbox;
    const xstep = this.xstep;
    const ystep = this.ystep;
    const paintType = this.paintType;
    const tilingType = this.tilingType;
    const color = this.color;
    const canvasGraphicsFactory = this.canvasGraphicsFactory;
    (0, _util.info)("TilingType: " + tilingType);
    const x0 = bbox[0],
          y0 = bbox[1],
          x1 = bbox[2],
          y1 = bbox[3];

    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    let adjustedX0 = x0;
    let adjustedY0 = y0;
    let adjustedX1 = x1;
    let adjustedY1 = y1;

    if (x0 < 0) {
      adjustedX0 = 0;
      adjustedX1 += Math.abs(x0);
    }

    if (y0 < 0) {
      adjustedY0 = 0;
      adjustedY1 += Math.abs(y0);
    }

    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
    tmpCtx.save();
    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
    graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: adjustedX0,
      offsetY: adjustedY0
    };
  }

  getSizeAndScale(step, realOutputSize, scale) {
    step = Math.abs(step);
    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);

    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }

    return {
      scale,
      size
    };
  }

  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
    graphics.clip();
    graphics.endPath();
  }

  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx,
          current = graphics.current;

    switch (paintType) {
      case PaintType.COLORED:
        const ctx = this.ctx;
        context.fillStyle = ctx.fillStyle;
        context.strokeStyle = ctx.strokeStyle;
        current.fillColor = ctx.fillStyle;
        current.strokeColor = ctx.strokeStyle;
        break;

      case PaintType.UNCOLORED:
        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

        context.fillStyle = cssColor;
        context.strokeStyle = cssColor;
        current.fillColor = cssColor;
        current.strokeColor = cssColor;
        break;

      default:
        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);
    }
  }

  getPattern(ctx, owner, inverse, pathType) {
    let matrix = inverse;

    if (pathType !== PathType.SHADING) {
      matrix = _util.Util.transform(matrix, owner.baseTransform);

      if (this.matrix) {
        matrix = _util.Util.transform(matrix, this.matrix);
      }
    }

    const temporaryPatternCanvas = this.createPatternCanvas(owner);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");

    try {
      pattern.setTransform(domMatrix);
    } catch (ex) {
      (0, _util.warn)(`TilingPattern.getPattern: "${ex === null || ex === void 0 ? void 0 : ex.message}".`);
    }

    return pattern;
  }

}

exports.TilingPattern = TilingPattern;

/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.applyMaskImageData = applyMaskImageData;

var _util = __w_pdfjs_require__(1);

function applyMaskImageData(_ref) {
  let {
    src,
    srcPos = 0,
    dest,
    destPos = 0,
    width,
    height,
    inverseDecode = false
  } = _ref;
  const opaque = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
  const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);

  for (let i = 0; i < height; i++) {
    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;
    }

    if (widthRemainder === 0) {
      continue;
    }

    const elem = srcPos < srcLength ? src[srcPos++] : 255;

    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }

  return {
    srcPos,
    destPos
  };
}

/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GlobalWorkerOptions = void 0;
const GlobalWorkerOptions = Object.create(null);
exports.GlobalWorkerOptions = GlobalWorkerOptions;
GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;

/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;

var _util = __w_pdfjs_require__(1);

const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};

function wrapReason(reason) {
  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
    (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }

  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);

    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);

    case "PasswordException":
      return new _util.PasswordException(reason.message, reason.code);

    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);

    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);

    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}

class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);

    this._onComObjOnMessage = event => {
      const data = event.data;

      if (data.targetName !== this.sourceName) {
        return;
      }

      if (data.stream) {
        this._processStreamMessage(data);

        return;
      }

      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];

        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }

        delete this.callbackCapabilities[callbackId];

        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }

        return;
      }

      const action = this.actionHandler[data.action];

      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }

      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }

      if (data.streamId) {
        this._createStreamSink(data);

        return;
      }

      action(data.data);
    };

    comObj.addEventListener("message", this._onComObjOnMessage);
  }

  on(actionName, handler) {
    const ah = this.actionHandler;

    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }

    ah[actionName] = handler;
  }

  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }

  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = (0, _util.createPromiseCapability)();
    this.callbackCapabilities[callbackId] = capability;

    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }

    return capability.promise;
  }

  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++,
          sourceName = this.sourceName,
          targetName = this.targetName,
          comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }

  _createStreamSink(data) {
    const streamId = data.streamId,
          sourceName = this.sourceName,
          targetName = data.sourceName,
          comObj = this.comObj;
    const self = this,
          action = this.actionHandler[data.action];
    const streamSink = {
      enqueue(chunk) {
        let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        let transfers = arguments.length > 2 ? arguments[2] : undefined;

        if (this.isCancelled) {
          return;
        }

        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;

        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = (0, _util.createPromiseCapability)();
          this.ready = this.sinkCapability.promise;
        }

        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },

      close() {
        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },

      error(reason) {
        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },

      sinkCapability: (0, _util.createPromiseCapability)(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }

  _processStreamMessage(data) {
    const streamId = data.streamId,
          sourceName = this.sourceName,
          targetName = data.sourceName,
          comObj = this.comObj;
    const streamController = this.streamControllers[streamId],
          streamSink = this.streamSinks[streamId];

    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }

        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }

        streamSink.desiredSize = data.desiredSize;
        new Promise(function (resolve) {
          resolve(streamSink.onPull && streamSink.onPull());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;

      case StreamKind.ENQUEUE:
        (0, _util.assert)(streamController, "enqueue should have stream controller");

        if (streamController.isClosed) {
          break;
        }

        streamController.controller.enqueue(data.chunk);
        break;

      case StreamKind.CLOSE:
        (0, _util.assert)(streamController, "close should have stream controller");

        if (streamController.isClosed) {
          break;
        }

        streamController.isClosed = true;
        streamController.controller.close();

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.ERROR:
        (0, _util.assert)(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data.reason));

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data.reason));
        }

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }

        new Promise(function (resolve) {
          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(wrapReason(data.reason));
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;

      default:
        throw new Error("Unexpected stream case");
    }
  }

  async _deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
    delete this.streamControllers[streamId];
  }

  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }

}

exports.MessageHandler = MessageHandler;

/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Metadata = void 0;

var _util = __w_pdfjs_require__(1);

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

var _metadataMap = /*#__PURE__*/new WeakMap();

var _data = /*#__PURE__*/new WeakMap();

class Metadata {
  constructor(_ref) {
    let {
      parsedData,
      rawData
    } = _ref;

    _classPrivateFieldInitSpec(this, _metadataMap, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _data, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _metadataMap, parsedData);

    _classPrivateFieldSet(this, _data, rawData);
  }

  getRaw() {
    return _classPrivateFieldGet(this, _data);
  }

  get(name) {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _metadataMap).get(name)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
  }

  getAll() {
    return (0, _util.objectFromMap)(_classPrivateFieldGet(this, _metadataMap));
  }

  has(name) {
    return _classPrivateFieldGet(this, _metadataMap).has(name);
  }

}

exports.Metadata = Metadata;

/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OptionalContentConfig = void 0;

var _util = __w_pdfjs_require__(1);

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

const INTERNAL = Symbol("INTERNAL");

var _visible = /*#__PURE__*/new WeakMap();

class OptionalContentGroup {
  constructor(name, intent) {
    _classPrivateFieldInitSpec(this, _visible, {
      writable: true,
      value: true
    });

    this.name = name;
    this.intent = intent;
  }

  get visible() {
    return _classPrivateFieldGet(this, _visible);
  }

  _setVisible(internal, visible) {
    if (internal !== INTERNAL) {
      (0, _util.unreachable)("Internal method `_setVisible` called.");
    }

    _classPrivateFieldSet(this, _visible, visible);
  }

}

var _cachedHasInitialVisibility = /*#__PURE__*/new WeakMap();

var _groups = /*#__PURE__*/new WeakMap();

var _initialVisibility = /*#__PURE__*/new WeakMap();

var _order = /*#__PURE__*/new WeakMap();

var _evaluateVisibilityExpression = /*#__PURE__*/new WeakSet();

class OptionalContentConfig {
  constructor(data) {
    _classPrivateMethodInitSpec(this, _evaluateVisibilityExpression);

    _classPrivateFieldInitSpec(this, _cachedHasInitialVisibility, {
      writable: true,
      value: true
    });

    _classPrivateFieldInitSpec(this, _groups, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _initialVisibility, {
      writable: true,
      value: null
    });

    _classPrivateFieldInitSpec(this, _order, {
      writable: true,
      value: null
    });

    this.name = null;
    this.creator = null;

    if (data === null) {
      return;
    }

    this.name = data.name;
    this.creator = data.creator;

    _classPrivateFieldSet(this, _order, data.order);

    for (const group of data.groups) {
      _classPrivateFieldGet(this, _groups).set(group.id, new OptionalContentGroup(group.name, group.intent));
    }

    if (data.baseState === "OFF") {
      for (const group of _classPrivateFieldGet(this, _groups).values()) {
        group._setVisible(INTERNAL, false);
      }
    }

    for (const on of data.on) {
      _classPrivateFieldGet(this, _groups).get(on)._setVisible(INTERNAL, true);
    }

    for (const off of data.off) {
      _classPrivateFieldGet(this, _groups).get(off)._setVisible(INTERNAL, false);
    }

    _classPrivateFieldSet(this, _initialVisibility, new Map());

    for (const [id, group] of _classPrivateFieldGet(this, _groups)) {
      _classPrivateFieldGet(this, _initialVisibility).set(id, group.visible);
    }
  }

  isVisible(group) {
    if (_classPrivateFieldGet(this, _groups).size === 0) {
      return true;
    }

    if (!group) {
      (0, _util.warn)("Optional content group not defined.");
      return true;
    }

    if (group.type === "OCG") {
      if (!_classPrivateFieldGet(this, _groups).has(group.id)) {
        (0, _util.warn)(`Optional content group not found: ${group.id}`);
        return true;
      }

      return _classPrivateFieldGet(this, _groups).get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return _classPrivateMethodGet(this, _evaluateVisibilityExpression, _evaluateVisibilityExpression2).call(this, group.expression);
      }

      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!_classPrivateFieldGet(this, _groups).has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (_classPrivateFieldGet(this, _groups).get(id).visible) {
            return true;
          }
        }

        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!_classPrivateFieldGet(this, _groups).has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (!_classPrivateFieldGet(this, _groups).get(id).visible) {
            return false;
          }
        }

        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!_classPrivateFieldGet(this, _groups).has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (!_classPrivateFieldGet(this, _groups).get(id).visible) {
            return true;
          }
        }

        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!_classPrivateFieldGet(this, _groups).has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (_classPrivateFieldGet(this, _groups).get(id).visible) {
            return false;
          }
        }

        return true;
      }

      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);
      return true;
    }

    (0, _util.warn)(`Unknown group type ${group.type}.`);
    return true;
  }

  setVisibility(id) {
    let visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (!_classPrivateFieldGet(this, _groups).has(id)) {
      (0, _util.warn)(`Optional content group not found: ${id}`);
      return;
    }

    _classPrivateFieldGet(this, _groups).get(id)._setVisible(INTERNAL, !!visible);

    _classPrivateFieldSet(this, _cachedHasInitialVisibility, null);
  }

  get hasInitialVisibility() {
    if (_classPrivateFieldGet(this, _cachedHasInitialVisibility) !== null) {
      return _classPrivateFieldGet(this, _cachedHasInitialVisibility);
    }

    for (const [id, group] of _classPrivateFieldGet(this, _groups)) {
      const visible = _classPrivateFieldGet(this, _initialVisibility).get(id);

      if (group.visible !== visible) {
        return _classPrivateFieldSet(this, _cachedHasInitialVisibility, false);
      }
    }

    return _classPrivateFieldSet(this, _cachedHasInitialVisibility, true);
  }

  getOrder() {
    if (!_classPrivateFieldGet(this, _groups).size) {
      return null;
    }

    if (_classPrivateFieldGet(this, _order)) {
      return _classPrivateFieldGet(this, _order).slice();
    }

    return [..._classPrivateFieldGet(this, _groups).keys()];
  }

  getGroups() {
    return _classPrivateFieldGet(this, _groups).size > 0 ? (0, _util.objectFromMap)(_classPrivateFieldGet(this, _groups)) : null;
  }

  getGroup(id) {
    return _classPrivateFieldGet(this, _groups).get(id) || null;
  }

}

exports.OptionalContentConfig = OptionalContentConfig;

function _evaluateVisibilityExpression2(array) {
  const length = array.length;

  if (length < 2) {
    return true;
  }

  const operator = array[0];

  for (let i = 1; i < length; i++) {
    const element = array[i];
    let state;

    if (Array.isArray(element)) {
      state = _classPrivateMethodGet(this, _evaluateVisibilityExpression, _evaluateVisibilityExpression2).call(this, element);
    } else if (_classPrivateFieldGet(this, _groups).has(element)) {
      state = _classPrivateFieldGet(this, _groups).get(element).visible;
    } else {
      (0, _util.warn)(`Optional content group not found: ${element}`);
      return true;
    }

    switch (operator) {
      case "And":
        if (!state) {
          return false;
        }

        break;

      case "Or":
        if (state) {
          return true;
        }

        break;

      case "Not":
        return !state;

      default:
        return true;
    }
  }

  return operator === "And";
}

/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFDataTransportStream = void 0;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(133);

class PDFDataTransportStream {
  constructor(params, pdfDataRangeTransport) {
    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    this._queuedChunks = [];
    this._progressiveDone = params.progressiveDone || false;
    this._contentDispositionFilename = params.contentDispositionFilename || null;
    const initialData = params.initialData;

    if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
      const buffer = new Uint8Array(initialData).buffer;

      this._queuedChunks.push(buffer);
    }

    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !params.disableStream;
    this._isRangeSupported = !params.disableRange;
    this._contentLength = params.length;
    this._fullRequestReader = null;
    this._rangeReaders = [];

    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });

    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });

    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
      this._onReceiveData({
        chunk
      });
    });

    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });

    this._pdfDataRangeTransport.transportReady();
  }

  _onReceiveData(args) {
    const buffer = new Uint8Array(args.chunk).buffer;

    if (args.begin === undefined) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function (rangeReader) {
        if (rangeReader._begin !== args.begin) {
          return false;
        }

        rangeReader._enqueue(buffer);

        return true;
      });

      (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }

  get _progressiveDataLength() {
    var _this$_fullRequestRea, _this$_fullRequestRea2;

    return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
  }

  _onProgress(evt) {
    if (evt.total === undefined) {
      const firstReader = this._rangeReaders[0];

      if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {
        firstReader.onProgress({
          loaded: evt.loaded
        });
      }
    } else {
      const fullReader = this._fullRequestReader;

      if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {
        fullReader.onProgress({
          loaded: evt.loaded,
          total: evt.total
        });
      }
    }
  }

  _onProgressiveDone() {
    if (this._fullRequestReader) {
      this._fullRequestReader.progressiveDone();
    }

    this._progressiveDone = true;
  }

  _removeRangeReader(reader) {
    const i = this._rangeReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeReaders.splice(i, 1);
    }
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }

  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);

    this._pdfDataRangeTransport.requestDataRange(begin, end);

    this._rangeReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }

    this._pdfDataRangeTransport.abort();
  }

}

exports.PDFDataTransportStream = PDFDataTransportStream;

class PDFDataTransportStreamReader {
  constructor(stream, queuedChunks) {
    let progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;

    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }

    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }

  _enqueue(chunk) {
    if (this._done) {
      return;
    }

    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }

    this._loaded += chunk.byteLength;
  }

  get headersReady() {
    return this._headersReady;
  }

  get filename() {
    return this._filename;
  }

  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }

  get contentLength() {
    return this._stream._contentLength;
  }

  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();

      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;
  }

  progressiveDone() {
    if (this._done) {
      return;
    }

    this._done = true;
  }

}

class PDFDataTransportStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }

  _enqueue(chunk) {
    if (this._done) {
      return;
    }

    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();

      requestsCapability.resolve({
        value: chunk,
        done: false
      });

      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      }

      this._requests.length = 0;
    }

    this._done = true;

    this._stream._removeRangeReader(this);
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    this._stream._removeRangeReader(this);
  }

}

/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaText = void 0;

class XfaText {
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: Object.create(null)
    };

    function walk(node) {
      var _node$attributes;

      if (!node) {
        return;
      }

      let str = null;
      const name = node.name;

      if (name === "#text") {
        str = node.value;
      } else if (!XfaText.shouldBuildText(name)) {
        return;
      } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }

      if (str !== null) {
        items.push({
          str
        });
      }

      if (!node.children) {
        return;
      }

      for (const child of node.children) {
        walk(child);
      }
    }

    walk(xfa);
    return output;
  }

  static shouldBuildText(name) {
    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
  }

}

exports.XfaText = XfaText;

/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;

var _base_factory = __w_pdfjs_require__(134);

const fetchData = function (url) {
  return new Promise((resolve, reject) => {
    const fs = require$$2__default['default'];

    fs.readFile(url, (error, data) => {
      if (error || !data) {
        reject(new Error(error));
        return;
      }

      resolve(new Uint8Array(data));
    });
  });
};

class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
  _createCanvas(width, height) {
    const Canvas = require$$3;

    return Canvas.createCanvas(width, height);
  }

}

exports.NodeCanvasFactory = NodeCanvasFactory;

class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData(url).then(data => {
      return {
        cMapData: data,
        compressionType
      };
    });
  }

}

exports.NodeCMapReaderFactory = NodeCMapReaderFactory;

class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData(url);
  }

}

exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;

/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationEditorLayer = void 0;

var _tools = __w_pdfjs_require__(132);

var _util = __w_pdfjs_require__(1);

var _freetext = __w_pdfjs_require__(148);

var _ink = __w_pdfjs_require__(149);

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

var _accessibilityManager = /*#__PURE__*/new WeakMap();

var _allowClick = /*#__PURE__*/new WeakMap();

var _boundPointerup = /*#__PURE__*/new WeakMap();

var _boundPointerdown = /*#__PURE__*/new WeakMap();

var _editors = /*#__PURE__*/new WeakMap();

var _hadPointerDown = /*#__PURE__*/new WeakMap();

var _isCleaningUp = /*#__PURE__*/new WeakMap();

var _uiManager = /*#__PURE__*/new WeakMap();

var _changeParent = /*#__PURE__*/new WeakSet();

var _createNewEditor = /*#__PURE__*/new WeakSet();

var _createAndAddNewEditor = /*#__PURE__*/new WeakSet();

var _cleanup = /*#__PURE__*/new WeakSet();

class AnnotationEditorLayer {
  constructor(options) {
    _classPrivateMethodInitSpec(this, _cleanup);

    _classPrivateMethodInitSpec(this, _createAndAddNewEditor);

    _classPrivateMethodInitSpec(this, _createNewEditor);

    _classPrivateMethodInitSpec(this, _changeParent);

    _classPrivateFieldInitSpec(this, _accessibilityManager, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _allowClick, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _boundPointerup, {
      writable: true,
      value: this.pointerup.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundPointerdown, {
      writable: true,
      value: this.pointerdown.bind(this)
    });

    _classPrivateFieldInitSpec(this, _editors, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _hadPointerDown, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _isCleaningUp, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _uiManager, {
      writable: true,
      value: void 0
    });

    if (!AnnotationEditorLayer._initialized) {
      AnnotationEditorLayer._initialized = true;

      _freetext.FreeTextEditor.initialize(options.l10n);

      _ink.InkEditor.initialize(options.l10n);

      options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);
    }

    _classPrivateFieldSet(this, _uiManager, options.uiManager);

    this.annotationStorage = options.annotationStorage;
    this.pageIndex = options.pageIndex;
    this.div = options.div;

    _classPrivateFieldSet(this, _accessibilityManager, options.accessibilityManager);

    _classPrivateFieldGet(this, _uiManager).addLayer(this);
  }

  updateToolbar(mode) {
    _classPrivateFieldGet(this, _uiManager).updateToolbar(mode);
  }

  updateMode() {
    let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _classPrivateFieldGet(this, _uiManager).getMode();

    _classPrivateMethodGet(this, _cleanup, _cleanup2).call(this);

    if (mode === _util.AnnotationEditorType.INK) {
      this.addInkEditorIfNeeded(false);
      this.disableClick();
    } else {
      this.enableClick();
    }

    _classPrivateFieldGet(this, _uiManager).unselectAll();
  }

  addInkEditorIfNeeded(isCommitting) {
    if (!isCommitting && _classPrivateFieldGet(this, _uiManager).getMode() !== _util.AnnotationEditorType.INK) {
      return;
    }

    if (!isCommitting) {
      for (const editor of _classPrivateFieldGet(this, _editors).values()) {
        if (editor.isEmpty()) {
          editor.setInBackground();
          return;
        }
      }
    }

    const editor = _classPrivateMethodGet(this, _createAndAddNewEditor, _createAndAddNewEditor2).call(this, {
      offsetX: 0,
      offsetY: 0
    });

    editor.setInBackground();
  }

  setEditingState(isEditing) {
    _classPrivateFieldGet(this, _uiManager).setEditingState(isEditing);
  }

  addCommands(params) {
    _classPrivateFieldGet(this, _uiManager).addCommands(params);
  }

  enable() {
    this.div.style.pointerEvents = "auto";

    for (const editor of _classPrivateFieldGet(this, _editors).values()) {
      editor.enableEditing();
    }
  }

  disable() {
    this.div.style.pointerEvents = "none";

    for (const editor of _classPrivateFieldGet(this, _editors).values()) {
      editor.disableEditing();
    }
  }

  setActiveEditor(editor) {
    const currentActive = _classPrivateFieldGet(this, _uiManager).getActive();

    if (currentActive === editor) {
      return;
    }

    _classPrivateFieldGet(this, _uiManager).setActiveEditor(editor);
  }

  enableClick() {
    this.div.addEventListener("pointerdown", _classPrivateFieldGet(this, _boundPointerdown));
    this.div.addEventListener("pointerup", _classPrivateFieldGet(this, _boundPointerup));
  }

  disableClick() {
    this.div.removeEventListener("pointerdown", _classPrivateFieldGet(this, _boundPointerdown));
    this.div.removeEventListener("pointerup", _classPrivateFieldGet(this, _boundPointerup));
  }

  attach(editor) {
    _classPrivateFieldGet(this, _editors).set(editor.id, editor);
  }

  detach(editor) {
    var _classPrivateFieldGet2;

    _classPrivateFieldGet(this, _editors).delete(editor.id);

    (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _accessibilityManager)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.removePointerInTextLayer(editor.contentDiv);
  }

  remove(editor) {
    _classPrivateFieldGet(this, _uiManager).removeEditor(editor);

    this.detach(editor);
    this.annotationStorage.remove(editor.id);
    editor.div.style.display = "none";
    setTimeout(() => {
      editor.div.style.display = "";
      editor.div.remove();
      editor.isAttachedToDOM = false;

      if (document.activeElement === document.body) {
        _classPrivateFieldGet(this, _uiManager).focusMainContainer();
      }
    }, 0);

    if (!_classPrivateFieldGet(this, _isCleaningUp)) {
      this.addInkEditorIfNeeded(false);
    }
  }

  add(editor) {
    _classPrivateMethodGet(this, _changeParent, _changeParent2).call(this, editor);

    _classPrivateFieldGet(this, _uiManager).addEditor(editor);

    this.attach(editor);

    if (!editor.isAttachedToDOM) {
      const div = editor.render();
      this.div.append(div);
      editor.isAttachedToDOM = true;
    }

    this.moveEditorInDOM(editor);
    editor.onceAdded();
    this.addToAnnotationStorage(editor);
  }

  moveEditorInDOM(editor) {
    var _classPrivateFieldGet3;

    (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _accessibilityManager)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
  }

  addToAnnotationStorage(editor) {
    if (!editor.isEmpty() && !this.annotationStorage.has(editor.id)) {
      this.annotationStorage.setValue(editor.id, editor);
    }
  }

  addOrRebuild(editor) {
    if (editor.needsToBeRebuilt()) {
      editor.rebuild();
    } else {
      this.add(editor);
    }
  }

  addANewEditor(editor) {
    const cmd = () => {
      this.addOrRebuild(editor);
    };

    const undo = () => {
      editor.remove();
    };

    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }

  addUndoableEditor(editor) {
    const cmd = () => {
      this.addOrRebuild(editor);
    };

    const undo = () => {
      editor.remove();
    };

    this.addCommands({
      cmd,
      undo,
      mustExec: false
    });
  }

  getNextId() {
    return _classPrivateFieldGet(this, _uiManager).getId();
  }

  deserialize(data) {
    switch (data.annotationType) {
      case _util.AnnotationEditorType.FREETEXT:
        return _freetext.FreeTextEditor.deserialize(data, this);

      case _util.AnnotationEditorType.INK:
        return _ink.InkEditor.deserialize(data, this);
    }

    return null;
  }

  setSelected(editor) {
    _classPrivateFieldGet(this, _uiManager).setSelected(editor);
  }

  toggleSelected(editor) {
    _classPrivateFieldGet(this, _uiManager).toggleSelected(editor);
  }

  isSelected(editor) {
    return _classPrivateFieldGet(this, _uiManager).isSelected(editor);
  }

  unselect(editor) {
    _classPrivateFieldGet(this, _uiManager).unselect(editor);
  }

  pointerup(event) {
    const isMac = _tools.KeyboardManager.platform.isMac;

    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }

    if (event.target !== this.div) {
      return;
    }

    if (!_classPrivateFieldGet(this, _hadPointerDown)) {
      return;
    }

    _classPrivateFieldSet(this, _hadPointerDown, false);

    if (!_classPrivateFieldGet(this, _allowClick)) {
      _classPrivateFieldSet(this, _allowClick, true);

      return;
    }

    _classPrivateMethodGet(this, _createAndAddNewEditor, _createAndAddNewEditor2).call(this, event);
  }

  pointerdown(event) {
    const isMac = _tools.KeyboardManager.platform.isMac;

    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }

    if (event.target !== this.div) {
      return;
    }

    _classPrivateFieldSet(this, _hadPointerDown, true);

    const editor = _classPrivateFieldGet(this, _uiManager).getActive();

    _classPrivateFieldSet(this, _allowClick, !editor || editor.isEmpty());
  }

  drop(event) {
    const id = event.dataTransfer.getData("text/plain");

    const editor = _classPrivateFieldGet(this, _uiManager).getEditor(id);

    if (!editor) {
      return;
    }

    event.preventDefault();
    event.dataTransfer.dropEffect = "move";

    _classPrivateMethodGet(this, _changeParent, _changeParent2).call(this, editor);

    const rect = this.div.getBoundingClientRect();
    const endX = event.clientX - rect.x;
    const endY = event.clientY - rect.y;
    editor.translate(endX - editor.startX, endY - editor.startY);
    this.moveEditorInDOM(editor);
    editor.div.focus();
  }

  dragover(event) {
    event.preventDefault();
  }

  destroy() {
    var _classPrivateFieldGet4;

    if (((_classPrivateFieldGet4 = _classPrivateFieldGet(this, _uiManager).getActive()) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.parent) === this) {
      _classPrivateFieldGet(this, _uiManager).setActiveEditor(null);
    }

    for (const editor of _classPrivateFieldGet(this, _editors).values()) {
      var _classPrivateFieldGet5;

      (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _accessibilityManager)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.removePointerInTextLayer(editor.contentDiv);
      editor.isAttachedToDOM = false;
      editor.div.remove();
      editor.parent = null;
    }

    this.div = null;

    _classPrivateFieldGet(this, _editors).clear();

    _classPrivateFieldGet(this, _uiManager).removeLayer(this);
  }

  render(parameters) {
    this.viewport = parameters.viewport;
    (0, _tools.bindEvents)(this, this.div, ["dragover", "drop"]);
    this.setDimensions();

    for (const editor of _classPrivateFieldGet(this, _uiManager).getEditors(this.pageIndex)) {
      this.add(editor);
    }

    this.updateMode();
  }

  update(parameters) {
    this.viewport = parameters.viewport;
    this.setDimensions();
    this.updateMode();
  }

  get scaleFactor() {
    return this.viewport.scale;
  }

  get pageDimensions() {
    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
    const width = pageURx - pageLLx;
    const height = pageURy - pageLLy;
    return [width, height];
  }

  get viewportBaseDimensions() {
    const {
      width,
      height,
      rotation
    } = this.viewport;
    return rotation % 180 === 0 ? [width, height] : [height, width];
  }

  setDimensions() {
    const {
      width,
      height,
      rotation
    } = this.viewport;
    const flipOrientation = rotation % 180 !== 0,
          widthStr = Math.floor(width) + "px",
          heightStr = Math.floor(height) + "px";
    this.div.style.width = flipOrientation ? heightStr : widthStr;
    this.div.style.height = flipOrientation ? widthStr : heightStr;
    this.div.setAttribute("data-main-rotation", rotation);
  }

}

exports.AnnotationEditorLayer = AnnotationEditorLayer;

function _changeParent2(editor) {
  var _editor$parent;

  if (editor.parent === this) {
    return;
  }

  this.attach(editor);
  editor.pageIndex = this.pageIndex;
  (_editor$parent = editor.parent) === null || _editor$parent === void 0 ? void 0 : _editor$parent.detach(editor);
  editor.parent = this;

  if (editor.div && editor.isAttachedToDOM) {
    editor.div.remove();
    this.div.append(editor.div);
  }
}

function _createNewEditor2(params) {
  switch (_classPrivateFieldGet(this, _uiManager).getMode()) {
    case _util.AnnotationEditorType.FREETEXT:
      return new _freetext.FreeTextEditor(params);

    case _util.AnnotationEditorType.INK:
      return new _ink.InkEditor(params);
  }

  return null;
}

function _createAndAddNewEditor2(event) {
  const id = this.getNextId();

  const editor = _classPrivateMethodGet(this, _createNewEditor, _createNewEditor2).call(this, {
    parent: this,
    id,
    x: event.offsetX,
    y: event.offsetY
  });

  if (editor) {
    this.add(editor);
  }

  return editor;
}

function _cleanup2() {
  _classPrivateFieldSet(this, _isCleaningUp, true);

  for (const editor of _classPrivateFieldGet(this, _editors).values()) {
    if (editor.isEmpty()) {
      editor.remove();
    }
  }

  _classPrivateFieldSet(this, _isCleaningUp, false);
}

_defineProperty(AnnotationEditorLayer, "_initialized", false);

/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FreeTextEditor = void 0;

var _util = __w_pdfjs_require__(1);

var _tools = __w_pdfjs_require__(132);

var _editor = __w_pdfjs_require__(131);

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

var _boundEditorDivBlur = /*#__PURE__*/new WeakMap();

var _boundEditorDivFocus = /*#__PURE__*/new WeakMap();

var _boundEditorDivKeydown = /*#__PURE__*/new WeakMap();

var _color = /*#__PURE__*/new WeakMap();

var _content = /*#__PURE__*/new WeakMap();

var _hasAlreadyBeenCommitted = /*#__PURE__*/new WeakMap();

var _fontSize = /*#__PURE__*/new WeakMap();

var _updateFontSize = /*#__PURE__*/new WeakSet();

var _updateColor = /*#__PURE__*/new WeakSet();

var _extractText = /*#__PURE__*/new WeakSet();

var _setEditorDimensions = /*#__PURE__*/new WeakSet();

class FreeTextEditor extends _editor.AnnotationEditor {
  constructor(params) {
    super({ ...params,
      name: "freeTextEditor"
    });

    _classPrivateMethodInitSpec(this, _setEditorDimensions);

    _classPrivateMethodInitSpec(this, _extractText);

    _classPrivateMethodInitSpec(this, _updateColor);

    _classPrivateMethodInitSpec(this, _updateFontSize);

    _classPrivateFieldInitSpec(this, _boundEditorDivBlur, {
      writable: true,
      value: this.editorDivBlur.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundEditorDivFocus, {
      writable: true,
      value: this.editorDivFocus.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundEditorDivKeydown, {
      writable: true,
      value: this.editorDivKeydown.bind(this)
    });

    _classPrivateFieldInitSpec(this, _color, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _content, {
      writable: true,
      value: ""
    });

    _classPrivateFieldInitSpec(this, _hasAlreadyBeenCommitted, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _fontSize, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _color, params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);

    _classPrivateFieldSet(this, _fontSize, params.fontSize || FreeTextEditor._defaultFontSize);
  }

  static initialize(l10n) {
    this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map(str => [str, l10n.get(str)]));
    const style = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
  }

  static updateDefaultParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:
        FreeTextEditor._defaultFontSize = value;
        break;

      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:
        FreeTextEditor._defaultColor = value;
        break;
    }
  }

  updateParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:
        _classPrivateMethodGet(this, _updateFontSize, _updateFontSize2).call(this, value);

        break;

      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:
        _classPrivateMethodGet(this, _updateColor, _updateColor2).call(this, value);

        break;
    }
  }

  static get defaultPropertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
  }

  get propertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, _classPrivateFieldGet(this, _fontSize)], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, _classPrivateFieldGet(this, _color)]];
  }

  getInitialTranslation() {
    return [-FreeTextEditor._internalPadding * this.parent.scaleFactor, -(FreeTextEditor._internalPadding + _classPrivateFieldGet(this, _fontSize)) * this.parent.scaleFactor];
  }

  rebuild() {
    super.rebuild();

    if (this.div === null) {
      return;
    }

    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }

  enableEditMode() {
    if (this.isInEditMode()) {
      return;
    }

    this.parent.setEditingState(false);
    this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);
    super.enableEditMode();
    this.enableEditing();
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this.div.draggable = false;
    this.editorDiv.addEventListener("keydown", _classPrivateFieldGet(this, _boundEditorDivKeydown));
    this.editorDiv.addEventListener("focus", _classPrivateFieldGet(this, _boundEditorDivFocus));
    this.editorDiv.addEventListener("blur", _classPrivateFieldGet(this, _boundEditorDivBlur));
  }

  disableEditMode() {
    if (!this.isInEditMode()) {
      return;
    }

    this.parent.setEditingState(true);
    super.disableEditMode();
    this.disableEditing();
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.draggable = true;
    this.editorDiv.removeEventListener("keydown", _classPrivateFieldGet(this, _boundEditorDivKeydown));
    this.editorDiv.removeEventListener("focus", _classPrivateFieldGet(this, _boundEditorDivFocus));
    this.editorDiv.removeEventListener("blur", _classPrivateFieldGet(this, _boundEditorDivBlur));
    this.div.focus();
    this.isEditing = false;
  }

  focusin(event) {
    super.focusin(event);

    if (event.target !== this.editorDiv) {
      this.editorDiv.focus();
    }
  }

  onceAdded() {
    if (this.width) {
      return;
    }

    this.enableEditMode();
    this.editorDiv.focus();
  }

  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }

  remove() {
    this.isEditing = false;
    this.parent.setEditingState(true);
    super.remove();
  }

  commit() {
    super.commit();

    if (!_classPrivateFieldGet(this, _hasAlreadyBeenCommitted)) {
      _classPrivateFieldSet(this, _hasAlreadyBeenCommitted, true);

      this.parent.addUndoableEditor(this);
    }

    this.disableEditMode();

    _classPrivateFieldSet(this, _content, _classPrivateMethodGet(this, _extractText, _extractText2).call(this).trimEnd());

    _classPrivateMethodGet(this, _setEditorDimensions, _setEditorDimensions2).call(this);
  }

  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }

  dblclick(event) {
    this.enableEditMode();
    this.editorDiv.focus();
  }

  keydown(event) {
    if (event.target === this.div && event.key === "Enter") {
      this.enableEditMode();
      this.editorDiv.focus();
    }
  }

  editorDivKeydown(event) {
    FreeTextEditor._keyboardManager.exec(this, event);
  }

  editorDivFocus(event) {
    this.isEditing = true;
  }

  editorDivBlur(event) {
    this.isEditing = false;
  }

  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }

  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }

  render() {
    if (this.div) {
      return this.div;
    }

    let baseX, baseY;

    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }

    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", `${this.id}-editor`);
    this.enableEditing();

    FreeTextEditor._l10nPromise.get("editor_free_text_aria_label").then(msg => {
      var _this$editorDiv;

      return (_this$editorDiv = this.editorDiv) === null || _this$editorDiv === void 0 ? void 0 : _this$editorDiv.setAttribute("aria-label", msg);
    });

    FreeTextEditor._l10nPromise.get("free_text_default_content").then(msg => {
      var _this$editorDiv2;

      return (_this$editorDiv2 = this.editorDiv) === null || _this$editorDiv2 === void 0 ? void 0 : _this$editorDiv2.setAttribute("default-content", msg);
    });

    this.editorDiv.contentEditable = true;
    const {
      style
    } = this.editorDiv;
    style.fontSize = `calc(${_classPrivateFieldGet(this, _fontSize)}px * var(--scale-factor))`;
    style.color = _classPrivateFieldGet(this, _color);
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);

    if (this.width) {
      const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);

      for (const line of _classPrivateFieldGet(this, _content).split("\n")) {
        const div = document.createElement("div");
        div.append(line ? document.createTextNode(line) : document.createElement("br"));
        this.editorDiv.append(div);
      }

      this.div.draggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this.div.draggable = false;
      this.editorDiv.contentEditable = true;
    }

    return this.div;
  }

  get contentDiv() {
    return this.editorDiv;
  }

  static deserialize(data, parent) {
    const editor = super.deserialize(data, parent);

    _classPrivateFieldSet(editor, _fontSize, data.fontSize);

    _classPrivateFieldSet(editor, _color, _util.Util.makeHexColor(...data.color));

    _classPrivateFieldSet(editor, _content, data.value);

    return editor;
  }

  serialize() {
    if (this.isEmpty()) {
      return null;
    }

    const padding = FreeTextEditor._internalPadding * this.parent.scaleFactor;
    const rect = this.getRect(padding, padding);

    const color = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);

    return {
      annotationType: _util.AnnotationEditorType.FREETEXT,
      color,
      fontSize: _classPrivateFieldGet(this, _fontSize),
      value: _classPrivateFieldGet(this, _content),
      pageIndex: this.parent.pageIndex,
      rect,
      rotation: this.rotation
    };
  }

}

exports.FreeTextEditor = FreeTextEditor;

function _updateFontSize2(fontSize) {
  const setFontsize = size => {
    this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
    this.translate(0, -(size - _classPrivateFieldGet(this, _fontSize)) * this.parent.scaleFactor);

    _classPrivateFieldSet(this, _fontSize, size);

    _classPrivateMethodGet(this, _setEditorDimensions, _setEditorDimensions2).call(this);
  };

  const savedFontsize = _classPrivateFieldGet(this, _fontSize);

  this.parent.addCommands({
    cmd: () => {
      setFontsize(fontSize);
    },
    undo: () => {
      setFontsize(savedFontsize);
    },
    mustExec: true,
    type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,
    overwriteIfSameType: true,
    keepUndo: true
  });
}

function _updateColor2(color) {
  const savedColor = _classPrivateFieldGet(this, _color);

  this.parent.addCommands({
    cmd: () => {
      _classPrivateFieldSet(this, _color, color);

      this.editorDiv.style.color = color;
    },
    undo: () => {
      _classPrivateFieldSet(this, _color, savedColor);

      this.editorDiv.style.color = savedColor;
    },
    mustExec: true,
    type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,
    overwriteIfSameType: true,
    keepUndo: true
  });
}

function _extractText2() {
  const divs = this.editorDiv.getElementsByTagName("div");

  if (divs.length === 0) {
    return this.editorDiv.innerText;
  }

  const buffer = [];

  for (let i = 0, ii = divs.length; i < ii; i++) {
    const div = divs[i];
    const first = div.firstChild;

    if ((first === null || first === void 0 ? void 0 : first.nodeName) === "#text") {
      buffer.push(first.data);
    } else {
      buffer.push("");
    }
  }

  return buffer.join("\n");
}

function _setEditorDimensions2() {
  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
  const rect = this.div.getBoundingClientRect();
  this.width = rect.width / parentWidth;
  this.height = rect.height / parentHeight;
}

_defineProperty(FreeTextEditor, "_freeTextDefaultContent", "");

_defineProperty(FreeTextEditor, "_l10nPromise", void 0);

_defineProperty(FreeTextEditor, "_internalPadding", 0);

_defineProperty(FreeTextEditor, "_defaultColor", null);

_defineProperty(FreeTextEditor, "_defaultFontSize", 10);

_defineProperty(FreeTextEditor, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], FreeTextEditor.prototype.commitOrRemove]]));

_defineProperty(FreeTextEditor, "_type", "freetext");

/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InkEditor = void 0;
Object.defineProperty(exports, "fitCurve", ({
  enumerable: true,
  get: function () {
    return _pdfjsFitCurve.fitCurve;
  }
}));

var _util = __w_pdfjs_require__(1);

var _editor = __w_pdfjs_require__(131);

var _pdfjsFitCurve = __w_pdfjs_require__(150);

var _tools = __w_pdfjs_require__(132);

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }

function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

const RESIZER_SIZE = 16;

var _aspectRatio = /*#__PURE__*/new WeakMap();

var _baseHeight = /*#__PURE__*/new WeakMap();

var _baseWidth = /*#__PURE__*/new WeakMap();

var _boundCanvasPointermove = /*#__PURE__*/new WeakMap();

var _boundCanvasPointerleave = /*#__PURE__*/new WeakMap();

var _boundCanvasPointerup = /*#__PURE__*/new WeakMap();

var _boundCanvasPointerdown = /*#__PURE__*/new WeakMap();

var _disableEditing = /*#__PURE__*/new WeakMap();

var _isCanvasInitialized = /*#__PURE__*/new WeakMap();

var _lastPoint = /*#__PURE__*/new WeakMap();

var _observer = /*#__PURE__*/new WeakMap();

var _realWidth = /*#__PURE__*/new WeakMap();

var _realHeight = /*#__PURE__*/new WeakMap();

var _requestFrameCallback = /*#__PURE__*/new WeakMap();

var _updateThickness = /*#__PURE__*/new WeakSet();

var _updateColor = /*#__PURE__*/new WeakSet();

var _updateOpacity = /*#__PURE__*/new WeakSet();

var _getInitialBBox = /*#__PURE__*/new WeakSet();

var _setStroke = /*#__PURE__*/new WeakSet();

var _startDrawing = /*#__PURE__*/new WeakSet();

var _draw = /*#__PURE__*/new WeakSet();

var _stopDrawing = /*#__PURE__*/new WeakSet();

var _redraw = /*#__PURE__*/new WeakSet();

var _endDrawing = /*#__PURE__*/new WeakSet();

var _createCanvas = /*#__PURE__*/new WeakSet();

var _createObserver = /*#__PURE__*/new WeakSet();

var _setCanvasDims = /*#__PURE__*/new WeakSet();

var _setScaleFactor = /*#__PURE__*/new WeakSet();

var _updateTransform = /*#__PURE__*/new WeakSet();

var _serializePaths = /*#__PURE__*/new WeakSet();

var _extractPointsOnBezier = /*#__PURE__*/new WeakSet();

var _isAlmostFlat = /*#__PURE__*/new WeakSet();

var _getBbox = /*#__PURE__*/new WeakSet();

var _getPadding = /*#__PURE__*/new WeakSet();

var _fitToContent = /*#__PURE__*/new WeakSet();

var _setMinDims = /*#__PURE__*/new WeakSet();

class InkEditor extends _editor.AnnotationEditor {
  constructor(params) {
    super({ ...params,
      name: "inkEditor"
    });

    _classPrivateMethodInitSpec(this, _setMinDims);

    _classPrivateMethodInitSpec(this, _fitToContent);

    _classPrivateMethodInitSpec(this, _getPadding);

    _classPrivateMethodInitSpec(this, _getBbox);

    _classPrivateMethodInitSpec(this, _isAlmostFlat);

    _classPrivateMethodInitSpec(this, _extractPointsOnBezier);

    _classPrivateMethodInitSpec(this, _serializePaths);

    _classPrivateMethodInitSpec(this, _updateTransform);

    _classPrivateMethodInitSpec(this, _setScaleFactor);

    _classPrivateMethodInitSpec(this, _setCanvasDims);

    _classPrivateMethodInitSpec(this, _createObserver);

    _classPrivateMethodInitSpec(this, _createCanvas);

    _classPrivateMethodInitSpec(this, _endDrawing);

    _classPrivateMethodInitSpec(this, _redraw);

    _classPrivateMethodInitSpec(this, _stopDrawing);

    _classPrivateMethodInitSpec(this, _draw);

    _classPrivateMethodInitSpec(this, _startDrawing);

    _classPrivateMethodInitSpec(this, _setStroke);

    _classPrivateMethodInitSpec(this, _getInitialBBox);

    _classPrivateMethodInitSpec(this, _updateOpacity);

    _classPrivateMethodInitSpec(this, _updateColor);

    _classPrivateMethodInitSpec(this, _updateThickness);

    _classPrivateFieldInitSpec(this, _aspectRatio, {
      writable: true,
      value: 0
    });

    _classPrivateFieldInitSpec(this, _baseHeight, {
      writable: true,
      value: 0
    });

    _classPrivateFieldInitSpec(this, _baseWidth, {
      writable: true,
      value: 0
    });

    _classPrivateFieldInitSpec(this, _boundCanvasPointermove, {
      writable: true,
      value: this.canvasPointermove.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundCanvasPointerleave, {
      writable: true,
      value: this.canvasPointerleave.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundCanvasPointerup, {
      writable: true,
      value: this.canvasPointerup.bind(this)
    });

    _classPrivateFieldInitSpec(this, _boundCanvasPointerdown, {
      writable: true,
      value: this.canvasPointerdown.bind(this)
    });

    _classPrivateFieldInitSpec(this, _disableEditing, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _isCanvasInitialized, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _lastPoint, {
      writable: true,
      value: null
    });

    _classPrivateFieldInitSpec(this, _observer, {
      writable: true,
      value: null
    });

    _classPrivateFieldInitSpec(this, _realWidth, {
      writable: true,
      value: 0
    });

    _classPrivateFieldInitSpec(this, _realHeight, {
      writable: true,
      value: 0
    });

    _classPrivateFieldInitSpec(this, _requestFrameCallback, {
      writable: true,
      value: null
    });

    this.color = params.color || null;
    this.thickness = params.thickness || null;
    this.opacity = params.opacity || null;
    this.paths = [];
    this.bezierPath2D = [];
    this.currentPath = [];
    this.scaleFactor = 1;
    this.translationX = this.translationY = 0;
    this.x = 0;
    this.y = 0;
  }

  static initialize(l10n) {
    this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map(str => [str, l10n.get(str)]));
  }

  static updateDefaultParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.INK_THICKNESS:
        InkEditor._defaultThickness = value;
        break;

      case _util.AnnotationEditorParamsType.INK_COLOR:
        InkEditor._defaultColor = value;
        break;

      case _util.AnnotationEditorParamsType.INK_OPACITY:
        InkEditor._defaultOpacity = value / 100;
        break;
    }
  }

  updateParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.INK_THICKNESS:
        _classPrivateMethodGet(this, _updateThickness, _updateThickness2).call(this, value);

        break;

      case _util.AnnotationEditorParamsType.INK_COLOR:
        _classPrivateMethodGet(this, _updateColor, _updateColor2).call(this, value);

        break;

      case _util.AnnotationEditorParamsType.INK_OPACITY:
        _classPrivateMethodGet(this, _updateOpacity, _updateOpacity2).call(this, value);

        break;
    }
  }

  static get defaultPropertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];
  }

  get propertiesToUpdate() {
    var _this$opacity;

    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * ((_this$opacity = this.opacity) !== null && _this$opacity !== void 0 ? _this$opacity : InkEditor._defaultOpacity))]];
  }

  rebuild() {
    super.rebuild();

    if (this.div === null) {
      return;
    }

    if (!this.canvas) {
      _classPrivateMethodGet(this, _createCanvas, _createCanvas2).call(this);

      _classPrivateMethodGet(this, _createObserver, _createObserver2).call(this);
    }

    if (!this.isAttachedToDOM) {
      this.parent.add(this);

      _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);
    }

    _classPrivateMethodGet(this, _fitToContent, _fitToContent2).call(this);
  }

  remove() {
    if (this.canvas === null) {
      return;
    }

    if (!this.isEmpty()) {
      this.commit();
    }

    this.canvas.width = this.canvas.height = 0;
    this.canvas.remove();
    this.canvas = null;

    _classPrivateFieldGet(this, _observer).disconnect();

    _classPrivateFieldSet(this, _observer, null);

    super.remove();
  }

  enableEditMode() {
    if (_classPrivateFieldGet(this, _disableEditing) || this.canvas === null) {
      return;
    }

    super.enableEditMode();
    this.div.draggable = false;
    this.canvas.addEventListener("pointerdown", _classPrivateFieldGet(this, _boundCanvasPointerdown));
    this.canvas.addEventListener("pointerup", _classPrivateFieldGet(this, _boundCanvasPointerup));
  }

  disableEditMode() {
    if (!this.isInEditMode() || this.canvas === null) {
      return;
    }

    super.disableEditMode();
    this.div.draggable = !this.isEmpty();
    this.div.classList.remove("editing");
    this.canvas.removeEventListener("pointerdown", _classPrivateFieldGet(this, _boundCanvasPointerdown));
    this.canvas.removeEventListener("pointerup", _classPrivateFieldGet(this, _boundCanvasPointerup));
  }

  onceAdded() {
    this.div.draggable = !this.isEmpty();
  }

  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }

  commit() {
    if (_classPrivateFieldGet(this, _disableEditing)) {
      return;
    }

    super.commit();
    this.isEditing = false;
    this.disableEditMode();
    this.setInForeground();

    _classPrivateFieldSet(this, _disableEditing, true);

    this.div.classList.add("disabled");

    _classPrivateMethodGet(this, _fitToContent, _fitToContent2).call(this, true);

    this.parent.addInkEditorIfNeeded(true);
    this.parent.moveEditorInDOM(this);
    this.div.focus();
  }

  focusin(event) {
    super.focusin(event);
    this.enableEditMode();
  }

  canvasPointerdown(event) {
    if (event.button !== 0 || !this.isInEditMode() || _classPrivateFieldGet(this, _disableEditing)) {
      return;
    }

    this.setInForeground();

    if (event.type !== "mouse") {
      this.div.focus();
    }

    event.stopPropagation();
    this.canvas.addEventListener("pointerleave", _classPrivateFieldGet(this, _boundCanvasPointerleave));
    this.canvas.addEventListener("pointermove", _classPrivateFieldGet(this, _boundCanvasPointermove));

    _classPrivateMethodGet(this, _startDrawing, _startDrawing2).call(this, event.offsetX, event.offsetY);
  }

  canvasPointermove(event) {
    event.stopPropagation();

    _classPrivateMethodGet(this, _draw, _draw2).call(this, event.offsetX, event.offsetY);
  }

  canvasPointerup(event) {
    if (event.button !== 0) {
      return;
    }

    if (this.isInEditMode() && this.currentPath.length !== 0) {
      event.stopPropagation();

      _classPrivateMethodGet(this, _endDrawing, _endDrawing2).call(this, event);

      this.setInBackground();
    }
  }

  canvasPointerleave(event) {
    _classPrivateMethodGet(this, _endDrawing, _endDrawing2).call(this, event);

    this.setInBackground();
  }

  render() {
    if (this.div) {
      return this.div;
    }

    let baseX, baseY;

    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }

    super.render();

    InkEditor._l10nPromise.get("editor_ink_aria_label").then(msg => {
      var _this$div;

      return (_this$div = this.div) === null || _this$div === void 0 ? void 0 : _this$div.setAttribute("aria-label", msg);
    });

    const [x, y, w, h] = _classPrivateMethodGet(this, _getInitialBBox, _getInitialBBox2).call(this);

    this.setAt(x, y, 0, 0);
    this.setDims(w, h);

    _classPrivateMethodGet(this, _createCanvas, _createCanvas2).call(this);

    if (this.width) {
      const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);

      _classPrivateFieldSet(this, _isCanvasInitialized, true);

      _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);

      this.setDims(this.width * parentWidth, this.height * parentHeight);

      _classPrivateMethodGet(this, _redraw, _redraw2).call(this);

      _classPrivateMethodGet(this, _setMinDims, _setMinDims2).call(this);

      this.div.classList.add("disabled");
    } else {
      this.div.classList.add("editing");
      this.enableEditMode();
    }

    _classPrivateMethodGet(this, _createObserver, _createObserver2).call(this);

    return this.div;
  }

  setDimensions(width, height) {
    const roundedWidth = Math.round(width);
    const roundedHeight = Math.round(height);

    if (_classPrivateFieldGet(this, _realWidth) === roundedWidth && _classPrivateFieldGet(this, _realHeight) === roundedHeight) {
      return;
    }

    _classPrivateFieldSet(this, _realWidth, roundedWidth);

    _classPrivateFieldSet(this, _realHeight, roundedHeight);

    this.canvas.style.visibility = "hidden";

    if (_classPrivateFieldGet(this, _aspectRatio) && Math.abs(_classPrivateFieldGet(this, _aspectRatio) - width / height) > 1e-2) {
      height = Math.ceil(width / _classPrivateFieldGet(this, _aspectRatio));
      this.setDims(width, height);
    }

    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;

    if (_classPrivateFieldGet(this, _disableEditing)) {
      _classPrivateMethodGet(this, _setScaleFactor, _setScaleFactor2).call(this, width, height);
    }

    _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);

    _classPrivateMethodGet(this, _redraw, _redraw2).call(this);

    this.canvas.style.visibility = "visible";
  }

  static deserialize(data, parent) {
    const editor = super.deserialize(data, parent);
    editor.thickness = data.thickness;
    editor.color = _util.Util.makeHexColor(...data.color);
    editor.opacity = data.opacity;
    const [pageWidth, pageHeight] = parent.pageDimensions;
    const width = editor.width * pageWidth;
    const height = editor.height * pageHeight;
    const scaleFactor = parent.scaleFactor;
    const padding = data.thickness / 2;

    _classPrivateFieldSet(editor, _aspectRatio, width / height);

    _classPrivateFieldSet(editor, _disableEditing, true);

    _classPrivateFieldSet(editor, _realWidth, Math.round(width));

    _classPrivateFieldSet(editor, _realHeight, Math.round(height));

    for (const {
      bezier
    } of data.paths) {
      const path = [];
      editor.paths.push(path);
      let p0 = scaleFactor * (bezier[0] - padding);
      let p1 = scaleFactor * (height - bezier[1] - padding);

      for (let i = 2, ii = bezier.length; i < ii; i += 6) {
        const p10 = scaleFactor * (bezier[i] - padding);
        const p11 = scaleFactor * (height - bezier[i + 1] - padding);
        const p20 = scaleFactor * (bezier[i + 2] - padding);
        const p21 = scaleFactor * (height - bezier[i + 3] - padding);
        const p30 = scaleFactor * (bezier[i + 4] - padding);
        const p31 = scaleFactor * (height - bezier[i + 5] - padding);
        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
        p0 = p30;
        p1 = p31;
      }

      const path2D = _classStaticPrivateMethodGet(this, InkEditor, _buildPath2D).call(this, path);

      editor.bezierPath2D.push(path2D);
    }

    const bbox = _classPrivateMethodGet(editor, _getBbox, _getBbox2).call(editor);

    _classPrivateFieldSet(editor, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));

    _classPrivateFieldSet(editor, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));

    _classPrivateMethodGet(editor, _setScaleFactor, _setScaleFactor2).call(editor, width, height);

    return editor;
  }

  serialize() {
    if (this.isEmpty()) {
      return null;
    }

    const rect = this.getRect(0, 0);
    const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];

    const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);

    return {
      annotationType: _util.AnnotationEditorType.INK,
      color,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: _classPrivateMethodGet(this, _serializePaths, _serializePaths2).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height),
      pageIndex: this.parent.pageIndex,
      rect,
      rotation: this.rotation
    };
  }

}

exports.InkEditor = InkEditor;

function _updateThickness2(thickness) {
  const savedThickness = this.thickness;
  this.parent.addCommands({
    cmd: () => {
      this.thickness = thickness;

      _classPrivateMethodGet(this, _fitToContent, _fitToContent2).call(this);
    },
    undo: () => {
      this.thickness = savedThickness;

      _classPrivateMethodGet(this, _fitToContent, _fitToContent2).call(this);
    },
    mustExec: true,
    type: _util.AnnotationEditorParamsType.INK_THICKNESS,
    overwriteIfSameType: true,
    keepUndo: true
  });
}

function _updateColor2(color) {
  const savedColor = this.color;
  this.parent.addCommands({
    cmd: () => {
      this.color = color;

      _classPrivateMethodGet(this, _redraw, _redraw2).call(this);
    },
    undo: () => {
      this.color = savedColor;

      _classPrivateMethodGet(this, _redraw, _redraw2).call(this);
    },
    mustExec: true,
    type: _util.AnnotationEditorParamsType.INK_COLOR,
    overwriteIfSameType: true,
    keepUndo: true
  });
}

function _updateOpacity2(opacity) {
  opacity /= 100;
  const savedOpacity = this.opacity;
  this.parent.addCommands({
    cmd: () => {
      this.opacity = opacity;

      _classPrivateMethodGet(this, _redraw, _redraw2).call(this);
    },
    undo: () => {
      this.opacity = savedOpacity;

      _classPrivateMethodGet(this, _redraw, _redraw2).call(this);
    },
    mustExec: true,
    type: _util.AnnotationEditorParamsType.INK_OPACITY,
    overwriteIfSameType: true,
    keepUndo: true
  });
}

function _getInitialBBox2() {
  const {
    width,
    height,
    rotation
  } = this.parent.viewport;

  switch (rotation) {
    case 90:
      return [0, width, width, height];

    case 180:
      return [width, height, width, height];

    case 270:
      return [height, 0, width, height];

    default:
      return [0, 0, width, height];
  }
}

function _setStroke2() {
  this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor;
  this.ctx.lineCap = "round";
  this.ctx.lineJoin = "round";
  this.ctx.miterLimit = 10;
  this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`;
}

function _startDrawing2(x, y) {
  this.isEditing = true;

  if (!_classPrivateFieldGet(this, _isCanvasInitialized)) {
    var _this$opacity2;

    _classPrivateFieldSet(this, _isCanvasInitialized, true);

    _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);

    this.thickness || (this.thickness = InkEditor._defaultThickness);
    this.color || (this.color = InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
    (_this$opacity2 = this.opacity) !== null && _this$opacity2 !== void 0 ? _this$opacity2 : this.opacity = InkEditor._defaultOpacity;
  }

  this.currentPath.push([x, y]);

  _classPrivateFieldSet(this, _lastPoint, null);

  _classPrivateMethodGet(this, _setStroke, _setStroke2).call(this);

  this.ctx.beginPath();
  this.ctx.moveTo(x, y);

  _classPrivateFieldSet(this, _requestFrameCallback, () => {
    if (!_classPrivateFieldGet(this, _requestFrameCallback)) {
      return;
    }

    if (_classPrivateFieldGet(this, _lastPoint)) {
      if (this.isEmpty()) {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      } else {
        _classPrivateMethodGet(this, _redraw, _redraw2).call(this);
      }

      this.ctx.lineTo(..._classPrivateFieldGet(this, _lastPoint));

      _classPrivateFieldSet(this, _lastPoint, null);

      this.ctx.stroke();
    }

    window.requestAnimationFrame(_classPrivateFieldGet(this, _requestFrameCallback));
  });

  window.requestAnimationFrame(_classPrivateFieldGet(this, _requestFrameCallback));
}

function _draw2(x, y) {
  const [lastX, lastY] = this.currentPath.at(-1);

  if (x === lastX && y === lastY) {
    return;
  }

  this.currentPath.push([x, y]);

  _classPrivateFieldSet(this, _lastPoint, [x, y]);
}

function _stopDrawing2(x, y) {
  this.ctx.closePath();

  _classPrivateFieldSet(this, _requestFrameCallback, null);

  x = Math.min(Math.max(x, 0), this.canvas.width);
  y = Math.min(Math.max(y, 0), this.canvas.height);
  const [lastX, lastY] = this.currentPath.at(-1);

  if (x !== lastX || y !== lastY) {
    this.currentPath.push([x, y]);
  }

  let bezier;

  if (this.currentPath.length !== 1) {
    bezier = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);
  } else {
    const xy = [x, y];
    bezier = [[xy, xy.slice(), xy.slice(), xy]];
  }

  const path2D = _classStaticPrivateMethodGet(InkEditor, InkEditor, _buildPath2D).call(InkEditor, bezier);

  this.currentPath.length = 0;

  const cmd = () => {
    this.paths.push(bezier);
    this.bezierPath2D.push(path2D);
    this.rebuild();
  };

  const undo = () => {
    this.paths.pop();
    this.bezierPath2D.pop();

    if (this.paths.length === 0) {
      this.remove();
    } else {
      if (!this.canvas) {
        _classPrivateMethodGet(this, _createCanvas, _createCanvas2).call(this);

        _classPrivateMethodGet(this, _createObserver, _createObserver2).call(this);
      }

      _classPrivateMethodGet(this, _fitToContent, _fitToContent2).call(this);
    }
  };

  this.parent.addCommands({
    cmd,
    undo,
    mustExec: true
  });
}

function _redraw2() {
  if (this.isEmpty()) {
    _classPrivateMethodGet(this, _updateTransform, _updateTransform2).call(this);

    return;
  }

  _classPrivateMethodGet(this, _setStroke, _setStroke2).call(this);

  const {
    canvas,
    ctx
  } = this;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  _classPrivateMethodGet(this, _updateTransform, _updateTransform2).call(this);

  for (const path of this.bezierPath2D) {
    ctx.stroke(path);
  }
}

function _endDrawing2(event) {
  _classPrivateMethodGet(this, _stopDrawing, _stopDrawing2).call(this, event.offsetX, event.offsetY);

  this.canvas.removeEventListener("pointerleave", _classPrivateFieldGet(this, _boundCanvasPointerleave));
  this.canvas.removeEventListener("pointermove", _classPrivateFieldGet(this, _boundCanvasPointermove));
  this.parent.addToAnnotationStorage(this);
}

function _createCanvas2() {
  this.canvas = document.createElement("canvas");
  this.canvas.width = this.canvas.height = 0;
  this.canvas.className = "inkEditorCanvas";

  InkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then(msg => {
    var _this$canvas;

    return (_this$canvas = this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.setAttribute("aria-label", msg);
  });

  this.div.append(this.canvas);
  this.ctx = this.canvas.getContext("2d");
}

function _createObserver2() {
  _classPrivateFieldSet(this, _observer, new ResizeObserver(entries => {
    const rect = entries[0].contentRect;

    if (rect.width && rect.height) {
      this.setDimensions(rect.width, rect.height);
    }
  }));

  _classPrivateFieldGet(this, _observer).observe(this.div);
}

function _setCanvasDims2() {
  if (!_classPrivateFieldGet(this, _isCanvasInitialized)) {
    return;
  }

  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
  this.canvas.width = Math.ceil(this.width * parentWidth);
  this.canvas.height = Math.ceil(this.height * parentHeight);

  _classPrivateMethodGet(this, _updateTransform, _updateTransform2).call(this);
}

function _setScaleFactor2(width, height) {
  const padding = _classPrivateMethodGet(this, _getPadding, _getPadding2).call(this);

  const scaleFactorW = (width - padding) / _classPrivateFieldGet(this, _baseWidth);

  const scaleFactorH = (height - padding) / _classPrivateFieldGet(this, _baseHeight);

  this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
}

function _updateTransform2() {
  const padding = _classPrivateMethodGet(this, _getPadding, _getPadding2).call(this) / 2;
  this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
}

function _buildPath2D(bezier) {
  const path2D = new Path2D();

  for (let i = 0, ii = bezier.length; i < ii; i++) {
    const [first, control1, control2, second] = bezier[i];

    if (i === 0) {
      path2D.moveTo(...first);
    }

    path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
  }

  return path2D;
}

function _serializePaths2(s, tx, ty, h) {
  const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;
  const paths = [];
  const padding = this.thickness / 2;
  let buffer, points;

  for (const bezier of this.paths) {
    buffer = [];
    points = [];

    for (let i = 0, ii = bezier.length; i < ii; i++) {
      const [first, control1, control2, second] = bezier[i];
      const p10 = s * (first[0] + tx) + padding;
      const p11 = h - s * (first[1] + ty) - padding;
      const p20 = s * (control1[0] + tx) + padding;
      const p21 = h - s * (control1[1] + ty) - padding;
      const p30 = s * (control2[0] + tx) + padding;
      const p31 = h - s * (control2[1] + ty) - padding;
      const p40 = s * (second[0] + tx) + padding;
      const p41 = h - s * (second[1] + ty) - padding;

      if (i === 0) {
        buffer.push(p10, p11);
        points.push(p10, p11);
      }

      buffer.push(p20, p21, p30, p31, p40, p41);

      _classPrivateMethodGet(this, _extractPointsOnBezier, _extractPointsOnBezier2).call(this, p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);
    }

    paths.push({
      bezier: buffer,
      points
    });
  }

  return paths;
}

function _extractPointsOnBezier2(p10, p11, p20, p21, p30, p31, p40, p41, n, points) {
  if (_classPrivateMethodGet(this, _isAlmostFlat, _isAlmostFlat2).call(this, p10, p11, p20, p21, p30, p31, p40, p41)) {
    points.push(p40, p41);
    return;
  }

  for (let i = 1; i < n - 1; i++) {
    const t = i / n;
    const mt = 1 - t;
    let q10 = t * p10 + mt * p20;
    let q11 = t * p11 + mt * p21;
    let q20 = t * p20 + mt * p30;
    let q21 = t * p21 + mt * p31;
    const q30 = t * p30 + mt * p40;
    const q31 = t * p31 + mt * p41;
    q10 = t * q10 + mt * q20;
    q11 = t * q11 + mt * q21;
    q20 = t * q20 + mt * q30;
    q21 = t * q21 + mt * q31;
    q10 = t * q10 + mt * q20;
    q11 = t * q11 + mt * q21;
    points.push(q10, q11);
  }

  points.push(p40, p41);
}

function _isAlmostFlat2(p10, p11, p20, p21, p30, p31, p40, p41) {
  const tol = 10;
  const ax = (3 * p20 - 2 * p10 - p40) ** 2;
  const ay = (3 * p21 - 2 * p11 - p41) ** 2;
  const bx = (3 * p30 - p10 - 2 * p40) ** 2;
  const by = (3 * p31 - p11 - 2 * p41) ** 2;
  return Math.max(ax, bx) + Math.max(ay, by) <= tol;
}

function _getBbox2() {
  let xMin = Infinity;
  let xMax = -Infinity;
  let yMin = Infinity;
  let yMax = -Infinity;

  for (const path of this.paths) {
    for (const [first, control1, control2, second] of path) {
      const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);

      xMin = Math.min(xMin, bbox[0]);
      yMin = Math.min(yMin, bbox[1]);
      xMax = Math.max(xMax, bbox[2]);
      yMax = Math.max(yMax, bbox[3]);
    }
  }

  return [xMin, yMin, xMax, yMax];
}

function _getPadding2() {
  return _classPrivateFieldGet(this, _disableEditing) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
}

function _fitToContent2() {
  let firstTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  if (this.isEmpty()) {
    return;
  }

  if (!_classPrivateFieldGet(this, _disableEditing)) {
    _classPrivateMethodGet(this, _redraw, _redraw2).call(this);

    return;
  }

  const bbox = _classPrivateMethodGet(this, _getBbox, _getBbox2).call(this);

  const padding = _classPrivateMethodGet(this, _getPadding, _getPadding2).call(this);

  _classPrivateFieldSet(this, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));

  _classPrivateFieldSet(this, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));

  const width = Math.ceil(padding + _classPrivateFieldGet(this, _baseWidth) * this.scaleFactor);
  const height = Math.ceil(padding + _classPrivateFieldGet(this, _baseHeight) * this.scaleFactor);
  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
  this.width = width / parentWidth;
  this.height = height / parentHeight;

  _classPrivateFieldSet(this, _aspectRatio, width / height);

  _classPrivateMethodGet(this, _setMinDims, _setMinDims2).call(this);

  const prevTranslationX = this.translationX;
  const prevTranslationY = this.translationY;
  this.translationX = -bbox[0];
  this.translationY = -bbox[1];

  _classPrivateMethodGet(this, _setCanvasDims, _setCanvasDims2).call(this);

  _classPrivateMethodGet(this, _redraw, _redraw2).call(this);

  _classPrivateFieldSet(this, _realWidth, width);

  _classPrivateFieldSet(this, _realHeight, height);

  this.setDims(width, height);
  const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
  this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
}

function _setMinDims2() {
  const {
    style
  } = this.div;

  if (_classPrivateFieldGet(this, _aspectRatio) >= 1) {
    style.minHeight = `${RESIZER_SIZE}px`;
    style.minWidth = `${Math.round(_classPrivateFieldGet(this, _aspectRatio) * RESIZER_SIZE)}px`;
  } else {
    style.minWidth = `${RESIZER_SIZE}px`;
    style.minHeight = `${Math.round(RESIZER_SIZE / _classPrivateFieldGet(this, _aspectRatio))}px`;
  }
}

_defineProperty(InkEditor, "_defaultColor", null);

_defineProperty(InkEditor, "_defaultOpacity", 1);

_defineProperty(InkEditor, "_defaultThickness", 1);

_defineProperty(InkEditor, "_l10nPromise", void 0);

_defineProperty(InkEditor, "_type", "ink");

/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.fitCurve = void 0;

const fitCurve = __w_pdfjs_require__(151);

exports.fitCurve = fitCurve;

/***/ }),
/* 151 */
/***/ ((module) => {


function fitCurve(points, maxError, progressCallback) {
  if (!Array.isArray(points)) {
    throw new TypeError("First argument should be an array");
  }

  points.forEach(point => {
    if (!Array.isArray(point) || point.some(item => typeof item !== 'number') || point.length !== points[0].length) {
      throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
    }
  });
  points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j]));

  if (points.length < 2) {
    return [];
  }

  const len = points.length;
  const leftTangent = createTangent(points[1], points[0]);
  const rightTangent = createTangent(points[len - 2], points[len - 1]);
  return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
}

function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
  const MaxIterations = 20;
  var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist, i;

  if (points.length === 2) {
    dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;
    bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];
    return [bezCurve];
  }

  u = chordLengthParameterize(points);
  [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);

  if (maxError === 0 || maxError < error) {
    return [bezCurve];
  }

  if (maxError < error * error) {
    uPrime = u;
    prevErr = maxError;
    prevSplit = splitPoint;

    for (i = 0; i < MaxIterations; i++) {
      uPrime = reparameterize(bezCurve, points, uPrime);
      [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);

      if (maxError < error) {
        return [bezCurve];
      } else if (splitPoint === prevSplit) {
        let errChange = maxError / prevErr;

        if (errChange > .9999 && errChange < 1.0001) {
          break;
        }
      }

      prevErr = maxError;
      prevSplit = splitPoint;
    }
  }

  beziers = [];
  centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);

  if (centerVector.every(val => val === 0)) {
    centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
    [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];
  }

  toCenterTangent = maths.normalize(centerVector);
  fromCenterTangent = maths.mulItems(toCenterTangent, -1);
  beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
  beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
  return beziers;
}

function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
  var bezCurve, maxError, splitPoint;
  bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent);
  [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);

  if (progressCallback) {
    progressCallback({
      bez: bezCurve,
      points: points,
      params: paramsOrig,
      maxErr: maxError,
      maxPoint: splitPoint
    });
  }

  return [bezCurve, maxError, splitPoint];
}

function generateBezier(points, parameters, leftTangent, rightTangent) {
  var bezCurve,
      A,
      a,
      C,
      X,
      det_C0_C1,
      det_C0_X,
      det_X_C1,
      alpha_l,
      alpha_r,
      epsilon,
      segLength,
      i,
      len,
      tmp,
      u,
      ux,
      firstPoint = points[0],
      lastPoint = points[points.length - 1];
  bezCurve = [firstPoint, null, null, lastPoint];
  A = maths.zeros_Xx2x2(parameters.length);

  for (i = 0, len = parameters.length; i < len; i++) {
    u = parameters[i];
    ux = 1 - u;
    a = A[i];
    a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
    a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
  }

  C = [[0, 0], [0, 0]];
  X = [0, 0];

  for (i = 0, len = points.length; i < len; i++) {
    u = parameters[i];
    a = A[i];
    C[0][0] += maths.dot(a[0], a[0]);
    C[0][1] += maths.dot(a[0], a[1]);
    C[1][0] += maths.dot(a[0], a[1]);
    C[1][1] += maths.dot(a[1], a[1]);
    tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
    X[0] += maths.dot(a[0], tmp);
    X[1] += maths.dot(a[1], tmp);
  }

  det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
  det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
  det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
  alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
  alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
  segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
  epsilon = 1.0e-6 * segLength;

  if (alpha_l < epsilon || alpha_r < epsilon) {
    bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0));
    bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0));
  } else {
    bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
    bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
  }

  return bezCurve;
}

function reparameterize(bezier, points, parameters) {
  return parameters.map((p, i) => newtonRaphsonRootFind(bezier, points[i], p));
}

function newtonRaphsonRootFind(bez, point, u) {
  var d = maths.subtract(bezier.q(bez, u), point),
      qprime = bezier.qprime(bez, u),
      numerator = maths.mulMatrix(d, qprime),
      denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));

  if (denominator === 0) {
    return u;
  } else {
    return u - numerator / denominator;
  }
}

function chordLengthParameterize(points) {
  var u = [],
      currU,
      prevU,
      prevP;
  points.forEach((p, i) => {
    currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
    u.push(currU);
    prevU = currU;
    prevP = p;
  });
  u = u.map(x => x / prevU);
  return u;
}

function computeMaxError(points, bez, parameters) {
  var dist, maxDist, splitPoint, v, i, count, point, t;
  maxDist = 0;
  splitPoint = Math.floor(points.length / 2);
  const t_distMap = mapTtoRelativeDistances(bez, 10);

  for (i = 0, count = points.length; i < count; i++) {
    point = points[i];
    t = find_t(bez, parameters[i], t_distMap, 10);
    v = maths.subtract(bezier.q(bez, t), point);
    dist = v[0] * v[0] + v[1] * v[1];

    if (dist > maxDist) {
      maxDist = dist;
      splitPoint = i;
    }
  }

  return [maxDist, splitPoint];
}

var mapTtoRelativeDistances = function (bez, B_parts) {
  var B_t_curr;
  var B_t_dist = [0];
  var B_t_prev = bez[0];
  var sumLen = 0;

  for (var i = 1; i <= B_parts; i++) {
    B_t_curr = bezier.q(bez, i / B_parts);
    sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
    B_t_dist.push(sumLen);
    B_t_prev = B_t_curr;
  }

  B_t_dist = B_t_dist.map(x => x / sumLen);
  return B_t_dist;
};

function find_t(bez, param, t_distMap, B_parts) {
  if (param < 0) {
    return 0;
  }

  if (param > 1) {
    return 1;
  }

  var lenMax, lenMin, tMax, tMin, t;

  for (var i = 1; i <= B_parts; i++) {
    if (param <= t_distMap[i]) {
      tMin = (i - 1) / B_parts;
      tMax = i / B_parts;
      lenMin = t_distMap[i - 1];
      lenMax = t_distMap[i];
      t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
      break;
    }
  }

  return t;
}

function createTangent(pointA, pointB) {
  return maths.normalize(maths.subtract(pointA, pointB));
}

class maths {
  static zeros_Xx2x2(x) {
    var zs = [];

    while (x--) {
      zs.push([0, 0]);
    }

    return zs;
  }

  static mulItems(items, multiplier) {
    return items.map(x => x * multiplier);
  }

  static mulMatrix(m1, m2) {
    return m1.reduce((sum, x1, i) => sum + x1 * m2[i], 0);
  }

  static subtract(arr1, arr2) {
    return arr1.map((x1, i) => x1 - arr2[i]);
  }

  static addArrays(arr1, arr2) {
    return arr1.map((x1, i) => x1 + arr2[i]);
  }

  static addItems(items, addition) {
    return items.map(x => x + addition);
  }

  static sum(items) {
    return items.reduce((sum, x) => sum + x);
  }

  static dot(m1, m2) {
    return maths.mulMatrix(m1, m2);
  }

  static vectorLen(v) {
    return Math.hypot(...v);
  }

  static divItems(items, divisor) {
    return items.map(x => x / divisor);
  }

  static squareItems(items) {
    return items.map(x => x * x);
  }

  static normalize(v) {
    return this.divItems(v, this.vectorLen(v));
  }

}

class bezier {
  static q(ctrlPoly, t) {
    var tx = 1.0 - t;
    var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx),
        pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t),
        pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t),
        pD = maths.mulItems(ctrlPoly[3], t * t * t);
    return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
  }

  static qprime(ctrlPoly, t) {
    var tx = 1.0 - t;
    var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx),
        pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t),
        pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
    return maths.addArrays(maths.addArrays(pA, pB), pC);
  }

  static qprimeprime(ctrlPoly, t) {
    return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
  }

}

module.exports = fitCurve;
module.exports.fitCubic = fitCubic;
module.exports.createTangent = createTangent;

/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationLayer = void 0;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(133);

var _annotation_storage = __w_pdfjs_require__(130);

var _scripting_utils = __w_pdfjs_require__(153);

var _xfa_layer = __w_pdfjs_require__(154);

function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }

function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

const DEFAULT_TAB_INDEX = 1000;
const DEFAULT_FONT_SIZE = 9;
const GetElementsByNameSet = new WeakSet();

function getRectDims(rect) {
  return {
    width: rect[2] - rect[0],
    height: rect[3] - rect[1]
  };
}

class AnnotationElementFactory {
  static create(parameters) {
    const subtype = parameters.data.annotationType;

    switch (subtype) {
      case _util.AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);

      case _util.AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);

      case _util.AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;

        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);

          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }

            return new PushButtonWidgetAnnotationElement(parameters);

          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
        }

        return new WidgetAnnotationElement(parameters);

      case _util.AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);

      case _util.AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);

      case _util.AnnotationType.LINE:
        return new LineAnnotationElement(parameters);

      case _util.AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);

      case _util.AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);

      case _util.AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);

      case _util.AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);

      case _util.AnnotationType.INK:
        return new InkAnnotationElement(parameters);

      case _util.AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);

      case _util.AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);

      case _util.AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);

      case _util.AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);

      case _util.AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);

      case _util.AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);

      case _util.AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);

      default:
        return new AnnotationElement(parameters);
    }
  }

}

class AnnotationElement {
  constructor(parameters) {
    let {
      isRenderable = false,
      ignoreBorder = false,
      createQuadrilaterals = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.page = parameters.page;
    this.viewport = parameters.viewport;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this._mouseState = parameters.mouseState;

    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }

    if (createQuadrilaterals) {
      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
    }
  }

  _createContainer() {
    let ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const data = this.data,
          page = this.page,
          viewport = this.viewport;
    const container = document.createElement("section");
    const {
      width,
      height
    } = getRectDims(data.rect);
    const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox;
    const pageWidth = pageURx - pageLLx;
    const pageHeight = pageURy - pageLLy;
    container.setAttribute("data-annotation-id", data.id);

    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

    if (!ignoreBorder && data.borderStyle.width > 0) {
      container.style.borderWidth = `${data.borderStyle.width}px`;
      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;

      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
        container.style.borderRadius = radius;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
        container.style.borderRadius = radius;
      }

      switch (data.borderStyle.style) {
        case _util.AnnotationBorderStyleType.SOLID:
          container.style.borderStyle = "solid";
          break;

        case _util.AnnotationBorderStyleType.DASHED:
          container.style.borderStyle = "dashed";
          break;

        case _util.AnnotationBorderStyleType.BEVELED:
          (0, _util.warn)("Unimplemented border style: beveled");
          break;

        case _util.AnnotationBorderStyleType.INSET:
          (0, _util.warn)("Unimplemented border style: inset");
          break;

        case _util.AnnotationBorderStyleType.UNDERLINE:
          container.style.borderBottomStyle = "solid";
          break;
      }

      const borderColor = data.borderColor || null;

      if (borderColor) {
        container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
      } else {
        container.style.borderWidth = 0;
      }
    }

    container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`;
    container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`;
    const {
      rotation
    } = data;

    if (data.hasOwnCanvas || rotation === 0) {
      container.style.width = `${100 * width / pageWidth}%`;
      container.style.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation, container);
    }

    return container;
  }

  setRotation(angle) {
    let container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
    const pageWidth = pageURx - pageLLx;
    const pageHeight = pageURy - pageLLy;
    const {
      width,
      height
    } = getRectDims(this.data.rect);
    let elementWidth, elementHeight;

    if (angle % 180 === 0) {
      elementWidth = 100 * width / pageWidth;
      elementHeight = 100 * height / pageHeight;
    } else {
      elementWidth = 100 * height / pageWidth;
      elementHeight = 100 * width / pageHeight;
    }

    container.style.width = `${elementWidth}%`;
    container.style.height = `${elementHeight}%`;
    container.setAttribute("data-main-rotation", (360 - angle) % 360);
  }

  get _commonActions() {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
    };

    return (0, _util.shadow)(this, "_commonActions", {
      display: event => {
        const hidden = event.detail.display % 2 === 1;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          hidden,
          print: event.detail.display === 0 || event.detail.display === 3
        });
      },
      print: event => {
        this.annotationStorage.setValue(this.data.id, {
          print: event.detail.print
        });
      },
      hidden: event => {
        this.container.style.visibility = event.detail.hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          hidden: event.detail.hidden
        });
      },
      focus: event => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: event => {
        event.target.title = event.detail.userName;
      },
      readonly: event => {
        if (event.detail.readonly) {
          event.target.setAttribute("readonly", "");
        } else {
          event.target.removeAttribute("readonly");
        }
      },
      required: event => {
        this._setRequired(event.target, event.detail.required);
      },
      bgColor: event => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: event => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: event => {
        setColor("fgColor", "color", event);
      },
      textColor: event => {
        setColor("textColor", "color", event);
      },
      borderColor: event => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: event => {
        setColor("strokeColor", "borderColor", event);
      },
      rotation: event => {
        const angle = event.detail.rotation;
        this.setRotation(angle);
        this.annotationStorage.setValue(this.data.id, {
          rotation: angle
        });
      }
    });
  }

  _dispatchEventFromSandbox(actions, jsEvent) {
    const commonActions = this._commonActions;

    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];

      if (action) {
        action(jsEvent);
      }
    }
  }

  _setDefaultPropertiesFromJS(element) {
    if (!this.enableScripting) {
      return;
    }

    const storedData = this.annotationStorage.getRawValue(this.data.id);

    if (!storedData) {
      return;
    }

    const commonActions = this._commonActions;

    for (const [actionName, detail] of Object.entries(storedData)) {
      const action = commonActions[actionName];

      if (action) {
        const eventProxy = {
          detail: {
            [actionName]: detail
          },
          target: element
        };
        action(eventProxy);
        delete storedData[actionName];
      }
    }
  }

  _createQuadrilaterals() {
    let ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (!this.data.quadPoints) {
      return null;
    }

    const quadrilaterals = [];
    const savedRect = this.data.rect;

    for (const quadPoint of this.data.quadPoints) {
      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
      quadrilaterals.push(this._createContainer(ignoreBorder));
    }

    this.data.rect = savedRect;
    return quadrilaterals;
  }

  _createPopup(trigger, data) {
    let container = this.container;

    if (this.quadrilaterals) {
      trigger = trigger || this.quadrilaterals;
      container = this.quadrilaterals[0];
    }

    if (!trigger) {
      trigger = document.createElement("div");
      trigger.className = "popupTriggerArea";
      container.append(trigger);
    }

    const popupElement = new PopupElement({
      container,
      trigger,
      color: data.color,
      titleObj: data.titleObj,
      modificationDate: data.modificationDate,
      contentsObj: data.contentsObj,
      richText: data.richText,
      hideWrapper: true
    });
    const popup = popupElement.render();
    popup.style.left = "100%";
    container.append(popup);
  }

  _renderQuadrilaterals(className) {
    for (const quadrilateral of this.quadrilaterals) {
      quadrilateral.className = className;
    }

    return this.quadrilaterals;
  }

  render() {
    (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
  }

  _getElementsByName(name) {
    let skipId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const fields = [];

    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name];

      if (fieldObj) {
        for (const {
          page,
          id,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }

          if (id === skipId) {
            continue;
          }

          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.querySelector(`[data-element-id="${id}"]`);

          if (domElement && !GetElementsByNameSet.has(domElement)) {
            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);
            continue;
          }

          fields.push({
            id,
            exportValue,
            domElement
          });
        }
      }

      return fields;
    }

    for (const domElement of document.getElementsByName(name)) {
      const {
        id,
        exportValue
      } = domElement;

      if (id === skipId) {
        continue;
      }

      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }

      fields.push({
        id,
        exportValue,
        domElement
      });
    }

    return fields;
  }

  static get platform() {
    const platform = typeof navigator !== "undefined" ? navigator.platform : "";
    return (0, _util.shadow)(this, "platform", {
      isWin: platform.includes("Win"),
      isMac: platform.includes("Mac")
    });
  }

}

class LinkAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    super(parameters, {
      isRenderable: true,
      ignoreBorder: !!(options !== null && options !== void 0 && options.ignoreBorder),
      createQuadrilaterals: true
    });
    this.isTooltipOnly = parameters.data.isTooltipOnly;
  }

  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");
    link.setAttribute("data-element-id", data.id);
    let isBound = false;

    if (data.url) {
      linkService.addLinkAttributes(link, data.url, data.newWindow);
      isBound = true;
    } else if (data.action) {
      this._bindNamedAction(link, data.action);

      isBound = true;
    } else if (data.dest) {
      this._bindLink(link, data.dest);

      isBound = true;
    } else {
      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data);

        isBound = true;
      }

      if (data.resetForm) {
        this._bindResetFormAction(link, data.resetForm);

        isBound = true;
      } else if (this.isTooltipOnly && !isBound) {
        this._bindLink(link, "");

        isBound = true;
      }
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
        const linkElement = index === 0 ? link : link.cloneNode();
        quadrilateral.append(linkElement);
        return quadrilateral;
      });
    }

    this.container.className = "linkAnnotation";

    if (isBound) {
      this.container.append(link);
    }

    return this.container;
  }

  _bindLink(link, destination) {
    link.href = this.linkService.getDestinationHash(destination);

    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }

      return false;
    };

    if (destination || destination === "") {
      link.className = "internalLink";
    }
  }

  _bindNamedAction(link, action) {
    link.href = this.linkService.getAnchorUrl("");

    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };

    link.className = "internalLink";
  }

  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

    for (const name of Object.keys(data.actions)) {
      const jsName = map.get(name);

      if (!jsName) {
        continue;
      }

      link[jsName] = () => {
        var _this$linkService$eve;

        (_this$linkService$eve = this.linkService.eventBus) === null || _this$linkService$eve === void 0 ? void 0 : _this$linkService$eve.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name
          }
        });
        return false;
      };
    }

    if (!link.onclick) {
      link.onclick = () => false;
    }

    link.className = "internalLink";
  }

  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;

    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }

    link.className = "internalLink";

    if (!this._fieldObjects) {
      (0, _util.warn)(`_bindResetFormAction - "resetForm" action not supported, ` + "ensure that the `fieldObjects` parameter is provided.");

      if (!otherClickAction) {
        link.onclick = () => false;
      }

      return;
    }

    link.onclick = () => {
      if (otherClickAction) {
        otherClickAction();
      }

      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];

      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);

        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];

          for (const {
            id
          } of fields) {
            fieldIds.add(id);
          }
        }

        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }

      const storage = this.annotationStorage;
      const allIds = [];

      for (const field of allFields) {
        const {
          id
        } = field;
        allIds.push(id);

        switch (field.type) {
          case "text":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }

          case "checkbox":
          case "radiobutton":
            {
              const value = field.defaultValue === field.exportValues;
              storage.setValue(id, {
                value
              });
              break;
            }

          case "combobox":
          case "listbox":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }

          default:
            continue;
        }

        const domElement = document.querySelector(`[data-element-id="${id}"]`);

        if (!domElement) {
          continue;
        } else if (!GetElementsByNameSet.has(domElement)) {
          (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);
          continue;
        }

        domElement.dispatchEvent(new Event("resetform"));
      }

      if (this.enableScripting) {
        var _this$linkService$eve2;

        (_this$linkService$eve2 = this.linkService.eventBus) === null || _this$linkService$eve2 === void 0 ? void 0 : _this$linkService$eve2.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }

      return false;
    };
  }

}

class TextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl, _parameters$data$cont, _parameters$data$rich;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl = parameters.data.titleObj) !== null && _parameters$data$titl !== void 0 && _parameters$data$titl.str || (_parameters$data$cont = parameters.data.contentsObj) !== null && _parameters$data$cont !== void 0 && _parameters$data$cont.str || (_parameters$data$rich = parameters.data.richText) !== null && _parameters$data$rich !== void 0 && _parameters$data$rich.str);
    super(parameters, {
      isRenderable
    });
  }

  render() {
    this.container.className = "textAnnotation";
    const image = document.createElement("img");
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.alt = "[{{type}} Annotation]";
    image.dataset.l10nId = "text_annotation_type";
    image.dataset.l10nArgs = JSON.stringify({
      type: this.data.name
    });

    if (!this.data.hasPopup) {
      this._createPopup(image, this.data);
    }

    this.container.append(image);
    return this.container;
  }

}

class WidgetAnnotationElement extends AnnotationElement {
  render() {
    if (this.data.alternativeText) {
      this.container.title = this.data.alternativeText;
    }

    return this.container;
  }

  _getKeyModifier(event) {
    const {
      isWin,
      isMac
    } = AnnotationElement.platform;
    return isWin && event.ctrlKey || isMac && event.metaKey;
  }

  _setEventListener(element, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, event => {
        var _this$linkService$eve3;

        (_this$linkService$eve3 = this.linkService.eventBus) === null || _this$linkService$eve3 === void 0 ? void 0 : _this$linkService$eve3.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, event => {
        var _this$linkService$eve4;

        (_this$linkService$eve4 = this.linkService.eventBus) === null || _this$linkService$eve4 === void 0 ? void 0 : _this$linkService$eve4.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event)
          }
        });
      });
    }
  }

  _setEventListeners(element, names, getter) {
    for (const [baseName, eventName] of names) {
      var _this$data$actions;

      if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
        this._setEventListener(element, baseName, eventName, getter);
      }
    }
  }

  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
  }

  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontColor
    } = this.data.defaultAppearanceData;
    const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
    const style = element.style;
    let computedFontSize;

    if (this.data.multiLine) {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
      const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;
      const lineHeight = height / numberOfLines;
      computedFontSize = Math.min(fontSize, Math.round(lineHeight / _util.LINE_FACTOR));
    } else {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
      computedFontSize = Math.min(fontSize, Math.round(height / _util.LINE_FACTOR));
    }

    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }

  _setRequired(element, isRequired) {
    if (isRequired) {
      element.setAttribute("required", true);
    } else {
      element.removeAttribute("required");
    }

    element.setAttribute("aria-required", isRequired);
  }

}

class TextWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }

  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;

    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }

      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }

  render() {
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.className = "textWidgetAnnotation";
    let element = null;

    if (this.renderForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue
      });
      let textContent = storedData.formattedValue || storedData.value || "";
      const maxLen = storage.getValue(id, {
        charLimit: this.data.maxLen
      }).charLimit;

      if (maxLen && textContent.length > maxLen) {
        textContent = textContent.slice(0, maxLen);
      }

      const elementData = {
        userValue: textContent,
        formattedValue: null,
        valueOnFocus: ""
      };

      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = textContent;

        if (this.data.doNotScroll) {
          element.style.overflowY = "hidden";
        }
      } else {
        element = document.createElement("input");
        element.type = "text";
        element.setAttribute("value", textContent);

        if (this.data.doNotScroll) {
          element.style.overflowX = "hidden";
        }
      }

      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = DEFAULT_TAB_INDEX;

      this._setRequired(element, this.data.required);

      if (maxLen) {
        element.maxLength = maxLen;
      }

      element.addEventListener("input", event => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
      });
      element.addEventListener("resetform", event => {
        var _this$data$defaultFie;

        const defaultValue = (_this$data$defaultFie = this.data.defaultFieldValue) !== null && _this$data$defaultFie !== void 0 ? _this$data$defaultFie : "";
        element.value = elementData.userValue = defaultValue;
        elementData.formattedValue = null;
      });

      let blurListener = event => {
        const {
          formattedValue
        } = elementData;

        if (formattedValue !== null && formattedValue !== undefined) {
          event.target.value = formattedValue;
        }

        event.target.scrollLeft = 0;
      };

      if (this.enableScripting && this.hasJSActions) {
        var _this$data$actions2;

        element.addEventListener("focus", event => {
          if (elementData.userValue) {
            event.target.value = elementData.userValue;
          }

          elementData.valueOnFocus = event.target.value;
        });
        element.addEventListener("updatefromsandbox", jsEvent => {
          const actions = {
            value(event) {
              var _event$detail$value;

              elementData.userValue = (_event$detail$value = event.detail.value) !== null && _event$detail$value !== void 0 ? _event$detail$value : "";
              storage.setValue(id, {
                value: elementData.userValue.toString()
              });
              event.target.value = elementData.userValue;
            },

            formattedValue(event) {
              const {
                formattedValue
              } = event.detail;
              elementData.formattedValue = formattedValue;

              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {
                event.target.value = formattedValue;
              }

              storage.setValue(id, {
                formattedValue
              });
            },

            selRange(event) {
              event.target.setSelectionRange(...event.detail.selRange);
            },

            charLimit: event => {
              var _this$linkService$eve5;

              const {
                charLimit
              } = event.detail;
              const {
                target
              } = event;

              if (charLimit === 0) {
                target.removeAttribute("maxLength");
                return;
              }

              target.setAttribute("maxLength", charLimit);
              let value = elementData.userValue;

              if (!value || value.length <= charLimit) {
                return;
              }

              value = value.slice(0, charLimit);
              target.value = elementData.userValue = value;
              storage.setValue(id, {
                value
              });
              (_this$linkService$eve5 = this.linkService.eventBus) === null || _this$linkService$eve5 === void 0 ? void 0 : _this$linkService$eve5.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: 1,
                  selStart: target.selectionStart,
                  selEnd: target.selectionEnd
                }
              });
            }
          };

          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", event => {
          var _this$linkService$eve6;

          let commitKey = -1;

          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter") {
            commitKey = 2;
          } else if (event.key === "Tab") {
            commitKey = 3;
          }

          if (commitKey === -1) {
            return;
          }

          const {
            value
          } = event.target;

          if (elementData.valueOnFocus === value) {
            return;
          }

          elementData.userValue = value;
          (_this$linkService$eve6 = this.linkService.eventBus) === null || _this$linkService$eve6 === void 0 ? void 0 : _this$linkService$eve6.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", event => {
          const {
            value
          } = event.target;
          elementData.userValue = value;

          if (this._mouseState.isDown && elementData.valueOnFocus !== value) {
            var _this$linkService$eve7;

            (_this$linkService$eve7 = this.linkService.eventBus) === null || _this$linkService$eve7 === void 0 ? void 0 : _this$linkService$eve7.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey: 1,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }

          _blurListener(event);
        });

        if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {
          element.addEventListener("beforeinput", event => {
            var _this$linkService$eve8;

            const {
              data,
              target
            } = event;
            const {
              value,
              selectionStart,
              selectionEnd
            } = target;
            let selStart = selectionStart,
                selEnd = selectionEnd;

            switch (event.inputType) {
              case "deleteWordBackward":
                {
                  const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);

                  if (match) {
                    selStart -= match[0].length;
                  }

                  break;
                }

              case "deleteWordForward":
                {
                  const match = value.substring(selectionStart).match(/^[^\w]*\w*/);

                  if (match) {
                    selEnd += match[0].length;
                  }

                  break;
                }

              case "deleteContentBackward":
                if (selectionStart === selectionEnd) {
                  selStart -= 1;
                }

                break;

              case "deleteContentForward":
                if (selectionStart === selectionEnd) {
                  selEnd += 1;
                }

                break;
            }

            event.preventDefault();
            (_this$linkService$eve8 = this.linkService.eventBus) === null || _this$linkService$eve8 === void 0 ? void 0 : _this$linkService$eve8.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                change: data || "",
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }

        this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
      }

      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }

      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
    }

    this._setTextStyle(element);

    this._setBackgroundColor(element);

    this._setDefaultPropertiesFromJS(element);

    this.container.append(element);
    return this.container;
  }

}

class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.exportValue === data.fieldValue
    }).value;

    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }

    this.container.className = "buttonWidgetAnnotation checkBox";
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;

    this._setRequired(element, this.data.required);

    element.type = "checkbox";
    element.name = data.fieldName;

    if (value) {
      element.setAttribute("checked", true);
    }

    element.setAttribute("exportValue", data.exportValue);
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;

      for (const checkbox of this._getElementsByName(name, id)) {
        const curChecked = checked && checkbox.exportValue === data.exportValue;

        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }

        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }

      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data.exportValue;
    });

    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });

      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }

    this._setBackgroundColor(element);

    this._setDefaultPropertiesFromJS(element);

    this.container.append(element);
    return this.container;
  }

}

class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    this.container.className = "buttonWidgetAnnotation radioButton";
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;

    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }

    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;

    this._setRequired(element, this.data.required);

    element.type = "radio";
    element.name = data.fieldName;

    if (value) {
      element.setAttribute("checked", true);
    }

    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;

      for (const radio of this._getElementsByName(name, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }

      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
    });

    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value: event => {
            const checked = pdfButtonValue === event.detail.value;

            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id;

              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }

              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }
        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });

      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }

    this._setBackgroundColor(element);

    this._setDefaultPropertiesFromJS(element);

    this.container.append(element);
    return this.container;
  }

}

class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }

  render() {
    const container = super.render();
    container.className = "buttonWidgetAnnotation pushButton";

    if (this.data.alternativeText) {
      container.title = this.data.alternativeText;
    }

    const linkElement = container.lastChild;

    if (this.enableScripting && this.hasJSActions && linkElement) {
      this._setDefaultPropertiesFromJS(linkElement);

      linkElement.addEventListener("updatefromsandbox", jsEvent => {
        this._dispatchEventFromSandbox({}, jsEvent);
      });
    }

    return container;
  }

}

class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    this.container.className = "choiceWidgetAnnotation";
    const storage = this.annotationStorage;
    const id = this.data.id;
    const storedData = storage.getValue(id, {
      value: this.data.fieldValue
    });
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.setAttribute("data-element-id", id);
    selectElement.disabled = this.data.readOnly;

    this._setRequired(selectElement, this.data.required);

    selectElement.name = this.data.fieldName;
    selectElement.tabIndex = DEFAULT_TAB_INDEX;
    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;

    if (!this.data.combo) {
      selectElement.size = this.data.options.length;

      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }

    selectElement.addEventListener("resetform", event => {
      const defaultValue = this.data.defaultFieldValue;

      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });

    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;

      if (storedData.value.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
        addAnEmptyEntry = false;
      }

      selectElement.append(optionElement);
    }

    let removeEmptyEntry = null;

    if (addAnEmptyEntry) {
      const noneOptionElement = document.createElement("option");
      noneOptionElement.value = " ";
      noneOptionElement.setAttribute("hidden", true);
      noneOptionElement.setAttribute("selected", true);
      selectElement.prepend(noneOptionElement);

      removeEmptyEntry = () => {
        noneOptionElement.remove();
        selectElement.removeEventListener("input", removeEmptyEntry);
        removeEmptyEntry = null;
      };

      selectElement.addEventListener("input", removeEmptyEntry);
    }

    const getValue = (event, isExport) => {
      const name = isExport ? "value" : "textContent";
      const options = event.target.options;

      if (!event.target.multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }

      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
    };

    const getItems = event => {
      const options = event.target.options;
      return Array.prototype.map.call(options, option => {
        return {
          displayValue: option.textContent,
          exportValue: option.value
        };
      });
    };

    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            var _removeEmptyEntry;

            (_removeEmptyEntry = removeEmptyEntry) === null || _removeEmptyEntry === void 0 ? void 0 : _removeEmptyEntry();
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);

            for (const option of selectElement.options) {
              option.selected = values.has(option.value);
            }

            storage.setValue(id, {
              value: getValue(event, true)
            });
          },

          multipleSelection(event) {
            selectElement.multiple = true;
          },

          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);

            if (options.length > 0) {
              const i = Array.prototype.findIndex.call(options, option => option.selected);

              if (i === -1) {
                options[0].selected = true;
              }
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }

            storage.setValue(id, {
              value: null,
              items: []
            });
          },

          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const selectChild = selectElement.children[index];
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;

            if (selectChild) {
              selectChild.before(optionElement);
            } else {
              selectElement.append(optionElement);
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          items(event) {
            const {
              items
            } = event.detail;

            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }

            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.append(optionElement);
            }

            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          indices(event) {
            const indices = new Set(event.detail.indices);

            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }

            storage.setValue(id, {
              value: getValue(event, true)
            });
          },

          editable(event) {
            event.target.disabled = !event.detail.editable;
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", event => {
        var _this$linkService$eve9;

        const exportValue = getValue(event, true);
        const value = getValue(event, false);
        storage.setValue(id, {
          value: exportValue
        });
        (_this$linkService$eve9 = this.linkService.eventBus) === null || _this$linkService$eve9 === void 0 ? void 0 : _this$linkService$eve9.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value,
            changeEx: exportValue,
            willCommit: true,
            commitKey: 1,
            keyDown: false
          }
        });
      });

      this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], event => event.target.checked);
    } else {
      selectElement.addEventListener("input", function (event) {
        storage.setValue(id, {
          value: getValue(event, true)
        });
      });
    }

    if (this.data.combo) {
      this._setTextStyle(selectElement);
    }

    this._setBackgroundColor(selectElement);

    this._setDefaultPropertiesFromJS(selectElement);

    this.container.append(selectElement);
    return this.container;
  }

}

class PopupAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl2, _parameters$data$cont2, _parameters$data$rich2;

    const isRenderable = !!((_parameters$data$titl2 = parameters.data.titleObj) !== null && _parameters$data$titl2 !== void 0 && _parameters$data$titl2.str || (_parameters$data$cont2 = parameters.data.contentsObj) !== null && _parameters$data$cont2 !== void 0 && _parameters$data$cont2.str || (_parameters$data$rich2 = parameters.data.richText) !== null && _parameters$data$rich2 !== void 0 && _parameters$data$rich2.str);
    super(parameters, {
      isRenderable
    });
  }

  render() {
    const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
    this.container.className = "popupAnnotation";

    if (IGNORE_TYPES.includes(this.data.parentType)) {
      return this.container;
    }

    const selector = `[data-annotation-id="${this.data.parentId}"]`;
    const parentElements = this.layer.querySelectorAll(selector);

    if (parentElements.length === 0) {
      return this.container;
    }

    const popup = new PopupElement({
      container: this.container,
      trigger: Array.from(parentElements),
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText
    });
    const page = this.page;

    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
    const popupTop = rect[1];
    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
    const pageWidth = pageURx - pageLLx;
    const pageHeight = pageURy - pageLLy;
    this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`;
    this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`;
    this.container.append(popup.render());
    return this.container;
  }

}

class PopupElement {
  constructor(parameters) {
    this.container = parameters.container;
    this.trigger = parameters.trigger;
    this.color = parameters.color;
    this.titleObj = parameters.titleObj;
    this.modificationDate = parameters.modificationDate;
    this.contentsObj = parameters.contentsObj;
    this.richText = parameters.richText;
    this.hideWrapper = parameters.hideWrapper || false;
    this.pinned = false;
  }

  render() {
    var _this$richText, _this$contentsObj;

    const BACKGROUND_ENLIGHT = 0.7;
    const wrapper = document.createElement("div");
    wrapper.className = "popupWrapper";
    this.hideElement = this.hideWrapper ? wrapper : this.container;
    this.hideElement.hidden = true;
    const popup = document.createElement("div");
    popup.className = "popup";
    const color = this.color;

    if (color) {
      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
    }

    const title = document.createElement("h1");
    title.dir = this.titleObj.dir;
    title.textContent = this.titleObj.str;
    popup.append(title);

    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

    if (dateObject) {
      const modificationDate = document.createElement("span");
      modificationDate.className = "popupDate";
      modificationDate.textContent = "{{date}}, {{time}}";
      modificationDate.dataset.l10nId = "annotation_date_string";
      modificationDate.dataset.l10nArgs = JSON.stringify({
        date: dateObject.toLocaleDateString(),
        time: dateObject.toLocaleTimeString()
      });
      popup.append(modificationDate);
    }

    if ((_this$richText = this.richText) !== null && _this$richText !== void 0 && _this$richText.str && (!((_this$contentsObj = this.contentsObj) !== null && _this$contentsObj !== void 0 && _this$contentsObj.str) || this.contentsObj.str === this.richText.str)) {
      _xfa_layer.XfaLayer.render({
        xfaHtml: this.richText.html,
        intent: "richText",
        div: popup
      });

      popup.lastChild.className = "richText popupContent";
    } else {
      const contents = this._formatContents(this.contentsObj);

      popup.append(contents);
    }

    if (!Array.isArray(this.trigger)) {
      this.trigger = [this.trigger];
    }

    for (const element of this.trigger) {
      element.addEventListener("click", this._toggle.bind(this));
      element.addEventListener("mouseover", this._show.bind(this, false));
      element.addEventListener("mouseout", this._hide.bind(this, false));
    }

    popup.addEventListener("click", this._hide.bind(this, true));
    wrapper.append(popup);
    return wrapper;
  }

  _formatContents(_ref) {
    let {
      str,
      dir
    } = _ref;
    const p = document.createElement("p");
    p.className = "popupContent";
    p.dir = dir;
    const lines = str.split(/(?:\r\n?|\n)/);

    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.append(document.createTextNode(line));

      if (i < ii - 1) {
        p.append(document.createElement("br"));
      }
    }

    return p;
  }

  _toggle() {
    if (this.pinned) {
      this._hide(true);
    } else {
      this._show(true);
    }
  }

  _show() {
    let pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (pin) {
      this.pinned = true;
    }

    if (this.hideElement.hidden) {
      this.hideElement.hidden = false;
      this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1000;
    }
  }

  _hide() {
    let unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (unpin) {
      this.pinned = false;
    }

    if (!this.hideElement.hidden && !this.pinned) {
      this.hideElement.hidden = true;
      this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1000;
    }
  }

}

class FreeTextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl3, _parameters$data$cont3, _parameters$data$rich3;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl3 = parameters.data.titleObj) !== null && _parameters$data$titl3 !== void 0 && _parameters$data$titl3.str || (_parameters$data$cont3 = parameters.data.contentsObj) !== null && _parameters$data$cont3 !== void 0 && _parameters$data$cont3.str || (_parameters$data$rich3 = parameters.data.richText) !== null && _parameters$data$rich3 !== void 0 && _parameters$data$rich3.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.textContent = parameters.data.textContent;
  }

  render() {
    this.container.className = "freeTextAnnotation";

    if (this.textContent) {
      const content = document.createElement("div");
      content.className = "annotationTextContent";
      content.setAttribute("role", "comment");

      for (const line of this.textContent) {
        const lineSpan = document.createElement("span");
        lineSpan.textContent = line;
        content.append(lineSpan);
      }

      this.container.append(content);
    }

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class LineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl4, _parameters$data$cont4, _parameters$data$rich4;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl4 = parameters.data.titleObj) !== null && _parameters$data$titl4 !== void 0 && _parameters$data$titl4.str || (_parameters$data$cont4 = parameters.data.contentsObj) !== null && _parameters$data$cont4 !== void 0 && _parameters$data$cont4.str || (_parameters$data$rich4 = parameters.data.richText) !== null && _parameters$data$rich4 !== void 0 && _parameters$data$rich4.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "lineAnnotation";
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const line = this.svgFactory.createElement("svg:line");
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    line.setAttribute("fill", "transparent");
    svg.append(line);
    this.container.append(svg);

    this._createPopup(line, data);

    return this.container;
  }

}

class SquareAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl5, _parameters$data$cont5, _parameters$data$rich5;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl5 = parameters.data.titleObj) !== null && _parameters$data$titl5 !== void 0 && _parameters$data$titl5.str || (_parameters$data$cont5 = parameters.data.contentsObj) !== null && _parameters$data$cont5 !== void 0 && _parameters$data$cont5.str || (_parameters$data$rich5 = parameters.data.richText) !== null && _parameters$data$rich5 !== void 0 && _parameters$data$rich5.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "squareAnnotation";
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const square = this.svgFactory.createElement("svg:rect");
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.append(square);
    this.container.append(svg);

    this._createPopup(square, data);

    return this.container;
  }

}

class CircleAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl6, _parameters$data$cont6, _parameters$data$rich6;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl6 = parameters.data.titleObj) !== null && _parameters$data$titl6 !== void 0 && _parameters$data$titl6.str || (_parameters$data$cont6 = parameters.data.contentsObj) !== null && _parameters$data$cont6 !== void 0 && _parameters$data$cont6.str || (_parameters$data$rich6 = parameters.data.richText) !== null && _parameters$data$rich6 !== void 0 && _parameters$data$rich6.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "circleAnnotation";
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const circle = this.svgFactory.createElement("svg:ellipse");
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.append(circle);
    this.container.append(svg);

    this._createPopup(circle, data);

    return this.container;
  }

}

class PolylineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl7, _parameters$data$cont7, _parameters$data$rich7;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl7 = parameters.data.titleObj) !== null && _parameters$data$titl7 !== void 0 && _parameters$data$titl7.str || (_parameters$data$cont7 = parameters.data.contentsObj) !== null && _parameters$data$cont7 !== void 0 && _parameters$data$cont7.str || (_parameters$data$rich7 = parameters.data.richText) !== null && _parameters$data$rich7 !== void 0 && _parameters$data$rich7.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }

  render() {
    this.container.className = this.containerClassName;
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    let points = [];

    for (const coordinate of data.vertices) {
      const x = coordinate.x - data.rect[0];
      const y = data.rect[3] - coordinate.y;
      points.push(x + "," + y);
    }

    points = points.join(" ");
    const polyline = this.svgFactory.createElement(this.svgElementName);
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.append(polyline);
    this.container.append(svg);

    this._createPopup(polyline, data);

    return this.container;
  }

}

class PolygonAnnotationElement extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }

}

class CaretAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl8, _parameters$data$cont8, _parameters$data$rich8;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl8 = parameters.data.titleObj) !== null && _parameters$data$titl8 !== void 0 && _parameters$data$titl8.str || (_parameters$data$cont8 = parameters.data.contentsObj) !== null && _parameters$data$cont8 !== void 0 && _parameters$data$cont8.str || (_parameters$data$rich8 = parameters.data.richText) !== null && _parameters$data$rich8 !== void 0 && _parameters$data$rich8.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "caretAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class InkAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl9, _parameters$data$cont9, _parameters$data$rich9;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl9 = parameters.data.titleObj) !== null && _parameters$data$titl9 !== void 0 && _parameters$data$titl9.str || (_parameters$data$cont9 = parameters.data.contentsObj) !== null && _parameters$data$cont9 !== void 0 && _parameters$data$cont9.str || (_parameters$data$rich9 = parameters.data.richText) !== null && _parameters$data$rich9 !== void 0 && _parameters$data$rich9.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
  }

  render() {
    this.container.className = this.containerClassName;
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);

    for (const inkList of data.inkLists) {
      let points = [];

      for (const coordinate of inkList) {
        const x = coordinate.x - data.rect[0];
        const y = data.rect[3] - coordinate.y;
        points.push(`${x},${y}`);
      }

      points = points.join(" ");
      const polyline = this.svgFactory.createElement(this.svgElementName);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "transparent");

      this._createPopup(polyline, data);

      svg.append(polyline);
    }

    this.container.append(svg);
    return this.container;
  }

}

class HighlightAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl10, _parameters$data$cont10, _parameters$data$rich10;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl10 = parameters.data.titleObj) !== null && _parameters$data$titl10 !== void 0 && _parameters$data$titl10.str || (_parameters$data$cont10 = parameters.data.contentsObj) !== null && _parameters$data$cont10 !== void 0 && _parameters$data$cont10.str || (_parameters$data$rich10 = parameters.data.richText) !== null && _parameters$data$rich10 !== void 0 && _parameters$data$rich10.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("highlightAnnotation");
    }

    this.container.className = "highlightAnnotation";
    return this.container;
  }

}

class UnderlineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl11, _parameters$data$cont11, _parameters$data$rich11;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl11 = parameters.data.titleObj) !== null && _parameters$data$titl11 !== void 0 && _parameters$data$titl11.str || (_parameters$data$cont11 = parameters.data.contentsObj) !== null && _parameters$data$cont11 !== void 0 && _parameters$data$cont11.str || (_parameters$data$rich11 = parameters.data.richText) !== null && _parameters$data$rich11 !== void 0 && _parameters$data$rich11.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("underlineAnnotation");
    }

    this.container.className = "underlineAnnotation";
    return this.container;
  }

}

class SquigglyAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl12, _parameters$data$cont12, _parameters$data$rich12;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl12 = parameters.data.titleObj) !== null && _parameters$data$titl12 !== void 0 && _parameters$data$titl12.str || (_parameters$data$cont12 = parameters.data.contentsObj) !== null && _parameters$data$cont12 !== void 0 && _parameters$data$cont12.str || (_parameters$data$rich12 = parameters.data.richText) !== null && _parameters$data$rich12 !== void 0 && _parameters$data$rich12.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("squigglyAnnotation");
    }

    this.container.className = "squigglyAnnotation";
    return this.container;
  }

}

class StrikeOutAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl13, _parameters$data$cont13, _parameters$data$rich13;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl13 = parameters.data.titleObj) !== null && _parameters$data$titl13 !== void 0 && _parameters$data$titl13.str || (_parameters$data$cont13 = parameters.data.contentsObj) !== null && _parameters$data$cont13 !== void 0 && _parameters$data$cont13.str || (_parameters$data$rich13 = parameters.data.richText) !== null && _parameters$data$rich13 !== void 0 && _parameters$data$rich13.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("strikeoutAnnotation");
    }

    this.container.className = "strikeoutAnnotation";
    return this.container;
  }

}

class StampAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _parameters$data$titl14, _parameters$data$cont14, _parameters$data$rich14;

    const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl14 = parameters.data.titleObj) !== null && _parameters$data$titl14 !== void 0 && _parameters$data$titl14.str || (_parameters$data$cont14 = parameters.data.contentsObj) !== null && _parameters$data$cont14 !== void 0 && _parameters$data$cont14.str || (_parameters$data$rich14 = parameters.data.richText) !== null && _parameters$data$rich14 !== void 0 && _parameters$data$rich14.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "stampAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class FileAttachmentAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    var _this$linkService$eve10;

    super(parameters, {
      isRenderable: true
    });
    const {
      filename,
      content
    } = this.data.file;
    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);
    this.content = content;
    (_this$linkService$eve10 = this.linkService.eventBus) === null || _this$linkService$eve10 === void 0 ? void 0 : _this$linkService$eve10.dispatch("fileattachmentannotation", {
      source: this,
      filename,
      content
    });
  }

  render() {
    var _this$data$titleObj, _this$data$contentsOb;

    this.container.className = "fileAttachmentAnnotation";
    const trigger = document.createElement("div");
    trigger.className = "popupTriggerArea";
    trigger.addEventListener("dblclick", this._download.bind(this));

    if (!this.data.hasPopup && ((_this$data$titleObj = this.data.titleObj) !== null && _this$data$titleObj !== void 0 && _this$data$titleObj.str || (_this$data$contentsOb = this.data.contentsObj) !== null && _this$data$contentsOb !== void 0 && _this$data$contentsOb.str || this.data.richText)) {
      this._createPopup(trigger, this.data);
    }

    this.container.append(trigger);
    return this.container;
  }

  _download() {
    var _this$downloadManager;

    (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
  }

}

class AnnotationLayer {
  static render(parameters) {
    const {
      annotations,
      div,
      viewport,
      accessibilityManager
    } = parameters;

    _classStaticPrivateMethodGet(this, AnnotationLayer, _setDimensions).call(this, div, viewport);

    let zIndex = 0;

    for (const data of annotations) {
      if (data.annotationType !== _util.AnnotationType.POPUP) {
        const {
          width,
          height
        } = getRectDims(data.rect);

        if (width <= 0 || height <= 0) {
          continue;
        }
      }

      const element = AnnotationElementFactory.create({
        data,
        layer: div,
        page: parameters.page,
        viewport,
        linkService: parameters.linkService,
        downloadManager: parameters.downloadManager,
        imageResourcesPath: parameters.imageResourcesPath || "",
        renderForms: parameters.renderForms !== false,
        svgFactory: new _display_utils.DOMSVGFactory(),
        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
        enableScripting: parameters.enableScripting,
        hasJSActions: parameters.hasJSActions,
        fieldObjects: parameters.fieldObjects,
        mouseState: parameters.mouseState || {
          isDown: false
        }
      });

      if (element.isRenderable) {
        const rendered = element.render();

        if (data.hidden) {
          rendered.style.visibility = "hidden";
        }

        if (Array.isArray(rendered)) {
          for (const renderedElement of rendered) {
            renderedElement.style.zIndex = zIndex++;

            _classStaticPrivateMethodGet(AnnotationLayer, AnnotationLayer, _appendElement).call(AnnotationLayer, renderedElement, data.id, div, accessibilityManager);
          }
        } else {
          rendered.style.zIndex = zIndex++;

          if (element instanceof PopupAnnotationElement) {
            div.prepend(rendered);
          } else {
            _classStaticPrivateMethodGet(AnnotationLayer, AnnotationLayer, _appendElement).call(AnnotationLayer, rendered, data.id, div, accessibilityManager);
          }
        }
      }
    }

    _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, parameters.annotationCanvasMap);
  }

  static update(parameters) {
    const {
      annotationCanvasMap,
      div,
      viewport
    } = parameters;

    _classStaticPrivateMethodGet(this, AnnotationLayer, _setDimensions).call(this, div, viewport);

    _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(this, div, annotationCanvasMap);

    div.hidden = false;
  }

}

exports.AnnotationLayer = AnnotationLayer;

function _appendElement(element, id, div, accessibilityManager) {
  const contentElement = element.firstChild || element;
  contentElement.id = `${_display_utils.AnnotationPrefix}${id}`;
  div.append(element);
  accessibilityManager === null || accessibilityManager === void 0 ? void 0 : accessibilityManager.moveElementInDOM(div, element, contentElement, false);
}

function _setDimensions(div, _ref2) {
  let {
    width,
    height,
    rotation
  } = _ref2;
  const {
    style
  } = div;
  const flipOrientation = rotation % 180 !== 0,
        widthStr = Math.floor(width) + "px",
        heightStr = Math.floor(height) + "px";
  style.width = flipOrientation ? heightStr : widthStr;
  style.height = flipOrientation ? widthStr : heightStr;
  div.setAttribute("data-main-rotation", rotation);
}

function _setAnnotationCanvasMap(div, annotationCanvasMap) {
  if (!annotationCanvasMap) {
    return;
  }

  for (const [id, canvas] of annotationCanvasMap) {
    const element = div.querySelector(`[data-annotation-id="${id}"]`);

    if (!element) {
      continue;
    }

    const {
      firstChild
    } = element;

    if (!firstChild) {
      element.append(canvas);
    } else if (firstChild.nodeName === "CANVAS") {
      firstChild.replaceWith(canvas);
    } else {
      firstChild.before(canvas);
    }
  }

  annotationCanvasMap.clear();
}

/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorConverters = void 0;

function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}

class ColorConverters {
  static CMYK_G(_ref) {
    let [c, y, m, k] = _ref;
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
  }

  static G_CMYK(_ref2) {
    let [g] = _ref2;
    return ["CMYK", 0, 0, 0, 1 - g];
  }

  static G_RGB(_ref3) {
    let [g] = _ref3;
    return ["RGB", g, g, g];
  }

  static G_HTML(_ref4) {
    let [g] = _ref4;
    const G = makeColorComp(g);
    return `#${G}${G}${G}`;
  }

  static RGB_G(_ref5) {
    let [r, g, b] = _ref5;
    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
  }

  static RGB_HTML(_ref6) {
    let [r, g, b] = _ref6;
    const R = makeColorComp(r);
    const G = makeColorComp(g);
    const B = makeColorComp(b);
    return `#${R}${G}${B}`;
  }

  static T_HTML() {
    return "#00000000";
  }

  static CMYK_RGB(_ref7) {
    let [c, y, m, k] = _ref7;
    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
  }

  static CMYK_HTML(components) {
    const rgb = this.CMYK_RGB(components).slice(1);
    return this.RGB_HTML(rgb);
  }

  static RGB_CMYK(_ref8) {
    let [r, g, b] = _ref8;
    const c = 1 - r;
    const m = 1 - g;
    const y = 1 - b;
    const k = Math.min(c, m, y);
    return ["CMYK", c, m, y, k];
  }

}

exports.ColorConverters = ColorConverters;

/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaLayer = void 0;

var _xfa_text = __w_pdfjs_require__(145);

class XfaLayer {
  static setupStorage(html, id, element, storage, intent) {
    const storedData = storage.getValue(id, {
      value: null
    });

    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }

        if (intent === "print") {
          break;
        }

        html.addEventListener("input", event => {
          storage.setValue(id, {
            value: event.target.value
          });
        });
        break;

      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }

          if (intent === "print") {
            break;
          }

          html.addEventListener("change", event => {
            storage.setValue(id, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }

          if (intent === "print") {
            break;
          }

          html.addEventListener("input", event => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
        }

        break;

      case "select":
        if (storedData.value !== null) {
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            }
          }
        }

        html.addEventListener("input", event => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id, {
            value
          });
        });
        break;
    }
  }

  static setAttributes(_ref) {
    let {
      html,
      element,
      storage = null,
      intent,
      linkService
    } = _ref;
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;

    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }

    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === undefined) {
        continue;
      }

      switch (key) {
        case "class":
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }

          break;

        case "dataId":
          break;

        case "id":
          html.setAttribute("data-element-id", value);
          break;

        case "style":
          Object.assign(html.style, value);
          break;

        case "textContent":
          html.textContent = value;
          break;

        default:
          if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
            html.setAttribute(key, value);
          }

      }
    }

    if (isHTMLAnchorElement) {
      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
    }

    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }

  static render(parameters) {
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);

    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }

    const stack = [[root, -1, rootHtml]];
    const rootDiv = parameters.div;
    rootDiv.append(rootHtml);

    if (parameters.viewport) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform;
    }

    if (intent !== "richText") {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }

    const textDivs = [];

    while (stack.length > 0) {
      var _child$attributes;

      const [parent, i, html] = stack.at(-1);

      if (i + 1 === parent.children.length) {
        stack.pop();
        continue;
      }

      const child = parent.children[++stack.at(-1)[1]];

      if (child === null) {
        continue;
      }

      const {
        name
      } = child;

      if (name === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.append(node);
        continue;
      }

      let childHtml;

      if (child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns) {
        childHtml = document.createElementNS(child.attributes.xmlns, name);
      } else {
        childHtml = document.createElement(name);
      }

      html.append(childHtml);

      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }

      if (child.children && child.children.length > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);

        if (_xfa_text.XfaText.shouldBuildText(name)) {
          textDivs.push(node);
        }

        childHtml.append(node);
      }
    }

    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }

    return {
      textDivs
    };
  }

  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }

}

exports.XfaLayer = XfaLayer;

/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TextLayerRenderTask = void 0;
exports.renderTextLayer = renderTextLayer;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(133);

const MAX_TEXT_DIVS_TO_RENDER = 100000;
const DEFAULT_FONT_SIZE = 30;
const DEFAULT_FONT_ASCENT = 0.8;
const ascentCache = new Map();
const AllWhitespaceRegexp = /^\s+$/g;

function getAscent(fontFamily, ctx) {
  const cachedAscent = ascentCache.get(fontFamily);

  if (cachedAscent) {
    return cachedAscent;
  }

  ctx.save();
  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
  const metrics = ctx.measureText("");
  let ascent = metrics.fontBoundingBoxAscent;
  let descent = Math.abs(metrics.fontBoundingBoxDescent);

  if (ascent) {
    ctx.restore();
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }

  ctx.strokeStyle = "red";
  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("g", 0, 0);
  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  descent = 0;

  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
    if (pixels[i] > 0) {
      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }

  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  ascent = 0;

  for (let i = 0, ii = pixels.length; i < ii; i += 4) {
    if (pixels[i] > 0) {
      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }

  ctx.restore();

  if (ascent) {
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }

  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
  return DEFAULT_FONT_ASCENT;
}

function appendText(task, geom, styles, ctx) {
  const textDiv = document.createElement("span");
  const textDivProperties = task._enhanceTextSelection ? {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    originalTransform: null,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    scale: 1,
    fontSize: 0
  } : {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    fontSize: 0
  };

  task._textDivs.push(textDiv);

  const tx = _util.Util.transform(task._viewport.transform, geom.transform);

  let angle = Math.atan2(tx[1], tx[0]);
  const style = styles[geom.fontName];

  if (style.vertical) {
    angle += Math.PI / 2;
  }

  const fontHeight = Math.hypot(tx[2], tx[3]);
  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
  let left, top;

  if (angle === 0) {
    left = tx[4];
    top = tx[5] - fontAscent;
  } else {
    left = tx[4] + fontAscent * Math.sin(angle);
    top = tx[5] - fontAscent * Math.cos(angle);
  }

  textDiv.style.left = `${left}px`;
  textDiv.style.top = `${top}px`;
  textDiv.style.fontSize = `${fontHeight}px`;
  textDiv.style.fontFamily = style.fontFamily;
  textDivProperties.fontSize = fontHeight;
  textDiv.setAttribute("role", "presentation");
  textDiv.textContent = geom.str;
  textDiv.dir = geom.dir;

  if (task._fontInspectorEnabled) {
    textDiv.dataset.fontName = geom.fontName;
  }

  if (angle !== 0) {
    textDivProperties.angle = angle * (180 / Math.PI);
  }

  let shouldScaleText = false;

  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
    shouldScaleText = true;
  } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
    const absScaleX = Math.abs(geom.transform[0]),
          absScaleY = Math.abs(geom.transform[3]);

    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
      shouldScaleText = true;
    }
  }

  if (shouldScaleText) {
    if (style.vertical) {
      textDivProperties.canvasWidth = geom.height * task._viewport.scale;
    } else {
      textDivProperties.canvasWidth = geom.width * task._viewport.scale;
    }
  }

  task._textDivProperties.set(textDiv, textDivProperties);

  if (task._textContentStream) {
    task._layoutText(textDiv);
  }

  if (task._enhanceTextSelection && textDivProperties.hasText) {
    let angleCos = 1,
        angleSin = 0;

    if (angle !== 0) {
      angleCos = Math.cos(angle);
      angleSin = Math.sin(angle);
    }

    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
    const divHeight = fontHeight;
    let m, b;

    if (angle !== 0) {
      m = [angleCos, angleSin, -angleSin, angleCos, left, top];
      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
    } else {
      b = [left, top, left + divWidth, top + divHeight];
    }

    task._bounds.push({
      left: b[0],
      top: b[1],
      right: b[2],
      bottom: b[3],
      div: textDiv,
      size: [divWidth, divHeight],
      m
    });
  }
}

function render(task) {
  if (task._canceled) {
    return;
  }

  const textDivs = task._textDivs;
  const capability = task._capability;
  const textDivsLength = textDivs.length;

  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
    task._renderingDone = true;
    capability.resolve();
    return;
  }

  if (!task._textContentStream) {
    for (let i = 0; i < textDivsLength; i++) {
      task._layoutText(textDivs[i]);
    }
  }

  task._renderingDone = true;
  capability.resolve();
}

function findPositiveMin(ts, offset, count) {
  let result = 0;

  for (let i = 0; i < count; i++) {
    const t = ts[offset++];

    if (t > 0) {
      result = result ? Math.min(t, result) : t;
    }
  }

  return result;
}

function expand(task) {
  const bounds = task._bounds;
  const viewport = task._viewport;
  const expanded = expandBounds(viewport.width, viewport.height, bounds);

  for (let i = 0; i < expanded.length; i++) {
    const div = bounds[i].div;

    const divProperties = task._textDivProperties.get(div);

    if (divProperties.angle === 0) {
      divProperties.paddingLeft = bounds[i].left - expanded[i].left;
      divProperties.paddingTop = bounds[i].top - expanded[i].top;
      divProperties.paddingRight = expanded[i].right - bounds[i].right;
      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

      task._textDivProperties.set(div, divProperties);

      continue;
    }

    const e = expanded[i],
          b = bounds[i];
    const m = b.m,
          c = m[0],
          s = m[1];
    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
    const ts = new Float64Array(64);

    for (let j = 0, jj = points.length; j < jj; j++) {
      const t = _util.Util.applyTransform(points[j], m);

      ts[j + 0] = c && (e.left - t[0]) / c;
      ts[j + 4] = s && (e.top - t[1]) / s;
      ts[j + 8] = c && (e.right - t[0]) / c;
      ts[j + 12] = s && (e.bottom - t[1]) / s;
      ts[j + 16] = s && (e.left - t[0]) / -s;
      ts[j + 20] = c && (e.top - t[1]) / c;
      ts[j + 24] = s && (e.right - t[0]) / -s;
      ts[j + 28] = c && (e.bottom - t[1]) / c;
      ts[j + 32] = c && (e.left - t[0]) / -c;
      ts[j + 36] = s && (e.top - t[1]) / -s;
      ts[j + 40] = c && (e.right - t[0]) / -c;
      ts[j + 44] = s && (e.bottom - t[1]) / -s;
      ts[j + 48] = s && (e.left - t[0]) / s;
      ts[j + 52] = c && (e.top - t[1]) / -c;
      ts[j + 56] = s && (e.right - t[0]) / s;
      ts[j + 60] = c && (e.bottom - t[1]) / -c;
    }

    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

    task._textDivProperties.set(div, divProperties);
  }
}

function expandBounds(width, height, boxes) {
  const bounds = boxes.map(function (box, i) {
    return {
      x1: box.left,
      y1: box.top,
      x2: box.right,
      y2: box.bottom,
      index: i,
      x1New: undefined,
      x2New: undefined
    };
  });
  expandBoundsLTR(width, bounds);
  const expanded = new Array(boxes.length);

  for (const b of bounds) {
    const i = b.index;
    expanded[i] = {
      left: b.x1New,
      top: 0,
      right: b.x2New,
      bottom: 0
    };
  }

  boxes.map(function (box, i) {
    const e = expanded[i],
          b = bounds[i];
    b.x1 = box.top;
    b.y1 = width - e.right;
    b.x2 = box.bottom;
    b.y2 = width - e.left;
    b.index = i;
    b.x1New = undefined;
    b.x2New = undefined;
  });
  expandBoundsLTR(height, bounds);

  for (const b of bounds) {
    const i = b.index;
    expanded[i].top = b.x1New;
    expanded[i].bottom = b.x2New;
  }

  return expanded;
}

function expandBoundsLTR(width, bounds) {
  bounds.sort(function (a, b) {
    return a.x1 - b.x1 || a.index - b.index;
  });
  const fakeBoundary = {
    x1: -Infinity,
    y1: -Infinity,
    x2: 0,
    y2: Infinity,
    index: -1,
    x1New: 0,
    x2New: 0
  };
  const horizon = [{
    start: -Infinity,
    end: Infinity,
    boundary: fakeBoundary
  }];

  for (const boundary of bounds) {
    let i = 0;

    while (i < horizon.length && horizon[i].end <= boundary.y1) {
      i++;
    }

    let j = horizon.length - 1;

    while (j >= 0 && horizon[j].start >= boundary.y2) {
      j--;
    }

    let horizonPart, affectedBoundary;
    let q,
        k,
        maxXNew = -Infinity;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;
      let xNew;

      if (affectedBoundary.x2 > boundary.x1) {
        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
      } else if (affectedBoundary.x2New === undefined) {
        xNew = (affectedBoundary.x2 + boundary.x1) / 2;
      } else {
        xNew = affectedBoundary.x2New;
      }

      if (xNew > maxXNew) {
        maxXNew = xNew;
      }
    }

    boundary.x1New = maxXNew;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New === undefined) {
        if (affectedBoundary.x2 > boundary.x1) {
          if (affectedBoundary.index > boundary.index) {
            affectedBoundary.x2New = affectedBoundary.x2;
          }
        } else {
          affectedBoundary.x2New = maxXNew;
        }
      } else if (affectedBoundary.x2New > maxXNew) {
        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
      }
    }

    const changedHorizon = [];
    let lastBoundary = null;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;
      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

      if (lastBoundary === useBoundary) {
        changedHorizon.at(-1).end = horizonPart.end;
      } else {
        changedHorizon.push({
          start: horizonPart.start,
          end: horizonPart.end,
          boundary: useBoundary
        });
        lastBoundary = useBoundary;
      }
    }

    if (horizon[i].start < boundary.y1) {
      changedHorizon[0].start = boundary.y1;
      changedHorizon.unshift({
        start: horizon[i].start,
        end: boundary.y1,
        boundary: horizon[i].boundary
      });
    }

    if (boundary.y2 < horizon[j].end) {
      changedHorizon.at(-1).end = boundary.y2;
      changedHorizon.push({
        start: boundary.y2,
        end: horizon[j].end,
        boundary: horizon[j].boundary
      });
    }

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New !== undefined) {
        continue;
      }

      let used = false;

      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
        used = horizon[k].boundary === affectedBoundary;
      }

      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
        used = horizon[k].boundary === affectedBoundary;
      }

      for (k = 0; !used && k < changedHorizon.length; k++) {
        used = changedHorizon[k].boundary === affectedBoundary;
      }

      if (!used) {
        affectedBoundary.x2New = maxXNew;
      }
    }

    Array.prototype.splice.apply(horizon, [i, j - i + 1, ...changedHorizon]);
  }

  for (const horizonPart of horizon) {
    const affectedBoundary = horizonPart.boundary;

    if (affectedBoundary.x2New === undefined) {
      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
    }
  }
}

class TextLayerRenderTask {
  constructor(_ref) {
    var _globalThis$FontInspe;

    let {
      textContent,
      textContentStream,
      container,
      viewport,
      textDivs,
      textContentItemsStr,
      enhanceTextSelection
    } = _ref;

    if (enhanceTextSelection) {
      (0, _display_utils.deprecated)("The `enhanceTextSelection` functionality will be removed in the future.");
    }

    this._textContent = textContent;
    this._textContentStream = textContentStream;
    this._container = container;
    this._document = container.ownerDocument;
    this._viewport = viewport;
    this._textDivs = textDivs || [];
    this._textContentItemsStr = textContentItemsStr || [];
    this._enhanceTextSelection = !!enhanceTextSelection;
    this._fontInspectorEnabled = !!((_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled);
    this._reader = null;
    this._layoutTextLastFontSize = null;
    this._layoutTextLastFontFamily = null;
    this._layoutTextCtx = null;
    this._textDivProperties = new WeakMap();
    this._renderingDone = false;
    this._canceled = false;
    this._capability = (0, _util.createPromiseCapability)();
    this._renderTimer = null;
    this._bounds = [];
    this._devicePixelRatio = globalThis.devicePixelRatio || 1;

    this._capability.promise.finally(() => {
      if (!this._enhanceTextSelection) {
        this._textDivProperties = null;
      }

      if (this._layoutTextCtx) {
        this._layoutTextCtx.canvas.width = 0;
        this._layoutTextCtx.canvas.height = 0;
        this._layoutTextCtx = null;
      }
    }).catch(() => {});
  }

  get promise() {
    return this._capability.promise;
  }

  cancel() {
    this._canceled = true;

    if (this._reader) {
      this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")).catch(() => {});

      this._reader = null;
    }

    if (this._renderTimer !== null) {
      clearTimeout(this._renderTimer);
      this._renderTimer = null;
    }

    this._capability.reject(new Error("TextLayer task cancelled."));
  }

  _processItems(items, styleCache) {
    for (let i = 0, len = items.length; i < len; i++) {
      if (items[i].str === undefined) {
        if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
          const parent = this._container;
          this._container = document.createElement("span");

          this._container.classList.add("markedContent");

          if (items[i].id !== null) {
            this._container.setAttribute("id", `${items[i].id}`);
          }

          parent.append(this._container);
        } else if (items[i].type === "endMarkedContent") {
          this._container = this._container.parentNode;
        }

        continue;
      }

      this._textContentItemsStr.push(items[i].str);

      appendText(this, items[i], styleCache, this._layoutTextCtx);
    }
  }

  _layoutText(textDiv) {
    const textDivProperties = this._textDivProperties.get(textDiv);

    let transform = "";

    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
      const {
        fontFamily
      } = textDiv.style;
      const {
        fontSize
      } = textDivProperties;

      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
        this._layoutTextCtx.font = `${fontSize * this._devicePixelRatio}px ${fontFamily}`;
        this._layoutTextLastFontSize = fontSize;
        this._layoutTextLastFontFamily = fontFamily;
      }

      const {
        width
      } = this._layoutTextCtx.measureText(textDiv.textContent);

      if (width > 0) {
        const scale = this._devicePixelRatio * textDivProperties.canvasWidth / width;

        if (this._enhanceTextSelection) {
          textDivProperties.scale = scale;
        }

        transform = `scaleX(${scale})`;
      }
    }

    if (textDivProperties.angle !== 0) {
      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
    }

    if (transform.length > 0) {
      if (this._enhanceTextSelection) {
        textDivProperties.originalTransform = transform;
      }

      textDiv.style.transform = transform;
    }

    if (textDivProperties.hasText) {
      this._container.append(textDiv);
    }

    if (textDivProperties.hasEOL) {
      const br = document.createElement("br");
      br.setAttribute("role", "presentation");

      this._container.append(br);
    }
  }

  _render() {
    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const capability = (0, _util.createPromiseCapability)();
    let styleCache = Object.create(null);

    const canvas = this._document.createElement("canvas");

    canvas.height = canvas.width = DEFAULT_FONT_SIZE;
    this._layoutTextCtx = canvas.getContext("2d", {
      alpha: false
    });

    if (this._textContent) {
      const textItems = this._textContent.items;
      const textStyles = this._textContent.styles;

      this._processItems(textItems, textStyles);

      capability.resolve();
    } else if (this._textContentStream) {
      const pump = () => {
        this._reader.read().then(_ref2 => {
          let {
            value,
            done
          } = _ref2;

          if (done) {
            capability.resolve();
            return;
          }

          Object.assign(styleCache, value.styles);

          this._processItems(value.items, styleCache);

          pump();
        }, capability.reject);
      };

      this._reader = this._textContentStream.getReader();
      pump();
    } else {
      throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
    }

    capability.promise.then(() => {
      styleCache = null;

      if (!timeout) {
        render(this);
      } else {
        this._renderTimer = setTimeout(() => {
          render(this);
          this._renderTimer = null;
        }, timeout);
      }
    }, this._capability.reject);
  }

  expandTextDivs() {
    let expandDivs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (!this._enhanceTextSelection || !this._renderingDone) {
      return;
    }

    if (this._bounds !== null) {
      expand(this);
      this._bounds = null;
    }

    const transformBuf = [],
          paddingBuf = [];

    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
      const div = this._textDivs[i];

      const divProps = this._textDivProperties.get(div);

      if (!divProps.hasText) {
        continue;
      }

      if (expandDivs) {
        transformBuf.length = 0;
        paddingBuf.length = 0;

        if (divProps.originalTransform) {
          transformBuf.push(divProps.originalTransform);
        }

        if (divProps.paddingTop > 0) {
          paddingBuf.push(`${divProps.paddingTop}px`);
          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingRight > 0) {
          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingBottom > 0) {
          paddingBuf.push(`${divProps.paddingBottom}px`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingLeft > 0) {
          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
        } else {
          paddingBuf.push(0);
        }

        div.style.padding = paddingBuf.join(" ");

        if (transformBuf.length) {
          div.style.transform = transformBuf.join(" ");
        }
      } else {
        div.style.padding = null;
        div.style.transform = divProps.originalTransform;
      }
    }
  }

}

exports.TextLayerRenderTask = TextLayerRenderTask;

function renderTextLayer(renderParameters) {
  const task = new TextLayerRenderTask({
    textContent: renderParameters.textContent,
    textContentStream: renderParameters.textContentStream,
    container: renderParameters.container,
    viewport: renderParameters.viewport,
    textDivs: renderParameters.textDivs,
    textContentItemsStr: renderParameters.textContentItemsStr,
    enhanceTextSelection: renderParameters.enhanceTextSelection
  });

  task._render(renderParameters.timeout);

  return task;
}

/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SVGGraphics = void 0;

var _display_utils = __w_pdfjs_require__(133);

var _util = __w_pdfjs_require__(1);

var _is_node = __w_pdfjs_require__(3);

let SVGGraphics = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: SVGGraphics");
  }

};
exports.SVGGraphics = SVGGraphics;
{
  const SVG_DEFAULTS = {
    fontStyle: "normal",
    fontWeight: "normal",
    fillColor: "#000000"
  };
  const XML_NS = "http://www.w3.org/XML/1998/namespace";
  const XLINK_NS = "http://www.w3.org/1999/xlink";
  const LINE_CAP_STYLES = ["butt", "round", "square"];
  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];

  const createObjectURL = function (data) {
    let contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    let forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
      return URL.createObjectURL(new Blob([data], {
        type: contentType
      }));
    }

    const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let buffer = `data:${contentType};base64,`;

    for (let i = 0, ii = data.length; i < ii; i += 3) {
      const b1 = data[i] & 0xff;
      const b2 = data[i + 1] & 0xff;
      const b3 = data[i + 2] & 0xff;
      const d1 = b1 >> 2,
            d2 = (b1 & 3) << 4 | b2 >> 4;
      const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
      const d4 = i + 2 < ii ? b3 & 0x3f : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }

    return buffer;
  };

  const convertImgDataToPng = function () {
    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
    const CHUNK_WRAPPER_SIZE = 12;
    const crcTable = new Int32Array(256);

    for (let i = 0; i < 256; i++) {
      let c = i;

      for (let h = 0; h < 8; h++) {
        if (c & 1) {
          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
        } else {
          c = c >> 1 & 0x7fffffff;
        }
      }

      crcTable[i] = c;
    }

    function crc32(data, start, end) {
      let crc = -1;

      for (let i = start; i < end; i++) {
        const a = (crc ^ data[i]) & 0xff;
        const b = crcTable[a];
        crc = crc >>> 8 ^ b;
      }

      return crc ^ -1;
    }

    function writePngChunk(type, body, data, offset) {
      let p = offset;
      const len = body.length;
      data[p] = len >> 24 & 0xff;
      data[p + 1] = len >> 16 & 0xff;
      data[p + 2] = len >> 8 & 0xff;
      data[p + 3] = len & 0xff;
      p += 4;
      data[p] = type.charCodeAt(0) & 0xff;
      data[p + 1] = type.charCodeAt(1) & 0xff;
      data[p + 2] = type.charCodeAt(2) & 0xff;
      data[p + 3] = type.charCodeAt(3) & 0xff;
      p += 4;
      data.set(body, p);
      p += body.length;
      const crc = crc32(data, offset + 4, p);
      data[p] = crc >> 24 & 0xff;
      data[p + 1] = crc >> 16 & 0xff;
      data[p + 2] = crc >> 8 & 0xff;
      data[p + 3] = crc & 0xff;
    }

    function adler32(data, start, end) {
      let a = 1;
      let b = 0;

      for (let i = start; i < end; ++i) {
        a = (a + (data[i] & 0xff)) % 65521;
        b = (b + a) % 65521;
      }

      return b << 16 | a;
    }

    function deflateSync(literals) {
      if (!_is_node.isNodeJS) {
        return deflateSyncUncompressed(literals);
      }

      try {
        let input;

        if (parseInt(process.versions.node) >= 8) {
          input = literals;
        } else {
          input = Buffer.from(literals);
        }

        const output = require$$4__default['default'].deflateSync(input, {
          level: 9
        });

        return output instanceof Uint8Array ? output : new Uint8Array(output);
      } catch (e) {
        (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
      }

      return deflateSyncUncompressed(literals);
    }

    function deflateSyncUncompressed(literals) {
      let len = literals.length;
      const maxBlockLength = 0xffff;
      const deflateBlocks = Math.ceil(len / maxBlockLength);
      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
      let pi = 0;
      idat[pi++] = 0x78;
      idat[pi++] = 0x9c;
      let pos = 0;

      while (len > maxBlockLength) {
        idat[pi++] = 0x00;
        idat[pi++] = 0xff;
        idat[pi++] = 0xff;
        idat[pi++] = 0x00;
        idat[pi++] = 0x00;
        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
        pi += maxBlockLength;
        pos += maxBlockLength;
        len -= maxBlockLength;
      }

      idat[pi++] = 0x01;
      idat[pi++] = len & 0xff;
      idat[pi++] = len >> 8 & 0xff;
      idat[pi++] = ~len & 0xffff & 0xff;
      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
      idat.set(literals.subarray(pos), pi);
      pi += literals.length - pos;
      const adler = adler32(literals, 0, literals.length);
      idat[pi++] = adler >> 24 & 0xff;
      idat[pi++] = adler >> 16 & 0xff;
      idat[pi++] = adler >> 8 & 0xff;
      idat[pi++] = adler & 0xff;
      return idat;
    }

    function encode(imgData, kind, forceDataSchema, isMask) {
      const width = imgData.width;
      const height = imgData.height;
      let bitDepth, colorType, lineSize;
      const bytes = imgData.data;

      switch (kind) {
        case _util.ImageKind.GRAYSCALE_1BPP:
          colorType = 0;
          bitDepth = 1;
          lineSize = width + 7 >> 3;
          break;

        case _util.ImageKind.RGB_24BPP:
          colorType = 2;
          bitDepth = 8;
          lineSize = width * 3;
          break;

        case _util.ImageKind.RGBA_32BPP:
          colorType = 6;
          bitDepth = 8;
          lineSize = width * 4;
          break;

        default:
          throw new Error("invalid format");
      }

      const literals = new Uint8Array((1 + lineSize) * height);
      let offsetLiterals = 0,
          offsetBytes = 0;

      for (let y = 0; y < height; ++y) {
        literals[offsetLiterals++] = 0;
        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
        offsetBytes += lineSize;
        offsetLiterals += lineSize;
      }

      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
        offsetLiterals = 0;

        for (let y = 0; y < height; y++) {
          offsetLiterals++;

          for (let i = 0; i < lineSize; i++) {
            literals[offsetLiterals++] ^= 0xff;
          }
        }
      }

      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
      const idat = deflateSync(literals);
      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
      const data = new Uint8Array(pngLength);
      let offset = 0;
      data.set(PNG_HEADER, offset);
      offset += PNG_HEADER.length;
      writePngChunk("IHDR", ihdr, data, offset);
      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
      writePngChunk("IDATA", idat, data, offset);
      offset += CHUNK_WRAPPER_SIZE + idat.length;
      writePngChunk("IEND", new Uint8Array(0), data, offset);
      return createObjectURL(data, "image/png", forceDataSchema);
    }

    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
      return encode(imgData, kind, forceDataSchema, isMask);
    };
  }();

  class SVGExtraState {
    constructor() {
      this.fontSizeScale = 1;
      this.fontWeight = SVG_DEFAULTS.fontWeight;
      this.fontSize = 0;
      this.textMatrix = _util.IDENTITY_MATRIX;
      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
      this.leading = 0;
      this.textRenderingMode = _util.TextRenderingMode.FILL;
      this.textMatrixScale = 1;
      this.x = 0;
      this.y = 0;
      this.lineX = 0;
      this.lineY = 0;
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.textHScale = 1;
      this.textRise = 0;
      this.fillColor = SVG_DEFAULTS.fillColor;
      this.strokeColor = "#000000";
      this.fillAlpha = 1;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.lineJoin = "";
      this.lineCap = "";
      this.miterLimit = 0;
      this.dashArray = [];
      this.dashPhase = 0;
      this.dependencies = [];
      this.activeClipUrl = null;
      this.clipGroup = null;
      this.maskId = "";
    }

    clone() {
      return Object.create(this);
    }

    setCurrentPoint(x, y) {
      this.x = x;
      this.y = y;
    }

  }

  function opListToTree(opList) {
    let opTree = [];
    const tmp = [];

    for (const opListElement of opList) {
      if (opListElement.fn === "save") {
        opTree.push({
          fnId: 92,
          fn: "group",
          items: []
        });
        tmp.push(opTree);
        opTree = opTree.at(-1).items;
        continue;
      }

      if (opListElement.fn === "restore") {
        opTree = tmp.pop();
      } else {
        opTree.push(opListElement);
      }
    }

    return opTree;
  }

  function pf(value) {
    if (Number.isInteger(value)) {
      return value.toString();
    }

    const s = value.toFixed(10);
    let i = s.length - 1;

    if (s[i] !== "0") {
      return s;
    }

    do {
      i--;
    } while (s[i] === "0");

    return s.substring(0, s[i] === "." ? i : i + 1);
  }

  function pm(m) {
    if (m[4] === 0 && m[5] === 0) {
      if (m[1] === 0 && m[2] === 0) {
        if (m[0] === 1 && m[3] === 1) {
          return "";
        }

        return `scale(${pf(m[0])} ${pf(m[3])})`;
      }

      if (m[0] === m[3] && m[1] === -m[2]) {
        const a = Math.acos(m[0]) * 180 / Math.PI;
        return `rotate(${pf(a)})`;
      }
    } else {
      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
        return `translate(${pf(m[4])} ${pf(m[5])})`;
      }
    }

    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;
  }

  let clipCount = 0;
  let maskCount = 0;
  let shadingCount = 0;
  exports.SVGGraphics = SVGGraphics = class {
    constructor(commonObjs, objs) {
      let forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      (0, _display_utils.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
      this.svgFactory = new _display_utils.DOMSVGFactory();
      this.current = new SVGExtraState();
      this.transformMatrix = _util.IDENTITY_MATRIX;
      this.transformStack = [];
      this.extraStack = [];
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.embedFonts = false;
      this.embeddedFonts = Object.create(null);
      this.cssStyle = null;
      this.forceDataSchema = !!forceDataSchema;
      this._operatorIdMapping = [];

      for (const op in _util.OPS) {
        this._operatorIdMapping[_util.OPS[op]] = op;
      }
    }

    save() {
      this.transformStack.push(this.transformMatrix);
      const old = this.current;
      this.extraStack.push(old);
      this.current = old.clone();
    }

    restore() {
      this.transformMatrix = this.transformStack.pop();
      this.current = this.extraStack.pop();
      this.pendingClip = null;
      this.tgrp = null;
    }

    group(items) {
      this.save();
      this.executeOpTree(items);
      this.restore();
    }

    loadDependencies(operatorList) {
      const fnArray = operatorList.fnArray;
      const argsArray = operatorList.argsArray;

      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        if (fnArray[i] !== _util.OPS.dependency) {
          continue;
        }

        for (const obj of argsArray[i]) {
          const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
          const promise = new Promise(resolve => {
            objsPool.get(obj, resolve);
          });
          this.current.dependencies.push(promise);
        }
      }

      return Promise.all(this.current.dependencies);
    }

    transform(a, b, c, d, e, f) {
      const transformMatrix = [a, b, c, d, e, f];
      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
      this.tgrp = null;
    }

    getSVG(operatorList, viewport) {
      this.viewport = viewport;

      const svgElement = this._initialize(viewport);

      return this.loadDependencies(operatorList).then(() => {
        this.transformMatrix = _util.IDENTITY_MATRIX;
        this.executeOpTree(this.convertOpList(operatorList));
        return svgElement;
      });
    }

    convertOpList(operatorList) {
      const operatorIdMapping = this._operatorIdMapping;
      const argsArray = operatorList.argsArray;
      const fnArray = operatorList.fnArray;
      const opList = [];

      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        const fnId = fnArray[i];
        opList.push({
          fnId,
          fn: operatorIdMapping[fnId],
          args: argsArray[i]
        });
      }

      return opListToTree(opList);
    }

    executeOpTree(opTree) {
      for (const opTreeElement of opTree) {
        const fn = opTreeElement.fn;
        const fnId = opTreeElement.fnId;
        const args = opTreeElement.args;

        switch (fnId | 0) {
          case _util.OPS.beginText:
            this.beginText();
            break;

          case _util.OPS.dependency:
            break;

          case _util.OPS.setLeading:
            this.setLeading(args);
            break;

          case _util.OPS.setLeadingMoveText:
            this.setLeadingMoveText(args[0], args[1]);
            break;

          case _util.OPS.setFont:
            this.setFont(args);
            break;

          case _util.OPS.showText:
            this.showText(args[0]);
            break;

          case _util.OPS.showSpacedText:
            this.showText(args[0]);
            break;

          case _util.OPS.endText:
            this.endText();
            break;

          case _util.OPS.moveText:
            this.moveText(args[0], args[1]);
            break;

          case _util.OPS.setCharSpacing:
            this.setCharSpacing(args[0]);
            break;

          case _util.OPS.setWordSpacing:
            this.setWordSpacing(args[0]);
            break;

          case _util.OPS.setHScale:
            this.setHScale(args[0]);
            break;

          case _util.OPS.setTextMatrix:
            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            break;

          case _util.OPS.setTextRise:
            this.setTextRise(args[0]);
            break;

          case _util.OPS.setTextRenderingMode:
            this.setTextRenderingMode(args[0]);
            break;

          case _util.OPS.setLineWidth:
            this.setLineWidth(args[0]);
            break;

          case _util.OPS.setLineJoin:
            this.setLineJoin(args[0]);
            break;

          case _util.OPS.setLineCap:
            this.setLineCap(args[0]);
            break;

          case _util.OPS.setMiterLimit:
            this.setMiterLimit(args[0]);
            break;

          case _util.OPS.setFillRGBColor:
            this.setFillRGBColor(args[0], args[1], args[2]);
            break;

          case _util.OPS.setStrokeRGBColor:
            this.setStrokeRGBColor(args[0], args[1], args[2]);
            break;

          case _util.OPS.setStrokeColorN:
            this.setStrokeColorN(args);
            break;

          case _util.OPS.setFillColorN:
            this.setFillColorN(args);
            break;

          case _util.OPS.shadingFill:
            this.shadingFill(args[0]);
            break;

          case _util.OPS.setDash:
            this.setDash(args[0], args[1]);
            break;

          case _util.OPS.setRenderingIntent:
            this.setRenderingIntent(args[0]);
            break;

          case _util.OPS.setFlatness:
            this.setFlatness(args[0]);
            break;

          case _util.OPS.setGState:
            this.setGState(args[0]);
            break;

          case _util.OPS.fill:
            this.fill();
            break;

          case _util.OPS.eoFill:
            this.eoFill();
            break;

          case _util.OPS.stroke:
            this.stroke();
            break;

          case _util.OPS.fillStroke:
            this.fillStroke();
            break;

          case _util.OPS.eoFillStroke:
            this.eoFillStroke();
            break;

          case _util.OPS.clip:
            this.clip("nonzero");
            break;

          case _util.OPS.eoClip:
            this.clip("evenodd");
            break;

          case _util.OPS.paintSolidColorImageMask:
            this.paintSolidColorImageMask();
            break;

          case _util.OPS.paintImageXObject:
            this.paintImageXObject(args[0]);
            break;

          case _util.OPS.paintInlineImageXObject:
            this.paintInlineImageXObject(args[0]);
            break;

          case _util.OPS.paintImageMaskXObject:
            this.paintImageMaskXObject(args[0]);
            break;

          case _util.OPS.paintFormXObjectBegin:
            this.paintFormXObjectBegin(args[0], args[1]);
            break;

          case _util.OPS.paintFormXObjectEnd:
            this.paintFormXObjectEnd();
            break;

          case _util.OPS.closePath:
            this.closePath();
            break;

          case _util.OPS.closeStroke:
            this.closeStroke();
            break;

          case _util.OPS.closeFillStroke:
            this.closeFillStroke();
            break;

          case _util.OPS.closeEOFillStroke:
            this.closeEOFillStroke();
            break;

          case _util.OPS.nextLine:
            this.nextLine();
            break;

          case _util.OPS.transform:
            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
            break;

          case _util.OPS.constructPath:
            this.constructPath(args[0], args[1]);
            break;

          case _util.OPS.endPath:
            this.endPath();
            break;

          case 92:
            this.group(opTreeElement.items);
            break;

          default:
            (0, _util.warn)(`Unimplemented operator ${fn}`);
            break;
        }
      }
    }

    setWordSpacing(wordSpacing) {
      this.current.wordSpacing = wordSpacing;
    }

    setCharSpacing(charSpacing) {
      this.current.charSpacing = charSpacing;
    }

    nextLine() {
      this.moveText(0, this.current.leading);
    }

    setTextMatrix(a, b, c, d, e, f) {
      const current = this.current;
      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
      current.textMatrixScale = Math.hypot(a, b);
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
      current.xcoords = [];
      current.ycoords = [];
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
      current.txtElement = this.svgFactory.createElement("svg:text");
      current.txtElement.append(current.tspan);
    }

    beginText() {
      const current = this.current;
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
      current.textMatrix = _util.IDENTITY_MATRIX;
      current.lineMatrix = _util.IDENTITY_MATRIX;
      current.textMatrixScale = 1;
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.txtElement = this.svgFactory.createElement("svg:text");
      current.txtgrp = this.svgFactory.createElement("svg:g");
      current.xcoords = [];
      current.ycoords = [];
    }

    moveText(x, y) {
      const current = this.current;
      current.x = current.lineX += x;
      current.y = current.lineY += y;
      current.xcoords = [];
      current.ycoords = [];
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
    }

    showText(glyphs) {
      const current = this.current;
      const font = current.font;
      const fontSize = current.fontSize;

      if (fontSize === 0) {
        return;
      }

      const fontSizeScale = current.fontSizeScale;
      const charSpacing = current.charSpacing;
      const wordSpacing = current.wordSpacing;
      const fontDirection = current.fontDirection;
      const textHScale = current.textHScale * fontDirection;
      const vertical = font.vertical;
      const spacingDir = vertical ? 1 : -1;
      const defaultVMetrics = font.defaultVMetrics;
      const widthAdvanceScale = fontSize * current.fontMatrix[0];
      let x = 0;

      for (const glyph of glyphs) {
        if (glyph === null) {
          x += fontDirection * wordSpacing;
          continue;
        } else if (typeof glyph === "number") {
          x += spacingDir * glyph * fontSize / 1000;
          continue;
        }

        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        const character = glyph.fontChar;
        let scaledX, scaledY;
        let width = glyph.width;

        if (vertical) {
          let vx;
          const vmetric = glyph.vmetric || defaultVMetrics;
          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
          vx = -vx * widthAdvanceScale;
          const vy = vmetric[2] * widthAdvanceScale;
          width = vmetric ? -vmetric[0] : width;
          scaledX = vx / fontSizeScale;
          scaledY = (x + vy) / fontSizeScale;
        } else {
          scaledX = x / fontSizeScale;
          scaledY = 0;
        }

        if (glyph.isInFont || font.missingFile) {
          current.xcoords.push(current.x + scaledX);

          if (vertical) {
            current.ycoords.push(-current.y + scaledY);
          }

          current.tspan.textContent += character;
        }

        let charWidth;

        if (vertical) {
          charWidth = width * widthAdvanceScale - spacing * fontDirection;
        } else {
          charWidth = width * widthAdvanceScale + spacing * fontDirection;
        }

        x += charWidth;
      }

      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

      if (vertical) {
        current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
      } else {
        current.tspan.setAttributeNS(null, "y", pf(-current.y));
      }

      if (vertical) {
        current.y -= x;
      } else {
        current.x += x * textHScale;
      }

      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);

      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
      }

      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
      }

      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
          current.tspan.setAttributeNS(null, "fill", current.fillColor);
        }

        if (current.fillAlpha < 1) {
          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
        }
      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
        current.tspan.setAttributeNS(null, "fill", "transparent");
      } else {
        current.tspan.setAttributeNS(null, "fill", "none");
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        const lineWidthScale = 1 / (current.textMatrixScale || 1);

        this._setStrokeAttributes(current.tspan, lineWidthScale);
      }

      let textMatrix = current.textMatrix;

      if (current.textRise !== 0) {
        textMatrix = textMatrix.slice();
        textMatrix[5] += current.textRise;
      }

      current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
      current.txtElement.append(current.tspan);
      current.txtgrp.append(current.txtElement);

      this._ensureTransformGroup().append(current.txtElement);
    }

    setLeadingMoveText(x, y) {
      this.setLeading(-y);
      this.moveText(x, y);
    }

    addFontStyle(fontObj) {
      if (!fontObj.data) {
        throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
      }

      if (!this.cssStyle) {
        this.cssStyle = this.svgFactory.createElement("svg:style");
        this.cssStyle.setAttributeNS(null, "type", "text/css");
        this.defs.append(this.cssStyle);
      }

      const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
      this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`;
    }

    setFont(details) {
      const current = this.current;
      const fontObj = this.commonObjs.get(details[0]);
      let size = details[1];
      current.font = fontObj;

      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
        this.addFontStyle(fontObj);
        this.embeddedFonts[fontObj.loadedName] = fontObj;
      }

      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      let bold = "normal";

      if (fontObj.black) {
        bold = "900";
      } else if (fontObj.bold) {
        bold = "bold";
      }

      const italic = fontObj.italic ? "italic" : "normal";

      if (size < 0) {
        size = -size;
        current.fontDirection = -1;
      } else {
        current.fontDirection = 1;
      }

      current.fontSize = size;
      current.fontFamily = fontObj.loadedName;
      current.fontWeight = bold;
      current.fontStyle = italic;
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
      current.xcoords = [];
      current.ycoords = [];
    }

    endText() {
      var _current$txtElement;

      const current = this.current;

      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
        current.element = current.txtElement;
        this.clip("nonzero");
        this.endPath();
      }
    }

    setLineWidth(width) {
      if (width > 0) {
        this.current.lineWidth = width;
      }
    }

    setLineCap(style) {
      this.current.lineCap = LINE_CAP_STYLES[style];
    }

    setLineJoin(style) {
      this.current.lineJoin = LINE_JOIN_STYLES[style];
    }

    setMiterLimit(limit) {
      this.current.miterLimit = limit;
    }

    setStrokeAlpha(strokeAlpha) {
      this.current.strokeAlpha = strokeAlpha;
    }

    setStrokeRGBColor(r, g, b) {
      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
    }

    setFillAlpha(fillAlpha) {
      this.current.fillAlpha = fillAlpha;
    }

    setFillRGBColor(r, g, b) {
      this.current.fillColor = _util.Util.makeHexColor(r, g, b);
      this.current.tspan = this.svgFactory.createElement("svg:tspan");
      this.current.xcoords = [];
      this.current.ycoords = [];
    }

    setStrokeColorN(args) {
      this.current.strokeColor = this._makeColorN_Pattern(args);
    }

    setFillColorN(args) {
      this.current.fillColor = this._makeColorN_Pattern(args);
    }

    shadingFill(args) {
      const width = this.viewport.width;
      const height = this.viewport.height;

      const inv = _util.Util.inverseTransform(this.transformMatrix);

      const bl = _util.Util.applyTransform([0, 0], inv);

      const br = _util.Util.applyTransform([0, height], inv);

      const ul = _util.Util.applyTransform([width, 0], inv);

      const ur = _util.Util.applyTransform([width, height], inv);

      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", x0);
      rect.setAttributeNS(null, "y", y0);
      rect.setAttributeNS(null, "width", x1 - x0);
      rect.setAttributeNS(null, "height", y1 - y0);
      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

      if (this.current.fillAlpha < 1) {
        rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
      }

      this._ensureTransformGroup().append(rect);
    }

    _makeColorN_Pattern(args) {
      if (args[0] === "TilingPattern") {
        return this._makeTilingPattern(args);
      }

      return this._makeShadingPattern(args);
    }

    _makeTilingPattern(args) {
      const color = args[1];
      const operatorList = args[2];
      const matrix = args[3] || _util.IDENTITY_MATRIX;
      const [x0, y0, x1, y1] = args[4];
      const xstep = args[5];
      const ystep = args[6];
      const paintType = args[7];
      const tilingId = `shading${shadingCount++}`;

      const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);

      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);

      const txstep = xstep * xscale;
      const tystep = ystep * yscale;
      const tiling = this.svgFactory.createElement("svg:pattern");
      tiling.setAttributeNS(null, "id", tilingId);
      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
      tiling.setAttributeNS(null, "width", txstep);
      tiling.setAttributeNS(null, "height", tystep);
      tiling.setAttributeNS(null, "x", `${tx0}`);
      tiling.setAttributeNS(null, "y", `${ty0}`);
      const svg = this.svg;
      const transformMatrix = this.transformMatrix;
      const fillColor = this.current.fillColor;
      const strokeColor = this.current.strokeColor;
      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
      this.svg = bbox;
      this.transformMatrix = matrix;

      if (paintType === 2) {
        const cssColor = _util.Util.makeHexColor(...color);

        this.current.fillColor = cssColor;
        this.current.strokeColor = cssColor;
      }

      this.executeOpTree(this.convertOpList(operatorList));
      this.svg = svg;
      this.transformMatrix = transformMatrix;
      this.current.fillColor = fillColor;
      this.current.strokeColor = strokeColor;
      tiling.append(bbox.childNodes[0]);
      this.defs.append(tiling);
      return `url(#${tilingId})`;
    }

    _makeShadingPattern(args) {
      if (typeof args === "string") {
        args = this.objs.get(args);
      }

      switch (args[0]) {
        case "RadialAxial":
          const shadingId = `shading${shadingCount++}`;
          const colorStops = args[3];
          let gradient;

          switch (args[1]) {
            case "axial":
              const point0 = args[4];
              const point1 = args[5];
              gradient = this.svgFactory.createElement("svg:linearGradient");
              gradient.setAttributeNS(null, "id", shadingId);
              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
              gradient.setAttributeNS(null, "x1", point0[0]);
              gradient.setAttributeNS(null, "y1", point0[1]);
              gradient.setAttributeNS(null, "x2", point1[0]);
              gradient.setAttributeNS(null, "y2", point1[1]);
              break;

            case "radial":
              const focalPoint = args[4];
              const circlePoint = args[5];
              const focalRadius = args[6];
              const circleRadius = args[7];
              gradient = this.svgFactory.createElement("svg:radialGradient");
              gradient.setAttributeNS(null, "id", shadingId);
              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
              gradient.setAttributeNS(null, "cx", circlePoint[0]);
              gradient.setAttributeNS(null, "cy", circlePoint[1]);
              gradient.setAttributeNS(null, "r", circleRadius);
              gradient.setAttributeNS(null, "fx", focalPoint[0]);
              gradient.setAttributeNS(null, "fy", focalPoint[1]);
              gradient.setAttributeNS(null, "fr", focalRadius);
              break;

            default:
              throw new Error(`Unknown RadialAxial type: ${args[1]}`);
          }

          for (const colorStop of colorStops) {
            const stop = this.svgFactory.createElement("svg:stop");
            stop.setAttributeNS(null, "offset", colorStop[0]);
            stop.setAttributeNS(null, "stop-color", colorStop[1]);
            gradient.append(stop);
          }

          this.defs.append(gradient);
          return `url(#${shadingId})`;

        case "Mesh":
          (0, _util.warn)("Unimplemented pattern Mesh");
          return null;

        case "Dummy":
          return "hotpink";

        default:
          throw new Error(`Unknown IR type: ${args[0]}`);
      }
    }

    setDash(dashArray, dashPhase) {
      this.current.dashArray = dashArray;
      this.current.dashPhase = dashPhase;
    }

    constructPath(ops, args) {
      const current = this.current;
      let x = current.x,
          y = current.y;
      let d = [];
      let j = 0;

      for (const op of ops) {
        switch (op | 0) {
          case _util.OPS.rectangle:
            x = args[j++];
            y = args[j++];
            const width = args[j++];
            const height = args[j++];
            const xw = x + width;
            const yh = y + height;
            d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
            break;

          case _util.OPS.moveTo:
            x = args[j++];
            y = args[j++];
            d.push("M", pf(x), pf(y));
            break;

          case _util.OPS.lineTo:
            x = args[j++];
            y = args[j++];
            d.push("L", pf(x), pf(y));
            break;

          case _util.OPS.curveTo:
            x = args[j + 4];
            y = args[j + 5];
            d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
            j += 6;
            break;

          case _util.OPS.curveTo2:
            d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
            x = args[j + 2];
            y = args[j + 3];
            j += 4;
            break;

          case _util.OPS.curveTo3:
            x = args[j + 2];
            y = args[j + 3];
            d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
            j += 4;
            break;

          case _util.OPS.closePath:
            d.push("Z");
            break;
        }
      }

      d = d.join(" ");

      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
        d = current.path.getAttributeNS(null, "d") + d;
      } else {
        current.path = this.svgFactory.createElement("svg:path");

        this._ensureTransformGroup().append(current.path);
      }

      current.path.setAttributeNS(null, "d", d);
      current.path.setAttributeNS(null, "fill", "none");
      current.element = current.path;
      current.setCurrentPoint(x, y);
    }

    endPath() {
      const current = this.current;
      current.path = null;

      if (!this.pendingClip) {
        return;
      }

      if (!current.element) {
        this.pendingClip = null;
        return;
      }

      const clipId = `clippath${clipCount++}`;
      const clipPath = this.svgFactory.createElement("svg:clipPath");
      clipPath.setAttributeNS(null, "id", clipId);
      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
      const clipElement = current.element.cloneNode(true);

      if (this.pendingClip === "evenodd") {
        clipElement.setAttributeNS(null, "clip-rule", "evenodd");
      } else {
        clipElement.setAttributeNS(null, "clip-rule", "nonzero");
      }

      this.pendingClip = null;
      clipPath.append(clipElement);
      this.defs.append(clipPath);

      if (current.activeClipUrl) {
        current.clipGroup = null;

        for (const prev of this.extraStack) {
          prev.clipGroup = null;
        }

        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
      }

      current.activeClipUrl = `url(#${clipId})`;
      this.tgrp = null;
    }

    clip(type) {
      this.pendingClip = type;
    }

    closePath() {
      const current = this.current;

      if (current.path) {
        const d = `${current.path.getAttributeNS(null, "d")}Z`;
        current.path.setAttributeNS(null, "d", d);
      }
    }

    setLeading(leading) {
      this.current.leading = -leading;
    }

    setTextRise(textRise) {
      this.current.textRise = textRise;
    }

    setTextRenderingMode(textRenderingMode) {
      this.current.textRenderingMode = textRenderingMode;
    }

    setHScale(scale) {
      this.current.textHScale = scale / 100;
    }

    setRenderingIntent(intent) {}

    setFlatness(flatness) {}

    setGState(states) {
      for (const [key, value] of states) {
        switch (key) {
          case "LW":
            this.setLineWidth(value);
            break;

          case "LC":
            this.setLineCap(value);
            break;

          case "LJ":
            this.setLineJoin(value);
            break;

          case "ML":
            this.setMiterLimit(value);
            break;

          case "D":
            this.setDash(value[0], value[1]);
            break;

          case "RI":
            this.setRenderingIntent(value);
            break;

          case "FL":
            this.setFlatness(value);
            break;

          case "Font":
            this.setFont(value);
            break;

          case "CA":
            this.setStrokeAlpha(value);
            break;

          case "ca":
            this.setFillAlpha(value);
            break;

          default:
            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);
            break;
        }
      }
    }

    fill() {
      const current = this.current;

      if (current.element) {
        current.element.setAttributeNS(null, "fill", current.fillColor);
        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
        this.endPath();
      }
    }

    stroke() {
      const current = this.current;

      if (current.element) {
        this._setStrokeAttributes(current.element);

        current.element.setAttributeNS(null, "fill", "none");
        this.endPath();
      }
    }

    _setStrokeAttributes(element) {
      let lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      const current = this.current;
      let dashArray = current.dashArray;

      if (lineWidthScale !== 1 && dashArray.length > 0) {
        dashArray = dashArray.map(function (value) {
          return lineWidthScale * value;
        });
      }

      element.setAttributeNS(null, "stroke", current.strokeColor);
      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
      element.setAttributeNS(null, "stroke-linecap", current.lineCap);
      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
    }

    eoFill() {
      if (this.current.element) {
        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
      }

      this.fill();
    }

    fillStroke() {
      this.stroke();
      this.fill();
    }

    eoFillStroke() {
      if (this.current.element) {
        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
      }

      this.fillStroke();
    }

    closeStroke() {
      this.closePath();
      this.stroke();
    }

    closeFillStroke() {
      this.closePath();
      this.fillStroke();
    }

    closeEOFillStroke() {
      this.closePath();
      this.eoFillStroke();
    }

    paintSolidColorImageMask() {
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", "0");
      rect.setAttributeNS(null, "y", "0");
      rect.setAttributeNS(null, "width", "1px");
      rect.setAttributeNS(null, "height", "1px");
      rect.setAttributeNS(null, "fill", this.current.fillColor);

      this._ensureTransformGroup().append(rect);
    }

    paintImageXObject(objId) {
      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

      if (!imgData) {
        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);
        return;
      }

      this.paintInlineImageXObject(imgData);
    }

    paintInlineImageXObject(imgData, mask) {
      const width = imgData.width;
      const height = imgData.height;
      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
      const cliprect = this.svgFactory.createElement("svg:rect");
      cliprect.setAttributeNS(null, "x", "0");
      cliprect.setAttributeNS(null, "y", "0");
      cliprect.setAttributeNS(null, "width", pf(width));
      cliprect.setAttributeNS(null, "height", pf(height));
      this.current.element = cliprect;
      this.clip("nonzero");
      const imgEl = this.svgFactory.createElement("svg:image");
      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
      imgEl.setAttributeNS(null, "x", "0");
      imgEl.setAttributeNS(null, "y", pf(-height));
      imgEl.setAttributeNS(null, "width", pf(width) + "px");
      imgEl.setAttributeNS(null, "height", pf(height) + "px");
      imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);

      if (mask) {
        mask.append(imgEl);
      } else {
        this._ensureTransformGroup().append(imgEl);
      }
    }

    paintImageMaskXObject(imgData) {
      const current = this.current;
      const width = imgData.width;
      const height = imgData.height;
      const fillColor = current.fillColor;
      current.maskId = `mask${maskCount++}`;
      const mask = this.svgFactory.createElement("svg:mask");
      mask.setAttributeNS(null, "id", current.maskId);
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", "0");
      rect.setAttributeNS(null, "y", "0");
      rect.setAttributeNS(null, "width", pf(width));
      rect.setAttributeNS(null, "height", pf(height));
      rect.setAttributeNS(null, "fill", fillColor);
      rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
      this.defs.append(mask);

      this._ensureTransformGroup().append(rect);

      this.paintInlineImageXObject(imgData, mask);
    }

    paintFormXObjectBegin(matrix, bbox) {
      if (Array.isArray(matrix) && matrix.length === 6) {
        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      }

      if (bbox) {
        const width = bbox[2] - bbox[0];
        const height = bbox[3] - bbox[1];
        const cliprect = this.svgFactory.createElement("svg:rect");
        cliprect.setAttributeNS(null, "x", bbox[0]);
        cliprect.setAttributeNS(null, "y", bbox[1]);
        cliprect.setAttributeNS(null, "width", pf(width));
        cliprect.setAttributeNS(null, "height", pf(height));
        this.current.element = cliprect;
        this.clip("nonzero");
        this.endPath();
      }
    }

    paintFormXObjectEnd() {}

    _initialize(viewport) {
      const svg = this.svgFactory.create(viewport.width, viewport.height);
      const definitions = this.svgFactory.createElement("svg:defs");
      svg.append(definitions);
      this.defs = definitions;
      const rootGroup = this.svgFactory.createElement("svg:g");
      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
      svg.append(rootGroup);
      this.svg = rootGroup;
      return svg;
    }

    _ensureClipGroup() {
      if (!this.current.clipGroup) {
        const clipGroup = this.svgFactory.createElement("svg:g");
        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
        this.svg.append(clipGroup);
        this.current.clipGroup = clipGroup;
      }

      return this.current.clipGroup;
    }

    _ensureTransformGroup() {
      if (!this.tgrp) {
        this.tgrp = this.svgFactory.createElement("svg:g");
        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

        if (this.current.activeClipUrl) {
          this._ensureClipGroup().append(this.tgrp);
        } else {
          this.svg.append(this.tgrp);
        }
      }

      return this.tgrp;
    }

  };
}

/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNodeStream = void 0;

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(158);

const fs = require$$2__default['default'];

const http = require$$5__default['default'];

const https = require$$6__default['default'];

const url = require$$7__default['default'];

const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

function parseUrl(sourceUrl) {
  const parsedUrl = url.parse(sourceUrl);

  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
    return parsedUrl;
  }

  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
    return url.parse(`file:///${sourceUrl}`);
  }

  if (!parsedUrl.host) {
    parsedUrl.protocol = "file:";
  }

  return parsedUrl;
}

class PDFNodeStream {
  constructor(source) {
    this.source = source;
    this.url = parseUrl(source.url);
    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
    this.isFsUrl = this.url.protocol === "file:";
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  get _progressiveDataLength() {
    var _this$_fullRequestRea, _this$_fullRequestRea2;

    return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
    return this._fullRequestReader;
  }

  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

    this._rangeRequestReaders.push(rangeReader);

    return rangeReader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFNodeStream = PDFNodeStream;

class BaseFullReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._headersCapability = (0, _util.createPromiseCapability)();
  }

  get headersReady() {
    return this._headersCapability.promise;
  }

  get filename() {
    return this._filename;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    if (this._storedError) {
      throw this._storedError;
    }

    const chunk = this._readableStream.read();

    if (chunk === null) {
      this._readCapability = (0, _util.createPromiseCapability)();
      return this.read();
    }

    this._loaded += chunk.length;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength
      });
    }

    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);

      return;
    }

    this._readableStream.destroy(reason);
  }

  _error(reason) {
    this._storedError = reason;

    this._readCapability.resolve();
  }

  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;

      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });

    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new _util.AbortException("streaming is disabled"));
    }

    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }

}

class BaseRangeReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    if (this._storedError) {
      throw this._storedError;
    }

    const chunk = this._readableStream.read();

    if (chunk === null) {
      this._readCapability = (0, _util.createPromiseCapability)();
      return this.read();
    }

    this._loaded += chunk.length;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded
      });
    }

    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);

      return;
    }

    this._readableStream.destroy(reason);
  }

  _error(reason) {
    this._storedError = reason;

    this._readCapability.resolve();
  }

  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;

      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });

    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }

}

function createRequestOptions(parsedUrl, headers) {
  return {
    protocol: parsedUrl.protocol,
    auth: parsedUrl.auth,
    host: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    method: "GET",
    headers
  };
}

class PDFNodeStreamFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);

    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;

        this._headersCapability.reject(error);

        return;
      }

      this._headersCapability.resolve();

      this._setReadableStream(response);

      const getResponseHeader = name => {
        return this._readableStream.headers[name.toLowerCase()];
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
    };

    this._request = null;

    if (this._url.protocol === "http:") {
      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    } else {
      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    }

    this._request.on("error", reason => {
      this._storedError = reason;

      this._headersCapability.reject(reason);
    });

    this._request.end();
  }

}

class PDFNodeStreamRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    this._httpHeaders = {};

    for (const property in stream.httpHeaders) {
      const value = stream.httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      this._httpHeaders[property] = value;
    }

    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;

    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;
        return;
      }

      this._setReadableStream(response);
    };

    this._request = null;

    if (this._url.protocol === "http:") {
      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    } else {
      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    }

    this._request.on("error", reason => {
      this._storedError = reason;
    });

    this._request.end();
  }

}

class PDFNodeStreamFsFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    let path = decodeURIComponent(this._url.path);

    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }

    fs.lstat(path, (error, stat) => {
      if (error) {
        if (error.code === "ENOENT") {
          error = new _util.MissingPDFException(`Missing PDF "${path}".`);
        }

        this._storedError = error;

        this._headersCapability.reject(error);

        return;
      }

      this._contentLength = stat.size;

      this._setReadableStream(fs.createReadStream(path));

      this._headersCapability.resolve();
    });
  }

}

class PDFNodeStreamFsRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    let path = decodeURIComponent(this._url.path);

    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }

    this._setReadableStream(fs.createReadStream(path, {
      start,
      end: end - 1
    }));
  }

}

/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createResponseStatusError = createResponseStatusError;
exports.extractFilenameFromHeader = extractFilenameFromHeader;
exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
exports.validateResponseStatus = validateResponseStatus;

var _util = __w_pdfjs_require__(1);

var _content_disposition = __w_pdfjs_require__(159);

var _display_utils = __w_pdfjs_require__(133);

function validateRangeRequestCapabilities(_ref) {
  let {
    getResponseHeader,
    isHttp,
    rangeChunkSize,
    disableRange
  } = _ref;
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: undefined
  };
  const length = parseInt(getResponseHeader("Content-Length"), 10);

  if (!Number.isInteger(length)) {
    return returnValues;
  }

  returnValues.suggestedLength = length;

  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }

  if (disableRange || !isHttp) {
    return returnValues;
  }

  if (getResponseHeader("Accept-Ranges") !== "bytes") {
    return returnValues;
  }

  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";

  if (contentEncoding !== "identity") {
    return returnValues;
  }

  returnValues.allowRangeRequests = true;
  return returnValues;
}

function extractFilenameFromHeader(getResponseHeader) {
  const contentDisposition = getResponseHeader("Content-Disposition");

  if (contentDisposition) {
    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch (ex) {}
    }

    if ((0, _display_utils.isPdfFile)(filename)) {
      return filename;
    }
  }

  return null;
}

function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && url.startsWith("file:")) {
    return new _util.MissingPDFException('Missing PDF "' + url + '".');
  }

  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}

function validateResponseStatus(status) {
  return status === 200 || status === 206;
}

/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

var _util = __w_pdfjs_require__(1);

function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  tmp = rfc2231getparam(contentDisposition);

  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }

  tmp = toParamRegExp("filename", "i").exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
  }

  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }

      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = (0, _util.stringToBytes)(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch (e) {}
    }

    return value;
  }

  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);

      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }

    return value;
  }

  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);

      if (n in matches) {
        if (n === 0) {
          break;
        }

        continue;
      }

      matches[n] = [quot, part];
    }

    const parts = [];

    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }

      let [quot, part] = matches[n];
      part = rfc2616unquote(part);

      if (quot) {
        part = unescape(part);

        if (n === 0) {
          part = rfc5987decode(part);
        }
      }

      parts.push(part);
    }

    return parts.join("");
  }

  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');

      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');

        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }

        parts[i] = parts[i].replace(/\\(.)/g, "$1");
      }

      value = parts.join('"');
    }

    return value;
  }

  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");

    if (encodingend === -1) {
      return extvalue;
    }

    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }

  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }

    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replace(/_/g, " ");
        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }

      try {
        text = atob(text);
      } catch (e) {}

      return textdecode(charset, text);
    });
  }

  return "";
}

/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNetworkStream = void 0;

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(158);
const OK_RESPONSE = 200;
const PARTIAL_CONTENT_RESPONSE = 206;

function getArrayBuffer(xhr) {
  const data = xhr.response;

  if (typeof data !== "string") {
    return data;
  }

  const array = (0, _util.stringToBytes)(data);
  return array.buffer;
}

class NetworkManager {
  constructor(url) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
    this.withCredentials = args.withCredentials || false;

    this.getXhr = args.getXhr || function NetworkManager_getXhr() {
      return new XMLHttpRequest();
    };

    this.currXhrId = 0;
    this.pendingRequests = Object.create(null);
  }

  requestRange(begin, end, listeners) {
    const args = {
      begin,
      end
    };

    for (const prop in listeners) {
      args[prop] = listeners[prop];
    }

    return this.request(args);
  }

  requestFull(listeners) {
    return this.request(listeners);
  }

  request(args) {
    const xhr = this.getXhr();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;

    for (const property in this.httpHeaders) {
      const value = this.httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      xhr.setRequestHeader(property, value);
    }

    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }

    xhr.responseType = "arraybuffer";

    if (args.onError) {
      xhr.onerror = function (evt) {
        args.onError(xhr.status);
      };
    }

    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }

  onProgress(xhrId, evt) {
    var _pendingRequest$onPro;

    const pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 ? void 0 : _pendingRequest$onPro.call(pendingRequest, evt);
  }

  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    const xhr = pendingRequest.xhr;

    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }

    if (xhr.readyState !== 4) {
      return;
    }

    if (!(xhrId in this.pendingRequests)) {
      return;
    }

    delete this.pendingRequests[xhrId];

    if (xhr.status === 0 && this.isHttp) {
      var _pendingRequest$onErr;

      (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 ? void 0 : _pendingRequest$onErr.call(pendingRequest, xhr.status);
      return;
    }

    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      var _pendingRequest$onErr2;

      (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 ? void 0 : _pendingRequest$onErr2.call(pendingRequest, xhr.status);
      return;
    }

    const chunk = getArrayBuffer(xhr);

    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      pendingRequest.onDone({
        begin: parseInt(matches[1], 10),
        chunk
      });
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      var _pendingRequest$onErr3;

      (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 ? void 0 : _pendingRequest$onErr3.call(pendingRequest, xhr.status);
    }
  }

  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }

  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }

  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }

}

class PDFNetworkStream {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source.url, {
      httpHeaders: source.httpHeaders,
      withCredentials: source.withCredentials
    });
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  _onRangeRequestReaderClosed(reader) {
    const i = this._rangeRequestReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    var _this$_fullRequestRea;

    (_this$_fullRequestRea = this._fullRequestReader) === null || _this$_fullRequestRea === void 0 ? void 0 : _this$_fullRequestRea.cancel(reason);

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFNetworkStream = PDFNetworkStream;

class PDFNetworkStreamFullRequestReader {
  constructor(manager, source) {
    this._manager = manager;
    const args = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = source.url;
    this._fullRequestId = manager.requestFull(args);
    this._headersReceivedCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = undefined;
    this._filename = null;
    this.onProgress = null;
  }

  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;

    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

    const getResponseHeader = name => {
      return fullRequestXhr.getResponseHeader(name);
    };

    const {
      allowRangeRequests,
      suggestedLength
    } = (0, _network_utils.validateRangeRequestCapabilities)({
      getResponseHeader,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });

    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }

    this._contentLength = suggestedLength || this._contentLength;
    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }

    this._headersReceivedCapability.resolve();
  }

  _onDone(data) {
    if (data) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();

        requestCapability.resolve({
          value: data.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data.chunk);
      }
    }

    this._done = true;

    if (this._cachedChunks.length > 0) {
      return;
    }

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;
  }

  _onError(status) {
    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

    this._headersReceivedCapability.reject(this._storedError);

    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }

    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }

  _onProgress(evt) {
    var _this$onProgress;

    (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 ? void 0 : _this$onProgress.call(this, {
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }

  get filename() {
    return this._filename;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  get contentLength() {
    return this._contentLength;
  }

  get headersReady() {
    return this._headersReceivedCapability.promise;
  }

  async read() {
    if (this._storedError) {
      throw this._storedError;
    }

    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();

      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    this._headersReceivedCapability.reject(reason);

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }

    this._fullRequestReader = null;
  }

}

class PDFNetworkStreamRangeRequestReader {
  constructor(manager, begin, end) {
    this._manager = manager;
    const args = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = manager.url;
    this._requestId = manager.requestRange(begin, end, args);
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = undefined;
    this.onProgress = null;
    this.onClosed = null;
  }

  _close() {
    var _this$onClosed;

    (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 ? void 0 : _this$onClosed.call(this, this);
  }

  _onDone(data) {
    const chunk = data.chunk;

    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }

    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    this._close();
  }

  _onError(status) {
    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }

    this._requests.length = 0;
    this._queuedChunk = null;
  }

  _onProgress(evt) {
    if (!this.isStreamingSupported) {
      var _this$onProgress2;

      (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 ? void 0 : _this$onProgress2.call(this, {
        loaded: evt.loaded
      });
    }
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    if (this._storedError) {
      throw this._storedError;
    }

    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }

    this._close();
  }

}

/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFFetchStream = void 0;

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(158);

function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}

function createHeaders(httpHeaders) {
  const headers = new Headers();

  for (const property in httpHeaders) {
    const value = httpHeaders[property];

    if (typeof value === "undefined") {
      continue;
    }

    headers.append(property, value);
  }

  return headers;
}

class PDFFetchStream {
  constructor(source) {
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  get _progressiveDataLength() {
    var _this$_fullRequestRea, _this$_fullRequestRea2;

    return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const reader = new PDFFetchStreamRangeReader(this, begin, end);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFFetchStream = PDFFetchStream;

class PDFFetchStreamReader {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._abortController = new AbortController();
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._headers = createHeaders(this._stream.httpHeaders);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      this._reader = response.body.getReader();

      this._headersCapability.resolve();

      const getResponseHeader = name => {
        return response.headers.get(name);
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new _util.AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }

  get headersReady() {
    return this._headersCapability.promise;
  }

  get filename() {
    return this._filename;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value,
        done
      };
    }

    this._loaded += value.byteLength;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength
      });
    }

    const buffer = new Uint8Array(value).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (this._reader) {
      this._reader.cancel(reason);
    }

    this._abortController.abort();
  }

}

class PDFFetchStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._isStreamingSupported = !source.disableStream;
    this._abortController = new AbortController();
    this._headers = createHeaders(this._stream.httpHeaders);

    this._headers.append("Range", `bytes=${begin}-${end - 1}`);

    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      this._readCapability.resolve();

      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value,
        done
      };
    }

    this._loaded += value.byteLength;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded
      });
    }

    const buffer = new Uint8Array(value).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (this._reader) {
      this._reader.cancel(reason);
    }

    this._abortController.abort();
  }

}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AnnotationEditorLayer", ({
  enumerable: true,
  get: function () {
    return _annotation_editor_layer.AnnotationEditorLayer;
  }
}));
Object.defineProperty(exports, "AnnotationEditorParamsType", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationEditorParamsType;
  }
}));
Object.defineProperty(exports, "AnnotationEditorType", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationEditorType;
  }
}));
Object.defineProperty(exports, "AnnotationEditorUIManager", ({
  enumerable: true,
  get: function () {
    return _tools.AnnotationEditorUIManager;
  }
}));
Object.defineProperty(exports, "AnnotationLayer", ({
  enumerable: true,
  get: function () {
    return _annotation_layer.AnnotationLayer;
  }
}));
Object.defineProperty(exports, "AnnotationMode", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationMode;
  }
}));
Object.defineProperty(exports, "CMapCompressionType", ({
  enumerable: true,
  get: function () {
    return _util.CMapCompressionType;
  }
}));
Object.defineProperty(exports, "GlobalWorkerOptions", ({
  enumerable: true,
  get: function () {
    return _worker_options.GlobalWorkerOptions;
  }
}));
Object.defineProperty(exports, "InvalidPDFException", ({
  enumerable: true,
  get: function () {
    return _util.InvalidPDFException;
  }
}));
Object.defineProperty(exports, "LoopbackPort", ({
  enumerable: true,
  get: function () {
    return _api.LoopbackPort;
  }
}));
Object.defineProperty(exports, "MissingPDFException", ({
  enumerable: true,
  get: function () {
    return _util.MissingPDFException;
  }
}));
Object.defineProperty(exports, "OPS", ({
  enumerable: true,
  get: function () {
    return _util.OPS;
  }
}));
Object.defineProperty(exports, "PDFDataRangeTransport", ({
  enumerable: true,
  get: function () {
    return _api.PDFDataRangeTransport;
  }
}));
Object.defineProperty(exports, "PDFDateString", ({
  enumerable: true,
  get: function () {
    return _display_utils.PDFDateString;
  }
}));
Object.defineProperty(exports, "PDFWorker", ({
  enumerable: true,
  get: function () {
    return _api.PDFWorker;
  }
}));
Object.defineProperty(exports, "PasswordResponses", ({
  enumerable: true,
  get: function () {
    return _util.PasswordResponses;
  }
}));
Object.defineProperty(exports, "PermissionFlag", ({
  enumerable: true,
  get: function () {
    return _util.PermissionFlag;
  }
}));
Object.defineProperty(exports, "PixelsPerInch", ({
  enumerable: true,
  get: function () {
    return _display_utils.PixelsPerInch;
  }
}));
Object.defineProperty(exports, "RenderingCancelledException", ({
  enumerable: true,
  get: function () {
    return _display_utils.RenderingCancelledException;
  }
}));
Object.defineProperty(exports, "SVGGraphics", ({
  enumerable: true,
  get: function () {
    return _svg.SVGGraphics;
  }
}));
Object.defineProperty(exports, "UNSUPPORTED_FEATURES", ({
  enumerable: true,
  get: function () {
    return _util.UNSUPPORTED_FEATURES;
  }
}));
Object.defineProperty(exports, "UnexpectedResponseException", ({
  enumerable: true,
  get: function () {
    return _util.UnexpectedResponseException;
  }
}));
Object.defineProperty(exports, "Util", ({
  enumerable: true,
  get: function () {
    return _util.Util;
  }
}));
Object.defineProperty(exports, "VerbosityLevel", ({
  enumerable: true,
  get: function () {
    return _util.VerbosityLevel;
  }
}));
Object.defineProperty(exports, "XfaLayer", ({
  enumerable: true,
  get: function () {
    return _xfa_layer.XfaLayer;
  }
}));
Object.defineProperty(exports, "build", ({
  enumerable: true,
  get: function () {
    return _api.build;
  }
}));
Object.defineProperty(exports, "createPromiseCapability", ({
  enumerable: true,
  get: function () {
    return _util.createPromiseCapability;
  }
}));
Object.defineProperty(exports, "createValidAbsoluteUrl", ({
  enumerable: true,
  get: function () {
    return _util.createValidAbsoluteUrl;
  }
}));
Object.defineProperty(exports, "getDocument", ({
  enumerable: true,
  get: function () {
    return _api.getDocument;
  }
}));
Object.defineProperty(exports, "getFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getPdfFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getPdfFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getXfaPageViewport", ({
  enumerable: true,
  get: function () {
    return _display_utils.getXfaPageViewport;
  }
}));
Object.defineProperty(exports, "isPdfFile", ({
  enumerable: true,
  get: function () {
    return _display_utils.isPdfFile;
  }
}));
Object.defineProperty(exports, "loadScript", ({
  enumerable: true,
  get: function () {
    return _display_utils.loadScript;
  }
}));
Object.defineProperty(exports, "renderTextLayer", ({
  enumerable: true,
  get: function () {
    return _text_layer.renderTextLayer;
  }
}));
Object.defineProperty(exports, "shadow", ({
  enumerable: true,
  get: function () {
    return _util.shadow;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _api.version;
  }
}));

var _util = __w_pdfjs_require__(1);

var _api = __w_pdfjs_require__(129);

var _display_utils = __w_pdfjs_require__(133);

var _annotation_editor_layer = __w_pdfjs_require__(147);

var _tools = __w_pdfjs_require__(132);

var _annotation_layer = __w_pdfjs_require__(152);

var _worker_options = __w_pdfjs_require__(140);

var _is_node = __w_pdfjs_require__(3);

var _text_layer = __w_pdfjs_require__(155);

var _svg = __w_pdfjs_require__(156);

var _xfa_layer = __w_pdfjs_require__(154);
{
  if (_is_node.isNodeJS) {
    const {
      PDFNodeStream
    } = __w_pdfjs_require__(157);

    (0, _api.setPDFNetworkStreamFactory)(params => {
      return new PDFNodeStream(params);
    });
  } else {
    const {
      PDFNetworkStream
    } = __w_pdfjs_require__(160);

    const {
      PDFFetchStream
    } = __w_pdfjs_require__(161);

    (0, _api.setPDFNetworkStreamFactory)(params => {
      if ((0, _display_utils.isValidFetchUrl)(params.url)) {
        return new PDFFetchStream(params);
      }

      return new PDFNetworkStream(params);
    });
  }
}
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.js.map
});

var pdf$1 = /*@__PURE__*/getDefaultExportFromCjs(pdf);

const swirlFileViewerPdfCss = "/*!@:host*/.sc-swirl-file-viewer-pdf-h{position:relative;display:inline-flex;width:100%;height:100%}/*!@:host(.file-viewer-pdf--view-mode-side-by-side) .file-viewer-pdf__pages*/.file-viewer-pdf--view-mode-side-by-side.sc-swirl-file-viewer-pdf-h .file-viewer-pdf__pages.sc-swirl-file-viewer-pdf{display:grid;grid-template-columns:repeat(2, 1fr);grid-row-gap:var(--s-space-8);grid-column-gap:var(--s-space-8);grid-auto-rows:auto}/*!@:host(.file-viewer-pdf--view-mode-side-by-side) .file-viewer-pdf__page*/.file-viewer-pdf--view-mode-side-by-side.sc-swirl-file-viewer-pdf-h .file-viewer-pdf__page.sc-swirl-file-viewer-pdf{margin:0}/*!@:host(.file-viewer-pdf--view-mode-side-by-side) .file-viewer-pdf__page:nth-child(odd)*/.file-viewer-pdf--view-mode-side-by-side.sc-swirl-file-viewer-pdf-h .file-viewer-pdf__page.sc-swirl-file-viewer-pdf:nth-child(odd){justify-self:end}/*!@:host(.file-viewer-pdf--view-mode-side-by-side) .file-viewer-pdf__page:nth-child(even)*/.file-viewer-pdf--view-mode-side-by-side.sc-swirl-file-viewer-pdf-h .file-viewer-pdf__page.sc-swirl-file-viewer-pdf:nth-child(even){justify-self:start}/*!@:host **/.sc-swirl-file-viewer-pdf-h *.sc-swirl-file-viewer-pdf{box-sizing:border-box}/*!@.file-viewer-pdf__pages*/.file-viewer-pdf__pages.sc-swirl-file-viewer-pdf{overflow:auto;width:100%;height:100%}@media (min-width: 768px){/*!@.file-viewer-pdf__pages*/.file-viewer-pdf__pages.sc-swirl-file-viewer-pdf{padding:var(--s-space-16)}}/*!@.file-viewer-pdf__page*/.file-viewer-pdf__page.sc-swirl-file-viewer-pdf{position:relative;margin-right:auto;margin-left:auto;border-bottom:var(--s-border-width-default) solid var(--s-border-default);background-color:#fff}@media (min-width: 768px){/*!@.file-viewer-pdf__page*/.file-viewer-pdf__page.sc-swirl-file-viewer-pdf{border:var(--s-border-width-default) solid var(--s-border-default)}/*!@.file-viewer-pdf__page:not(:last-of-type)*/.file-viewer-pdf__page.sc-swirl-file-viewer-pdf:not(:last-of-type){margin-bottom:var(--s-space-8)}}/*!@.file-viewer-pdf__page-spinner*/.file-viewer-pdf__page-spinner.sc-swirl-file-viewer-pdf{position:absolute;top:50%;left:50%;transform:translate3d(-50%, -50%, 0)}/*!@.file-viewer-pdf__canvas*/.file-viewer-pdf__canvas.sc-swirl-file-viewer-pdf{display:flex;width:100%;height:100%;margin-right:auto;margin-left:auto}/*!@.file-viewer-pdf__text-container*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf{position:absolute;overflow:hidden;line-height:1;text-align:initial;-webkit-user-select:none;-moz-user-select:none;user-select:none;inset:0;-webkit-text-size-adjust:none;-moz-text-size-adjust:none;text-size-adjust:none;forced-color-adjust:none}/*!@.file-viewer-pdf__text-container > **/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.sc-swirl-file-viewer-pdf{position:absolute;color:transparent;white-space:pre;cursor:text;transform-origin:0% 0%}/*!@.file-viewer-pdf__text-container > *.markedContent*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.markedContent.sc-swirl-file-viewer-pdf{top:0;height:0}/*!@.file-viewer-pdf__text-container > *.highlight*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.highlight.sc-swirl-file-viewer-pdf{margin:-1px;padding:1px;border-radius:4px;background-color:rgba(180, 0, 170, 1)}/*!@.file-viewer-pdf__text-container > *.highlight.appended*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.highlight.appended.sc-swirl-file-viewer-pdf{position:initial}/*!@.file-viewer-pdf__text-container > *.highlight.begin*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.highlight.begin.sc-swirl-file-viewer-pdf{border-radius:4px 0 0 4px}/*!@.file-viewer-pdf__text-container > *.highlight.end*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.highlight.end.sc-swirl-file-viewer-pdf{border-radius:0 4px 4px 0}/*!@.file-viewer-pdf__text-container > *.highlight.middle*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.highlight.middle.sc-swirl-file-viewer-pdf{border-radius:0}/*!@.file-viewer-pdf__text-container > *.highlight.selected*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.highlight.selected.sc-swirl-file-viewer-pdf{background-color:rgba(0, 100, 0, 1)}/*!@.file-viewer-pdf__text-container > *.endOfContent*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.endOfContent.sc-swirl-file-viewer-pdf{position:absolute;z-index:-1;top:100%;right:0;bottom:0;left:0;display:block;cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none}/*!@.file-viewer-pdf__text-container > *.endOfContent.active*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>*.endOfContent.active.sc-swirl-file-viewer-pdf{top:0}/*!@.file-viewer-pdf__text-container > br::-moz-selection*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>br.sc-swirl-file-viewer-pdf::-moz-selection{background:transparent}/*!@.file-viewer-pdf__text-container > br::selection*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf>br.sc-swirl-file-viewer-pdf::selection{background:transparent}@media (min-width: 768px){/*!@.file-viewer-pdf__text-container*/.file-viewer-pdf__text-container.sc-swirl-file-viewer-pdf{-webkit-user-select:auto;-moz-user-select:auto;user-select:auto}}/*!@.file-viewer-pdf__spinner*/.file-viewer-pdf__spinner.sc-swirl-file-viewer-pdf{position:absolute;display:flex;justify-content:center;align-items:center;background-color:rgba(0, 0, 0, 0.2);inset:0}/*!@.file-viewer-pdf__error*/.file-viewer-pdf__error.sc-swirl-file-viewer-pdf{position:absolute;top:50%;left:50%;transform:translate3d(-50%, -50%, 0)}/*!@.file-viewer-pdf__pagination*/.file-viewer-pdf__pagination.sc-swirl-file-viewer-pdf{position:absolute;bottom:var(--s-space-16);left:50%;padding:var(--s-space-4) var(--s-space-12);border-radius:var(--s-border-radius-base);color:var(--s-text-on-image);background-color:rgba(0, 0, 0, 0.6);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base);transform:translateX(-50%);pointer-events:none}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.file-viewer-pdf__pagination*/.file-viewer-pdf__pagination.sc-swirl-file-viewer-pdf{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}";

pdf$1.GlobalWorkerOptions.workerSrc = "/pdfjs/pdf.worker.min.js";
class SwirlFileViewerPdf {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activate = createEvent(this, "activate", 7);
    this.visiblePagesChange = createEvent(this, "visiblePagesChange", 7);
    this.pages = [];
    this.renderingPageNumbers = [];
    this.recentScrollPosition = { x: 0, y: 0 };
    this.determineScrollStatus = () => {
      var _a, _b, _c;
      const scrolledDown = Math.ceil(((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollTop) + ((_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.offsetHeight)) >= ((_c = this.scrollContainer) === null || _c === void 0 ? void 0 : _c.scrollHeight);
      if (scrolledDown !== this.scrolledDown) {
        this.scrolledDown = scrolledDown;
      }
    };
    this.storeRecentScrollPosition = () => {
      var _a, _b, _c, _d;
      this.recentScrollPosition = {
        x: Math.round((((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollLeft) /
          ((_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.scrollWidth)) *
          100) / 100,
        y: Math.round((((_c = this.scrollContainer) === null || _c === void 0 ? void 0 : _c.scrollTop) /
          ((_d = this.scrollContainer) === null || _d === void 0 ? void 0 : _d.scrollHeight)) *
          100) / 100,
      };
    };
    this.onScroll = debounce(() => {
      this.updateVisiblePages();
      this.determineScrollStatus();
      this.storeRecentScrollPosition();
    }, 60);
    this.errorMessage = "File could not be loaded.";
    this.file = undefined;
    this.singlePageMode = undefined;
    this.viewMode = "single";
    this.zoom = 1;
    this.doc = undefined;
    this.error = undefined;
    this.loading = true;
    this.renderedPages = [];
    this.scrolledDown = false;
    this.singlePageModePage = 1;
    this.visiblePages = [];
  }
  async componentWillLoad() {
    await this.getPages();
  }
  async componentDidLoad() {
    await this.updateVisiblePages();
    this.activate.emit(this.el);
    this.determineScrollStatus();
  }
  disconnectedCallback() {
    var _a;
    (_a = this.doc) === null || _a === void 0 ? void 0 : _a.destroy();
  }
  async onWindowResize() {
    this.visiblePages = [];
    this.renderedPages = [];
    await this.updateVisiblePages();
    this.determineScrollStatus();
  }
  async watchProps() {
    await this.getPages();
    await this.updateVisiblePages();
    this.determineScrollStatus();
  }
  async watchViewMode() {
    queueMicrotask(async () => {
      this.visiblePages = [];
      this.renderedPages = [];
      await this.updateVisiblePages();
      this.determineScrollStatus();
    });
  }
  watchZoom() {
    queueMicrotask(async () => {
      this.restoreScrollPosition();
      this.visiblePages = [];
      this.renderedPages = [];
      await this.updateVisiblePages();
      this.determineScrollStatus();
    });
  }
  /**
   * Get thumbnails of all pages.
   */
  async getThumbnails() {
    return await Promise.all(this.pages.filter(Boolean).map((page) => {
      const vp = page.getViewport({ scale: 1 });
      const canvas = document.createElement("canvas");
      canvas.width = vp.width;
      canvas.height = vp.height;
      const scale = Math.min(canvas.width / vp.width, canvas.height / vp.height);
      return page
        .render({
        canvasContext: canvas.getContext("2d"),
        viewport: page.getViewport({ scale: scale }),
      })
        .promise.then(function () {
        return canvas;
      });
    }));
  }
  /**
   * Print the file.
   */
  async print() {
    this.loading = true;
    await this.updateVisiblePages(true);
    await this.openPrintDialog();
    this.loading = false;
  }
  /**
   * Navigate to next page, if single page mode is enabled.
   */
  async nextPage() {
    await this.setPage(this.singlePageModePage + 1);
    await this.updateVisiblePages();
  }
  /**
   * Navigate to previous page, if single page mode is enabled.
   */
  async previousPage() {
    await this.setPage(this.singlePageModePage - 1);
    await this.updateVisiblePages();
  }
  /**
   * Navigate to specific page, if single page mode is enabled.
   */
  async setPage(page) {
    this.singlePageModePage = Math.min(Math.max(page, 1), this.pages.length - 1);
    await this.updateVisiblePages();
  }
  async getPages() {
    this.error = false;
    this.loading = true;
    try {
      if (Boolean(this.doc)) {
        this.doc.destroy();
      }
      this.doc = await pdf.getDocument(this.file).promise;
      for (let i = 1; i <= this.doc.numPages; i++) {
        const page = await this.doc.getPage(i);
        this.pages[i] = page;
      }
      this.loading = false;
    }
    catch (e) {
      this.error = true;
      this.loading = false;
    }
  }
  async renderVisiblePages(forPrint) {
    const canvases = Array.from(this.el.shadowRoot.querySelectorAll("canvas"));
    const renderedPages = [];
    for (const canvas of canvases) {
      const container = canvas.closest(".file-viewer-pdf__page");
      const page = this.pages.find((page) => (page === null || page === void 0 ? void 0 : page.pageNumber) === +(container === null || container === void 0 ? void 0 : container.dataset.pageNumber));
      if (!Boolean(page) ||
        this.renderingPageNumbers.includes(page.pageNumber)) {
        continue;
      }
      if (!this.visiblePages.includes(page.pageNumber)) {
        this.destroyPage(page);
        continue;
      }
      if (this.renderedPages.includes(page.pageNumber) && !forPrint) {
        renderedPages.push(page.pageNumber);
        continue;
      }
      await this.renderPage(page, canvas, forPrint);
      renderedPages.push(page.pageNumber);
    }
    this.renderedPages = renderedPages;
  }
  async renderPage(page, canvas, forPrint) {
    const container = canvas.closest(".file-viewer-pdf__page");
    const textContainer = container === null || container === void 0 ? void 0 : container.querySelector(".file-viewer-pdf__text-container");
    this.renderingPageNumbers = [...this.renderingPageNumbers, page.pageNumber];
    const scale = forPrint ? 2 : this.getScale(page);
    const outputScale = window.devicePixelRatio || 1;
    const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
    const viewport = page.getViewport({ scale });
    const context = canvas.getContext("2d");
    canvas.height = Math.floor(viewport.height * outputScale);
    canvas.width = Math.floor(viewport.width * outputScale);
    const renderContext = {
      canvasContext: context,
      transform,
      viewport: viewport,
    };
    try {
      await page.render(renderContext).promise;
      page.cleanup();
      textContainer.innerHTML = "";
      this.renderTextLayer(page, textContainer).catch();
      this.renderingPageNumbers = this.renderingPageNumbers.filter((pageNumber) => pageNumber !== page.pageNumber);
    }
    catch (e) { }
  }
  destroyPage(page) {
    const container = this.el.shadowRoot.querySelector(`[data-page-number="${page.pageNumber}"]`);
    const canvas = container.querySelector("canvas");
    const textLayer = container.querySelector(".file-viewer-pdf__text-container");
    canvas.width = 1;
    canvas.height = 1;
    canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
    textLayer.innerHTML = "";
  }
  async updateVisiblePages(forPrint) {
    const pages = Array.from(this.el.shadowRoot.querySelectorAll(".file-viewer-pdf__page"));
    let visiblePages = [];
    if (this.singlePageMode) {
      visiblePages = [this.singlePageModePage];
    }
    else {
      visiblePages = forPrint
        ? pages.map((page) => +page.dataset.pageNumber)
        : pages
          .filter((page) => getVisibleHeight(page, this.scrollContainer) > 0)
          .map((page) => +page.dataset.pageNumber);
      const visiblePagesDidNotChanged = this.visiblePages.length === visiblePages.length &&
        this.visiblePages.every((pageNumber) => visiblePages.includes(pageNumber));
      if (visiblePagesDidNotChanged) {
        return;
      }
    }
    this.visiblePages = visiblePages;
    await this.renderVisiblePages(forPrint);
    this.visiblePagesChange.emit(this.visiblePages);
  }
  async renderTextLayer(page, container) {
    pdf.renderTextLayer({
      container,
      textContent: await page.getTextContent(),
      viewport: page.getViewport({
        scale: this.getScale(page),
      }),
    });
  }
  async openPrintDialog() {
    const canvases = Array.from(this.scrollContainer.querySelectorAll("canvas"));
    let styles = `
      *, *:before, *:after {
        margin: 0;
        padding: 0;
      }

      img {
        display: block;
        width: 100%;
        page-break-after: always;
      }
      `;
    let html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${this.file}</title>
        <style>${styles}</style>
      </head>
      <body>
    `;
    for (const canvas of canvases) {
      html += `<img src="${canvas.toDataURL()}">`;
    }
    html += `
      </body>
      </html>
    `;
    const iframe = document.createElement("iframe");
    this.el.append(iframe);
    const win = iframe.contentWindow;
    win.document.write(html);
    win.focus();
    await new Promise((resolve) => setTimeout(resolve, 100));
    win.print();
    iframe.remove();
  }
  getScale(page) {
    var _a;
    const padding = isMobileViewport() ? 0 : 32;
    if (this.zoom === "auto") {
      return (((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.clientWidth) - padding) / page.view[2];
    }
    else if (isNaN(this.zoom)) {
      return 1;
    }
    return this.zoom;
  }
  restoreScrollPosition() {
    var _a, _b;
    this.scrollContainer.scrollTop =
      this.recentScrollPosition.y * ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollHeight);
    this.scrollContainer.scrollLeft =
      this.recentScrollPosition.x * ((_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.scrollWidth);
  }
  render() {
    const showPagination = !this.error && !this.loading && this.visiblePages.length > 0;
    const currentPage = this.scrolledDown && !this.singlePageMode
      ? this.pages.length - 1
      : this.visiblePages[0];
    const showSpinner = this.loading;
    const className = classnames("file-viewer-pdf", `file-viewer-pdf--view-mode-${this.viewMode}`);
    return (hAsync(Host, { class: className, exportparts: "file-viewer-pdf__pagination" }, this.error && (hAsync("swirl-inline-error", { class: "file-viewer-pdf__error", message: this.errorMessage })), hAsync("div", { "aria-describedby": "pagination", class: "file-viewer-pdf__pages", onScroll: this.onScroll, ref: (el) => (this.scrollContainer = el) }, this.pages.map((page) => {
      const viewport = page.getViewport({
        scale: this.getScale(page),
      });
      const height = viewport.height;
      const width = viewport.width;
      const rendered = this.renderedPages.includes(page.pageNumber);
      return (hAsync("div", { "aria-label": page.pageNumber, class: "file-viewer-pdf__page", "data-page-number": page.pageNumber, hidden: !this.singlePageMode ||
          page.pageNumber === this.singlePageModePage
          ? undefined
          : true, id: `page-${page.pageNumber}`, key: page.pageNumber, role: "region", style: {
          width: `${width}px`,
          height: `${height}px`,
        }, tabIndex: 0 }, !rendered && (hAsync("swirl-spinner", { class: "file-viewer-pdf__page-spinner" })), hAsync("canvas", { class: "file-viewer-pdf__canvas", style: { opacity: rendered ? "1" : "0" } }), hAsync("div", { class: "file-viewer-pdf__text-container" })));
    })), showPagination && (hAsync("span", { class: "file-viewer-pdf__pagination", id: "pagination", part: "file-viewer-pdf__pagination" }, hAsync("span", { "aria-current": "page" }, currentPage), " / ", this.doc.numPages)), showSpinner && (hAsync("div", { class: "file-viewer-pdf__spinner" }, hAsync("swirl-spinner", null)))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "file": ["watchProps"],
    "viewMode": ["watchViewMode"],
    "zoom": ["watchZoom"]
  }; }
  static get style() { return swirlFileViewerPdfCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-file-viewer-pdf",
    "$members$": {
      "errorMessage": [1, "error-message"],
      "file": [1],
      "singlePageMode": [4, "single-page-mode"],
      "viewMode": [1, "view-mode"],
      "zoom": [8],
      "doc": [32],
      "error": [32],
      "loading": [32],
      "renderedPages": [32],
      "scrolledDown": [32],
      "singlePageModePage": [32],
      "visiblePages": [32],
      "getThumbnails": [64],
      "print": [64],
      "nextPage": [64],
      "previousPage": [64],
      "setPage": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlFileViewerTextCss = "/*!@:host*/.sc-swirl-file-viewer-text-h{position:relative;display:inline-flex;width:100%;max-height:100%}/*!@:host **/.sc-swirl-file-viewer-text-h *.sc-swirl-file-viewer-text{box-sizing:border-box}/*!@.file-viewer-text__text*/.file-viewer-text__text.sc-swirl-file-viewer-text{overflow:auto;width:100%;max-height:100%;margin:0;padding:0;padding:var(--s-space-16);background-color:var(--s-background-default);font-family:var(--s-font-family-code)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.file-viewer-text__text*/.file-viewer-text__text.sc-swirl-file-viewer-text{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.file-viewer-text__spinner*/.file-viewer-text__spinner.sc-swirl-file-viewer-text{position:absolute;display:flex;justify-content:center;align-items:center;background-color:rgba(0, 0, 0, 0.2);inset:0}/*!@.file-viewer-text__error*/.file-viewer-text__error.sc-swirl-file-viewer-text{position:absolute;top:50%;left:50%;transform:translate3d(-50%, -50%, 0)}";

class SwirlFileViewerText {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activate = createEvent(this, "activate", 7);
    this.errorMessage = "File could not be loaded.";
    this.file = undefined;
    this.error = undefined;
    this.loading = undefined;
    this.text = undefined;
  }
  componentWillLoad() {
    this.updateText();
  }
  componentDidLoad() {
    this.activate.emit(this.el);
  }
  async updateText() {
    this.error = false;
    this.loading = true;
    try {
      const response = await fetch(this.file);
      this.text = await response.text();
      this.loading = false;
    }
    catch (e) {
      this.loading = false;
      this.error = true;
    }
  }
  render() {
    return (hAsync(Host, { class: "file-viewer-text", exportparts: "file-viewer-text__text" }, this.error && (hAsync("swirl-inline-error", { class: "file-viewer-text__error", message: this.errorMessage })), hAsync("pre", { class: "file-viewer-text__text", part: "file-viewer-text__text", tabIndex: 0 }, this.text), this.loading && (hAsync("div", { class: "file-viewer-text__spinner" }, hAsync("swirl-spinner", null)))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "file": ["updateText"]
  }; }
  static get style() { return swirlFileViewerTextCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-file-viewer-text",
    "$members$": {
      "errorMessage": [1, "error-message"],
      "file": [1],
      "error": [32],
      "loading": [32],
      "text": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlFileViewerVideoCss = "/*!@:host*/.sc-swirl-file-viewer-video-h{display:inline-flex;width:100%;max-height:100%}/*!@:host **/.sc-swirl-file-viewer-video-h *.sc-swirl-file-viewer-video{box-sizing:border-box}/*!@.file-viewer-video__video*/.file-viewer-video__video.sc-swirl-file-viewer-video{width:100%;background-color:rgba(0, 0, 0, 1)}";

class SwirlFileViewerVideo {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activate = createEvent(this, "activate", 7);
    this.autoplay = undefined;
    this.file = undefined;
    this.type = undefined;
  }
  componentDidLoad() {
    this.activate.emit(this.el);
  }
  render() {
    return (hAsync(Host, { class: "file-viewer-video" }, hAsync("video", { autoplay: this.autoplay, class: "file-viewer-video__video", controls: true }, hAsync("source", { src: this.file, type: this.type }))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlFileViewerVideoCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-file-viewer-video",
    "$members$": {
      "autoplay": [4],
      "file": [1],
      "type": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlFormControlCss = ".sc-swirl-form-control-h{display:block;width:100%}.sc-swirl-form-control-h *.sc-swirl-form-control{box-sizing:border-box}.form-control.sc-swirl-form-control{display:block;width:100%;line-height:var(--s-line-height-sm)}.form-control.form-control--has-focus.sc-swirl-form-control:not(.form-control--disabled) .form-control__label.sc-swirl-form-control{border-color:var(--s-border-highlight);box-shadow:0 0 0 var(--s-border-width-default) var(--s-border-highlight)}.form-control.sc-swirl-form-control:not(.form-control--has-value):not(.form-control--has-focus):not(.form-control--is-select):not(.form-control--has-placeholder) .form-control__input.sc-swirl-form-control{overflow:hidden;max-height:0}.form-control.sc-swirl-form-control:not(.form-control--has-value):not(.form-control--has-focus):not(.form-control--is-select):not(.form-control--has-placeholder) .form-control__label-text.sc-swirl-form-control{bottom:50%;font-size:var(--s-font-size-base);transform:translateY(50%);opacity:1}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.form-control.sc-swirl-form-control:not(.form-control--has-value):not(.form-control--has-focus):not(.form-control--is-select):not(.form-control--has-placeholder) .form-control__label-text.sc-swirl-form-control{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.form-control.sc-swirl-form-control:not(.form-control--has-value).form-control--is-select .select__label.sc-swirl-form-control{overflow:hidden;max-height:0;pointer-events:none}.form-control.sc-swirl-form-control:not(.form-control--has-value).form-control--is-select .form-control__label-text.sc-swirl-form-control{bottom:50%;font-size:var(--s-font-size-base);transform:translateY(50%);opacity:1}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.form-control.sc-swirl-form-control:not(.form-control--has-value).form-control--is-select .form-control__label-text.sc-swirl-form-control{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.form-control--label-position-outside.sc-swirl-form-control{padding-top:calc(var(--s-line-height-sm) + var(--s-space-4))}.form-control--label-position-outside.sc-swirl-form-control:not(.form-control--is-select) .form-control__label.sc-swirl-form-control{cursor:text}.form-control--label-position-outside.sc-swirl-form-control .form-control__label.sc-swirl-form-control{min-height:calc(2.375rem + 2 * var(--s-border-width-default));padding:var(--s-space-8) var(--s-space-12);gap:var(--s-space-2)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.form-control--label-position-outside.sc-swirl-form-control .form-control__label.sc-swirl-form-control{min-height:calc(2.25rem + 2 * var(--s-border-width-default))}}.form-control--label-position-outside.sc-swirl-form-control .form-control__label-text.sc-swirl-form-control,.form-control--label-position-outside.sc-swirl-form-control:not(.form-control--has-value):not(.form-control--has-focus):not(.form-control--is-select):not(.form-control--has-placeholder) .form-control__label-text.sc-swirl-form-control,.form-control--label-position-outside.sc-swirl-form-control:not(.form-control--has-value).form-control--is-select .form-control__label-text.sc-swirl-form-control{bottom:calc(100% + var(--s-space-4));left:0;color:var(--s-text-default);font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-medium);transform:none;opacity:1}.form-control--label-position-outside.form-control--disabled.sc-swirl-form-control .form-control__label-text.sc-swirl-form-control,.form-control--label-position-outside.form-control--disabled.sc-swirl-form-control:not(.form-control--has-value):not(.form-control--has-focus):not(.form-control--is-select):not(.form-control--has-placeholder) .form-control__label-text.sc-swirl-form-control,.form-control--label-position-outside.form-control--disabled.sc-swirl-form-control:not(.form-control--has-value).form-control--is-select .form-control__label-text.sc-swirl-form-control{color:var(--s-text-disabled)}.form-control--label-position-outside.form-control--has-character-counter.sc-swirl-form-control .form-control__description.sc-swirl-form-control{max-width:calc(100% - 6rem)}.form-control--invalid.form-control--has-focus.sc-swirl-form-control:not(.form-control--disabled) .form-control__label.sc-swirl-form-control{border-color:var(--s-border-critical);box-shadow:0 0 0 var(--s-border-width-default) var(--s-border-critical)}.form-control--invalid.sc-swirl-form-control .form-control__label.sc-swirl-form-control{border-color:var(--s-border-critical)}.form-control--disabled.sc-swirl-form-control .form-control__label.sc-swirl-form-control{border-color:var(--s-border-disabled);color:var(--s-text-disabled)}.form-control--disabled.sc-swirl-form-control .form-control__description.sc-swirl-form-control{color:var(--s-text-disabled)}.form-control--inline.sc-swirl-form-control .form-control__label.sc-swirl-form-control{min-height:calc(2.375rem + 2 * var(--s-border-width-default));padding:var(--s-space-8) var(--s-space-12);gap:var(--s-space-2)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.form-control--inline.sc-swirl-form-control .form-control__label.sc-swirl-form-control{min-height:calc(2.25rem + 2 * var(--s-border-width-default))}}.form-control--inline.sc-swirl-form-control:not(.form-control--has-placeholder) .form-control__label-text.sc-swirl-form-control{right:var(--s-space-12);left:var(--s-space-12);transition:none;opacity:0}.form-control--inline.form-control--has-character-counter.sc-swirl-form-control .form-control__description.sc-swirl-form-control{max-width:calc(100% - 6rem)}.form-control--hide-label.sc-swirl-form-control .form-control__label-text.sc-swirl-form-control{position:absolute;display:inline;overflow:hidden;width:1px;height:1px;margin:-1px;padding:0;border:0;white-space:nowrap;word-wrap:normal;clip:rect(0, 0, 0, 0)}.form-control__label.sc-swirl-form-control{position:relative;display:flex;width:100%;min-height:4.375rem;padding:calc(var(--s-space-12) + 1.25rem) var(--s-space-16) var(--s-space-12);justify-content:center;border:var(--s-border-width-default) solid var(--s-border-strong);border-radius:var(--s-border-radius-sm);color:var(--s-text-subdued);flex-direction:column;gap:var(--s-space-2)}.form-control__label-text.sc-swirl-form-control{position:absolute;right:var(--s-space-16);bottom:calc(100% - 1.25rem - var(--s-space-12));left:var(--s-space-16);overflow:hidden;font-size:var(--s-font-size-sm);white-space:nowrap;text-overflow:ellipsis;transition:font-size 0.15s, transform 0.15s, top 0.15s;transform:none}.form-control__description.sc-swirl-form-control{display:block;margin-top:var(--s-space-4);padding-left:var(--s-space-4);color:var(--s-text-subdued);font-size:var(--s-font-size-sm)}.form-control__error-message.sc-swirl-form-control{display:block;margin-top:var(--s-space-4)}";

/**
 * @slot slot - The input element, e.g. `<swirl-text-input></swirl-text-input>`
 */
class SwirlFormControl {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.descriptionId = `form-control-description-${Math.round(Math.random() * 100000)}`;
    this.listenToInputValueChanges = () => {
      this.inputEl.addEventListener("valueChange", this.checkInputValue);
    };
    this.checkInputValue = () => {
      var _a;
      this.inputValue = (_a = this.inputEl) === null || _a === void 0 ? void 0 : _a.value;
    };
    this.onFocusIn = () => {
      this.hasFocus = true;
    };
    this.onKeyDown = (event) => {
      if (event.key === "Tab") {
        setTimeout(() => {
          if (!this.el.contains(getActiveElement())) {
            this.hasFocus = false;
          }
        });
      }
    };
    this.description = undefined;
    this.disabled = undefined;
    this.errorMessage = undefined;
    this.hideLabel = undefined;
    this.inline = undefined;
    this.invalid = undefined;
    this.label = undefined;
    this.labelPosition = "inside";
    this.hasFocus = undefined;
    this.inputValue = undefined;
  }
  componentWillLoad() {
    this.inputEl = this.el.children[0];
    this.associateDescriptionWithInputElement();
    this.setInputElementDisabledState();
    this.setInputElementInlineState();
    this.setInputElementInvalidState();
    this.setInputElementLabel();
    this.checkInputValue();
    this.listenToInputValueChanges();
  }
  associateDescriptionWithInputElement() {
    if (!Boolean(this.description) || !Boolean(this.inputEl)) {
      return;
    }
    this.inputEl.setAttribute("swirl-aria-describedby", this.descriptionId);
  }
  setInputElementDisabledState() {
    if (!Boolean(this.inputEl)) {
      return;
    }
    if (this.disabled) {
      this.inputEl.setAttribute("disabled", "true");
    }
    else {
      this.inputEl.removeAttribute("disabled");
    }
  }
  setInputElementInlineState() {
    if (!Boolean(this.inputEl)) {
      return;
    }
    if (this.inline || this.labelPosition === "outside") {
      this.inputEl.setAttribute("inline", "true");
    }
    else {
      this.inputEl.removeAttribute("inline");
    }
  }
  setInputElementInvalidState() {
    if (!Boolean(this.inputEl)) {
      return;
    }
    if (this.invalid) {
      this.inputEl.setAttribute("invalid", "true");
    }
    else {
      this.inputEl.removeAttribute("invalid");
    }
  }
  setInputElementLabel() {
    if (!Boolean(this.inputEl)) {
      return;
    }
    this.inputEl.setAttribute("label", this.label);
  }
  onWindowClick(event) {
    if (!this.hasFocus) {
      return;
    }
    const target = event.target;
    if (this.el.contains(target)) {
      return;
    }
    this.hasFocus = false;
  }
  render() {
    const showErrorMessage = Boolean(this.errorMessage);
    const showDescription = Boolean(this.description) && !showErrorMessage;
    const hasValue = Array.isArray(this.inputValue)
      ? this.inputValue.length > 0
      : Boolean(this.inputValue);
    const hasCharacterCounter = Boolean(this.inputEl.getAttribute("show-character-counter"));
    const hasPlaceholder = Boolean(this.inputEl.getAttribute("placeholder"));
    const isSelect = this.inputEl.tagName === "SWIRL-SELECT";
    const className = classnames("form-control", `form-control--label-position-${this.labelPosition}`, {
      "form-control--disabled": this.disabled,
      "form-control--has-character-counter": hasCharacterCounter,
      "form-control--has-focus": this.hasFocus,
      "form-control--has-placeholder": hasPlaceholder,
      "form-control--has-value": hasValue,
      "form-control--hide-label": this.hideLabel,
      "form-control--inline": this.inline,
      "form-control--invalid": this.invalid,
      "form-control--is-select": isSelect,
    });
    return (hAsync(Host, { onFocusin: this.onFocusIn, onKeyDown: this.onKeyDown }, hAsync("div", { class: className, role: "group" }, hAsync("label", { class: "form-control__label" }, hAsync("span", { class: "form-control__label-text" }, this.label), hAsync("span", { class: "form-control__input" }, hAsync("slot", null))), showDescription && (hAsync("span", { class: "form-control__description", id: this.descriptionId }, this.description)), showErrorMessage && (hAsync("span", { "aria-live": "polite", class: "form-control__error-message", id: this.descriptionId }, hAsync("swirl-inline-error", { message: this.errorMessage, size: "s" }))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "description": ["associateDescriptionWithInputElement"],
    "disabled": ["setInputElementDisabledState"],
    "inline": ["setInputElementInlineState"],
    "invalid": ["setInputElementInvalidState"],
    "label": ["setInputElementLabel"]
  }; }
  static get style() { return swirlFormControlCss; }
  static get cmpMeta() { return {
    "$flags$": 6,
    "$tagName$": "swirl-form-control",
    "$members$": {
      "description": [1],
      "disabled": [4],
      "errorMessage": [1, "error-message"],
      "hideLabel": [4, "hide-label"],
      "inline": [4],
      "invalid": [4],
      "label": [1],
      "labelPosition": [1, "label-position"],
      "hasFocus": [32],
      "inputValue": [32]
    },
    "$listeners$": [[8, "click", "onWindowClick"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlFormGroupCss = ".sc-swirl-form-group-h{display:block;width:100%}.sc-swirl-form-group-h *.sc-swirl-form-group{box-sizing:border-box}.form-group.sc-swirl-form-group{display:flex;flex-direction:column;gap:var(--s-space-16)}@media (min-width: 768px){.form-group.sc-swirl-form-group{gap:var(--s-space-24)}}.form-group--orientation-horizontal.sc-swirl-form-group{gap:var(--s-space-16)}@media (min-width: 768px){.form-group--orientation-horizontal.sc-swirl-form-group{flex-direction:row}}";

class SwirlFormGroup {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.orientation = "vertical";
  }
  render() {
    const className = classnames("form-group", `form-group--orientation-${this.orientation}`);
    return (hAsync(Host, null, hAsync("div", { class: className }, hAsync("slot", null))));
  }
  static get style() { return swirlFormGroupCss; }
  static get cmpMeta() { return {
    "$flags$": 6,
    "$tagName$": "swirl-form-group",
    "$members$": {
      "orientation": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

var balancetext = createCommonjsModule(function (module) {
/*
 * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. *
 */
/**
 * balancetext.js
 *
 * Author: Randy Edmunds
 */

/* global define, module */

/*
 * Copyright (c) 2007-2009 unscriptable.com and John M. Hann
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the “Software”), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above
 * copyright holders (unscriptable.com and John M. Hann) shall not be
 * used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization.
 *
 * http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/
 *
 * Tested to work on (lowest browser):
 * - Sarari 4
 * - Chrome 16
 * - Firefox 10
 * - IE 9
 * - Edge 13
 */

(function (root, factory) {
    if (module.exports) {
        module.exports = factory();
    } else {
        root.balanceText = factory();
    }
}(commonjsGlobal, () => {
    /**
     * Line breaking global vars
     */
    let breakMatches, wsnwMatches, wsnwOffset;

    /**
     * Selectors and elements to watch;
     * calling $.balanceText(elements) adds "elements" to this list.
     */
    const watching = {
        sel: [], // default class to watch
        el: [],
    };

    /**
     * Have handlers been initialized?
     */
    let handlersInitialized = false;

    /**
     * Is this a polyfill?
     */
    let polyfilled = false;


    /**
     * Do nothing
     */
    function noop() { }

    /**
     * Loop that works with array-likes
     * @param {Array-like} elements - List of elements to run a function on
     * @param {Function}   callback - The function to call on each supplied element
     */
    function forEach(elements, callback) {
        Array.prototype.forEach.call(elements, callback);
    }

    /**
     * Polyfill for $(document).ready()
     *
     * @param {Function} fn - The function to execute when the document is ready
     */
    function ready(fn) {
        if (document.readyState !== "loading") {
            fn();
        } else if (document.addEventListener) {
            document.addEventListener("DOMContentLoaded", fn);
        } else {
            document.attachEvent("onreadystatechange", () => {
                if (document.readyState !== "loading") {
                    fn();
                }
            });
        }
    }

    /**
     * Debounces a function over a threshold
     *
     * @param {Function} func      - The function to debounce
     * @param {number}   threshold - time in ms
     * @param {boolean}  execAsap  - when true, execute immediately
     * @param args
     * @return {Function} Debounced function
     */
    function debounce(func, threshold, execAsap, ...args) {
        let timeout;

        return function () {
            const obj = this;

            function delayed() {
                if (!execAsap) {
                    func.apply(obj, args);
                }
                timeout = null;
            }

            if (timeout) {
                clearTimeout(timeout);
            } else if (execAsap) {
                func.apply(obj, args);
            }
            timeout = setTimeout(delayed, threshold || 100);
        };
    }

    /**
     * Determine whether the document supports TextWrap
     * @return {boolean}
     */
    function hasTextWrap() {
        if (typeof window === "undefined") {
            return false;
        }
        const { style } = document.documentElement;
        return style.textWrap || style.WebkitTextWrap || style.MozTextWrap || style.MsTextWrap;
    }

    /**
     * Object for tracking next whitespace params
     */
    // eslint-disable-next-line camelcase
    function NextWS_params() {
        this.reset();
    }

    NextWS_params.prototype.reset = function () {
        this.index = 0;
        this.width = 0;
    };

    /**
     * Check if index is contained in previously calculated list of white-space:nowrap ranges
     *
     * @param {number} index - the index of the character to check
     * @return {boolean}
     */
    function isWhiteSpaceNoWrap(index) {
        // Is index inside 1 of the ranges?
        // start and end are breakable, but not inside range
        return wsnwMatches.some(range => (range.start < index && index < range.end));
    }

    /**
     * Recursively calculate white-space:nowrap offsets for line.
     *
     * @param {Node}    el         - the element to act on
     * @param {boolean} includeTag - include length of tag itself
     */
    function recursiveCalcNoWrapOffsetsForLine(el, includeTag) {
        if (el.nodeType === el.ELEMENT_NODE) {
            // Found an embedded tag
            const style = window.getComputedStyle(el);
            if (style.whiteSpace === "nowrap") {
                // Tag with white-space:nowrap - add match, skip children
                const len = el.outerHTML.length;
                wsnwMatches.push({ start: wsnwOffset, end: wsnwOffset + len });
                wsnwOffset += len;
            } else {
                // Tag without white-space:nowrap - recursively check children of tag
                forEach(el.childNodes, (child) => {
                    recursiveCalcNoWrapOffsetsForLine(child, true);
                });
                if (includeTag) {
                    // Length of opening tag, attributes, and closing tag
                    wsnwOffset += (el.outerHTML.length - el.innerHTML.length);
                }
            }
        } else if (el.nodeType === el.COMMENT_NODE) {
            wsnwOffset += el.length + 7; // delimiter: <!-- -->
        } else if (el.nodeType === el.PROCESSING_INSTRUCTION_NODE) {
            wsnwOffset += el.length + 2; // delimiter: < >
        } else {
            // Text node: add length
            wsnwOffset += el.length;
        }
    }

    /**
     * Calculate white-space:nowrap offsets for line.
     *
     * @param {Node}    el             - the element to act on
     * @param {string}  oldWS          - "old" whitespace setting for temporarily resetting
     * @param {number}  lineCharOffset - char offset of current line from start of text
     */
    function calcNoWrapOffsetsForLine(el, oldWS, lineCharOffset) {
        // For first line (lineCharOffset === 0), calculate start and end offsets for each
        // white-space:nowrap element in the line.
        if (lineCharOffset === 0) {
            // Reset whiteSpace setting when breakMatches is being calculated
            // so white-space:nowrap can be detected in text
            el.style.whiteSpace = oldWS;

            wsnwOffset = 0;
            wsnwMatches = [];
            recursiveCalcNoWrapOffsetsForLine(el, false);

            // Restore temporary whitespace setting to recalc width
            el.style.whiteSpace = "nowrap";
        } else {
            // For all other lines, update the offsets for current line
            // 1. Ignore matches less than offset
            // 2. Subtract offset from remaining matches
            const newMatches = [];
            wsnwMatches.forEach((match) => {
                if (match.start > lineCharOffset) {
                    newMatches.push({ start: match.start - lineCharOffset, end: match.end - lineCharOffset });
                }
            });
            wsnwMatches = newMatches;
        }
    }

    /**
     * Strip balance-text tags from an element inserted in previous run
     *
     * @param {Node} el - the element to act on
     */
    function removeTags(el) {
        // Remove soft-hyphen breaks
        let brs = el.querySelectorAll('br[data-owner="balance-text-hyphen"]');
        forEach(brs, (br) => {
            br.outerHTML = "";
        });

        // Replace other breaks with whitespace
        brs = el.querySelectorAll('br[data-owner="balance-text"]');
        forEach(brs, (br) => {
            br.outerHTML = " ";
        });

        // Restore hyphens inserted for soft-hyphens
        let spans = el.querySelectorAll('span[data-owner="balance-text-softhyphen"]');
        if (spans.length > 0) {
            forEach(spans, (span) => {
                const textNode = document.createTextNode("\u00ad");
                span.parentNode.insertBefore(textNode, span);
                span.parentNode.removeChild(span);
            });
        }

        // Remove spans inserted for justified text
        spans = el.querySelectorAll('span[data-owner="balance-text-justify"]');
        if (spans.length > 0) {
            let txt = "";
            forEach(spans, (span) => {
                txt += span.textContent;
                span.parentNode.removeChild(span);
            });
            el.innerHTML = txt;
        }
    }

    /**
     * Checks to see if we should justify the balanced text with the
     * element based on the textAlign property in the computed CSS
     *
     * @param {Node} el - element to check
     * @return {boolean}
     */
    const isJustified = function (el) {
        const style = el.currentStyle || window.getComputedStyle(el, null);
        return (style.textAlign === "justify");
    };

    /**
     * Add whitespace after words in text to justify the string to
     * the specified size.
     * @param {Node}    el       - the element to justify
     * @param {string}  txt      - text string
     * @param {number}  conWidth - container width
     * @return {string} Justified text
     */
    function justify(el, txt, conWidth) {
        txt = txt.trim();
        const words = txt.split(" ").length;
        txt = `${txt} `;

        // if we don't have at least 2 words, no need to justify.
        if (words < 2) {
            return txt;
        }

        // Find width of text in the DOM
        const tmp = document.createElement("span");
        tmp.innerHTML = txt;
        el.appendChild(tmp);
        const size = tmp.offsetWidth;
        tmp.parentNode.removeChild(tmp);

        // Figure out our word spacing and return the element
        const wordSpacing = Math.floor((conWidth - size) / (words - 1));
        tmp.style.wordSpacing = `${wordSpacing}px`;
        tmp.setAttribute("data-owner", "balance-text-justify");

        const div = document.createElement("div");
        div.appendChild(tmp);
        return div.innerHTML;
    }

    /**
     * Returns true iff char at index is a break char outside of HTML < > tags.
     * Break char can be: whitespace (except non-breaking-space: u00a0),
     * hypen, emdash (u2014), endash (u2013), or soft-hyphen (u00ad).
     *
     * @param {string} txt   - the text to check
     * @param {number} index - the index of the character to check
     * @return {boolean}
     */
    function isBreakChar(txt, index) {
        const re = /([^\S\u00a0]|-|\u2014|\u2013|\u00ad)(?![^<]*>)/g;
        let match;

        if (!breakMatches) {
            // Only calc break matches once per line
            breakMatches = [];
            match = re.exec(txt);
            while (match !== null) {
                if (!isWhiteSpaceNoWrap(match.index)) {
                    breakMatches.push(match.index);
                }
                match = re.exec(txt);
            }
        }

        return breakMatches.indexOf(index) !== -1;
    }

    /**
     * In the current implementation, an index is a break
     * opportunity in txt iff it is:
     * - 0 or txt.length
     * - index of a non-whitespace char immediately preceded by a
     *   whitespace, hyphen, soft-hyphen, em-dash, or en-dash char.
     *
     * Thus, it doesn't honour "white-space" or any other Unicode
     * line-breaking classes.)
     *
     * @precondition 0 <= index && index <= txt.length
     *
     * @param {string} txt   - the text to check
     * @param {number} index - the index to check
     * @return {boolean}
     */
    function isBreakOpportunity(txt, index) {
        return ((index === 0) || (index === txt.length) ||
                (isBreakChar(txt, index - 1) && !isBreakChar(txt, index)));
    }

    /**
     * Finds the first break opportunity (@see isBreakOpportunity)
     * in txt that's both after-or-equal-to index c in the direction dir
     * and resulting in line width equal to or past clamp(desWidth,
     * 0, conWidth) in direction dir.  Sets ret.index and ret.width
     * to the corresponding index and line width (from the start of
     * txt to ret.index).
     *
     * @param {Node}    el       - element
     * @param {string}  txt      - text string
     * @param {number}  conWidth - container width
     * @param {number}  desWidth - desired width
     * @param {number}  dir      - direction (-1 or +1)
     * @param {number}  c        - char index (0 <= c && c <= txt.length)
     * @param {Object}  ret      - return {index: {number}, width: {number}} of previous/next break
     */
    function findBreakOpportunity(el, txt, conWidth, desWidth, dir, c, ret) {
        let w;

        if (txt && typeof txt === "string") {
            for (;;) {
                while (!isBreakOpportunity(txt, c)) {
                    c += dir;
                }

                el.innerHTML = txt.substr(0, c);
                w = el.offsetWidth;

                if (dir < 0) {
                    if ((w <= desWidth) || (w <= 0) || (c === 0)) {
                        break;
                    }
                } else if ((desWidth <= w) || (conWidth <= w) || (c === txt.length)) {
                    break;
                }

                c += dir;
            }
        }
        ret.index = c;
        ret.width = w;
    }

    /**
     * Detects the width of a non-breaking space character, given the height of
     * the element with no-wrap applied.
     *
     * @param {Node}   el - element
     * @param {number} h  - height
     * @return {number}
     */
    function getSpaceWidth(el, h) {
        const container = document.createElement("div");

        container.style.display = "block";
        container.style.position = "absolute";
        container.style.bottom = 0;
        container.style.right = 0;
        container.style.width = 0;
        container.style.height = 0;
        container.style.margin = 0;
        container.style.padding = 0;
        container.style.visibility = "hidden";
        container.style.overflow = "hidden";

        const space = document.createElement("span");

        space.style.fontSize = "2000px";
        space.innerHTML = "&nbsp;";

        container.appendChild(space);

        el.appendChild(container);

        const dims = space.getBoundingClientRect();
        container.parentNode.removeChild(container);

        const spaceRatio = dims.height / dims.width;

        return (h / spaceRatio);
    }

    /**
     * Get a list of elements regardless of input
     *
     * @param {string|Node|Array-like} elements - The selector to query, one or more elements
     * @return {Array<{Node}>}
     */
    function getElementsList(elements) {
        if (!elements) {
            return [];
        }

        // is selector
        if (typeof elements === "string") {
            return document.querySelectorAll(elements);
        }

        // is single element
        if (elements.tagName && elements.querySelectorAll) {
            return [elements];
        }

        return elements;
    }

    /**
     *  When a browser has native support for the text-wrap property,
     * the text balanceText plugin will let the browser handle it natively,
     * otherwise it will apply its own text balancing code.
     *
     * @param {string|Node|Array-like} elements - the list of elements to balance
     */
    function balanceText(elements) {
        forEach(getElementsList(elements), (el) => {
            // In a lower level language, this algorithm takes time
            // comparable to normal text layout other than the fact
            // that we do two passes instead of one, so we should
            // be able to do without this limit.
            const maxTextWidth = 5000;

            // strip balance-text generated tags
            removeTags(el);

            // save settings
            const oldWS = el.style.whiteSpace;
            const oldFloat = el.style.float;
            const oldDisplay = el.style.display;
            const oldPosition = el.style.position;
            const oldLH = el.style.lineHeight;

            // remove line height before measuring container size
            el.style.lineHeight = "normal";

            const containerWidth = el.offsetWidth;
            const containerHeight = el.offsetHeight;

            // temporary settings
            el.style.whiteSpace = "nowrap";
            el.style.float = "none";
            el.style.display = "inline";
            el.style.position = "static";

            let nowrapWidth = el.offsetWidth;
            const nowrapHeight = el.offsetHeight;

            // An estimate of the average line width reduction due
            // to trimming trailing space that we expect over all
            // lines other than the last.
            const spaceWidth = ((oldWS === "pre-wrap") ? 0 : getSpaceWidth(el, nowrapHeight));

            if (containerWidth > 0 &&               // prevent divide by zero
                    nowrapWidth > containerWidth && // text is more than 1 line
                    nowrapWidth < maxTextWidth) {   // text is less than arbitrary limit (make this a param?)
                let remainingText = el.innerHTML;
                let newText = "";
                let lineText = "";
                const shouldJustify = isJustified(el);
                const totLines = Math.round(containerHeight / nowrapHeight);
                let remLines = totLines;
                let lineCharOffset = 0;

                // loop vars
                let desiredWidth, guessIndex, le, ge, splitIndex, isHyphen, isSoftHyphen;

                // Determine where to break:
                while (remLines > 1) {
                    // clear whitespace match cache for each line
                    breakMatches = null;

                    // Must calc white-space:nowrap offsets before first call to findBreakOpportunity()
                    calcNoWrapOffsetsForLine(el, oldWS, lineCharOffset);

                    desiredWidth = Math.round((nowrapWidth + spaceWidth) / remLines - spaceWidth);

                    // Guessed char index
                    guessIndex = Math.round((remainingText.length + 1) / remLines) - 1;

                    le = new NextWS_params();

                    // Find a breaking space somewhere before (or equal to) desired width,
                    // not necessarily the closest to the desired width.
                    findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, -1, guessIndex, le);

                    // Find first breaking char after (or equal to) desired width.
                    ge = new NextWS_params();
                    guessIndex = le.index;
                    findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, +1, guessIndex, ge);

                    // Find first breaking char before (or equal to) desired width.
                    le.reset();
                    guessIndex = ge.index;
                    findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, -1, guessIndex, le);

                    // Find closest string to desired length
                    if (le.index === 0) {
                        splitIndex = ge.index;
                    } else if ((containerWidth < ge.width) || (le.index === ge.index)) {
                        splitIndex = le.index;
                    } else {
                        splitIndex = ((Math.abs(desiredWidth - le.width) < Math.abs(ge.width - desiredWidth))
                            ? le.index
                            : ge.index);
                    }

                    // Break string
                    lineText = remainingText.substr(0, splitIndex).replace(/\s$/, "");

                    isSoftHyphen = Boolean(lineText.match(/\u00ad$/));
                    if (isSoftHyphen) {
                        // Replace soft-hyphen causing break with explicit hyphen
                        lineText = lineText.replace(/\u00ad$/, '<span data-owner="balance-text-softhyphen">-</span>');
                    }

                    if (shouldJustify) {
                        newText += justify(el, lineText, containerWidth);
                    } else {
                        newText += lineText;
                        isHyphen = isSoftHyphen || Boolean(lineText.match(/(-|\u2014|\u2013)$/));
                        newText += isHyphen ? '<br data-owner="balance-text-hyphen" />'
                            : '<br data-owner="balance-text" aria-hidden="true" />';
                    }
                    remainingText = remainingText.substr(splitIndex);
                    lineCharOffset = splitIndex;

                    // update counters
                    remLines--;
                    el.innerHTML = remainingText;
                    nowrapWidth = el.offsetWidth;
                }

                if (shouldJustify) {
                    el.innerHTML = newText + justify(el, remainingText, containerWidth);
                } else {
                    el.innerHTML = newText + remainingText;
                }
            }

            // restore settings
            el.style.whiteSpace = oldWS;
            el.style.float = oldFloat;
            el.style.display = oldDisplay;
            el.style.position = oldPosition;
            el.style.lineHeight = oldLH;
        });
    }

    /**
     * Call the balanceText plugin on elements that it's watching.
     */
    function updateWatched() {
        const selectors = watching.sel.join(",");
        const selectedElements = getElementsList(selectors);
        const elements = Array.prototype.concat.apply(watching.el, selectedElements);
        balanceText(elements);
    }

    /**
     * Initialize the events for which to re-apply BalanceText.  They are:
     * - Document ready
     * - Document full load
     * - Window resize
     */
    function initHandlers() {
        if (handlersInitialized) {
            return;
        }

        // Apply on DOM ready
        ready(updateWatched);

        // Reapply on full load
        window.addEventListener("load", updateWatched);

        // Reapply on resize
        window.addEventListener("resize", debounce(updateWatched));

        handlersInitialized = true;
    }

    /**
     * Apply the BalanceText routine on the document and watch the list
     * of elements.  On window resize, re-apply BalanceText to the given elements
     *
     * @param {string|Node|Array-like} elements - the elements to watch after applying BalanceText
     */
    function balanceTextAndWatch(elements) {
        if (typeof elements === "string") {
            watching.sel.push(elements);
        } else {
            forEach(getElementsList(elements), (el) => {
                watching.el.push(el);
            });
        }

        initHandlers();
        updateWatched();
    }

    /**
     * Stop watching elements
     *
     * @param {string|Node|Array-like} elements
     */
    function unwatch(elements) {
        if (typeof elements === "string") {
            watching.sel = watching.sel.filter(el => el !== elements);
        } else {
            elements = getElementsList(elements);
            watching.el = watching.el.filter(el => elements.indexOf(el) === -1);
        }
    }

    /**
     * Treat this app as a polyfill.  Watch for changes to the .balance-text selector
     */
    function polyfill() {
        if (polyfilled) {
            return;
        }

        watching.sel.push(".balance-text");
        initHandlers();
        polyfilled = true;
    }

    /**
     * Public interface
     *
     * @param {string|Node|Array-like} elements - elements to balance
     * @param {Object}                 options  - processing options
     *  - {boolean} watch - watch elements for resize
     */
    function publicInterface(elements, options) {
        if (!elements) {
            // empty call means polyfill (watch for changes)
            polyfill();
        } else if (options && options.watch === true) {
            balanceTextAndWatch(elements);
        } else if (options && options.watch === false) {
            unwatch(elements);
        } else {
            balanceText(elements);
        }
    }

    publicInterface.updateWatched = updateWatched;

    if (hasTextWrap()) {
        noop.updateWatched = noop;
        return noop;
    }
    return publicInterface;
}));
});

const swirlHeadingCss = ".sc-swirl-heading-h{display:block;width:100%}.sc-swirl-heading-h *.sc-swirl-heading{box-sizing:border-box}.heading.sc-swirl-heading{display:block;width:100%;margin:0;padding:0;text-align:start}.heading--align-start.sc-swirl-heading{text-align:start}.heading--align-center.sc-swirl-heading{text-align:center}.heading--align-end.sc-swirl-heading{text-align:end}.heading--level-1.sc-swirl-heading{font-size:var(--s-font-size-2xl);font-weight:var(--s-font-weight-bold);line-height:var(--s-line-height-2xl);letter-spacing:var(--s-letter-spacing-tight)}.heading--level-2.sc-swirl-heading{font-size:var(--s-font-size-xl);font-weight:var(--s-font-weight-bold);line-height:var(--s-line-height-xl)}.heading--level-3.sc-swirl-heading{font-size:var(--s-font-size-lg);font-weight:var(--s-font-weight-semibold);line-height:var(--s-line-height-lg)}.heading--level-4.sc-swirl-heading{font-size:var(--s-font-size-base);font-weight:var(--s-font-weight-semibold);line-height:var(--s-line-height-base)}.heading--level-5.sc-swirl-heading,.heading--level-6.sc-swirl-heading{font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-semibold);line-height:var(--s-line-height-sm)}.heading--truncate.sc-swirl-heading{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}";

class SwirlHeading$1 {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.align = "start";
    this.as = undefined;
    this.balance = true;
    this.headingId = undefined;
    this.level = 1;
    this.lines = undefined;
    this.text = undefined;
    this.truncate = undefined;
  }
  componentDidRender() {
    this.rebalance();
  }
  onWindowResize() {
    this.rebalance();
  }
  rebalance() {
    if (!this.balance || !Boolean(this.headingEl) || Boolean(this.lines)) {
      return;
    }
    balancetext(this.headingEl);
  }
  render() {
    const Tag = this.as || `h${this.level}`;
    const styles = Boolean(this.lines)
      ? {
        display: "-webkit-box",
        overflow: "hidden",
        "-webkit-line-clamp": String(this.lines),
        "-webkit-box-orient": "vertical",
        whiteSpace: "normal",
      }
      : undefined;
    const className = classnames("heading", `heading--align-${this.align}`, `heading--level-${this.level}`, {
      "heading--truncate": this.truncate,
    });
    return (hAsync(Host, null, hAsync(Tag, { class: className, id: this.headingId, ref: (el) => (this.headingEl = el), style: styles }, this.text)));
  }
  static get style() { return swirlHeadingCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-heading",
    "$members$": {
      "align": [1],
      "as": [1],
      "balance": [4],
      "headingId": [1, "heading-id"],
      "level": [2],
      "lines": [2],
      "text": [1],
      "truncate": [4]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1X = "/*!@:host*/.sc-swirl-icon-h{display:inline-flex}";

class SwirlHeading {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.glyph = undefined;
    this.size = 24;
  }
  render() {
    const Tag = `swirl-icon-${this.glyph}`;
    return (hAsync(Host, null, hAsync(Tag, { size: this.size })));
  }
  static get style() { return swirlIconCss$1X; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon",
    "$members$": {
      "glyph": [1],
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1W = "/*!@:host*/.sc-swirl-icon-add-h{display:inline-flex}";

class SwirlIconAdd {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 12.7666C7.78889 12.7666 7.60845 12.6915 7.45867 12.5413C7.30845 12.3915 7.23334 12.2111 7.23334 11.9999V8.76661H4C3.78889 8.76661 3.60845 8.6915 3.45867 8.54128C3.30845 8.3915 3.23334 8.21105 3.23334 7.99994C3.23334 7.78883 3.30845 7.60839 3.45867 7.45861C3.60845 7.30839 3.78889 7.23328 4 7.23328H7.23334V3.99994C7.23334 3.78883 7.30845 3.60817 7.45867 3.45794C7.60845 3.30817 7.78889 3.23328 8 3.23328C8.21112 3.23328 8.39156 3.30817 8.54134 3.45794C8.69156 3.60817 8.76667 3.78883 8.76667 3.99994V7.23328H12C12.2111 7.23328 12.3916 7.30839 12.5413 7.45861C12.6916 7.60839 12.7667 7.78883 12.7667 7.99994C12.7667 8.21105 12.6916 8.3915 12.5413 8.54128C12.3916 8.6915 12.2111 8.76661 12 8.76661H8.76667V11.9999C8.76667 12.2111 8.69156 12.3915 8.54134 12.5413C8.39156 12.6915 8.21112 12.7666 8 12.7666V12.7666Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 19.15C11.6833 19.15 11.4127 19.0373 11.188 18.812C10.9627 18.5873 10.85 18.3166 10.85 18V13.15H6.00001C5.68334 13.15 5.41267 13.0373 5.18801 12.812C4.96267 12.5873 4.85001 12.3166 4.85001 12C4.85001 11.6833 4.96267 11.4126 5.18801 11.188C5.41267 10.9626 5.68334 10.85 6.00001 10.85H10.85V5.99998C10.85 5.68331 10.9627 5.41231 11.188 5.18698C11.4127 4.96231 11.6833 4.84998 12 4.84998C12.3167 4.84998 12.5873 4.96231 12.812 5.18698C13.0373 5.41231 13.15 5.68331 13.15 5.99998V10.85H18C18.3167 10.85 18.5873 10.9626 18.812 11.188C19.0373 11.4126 19.15 11.6833 19.15 12C19.15 12.3166 19.0373 12.5873 18.812 12.812C18.5873 13.0373 18.3167 13.15 18 13.15H13.15V18C13.15 18.3166 13.0373 18.5873 12.812 18.812C12.5873 19.0373 12.3167 19.15 12 19.15Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 22.3417C13.6305 22.3417 13.3148 22.2102 13.0527 21.9473C12.7898 21.6852 12.6583 21.3694 12.6583 21V15.3417H6.99999C6.63055 15.3417 6.31477 15.2102 6.05266 14.9473C5.78977 14.6852 5.65833 14.3694 5.65833 14C5.65833 13.6305 5.78977 13.3148 6.05266 13.0527C6.31477 12.7898 6.63055 12.6583 6.99999 12.6583H12.6583V6.99999C12.6583 6.63055 12.7898 6.31438 13.0527 6.05149C13.3148 5.78938 13.6305 5.65833 14 5.65833C14.3694 5.65833 14.6852 5.78938 14.9473 6.05149C15.2102 6.31438 15.3417 6.63055 15.3417 6.99999V12.6583H21C21.3694 12.6583 21.6852 12.7898 21.9473 13.0527C22.2102 13.3148 22.3417 13.6305 22.3417 14C22.3417 14.3694 22.2102 14.6852 21.9473 14.9473C21.6852 15.2102 21.3694 15.3417 21 15.3417H15.3417V21C15.3417 21.3694 15.2102 21.6852 14.9473 21.9473C14.6852 22.2102 14.3694 22.3417 14 22.3417V22.3417Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1W; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-add",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1V = "/*!@:host*/.sc-swirl-icon-add-photo-h{display:inline-flex}";

class SwirlIconAddPhoto {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M1.99999 14.6666C1.63332 14.6666 1.31955 14.5362 1.05866 14.2753C0.797323 14.014 0.666656 13.7 0.666656 13.3333V5.33331C0.666656 4.96665 0.797323 4.65287 1.05866 4.39198C1.31955 4.13065 1.63332 3.99998 1.99999 3.99998H4.09999L4.93332 3.09998C5.05555 2.96665 5.20266 2.86109 5.37466 2.78331C5.5471 2.70554 5.72777 2.66665 5.91666 2.66665H8.66666C8.85555 2.66665 9.01399 2.73042 9.14199 2.85798C9.26955 2.98598 9.33332 3.14442 9.33332 3.33331V4.66665C9.33332 4.85553 9.39732 5.01398 9.52532 5.14198C9.65288 5.26953 9.8111 5.33331 9.99999 5.33331H11.3333V6.66665C11.3333 6.85553 11.3973 7.01376 11.5253 7.14131C11.6529 7.26931 11.8111 7.33331 12 7.33331H13.3333C13.5222 7.33331 13.6804 7.39709 13.808 7.52465C13.936 7.65265 14 7.81109 14 7.99998V13.3333C14 13.7 13.8695 14.014 13.6087 14.2753C13.3473 14.5362 13.0333 14.6666 12.6667 14.6666H1.99999ZM7.33332 12.3333C8.16666 12.3333 8.8751 12.0418 9.45866 11.4586C10.0418 10.8751 10.3333 10.1666 10.3333 9.33331C10.3333 8.49998 10.0418 7.79153 9.45866 7.20798C8.8751 6.62487 8.16666 6.33331 7.33332 6.33331C6.49999 6.33331 5.79155 6.62487 5.20799 7.20798C4.62488 7.79153 4.33332 8.49998 4.33332 9.33331C4.33332 10.1666 4.62488 10.8751 5.20799 11.4586C5.79155 12.0418 6.49999 12.3333 7.33332 12.3333ZM12.6667 3.99998H12C11.8111 3.99998 11.6529 3.9362 11.5253 3.80865C11.3973 3.68065 11.3333 3.5222 11.3333 3.33331C11.3333 3.14442 11.3973 2.98598 11.5253 2.85798C11.6529 2.73042 11.8111 2.66665 12 2.66665H12.6667V1.99998C12.6667 1.81109 12.7307 1.65265 12.8587 1.52465C12.9862 1.39709 13.1444 1.33331 13.3333 1.33331C13.5222 1.33331 13.6804 1.39709 13.808 1.52465C13.936 1.65265 14 1.81109 14 1.99998V2.66665H14.6667C14.8555 2.66665 15.0138 2.73042 15.1413 2.85798C15.2693 2.98598 15.3333 3.14442 15.3333 3.33331C15.3333 3.5222 15.2693 3.68065 15.1413 3.80865C15.0138 3.9362 14.8555 3.99998 14.6667 3.99998H14V4.66665C14 4.85553 13.936 5.01398 13.808 5.14198C13.6804 5.26953 13.5222 5.33331 13.3333 5.33331C13.1444 5.33331 12.9862 5.26953 12.8587 5.14198C12.7307 5.01398 12.6667 4.85553 12.6667 4.66665V3.99998Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M3 22C2.45 22 1.97933 21.8043 1.588 21.413C1.196 21.021 1 20.55 1 20V8C1 7.45 1.196 6.97933 1.588 6.588C1.97933 6.196 2.45 6 3 6H6.15L7.4 4.65C7.58333 4.45 7.804 4.29167 8.062 4.175C8.32067 4.05833 8.59167 4 8.875 4H13C13.2833 4 13.521 4.09567 13.713 4.287C13.9043 4.479 14 4.71667 14 5V7C14 7.28333 14.096 7.521 14.288 7.713C14.4793 7.90433 14.7167 8 15 8H17V10C17 10.2833 17.096 10.5207 17.288 10.712C17.4793 10.904 17.7167 11 18 11H20C20.2833 11 20.5207 11.0957 20.712 11.287C20.904 11.479 21 11.7167 21 12V20C21 20.55 20.8043 21.021 20.413 21.413C20.021 21.8043 19.55 22 19 22H3ZM11 18.5C12.25 18.5 13.3127 18.0627 14.188 17.188C15.0627 16.3127 15.5 15.25 15.5 14C15.5 12.75 15.0627 11.6873 14.188 10.812C13.3127 9.93733 12.25 9.5 11 9.5C9.75 9.5 8.68733 9.93733 7.812 10.812C6.93733 11.6873 6.5 12.75 6.5 14C6.5 15.25 6.93733 16.3127 7.812 17.188C8.68733 18.0627 9.75 18.5 11 18.5ZM19 6H18C17.7167 6 17.4793 5.90433 17.288 5.713C17.096 5.521 17 5.28333 17 5C17 4.71667 17.096 4.479 17.288 4.287C17.4793 4.09567 17.7167 4 18 4H19V3C19 2.71667 19.096 2.479 19.288 2.287C19.4793 2.09567 19.7167 2 20 2C20.2833 2 20.5207 2.09567 20.712 2.287C20.904 2.479 21 2.71667 21 3V4H22C22.2833 4 22.5207 4.09567 22.712 4.287C22.904 4.479 23 4.71667 23 5C23 5.28333 22.904 5.521 22.712 5.713C22.5207 5.90433 22.2833 6 22 6H21V7C21 7.28333 20.904 7.521 20.712 7.713C20.5207 7.90433 20.2833 8 20 8C19.7167 8 19.4793 7.90433 19.288 7.713C19.096 7.521 19 7.28333 19 7V6Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M3.49999 25.6666C2.85832 25.6666 2.30921 25.4384 1.85266 24.9818C1.39532 24.5245 1.16666 23.975 1.16666 23.3333V9.33331C1.16666 8.69165 1.39532 8.14254 1.85266 7.68598C2.30921 7.22865 2.85832 6.99998 3.49999 6.99998H7.17499L8.63332 5.42498C8.84721 5.19165 9.10466 5.00692 9.40566 4.87081C9.70743 4.7347 10.0236 4.66665 10.3542 4.66665H15.1667C15.4972 4.66665 15.7745 4.77826 15.9985 5.00148C16.2217 5.22548 16.3333 5.50276 16.3333 5.83331V8.16665C16.3333 8.4972 16.4453 8.77448 16.6693 8.99848C16.8925 9.2217 17.1694 9.33331 17.5 9.33331H19.8333V11.6666C19.8333 11.9972 19.9453 12.2741 20.1693 12.4973C20.3925 12.7213 20.6694 12.8333 21 12.8333H23.3333C23.6639 12.8333 23.9408 12.9449 24.164 13.1681C24.388 13.3921 24.5 13.6694 24.5 14V23.3333C24.5 23.975 24.2717 24.5245 23.8152 24.9818C23.3578 25.4384 22.8083 25.6666 22.1667 25.6666H3.49999ZM12.8333 21.5833C14.2917 21.5833 15.5314 21.0731 16.5527 20.0526C17.5731 19.0314 18.0833 17.7916 18.0833 16.3333C18.0833 14.875 17.5731 13.6352 16.5527 12.614C15.5314 11.5935 14.2917 11.0833 12.8333 11.0833C11.375 11.0833 10.1352 11.5935 9.11399 12.614C8.09354 13.6352 7.58332 14.875 7.58332 16.3333C7.58332 17.7916 8.09354 19.0314 9.11399 20.0526C10.1352 21.0731 11.375 21.5833 12.8333 21.5833ZM22.1667 6.99998H21C20.6694 6.99998 20.3925 6.88837 20.1693 6.66515C19.9453 6.44115 19.8333 6.16387 19.8333 5.83331C19.8333 5.50276 19.9453 5.22548 20.1693 5.00148C20.3925 4.77826 20.6694 4.66665 21 4.66665H22.1667V3.49998C22.1667 3.16942 22.2787 2.89215 22.5027 2.66815C22.7259 2.44492 23.0028 2.33331 23.3333 2.33331C23.6639 2.33331 23.9408 2.44492 24.164 2.66815C24.388 2.89215 24.5 3.16942 24.5 3.49998V4.66665H25.6667C25.9972 4.66665 26.2741 4.77826 26.4973 5.00148C26.7213 5.22548 26.8333 5.50276 26.8333 5.83331C26.8333 6.16387 26.7213 6.44115 26.4973 6.66515C26.2741 6.88837 25.9972 6.99998 25.6667 6.99998H24.5V8.16665C24.5 8.4972 24.388 8.77448 24.164 8.99848C23.9408 9.2217 23.6639 9.33331 23.3333 9.33331C23.0028 9.33331 22.7259 9.2217 22.5027 8.99848C22.2787 8.77448 22.1667 8.4972 22.1667 8.16665V6.99998Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1V; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-add-photo",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1U = "/*!@:host*/.sc-swirl-icon-admin-panel-settings-h{display:inline-flex}";

class SwirlIconAdminPanelSettings {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M11.3333 7.27165C11.56 7.27165 11.78 7.29831 12 7.33165V4.99165C12 4.45831 11.6867 3.97831 11.2 3.77165L7.53333 2.17165C7.19333 2.02498 6.80667 2.02498 6.46667 2.17165L2.8 3.77165C2.31333 3.98498 2 4.46498 2 4.99165V7.39165C2 10.4183 4.13333 13.2516 7 13.9383C7.36667 13.8516 7.72 13.725 8.06667 13.5716C7.60667 12.9183 7.33333 12.125 7.33333 11.2716C7.33333 9.06498 9.12667 7.27165 11.3333 7.27165Z", fill: "currentColor" }), hAsync("path", { d: "M11.3333 8.60498C9.86 8.60498 8.66667 9.79831 8.66667 11.2716C8.66667 12.745 9.86 13.9383 11.3333 13.9383C12.8067 13.9383 14 12.745 14 11.2716C14 9.79831 12.8067 8.60498 11.3333 8.60498ZM11.3333 9.52498C11.7467 9.52498 12.08 9.86498 12.08 10.2716C12.08 10.6783 11.74 11.0183 11.3333 11.0183C10.9267 11.0183 10.5867 10.6783 10.5867 10.2716C10.5867 9.86498 10.92 9.52498 11.3333 9.52498ZM11.3333 13.105C10.7133 13.105 10.1733 12.7983 9.84 12.325C9.87333 11.845 10.8467 11.605 11.3333 11.605C11.82 11.605 12.7933 11.845 12.8267 12.325C12.4933 12.7983 11.9533 13.105 11.3333 13.105Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M17 10.9075C17.34 10.9075 17.67 10.9475 18 10.9975V7.48753C18 6.68753 17.53 5.96753 16.8 5.65753L11.3 3.25753C10.79 3.03753 10.21 3.03753 9.7 3.25753L4.2 5.65753C3.47 5.97753 3 6.69753 3 7.48753V11.0875C3 15.6275 6.2 19.8775 10.5 20.9075C11.05 20.7775 11.58 20.5875 12.1 20.3575C11.41 19.3775 11 18.1875 11 16.9075C11 13.5975 13.69 10.9075 17 10.9075Z", fill: "currentColor" }), hAsync("path", { d: "M17 12.9075C14.79 12.9075 13 14.6975 13 16.9075C13 19.1175 14.79 20.9075 17 20.9075C19.21 20.9075 21 19.1175 21 16.9075C21 14.6975 19.21 12.9075 17 12.9075ZM17 14.2875C17.62 14.2875 18.12 14.7975 18.12 15.4075C18.12 16.0175 17.61 16.5275 17 16.5275C16.39 16.5275 15.88 16.0175 15.88 15.4075C15.88 14.7975 16.38 14.2875 17 14.2875ZM17 19.6575C16.07 19.6575 15.26 19.1975 14.76 18.4875C14.81 17.7675 16.27 17.4075 17 17.4075C17.73 17.4075 19.19 17.7675 19.24 18.4875C18.74 19.1975 17.93 19.6575 17 19.6575Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M19.8333 12.7254C20.23 12.7254 20.615 12.7721 21 12.8304V8.73541C21 7.80208 20.4517 6.96208 19.6 6.60041L13.1833 3.80041C12.5883 3.54374 11.9117 3.54374 11.3167 3.80041L4.9 6.60041C4.04833 6.97374 3.5 7.81374 3.5 8.73541V12.9354C3.5 18.2321 7.23333 23.1904 12.25 24.3921C12.8917 24.2404 13.51 24.0187 14.1167 23.7504C13.3117 22.6071 12.8333 21.2187 12.8333 19.7254C12.8333 15.8637 15.9717 12.7254 19.8333 12.7254Z", fill: "currentColor" }), hAsync("path", { d: "M19.8333 15.0587C17.255 15.0587 15.1667 17.1471 15.1667 19.7254C15.1667 22.3037 17.255 24.3921 19.8333 24.3921C22.4117 24.3921 24.5 22.3037 24.5 19.7254C24.5 17.1471 22.4117 15.0587 19.8333 15.0587ZM19.8333 16.6687C20.5567 16.6687 21.14 17.2637 21.14 17.9754C21.14 18.6871 20.545 19.2821 19.8333 19.2821C19.1217 19.2821 18.5267 18.6871 18.5267 17.9754C18.5267 17.2637 19.11 16.6687 19.8333 16.6687ZM19.8333 22.9337C18.7483 22.9337 17.8033 22.3971 17.22 21.5687C17.2783 20.7287 18.9817 20.3087 19.8333 20.3087C20.685 20.3087 22.3883 20.7287 22.4467 21.5687C21.8633 22.3971 20.9183 22.9337 19.8333 22.9337Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1U; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-admin-panel-settings",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1T = "/*!@:host*/.sc-swirl-icon-ai-h{display:inline-flex}";

class SwirlIconAi {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6.66665 9.45L7.33331 8L8.78331 7.33333L7.33331 6.66667L6.66665 5.21667L5.99998 6.66667L4.54998 7.33333L5.99998 8L6.66665 9.45ZM6.66665 12.6667L4.99998 9L1.33331 7.33333L4.99998 5.66667L6.66665 2L8.33331 5.66667L12 7.33333L8.33331 9L6.66665 12.6667ZM12 14L11.1666 12.1667L9.33331 11.3333L11.1666 10.5L12 8.66667L12.8333 10.5L14.6666 11.3333L12.8333 12.1667L12 14Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M10 14.175L11 12L13.175 11L11 10L10 7.825L9 10L6.825 11L9 12L10 14.175ZM10 19L7.5 13.5L2 11L7.5 8.5L10 3L12.5 8.5L18 11L12.5 13.5L10 19ZM18 21L16.75 18.25L14 17L16.75 15.75L18 13L19.25 15.75L22 17L19.25 18.25L18 21Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M11.6667 16.5375L12.8333 14L15.3708 12.8333L12.8333 11.6667L11.6667 9.12917L10.5 11.6667L7.96251 12.8333L10.5 14L11.6667 16.5375ZM11.6667 22.1667L8.75001 15.75L2.33334 12.8333L8.75001 9.91667L11.6667 3.5L14.5833 9.91667L21 12.8333L14.5833 15.75L11.6667 22.1667ZM21 24.5L19.5417 21.2917L16.3333 19.8333L19.5417 18.375L21 15.1667L22.4583 18.375L25.6667 19.8333L22.4583 21.2917L21 24.5Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1T; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-ai",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1S = "/*!@:host*/.sc-swirl-icon-arrow-back-h{display:inline-flex}";

class SwirlIconArrowBack {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M9.50758 13.1114L4.83311 8.45076C4.77762 8.38603 4.73601 8.31668 4.70827 8.2427C4.68053 8.16872 4.66666 8.09012 4.66666 8.00689C4.66666 7.92367 4.68053 7.84507 4.70827 7.77109C4.73601 7.69711 4.77762 7.62776 4.83311 7.56303L9.50758 2.88856C9.65553 2.7406 9.83826 2.66663 10.0558 2.66663C10.2729 2.66663 10.4554 2.74523 10.6034 2.90243C10.7606 3.05039 10.8392 3.2283 10.8392 3.43618C10.8392 3.64443 10.7606 3.82715 10.6034 3.98435L6.58083 8.00689L10.6034 12.0294C10.7513 12.1774 10.8253 12.3553 10.8253 12.5632C10.8253 12.7714 10.7467 12.9542 10.5895 13.1114C10.4415 13.2593 10.2634 13.3333 10.0552 13.3333C9.84732 13.3333 9.66478 13.2593 9.50758 13.1114V13.1114Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M14.2614 19.6671L7.24967 12.6762C7.16645 12.5791 7.10403 12.4751 7.06242 12.3641C7.02081 12.2531 7 12.1352 7 12.0104C7 11.8856 7.02081 11.7677 7.06242 11.6567C7.10403 11.5457 7.16645 11.4417 7.24967 11.3446L14.2614 4.3329C14.4833 4.11097 14.7574 4 15.0836 4C15.4093 4 15.6831 4.1179 15.9051 4.35371C16.1409 4.57564 16.2588 4.84251 16.2588 5.15433C16.2588 5.4667 16.1409 5.74079 15.9051 5.97659L9.87126 12.0104L15.9051 18.0442C16.127 18.2661 16.238 18.533 16.238 18.8448C16.238 19.1572 16.1201 19.4313 15.8843 19.6671C15.6623 19.889 15.3952 20 15.0828 20C14.771 20 14.4972 19.889 14.2614 19.6671Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M16.6383 22.9449L8.45794 14.7889C8.36085 14.6756 8.28803 14.5542 8.23948 14.4248C8.19093 14.2953 8.16666 14.1577 8.16666 14.0121C8.16666 13.8665 8.19093 13.7289 8.23948 13.5994C8.28803 13.47 8.36085 13.3486 8.45794 13.2353L16.6383 5.05501C16.8972 4.79609 17.217 4.66663 17.5976 4.66663C17.9775 4.66663 18.297 4.80418 18.5559 5.07928C18.831 5.33821 18.9686 5.64956 18.9686 6.01334C18.9686 6.37778 18.831 6.69755 18.5559 6.97265L11.5165 14.0121L18.5559 21.0515C18.8148 21.3105 18.9443 21.6218 18.9443 21.9856C18.9443 22.35 18.8067 22.6698 18.5316 22.9449C18.2727 23.2038 17.961 23.3333 17.5966 23.3333C17.2328 23.3333 16.9134 23.2038 16.6383 22.9449V22.9449Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1S; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-arrow-back",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1R = "/*!@:host*/.sc-swirl-icon-arrow-downward-h{display:inline-flex}";

class SwirlIconArrowDownward {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 13.0501C7.91111 13.0501 7.82778 13.0361 7.75 13.0081C7.67222 12.9805 7.6 12.9334 7.53333 12.8667L3.13333 8.46675C3 8.33341 2.93333 8.17497 2.93333 7.99141C2.93333 7.8083 3 7.65008 3.13333 7.51675C3.26667 7.38341 3.42222 7.31675 3.6 7.31675C3.77778 7.31675 3.93333 7.38341 4.06667 7.51675L7.33333 10.7834V3.31675C7.33333 3.12786 7.39733 2.9723 7.52533 2.85008C7.65289 2.72786 7.81111 2.66675 8 2.66675C8.18889 2.66675 8.34733 2.73053 8.47533 2.85808C8.60289 2.98608 8.66667 3.14453 8.66667 3.33341V10.7834L11.9333 7.51675C12.0667 7.38341 12.2222 7.31675 12.4 7.31675C12.5778 7.31675 12.7333 7.38341 12.8667 7.51675C13 7.65008 13.0667 7.8083 13.0667 7.99141C13.0667 8.17497 13 8.33341 12.8667 8.46675L8.46667 12.8667C8.4 12.9334 8.32778 12.9805 8.25 13.0081C8.17222 13.0361 8.08889 13.0501 8 13.0501Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 19.575C11.8667 19.575 11.7417 19.554 11.625 19.512C11.5083 19.4707 11.4 19.4 11.3 19.3L4.7 12.7C4.5 12.5 4.4 12.2623 4.4 11.987C4.4 11.7123 4.5 11.475 4.7 11.275C4.9 11.075 5.13333 10.975 5.4 10.975C5.66667 10.975 5.9 11.075 6.1 11.275L11 16.175V4.975C11 4.69167 11.096 4.45833 11.288 4.275C11.4793 4.09167 11.7167 4 12 4C12.2833 4 12.521 4.09567 12.713 4.287C12.9043 4.479 13 4.71667 13 5V16.175L17.9 11.275C18.1 11.075 18.3333 10.975 18.6 10.975C18.8667 10.975 19.1 11.075 19.3 11.275C19.5 11.475 19.6 11.7123 19.6 11.987C19.6 12.2623 19.5 12.5 19.3 12.7L12.7 19.3C12.6 19.4 12.4917 19.4707 12.375 19.512C12.2583 19.554 12.1333 19.575 12 19.575Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 22.8376C13.8444 22.8376 13.6986 22.8131 13.5625 22.7641C13.4264 22.7159 13.3 22.6334 13.1833 22.5167L5.48333 14.8167C5.25 14.5834 5.13333 14.3061 5.13333 13.9849C5.13333 13.6645 5.25 13.3876 5.48333 13.1542C5.71666 12.9209 5.98889 12.8042 6.3 12.8042C6.61111 12.8042 6.88333 12.9209 7.11666 13.1542L12.8333 18.8709V5.80425C12.8333 5.47369 12.9453 5.20147 13.1693 4.98758C13.3926 4.77369 13.6694 4.66675 14 4.66675C14.3306 4.66675 14.6078 4.77836 14.8318 5.00158C15.0551 5.22558 15.1667 5.50286 15.1667 5.83341V18.8709L20.8833 13.1542C21.1167 12.9209 21.3889 12.8042 21.7 12.8042C22.0111 12.8042 22.2833 12.9209 22.5167 13.1542C22.75 13.3876 22.8667 13.6645 22.8667 13.9849C22.8667 14.3061 22.75 14.5834 22.5167 14.8167L14.8167 22.5167C14.7 22.6334 14.5736 22.7159 14.4375 22.7641C14.3014 22.8131 14.1556 22.8376 14 22.8376Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1R; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-arrow-downward",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1Q = "/*!@:host*/.sc-swirl-icon-arrow-forward-h{display:inline-flex}";

class SwirlIconArrowForward {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6.4916 13.1114L11.1661 8.45076C11.2216 8.38603 11.2632 8.31668 11.2909 8.2427C11.3187 8.16872 11.3325 8.09012 11.3325 8.00689C11.3325 7.92367 11.3187 7.84507 11.2909 7.77109C11.2632 7.69711 11.2216 7.62776 11.1661 7.56303L6.4916 2.88856C6.34365 2.7406 6.16092 2.66663 5.94343 2.66663C5.7263 2.66663 5.54376 2.74523 5.39581 2.90243C5.2386 3.05039 5.16 3.2283 5.16 3.43618C5.16 3.64443 5.2386 3.82715 5.39581 3.98435L9.41835 8.00689L5.39581 12.0294C5.24785 12.1774 5.17387 12.3553 5.17387 12.5632C5.17387 12.7714 5.25248 12.9542 5.40968 13.1114C5.55763 13.2593 5.73574 13.3333 5.94398 13.3333C6.15186 13.3333 6.3344 13.2593 6.4916 13.1114Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9.73739 19.6671L16.7491 12.6762C16.8323 12.5791 16.8947 12.4751 16.9363 12.3641C16.978 12.2531 16.9988 12.1352 16.9988 12.0104C16.9988 11.8856 16.978 11.7677 16.9363 11.6567C16.8947 11.5457 16.8323 11.4417 16.7491 11.3446L9.73739 4.3329C9.51546 4.11097 9.24137 4 8.91513 4C8.58944 4 8.31563 4.1179 8.0937 4.35371C7.85789 4.57564 7.73999 4.84251 7.73999 5.15433C7.73999 5.4667 7.85789 5.74079 8.0937 5.97659L14.1275 12.0104L8.0937 18.0442C7.87176 18.2661 7.7608 18.533 7.7608 18.8448C7.7608 19.1572 7.8787 19.4313 8.1145 19.6671C8.33643 19.889 8.60359 20 8.91596 20C9.22778 20 9.50159 19.889 9.73739 19.6671Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M11.3603 22.9449L19.5406 14.7889C19.6377 14.6756 19.7105 14.5542 19.7591 14.4248C19.8076 14.2953 19.8319 14.1577 19.8319 14.0121C19.8319 13.8665 19.8076 13.7289 19.7591 13.5994C19.7105 13.47 19.6377 13.3486 19.5406 13.2353L11.3603 5.05501C11.1014 4.79609 10.7816 4.66663 10.401 4.66663C10.021 4.66663 9.70158 4.80418 9.44266 5.07928C9.16755 5.33821 9.03 5.64956 9.03 6.01334C9.03 6.37778 9.16755 6.69755 9.44266 6.97265L16.4821 14.0121L9.44266 21.0515C9.18373 21.3105 9.05427 21.6218 9.05427 21.9856C9.05427 22.35 9.19182 22.6698 9.46693 22.9449C9.72585 23.2038 10.0375 23.3333 10.402 23.3333C10.7657 23.3333 11.0852 23.2038 11.3603 22.9449Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1Q; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-arrow-forward",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1P = "/*!@:host*/.sc-swirl-icon-arrow-left-h{display:inline-flex}";

class SwirlIconArrowLeft {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.15 12.8666L2.81667 8.53327C2.73889 8.45549 2.68333 8.37216 2.65 8.28327C2.61667 8.19438 2.6 8.09993 2.6 7.99993C2.6 7.89993 2.61667 7.80549 2.65 7.7166C2.68333 7.62771 2.73889 7.54438 2.81667 7.4666L7.15 3.13327C7.29444 2.99993 7.46955 2.93038 7.67533 2.9246C7.88066 2.91927 8.06111 2.98882 8.21666 3.13327C8.37222 3.27771 8.45289 3.45549 8.45867 3.6666C8.464 3.87771 8.38889 4.05549 8.23333 4.19993L5.2 7.23327H12.3167C12.5278 7.23327 12.7084 7.30838 12.8587 7.4586C13.0084 7.60838 13.0833 7.78882 13.0833 7.99993C13.0833 8.21105 13.0084 8.39149 12.8587 8.54127C12.7084 8.69149 12.5278 8.7666 12.3167 8.7666H5.2L8.23333 11.7999C8.37778 11.9333 8.45289 12.1084 8.45867 12.3253C8.464 12.5417 8.38889 12.7222 8.23333 12.8666C8.08889 13.011 7.91111 13.0833 7.7 13.0833C7.48889 13.0833 7.30555 13.011 7.15 12.8666V12.8666Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M10.725 19.2999L4.225 12.7999C4.10833 12.6832 4.025 12.5582 3.975 12.4249C3.925 12.2916 3.9 12.1499 3.9 11.9999C3.9 11.8499 3.925 11.7082 3.975 11.5749C4.025 11.4416 4.10833 11.3166 4.225 11.1999L10.725 4.6999C10.9417 4.4999 11.2043 4.39557 11.513 4.3869C11.821 4.3789 12.0917 4.48323 12.325 4.6999C12.5583 4.91657 12.6793 5.18324 12.688 5.4999C12.696 5.81657 12.5833 6.08324 12.35 6.2999L7.8 10.8499H18.475C18.7917 10.8499 19.0627 10.9626 19.288 11.1879C19.5127 11.4126 19.625 11.6832 19.625 11.9999C19.625 12.3166 19.5127 12.5872 19.288 12.8119C19.0627 13.0372 18.7917 13.1499 18.475 13.1499H7.8L12.35 17.6999C12.5667 17.8999 12.6793 18.1626 12.688 18.4879C12.696 18.8126 12.5833 19.0832 12.35 19.2999C12.1333 19.5166 11.8667 19.6249 11.55 19.6249C11.2333 19.6249 10.9583 19.5166 10.725 19.2999V19.2999Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M12.5125 22.5167L4.92917 14.9333C4.79306 14.7972 4.69584 14.6514 4.6375 14.4958C4.57917 14.3403 4.55 14.175 4.55 14C4.55 13.825 4.57917 13.6597 4.6375 13.5042C4.69584 13.3486 4.79306 13.2028 4.92917 13.0667L12.5125 5.48334C12.7653 5.25001 13.0717 5.12829 13.4318 5.11817C13.7912 5.10884 14.1069 5.23056 14.3792 5.48334C14.6514 5.73612 14.7926 6.04723 14.8027 6.41667C14.812 6.78612 14.6806 7.09723 14.4083 7.35001L9.1 12.6583H21.5542C21.9236 12.6583 22.2398 12.7898 22.5027 13.0527C22.7648 13.3148 22.8958 13.6306 22.8958 14C22.8958 14.3695 22.7648 14.6852 22.5027 14.9473C22.2398 15.2102 21.9236 15.3417 21.5542 15.3417H9.1L14.4083 20.65C14.6611 20.8833 14.7926 21.1898 14.8027 21.5693C14.812 21.9481 14.6806 22.2639 14.4083 22.5167C14.1556 22.7695 13.8444 22.8958 13.475 22.8958C13.1056 22.8958 12.7847 22.7695 12.5125 22.5167V22.5167Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1P; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-arrow-left",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1O = "/*!@:host*/.sc-swirl-icon-arrow-right-h{display:inline-flex}";

class SwirlIconArrowRight {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.46667 12.8667C7.32222 12.7222 7.24733 12.5445 7.242 12.3333C7.23622 12.1222 7.30555 11.9445 7.45 11.8L10.4833 8.76668H3.36667C3.15555 8.76668 2.97511 8.69157 2.82533 8.54135C2.67511 8.39157 2.6 8.21113 2.6 8.00002C2.6 7.7889 2.67511 7.60846 2.82533 7.45868C2.97511 7.30846 3.15555 7.23335 3.36667 7.23335H10.4833L7.45 4.20002C7.30555 4.05557 7.23622 3.87779 7.242 3.66668C7.24733 3.45557 7.32222 3.27779 7.46667 3.13335C7.61111 3.00002 7.78889 2.93335 8 2.93335C8.21111 2.93335 8.38889 3.00002 8.53333 3.13335L12.8667 7.46668C12.9444 7.53335 13 7.61379 13.0333 7.70802C13.0667 7.80268 13.0833 7.90002 13.0833 8.00002C13.0833 8.10002 13.0667 8.19446 13.0333 8.28335C13 8.37224 12.9444 8.45557 12.8667 8.53335L8.53333 12.8667C8.38889 13.0111 8.21111 13.0807 8 13.0753C7.78889 13.0696 7.61111 13 7.46667 12.8667V12.8667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M11.2 19.2999C10.9833 19.0832 10.871 18.8166 10.863 18.4999C10.8543 18.1832 10.9583 17.9166 11.175 17.6999L15.725 13.1499H5.05C4.73333 13.1499 4.46267 13.0372 4.238 12.8119C4.01267 12.5872 3.9 12.3166 3.9 11.9999C3.9 11.6832 4.01267 11.4126 4.238 11.1879C4.46267 10.9626 4.73333 10.8499 5.05 10.8499H15.725L11.175 6.2999C10.9583 6.08324 10.8543 5.81657 10.863 5.4999C10.871 5.18324 10.9833 4.91657 11.2 4.6999C11.4167 4.4999 11.6833 4.3999 12 4.3999C12.3167 4.3999 12.5833 4.4999 12.8 4.6999L19.3 11.1999C19.4167 11.2999 19.5 11.4206 19.55 11.5619C19.6 11.7039 19.625 11.8499 19.625 11.9999C19.625 12.1499 19.6 12.2916 19.55 12.4249C19.5 12.5582 19.4167 12.6832 19.3 12.7999L12.8 19.2999C12.5833 19.5166 12.3167 19.6209 12 19.6129C11.6833 19.6042 11.4167 19.4999 11.2 19.2999V19.2999Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M13.0667 22.5166C12.8139 22.2639 12.6828 21.9527 12.6735 21.5833C12.6634 21.2139 12.7847 20.9027 13.0375 20.65L18.3458 15.3416H5.89167C5.52223 15.3416 5.20645 15.2102 4.94434 14.9473C4.68145 14.6852 4.55 14.3694 4.55 14C4.55 13.6305 4.68145 13.3147 4.94434 13.0526C5.20645 12.7897 5.52223 12.6583 5.89167 12.6583H18.3458L13.0375 7.34997C12.7847 7.09719 12.6634 6.78608 12.6735 6.41663C12.6828 6.04719 12.8139 5.73608 13.0667 5.4833C13.3194 5.24997 13.6306 5.1333 14 5.1333C14.3694 5.1333 14.6806 5.24997 14.9333 5.4833L22.5167 13.0666C22.6528 13.1833 22.75 13.3241 22.8083 13.489C22.8667 13.6546 22.8958 13.825 22.8958 14C22.8958 14.175 22.8667 14.3402 22.8083 14.4958C22.75 14.6514 22.6528 14.7972 22.5167 14.9333L14.9333 22.5166C14.6806 22.7694 14.3694 22.8911 14 22.8818C13.6306 22.8717 13.3194 22.75 13.0667 22.5166V22.5166Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1O; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-arrow-right",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1N = "/*!@:host*/.sc-swirl-icon-arrow-right-small-h{display:inline-flex}";

class SwirlIconArrowRightSmall {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.60918 10.1958L9.33584 8.46918C9.59584 8.20918 9.59584 7.78918 9.33584 7.52918L7.60918 5.80251C7.18918 5.38251 6.46918 5.68251 6.46918 6.27584L6.46918 9.72918C6.46918 10.3225 7.18918 10.6158 7.60918 10.1958Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M11.4137 15.2938L14.0037 12.7038C14.3937 12.3138 14.3937 11.6838 14.0037 11.2938L11.4137 8.70379C10.7837 8.07379 9.70374 8.52379 9.70374 9.41379L9.70374 14.5938C9.70374 15.4838 10.7837 15.9238 11.4137 15.2938Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M13.316 17.8427L16.3377 14.821C16.7927 14.366 16.7927 13.631 16.3377 13.176L13.316 10.1544C12.581 9.41938 11.321 9.94438 11.321 10.9827L11.321 17.026C11.321 18.0644 12.581 18.5777 13.316 17.8427Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1N; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-arrow-right-small",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1M = "/*!@:host*/.sc-swirl-icon-arrow-upward-h{display:inline-flex}";

class SwirlIconArrowUpward {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 13.3333C7.81111 13.3333 7.65289 13.2693 7.52533 13.1413C7.39733 13.0137 7.33333 12.8555 7.33333 12.6666V5.21662L4.08333 8.46662C3.95 8.59995 3.79156 8.66662 3.608 8.66662C3.42489 8.66662 3.26667 8.59995 3.13333 8.46662C3 8.33328 2.93333 8.17773 2.93333 7.99995C2.93333 7.82217 3 7.66662 3.13333 7.53328L7.53333 3.13328C7.6 3.06662 7.67222 3.01928 7.75 2.99128C7.82778 2.96373 7.91111 2.94995 8 2.94995C8.08889 2.94995 8.17511 2.96373 8.25867 2.99128C8.34178 3.01928 8.41111 3.06662 8.46667 3.13328L12.8667 7.53328C13 7.66662 13.0667 7.82217 13.0667 7.99995C13.0667 8.17773 13 8.33328 12.8667 8.46662C12.7333 8.59995 12.5749 8.66662 12.3913 8.66662C12.2082 8.66662 12.05 8.59995 11.9167 8.46662L8.66667 5.21662V12.6666C8.66667 12.8555 8.60289 13.0137 8.47533 13.1413C8.34733 13.2693 8.18889 13.3333 8 13.3333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 20C11.7167 20 11.4793 19.904 11.288 19.712C11.096 19.5207 11 19.2834 11 19V7.82505L6.125 12.7C5.925 12.9 5.68733 13 5.412 13C5.13733 13 4.9 12.9 4.7 12.7C4.5 12.5 4.4 12.2667 4.4 12C4.4 11.7334 4.5 11.5 4.7 11.3L11.3 4.70005C11.4 4.60005 11.5083 4.52905 11.625 4.48705C11.7417 4.44572 11.8667 4.42505 12 4.42505C12.1333 4.42505 12.2627 4.44572 12.388 4.48705C12.5127 4.52905 12.6167 4.60005 12.7 4.70005L19.3 11.3C19.5 11.5 19.6 11.7334 19.6 12C19.6 12.2667 19.5 12.5 19.3 12.7C19.1 12.9 18.8623 13 18.587 13C18.3123 13 18.075 12.9 17.875 12.7L13 7.82505V19C13 19.2834 12.9043 19.5207 12.713 19.712C12.521 19.904 12.2833 20 12 20Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 23.3334C13.6694 23.3334 13.3926 23.2214 13.1693 22.9974C12.9453 22.7742 12.8333 22.4973 12.8333 22.1668V9.12926L7.14583 14.8168C6.9125 15.0501 6.63522 15.1668 6.314 15.1668C5.99355 15.1668 5.71666 15.0501 5.48333 14.8168C5.25 14.5834 5.13333 14.3112 5.13333 14.0001C5.13333 13.689 5.25 13.4168 5.48333 13.1834L13.1833 5.48343C13.3 5.36676 13.4264 5.28393 13.5625 5.23493C13.6986 5.18671 13.8444 5.1626 14 5.1626C14.1556 5.1626 14.3064 5.18671 14.4527 5.23493C14.5981 5.28393 14.7194 5.36676 14.8167 5.48343L22.5167 13.1834C22.75 13.4168 22.8667 13.689 22.8667 14.0001C22.8667 14.3112 22.75 14.5834 22.5167 14.8168C22.2833 15.0501 22.0061 15.1668 21.6848 15.1668C21.3644 15.1668 21.0875 15.0501 20.8542 14.8168L15.1667 9.12926V22.1668C15.1667 22.4973 15.0551 22.7742 14.8318 22.9974C14.6078 23.2214 14.3306 23.3334 14 23.3334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1M; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-arrow-upward",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1L = "/*!@:host*/.sc-swirl-icon-attachment-h{display:inline-flex}";

class SwirlIconAttachment {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.57157 12.8796C7.81732 13.6338 6.91584 14.0089 5.86712 14.0048C4.81809 14.0011 3.92038 13.626 3.17399 12.8796C2.41974 12.1253 2.04073 11.2237 2.03696 10.1747C2.03287 9.12594 2.40795 8.22446 3.1622 7.47021L8.15909 2.47333C8.7012 1.93121 9.35913 1.66204 10.1329 1.66581C10.9069 1.6699 11.565 1.943 12.1071 2.48511C12.6492 3.02723 12.9203 3.68327 12.9203 4.45323C12.9203 5.22319 12.6492 5.87922 12.1071 6.42134L7.60519 10.9233C7.25949 11.2689 6.84513 11.4438 6.3621 11.4479C5.87875 11.4517 5.46423 11.2807 5.11853 10.935C4.76498 10.5815 4.59024 10.1632 4.59433 9.68016C4.5981 9.19681 4.77283 8.78229 5.11853 8.43659L9.21975 4.33537C9.32974 4.22538 9.46127 4.16834 9.61432 4.16425C9.76768 4.16048 9.90329 4.21752 10.0211 4.33537C10.1311 4.44537 10.1842 4.57705 10.1805 4.73041C10.1764 4.88346 10.1193 5.01498 10.0094 5.12498L5.90813 9.2262C5.78243 9.3519 5.71957 9.50118 5.71957 9.67403C5.71957 9.84688 5.78635 10.0001 5.91992 10.1337C6.04563 10.2594 6.1949 10.3222 6.36775 10.3222C6.5406 10.3222 6.68988 10.2594 6.81559 10.1337L11.3175 5.63174C11.6475 5.30175 11.8125 4.90892 11.8125 4.45323C11.8125 3.99753 11.6475 3.6047 11.3175 3.27471C10.9875 2.94473 10.5947 2.77974 10.139 2.77974C9.6833 2.77974 9.29046 2.94473 8.96048 3.27471L3.96359 8.2716C3.43719 8.798 3.17399 9.43424 3.17399 10.1803C3.17399 10.927 3.43719 11.5636 3.96359 12.09C4.48999 12.6164 5.1245 12.8775 5.86712 12.8735C6.60943 12.8697 7.24378 12.6046 7.77018 12.0782L12.3664 7.482C12.4764 7.372 12.6099 7.31701 12.7671 7.31701C12.9242 7.31701 13.0578 7.372 13.1678 7.482C13.2856 7.59985 13.3425 7.7353 13.3384 7.88835C13.3346 8.04171 13.2778 8.17339 13.1678 8.28339L8.57157 12.8796Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12.8574 19.3194C11.726 20.4507 10.3738 21.0134 8.80068 21.0072C7.22713 21.0016 5.88057 20.439 4.76098 19.3194C3.62961 18.188 3.0611 16.8355 3.05544 15.262C3.04931 13.6889 3.61193 12.3367 4.7433 11.2053L12.2386 3.70999C13.0518 2.89682 14.0387 2.49306 15.1993 2.49872C16.3604 2.50484 17.3475 2.91449 18.1607 3.72767C18.9738 4.54084 19.3804 5.5249 19.3804 6.67984C19.3804 7.83478 18.9738 8.81884 18.1607 9.63201L11.4078 16.3849C10.8892 16.9034 10.2677 17.1658 9.54314 17.1719C8.81812 17.1775 8.19634 16.9211 7.6778 16.4026C7.14747 15.8722 6.88536 15.2448 6.89149 14.5202C6.89715 13.7952 7.15925 13.1734 7.6778 12.6549L13.8296 6.50306C13.9946 6.33807 14.1919 6.25251 14.4215 6.24638C14.6515 6.24072 14.8549 6.32628 15.0317 6.50306C15.1967 6.66805 15.2764 6.86557 15.2707 7.09562C15.2646 7.32519 15.179 7.52247 15.014 7.68747L8.8622 13.8393C8.67364 14.0279 8.57936 14.2518 8.57936 14.511C8.57936 14.7703 8.67953 15.0001 8.87988 15.2005C9.06844 15.389 9.29236 15.4833 9.55163 15.4833C9.8109 15.4833 10.0348 15.389 10.2234 15.2005L16.9762 8.4476C17.4712 7.95263 17.7187 7.36337 17.7187 6.67984C17.7187 5.9963 17.4712 5.40704 16.9762 4.91207C16.4813 4.4171 15.892 4.16961 15.2085 4.16961C14.5249 4.16961 13.9357 4.4171 13.4407 4.91207L5.94538 12.4074C5.15578 13.197 4.76098 14.1514 4.76098 15.2705C4.76098 16.3905 5.15578 17.3454 5.94538 18.135C6.73499 18.9246 7.68675 19.3163 8.80068 19.3102C9.91414 19.3045 10.8657 18.9069 11.6553 18.1173L18.5496 11.223C18.7146 11.058 18.9149 10.9755 19.1506 10.9755C19.3863 10.9755 19.5867 11.058 19.7516 11.223C19.9284 11.3998 20.0137 11.603 20.0076 11.8325C20.002 12.0626 19.9166 12.2601 19.7516 12.4251L12.8574 19.3194Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M15.0003 22.5393C13.6803 23.8593 12.1027 24.5157 10.2675 24.5085C8.43167 24.5019 6.86068 23.8455 5.55449 22.5393C4.23456 21.2194 3.57129 19.6415 3.56469 17.8057C3.55754 15.9705 4.21394 14.3929 5.53387 13.0729L14.2784 4.32838C15.2271 3.37968 16.3785 2.90863 17.7325 2.91523C19.0871 2.92238 20.2387 3.4003 21.1874 4.34901C22.1361 5.29771 22.6105 6.44578 22.6105 7.79321C22.6105 9.14064 22.1361 10.2887 21.1874 11.2374L13.3091 19.1158C12.7041 19.7207 11.979 20.0268 11.1337 20.0339C10.2878 20.0405 9.56241 19.7413 8.95744 19.1364C8.33873 18.5177 8.03294 17.7856 8.04009 16.9403C8.04669 16.0945 8.35247 15.3691 8.95744 14.7641L16.1346 7.58697C16.3271 7.39448 16.5572 7.29466 16.8251 7.28751C17.0935 7.28091 17.3308 7.38073 17.537 7.58697C17.7295 7.77946 17.8224 8.00989 17.8158 8.27828C17.8087 8.54612 17.7089 8.77628 17.5164 8.96877L10.3392 16.1459C10.1193 16.3659 10.0093 16.6271 10.0093 16.9296C10.0093 17.2321 10.1261 17.5002 10.3599 17.7339C10.5799 17.9539 10.8411 18.0639 11.1436 18.0639C11.4461 18.0639 11.7073 17.9539 11.9273 17.7339L19.8056 9.8556C20.3831 9.27813 20.6718 8.59066 20.6718 7.79321C20.6718 6.99575 20.3831 6.30828 19.8056 5.73081C19.2282 5.15334 18.5407 4.8646 17.7432 4.8646C16.9458 4.8646 16.2583 5.15334 15.6808 5.73081L6.9363 14.4754C6.01509 15.3966 5.55449 16.51 5.55449 17.8156C5.55449 19.1224 6.01509 20.2363 6.9363 21.1575C7.8575 22.0787 8.96789 22.5358 10.2675 22.5286C11.5665 22.522 12.6766 22.0581 13.5978 21.1369L21.6412 13.0936C21.8337 12.9011 22.0674 12.8048 22.3424 12.8048C22.6174 12.8048 22.8511 12.9011 23.0436 13.0936C23.2498 13.2998 23.3494 13.5368 23.3422 13.8047C23.3356 14.0731 23.2361 14.3035 23.0436 14.496L15.0003 22.5393Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1L; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-attachment",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1K = "/*!@:host*/.sc-swirl-icon-bar-chart-h{display:inline-flex}";

class SwirlIconBarChart {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M2.00004 14C1.81115 14 1.65282 13.9361 1.52504 13.8083C1.39726 13.6806 1.33337 13.5222 1.33337 13.3333C1.33337 13.1444 1.39726 12.9861 1.52504 12.8583C1.65282 12.7306 1.81115 12.6667 2.00004 12.6667H14C14.1889 12.6667 14.3473 12.7306 14.475 12.8583C14.6028 12.9861 14.6667 13.1444 14.6667 13.3333C14.6667 13.5222 14.6028 13.6806 14.475 13.8083C14.3473 13.9361 14.1889 14 14 14H2.00004ZM3.00004 12C2.72226 12 2.48615 11.9028 2.29171 11.7083C2.09726 11.5139 2.00004 11.2778 2.00004 11V8.33333C2.00004 8.05556 2.09726 7.81944 2.29171 7.625C2.48615 7.43056 2.72226 7.33333 3.00004 7.33333C3.27782 7.33333 3.51393 7.43056 3.70837 7.625C3.90282 7.81944 4.00004 8.05556 4.00004 8.33333V11C4.00004 11.2778 3.90282 11.5139 3.70837 11.7083C3.51393 11.9028 3.27782 12 3.00004 12ZM6.33337 12C6.0556 12 5.81948 11.9028 5.62504 11.7083C5.4306 11.5139 5.33337 11.2778 5.33337 11V5C5.33337 4.72222 5.4306 4.48611 5.62504 4.29167C5.81948 4.09722 6.0556 4 6.33337 4C6.61115 4 6.84726 4.09722 7.04171 4.29167C7.23615 4.48611 7.33337 4.72222 7.33337 5V11C7.33337 11.2778 7.23615 11.5139 7.04171 11.7083C6.84726 11.9028 6.61115 12 6.33337 12ZM9.66671 12C9.38893 12 9.15282 11.9028 8.95837 11.7083C8.76393 11.5139 8.66671 11.2778 8.66671 11V7C8.66671 6.72222 8.76393 6.48611 8.95837 6.29167C9.15282 6.09722 9.38893 6 9.66671 6C9.94448 6 10.1806 6.09722 10.375 6.29167C10.5695 6.48611 10.6667 6.72222 10.6667 7V11C10.6667 11.2778 10.5695 11.5139 10.375 11.7083C10.1806 11.9028 9.94448 12 9.66671 12ZM13 12C12.7223 12 12.4862 11.9028 12.2917 11.7083C12.0973 11.5139 12 11.2778 12 11V3C12 2.72222 12.0973 2.48611 12.2917 2.29167C12.4862 2.09722 12.7223 2 13 2C13.2778 2 13.5139 2.09722 13.7084 2.29167C13.9028 2.48611 14 2.72222 14 3V11C14 11.2778 13.9028 11.5139 13.7084 11.7083C13.5139 11.9028 13.2778 12 13 12Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M3 21C2.71667 21 2.47917 20.9042 2.2875 20.7125C2.09583 20.5208 2 20.2833 2 20C2 19.7167 2.09583 19.4792 2.2875 19.2875C2.47917 19.0958 2.71667 19 3 19H21C21.2833 19 21.5208 19.0958 21.7125 19.2875C21.9042 19.4792 22 19.7167 22 20C22 20.2833 21.9042 20.5208 21.7125 20.7125C21.5208 20.9042 21.2833 21 21 21H3ZM4.5 18C4.08333 18 3.72917 17.8542 3.4375 17.5625C3.14583 17.2708 3 16.9167 3 16.5V12.5C3 12.0833 3.14583 11.7292 3.4375 11.4375C3.72917 11.1458 4.08333 11 4.5 11C4.91667 11 5.27083 11.1458 5.5625 11.4375C5.85417 11.7292 6 12.0833 6 12.5V16.5C6 16.9167 5.85417 17.2708 5.5625 17.5625C5.27083 17.8542 4.91667 18 4.5 18ZM9.5 18C9.08333 18 8.72917 17.8542 8.4375 17.5625C8.14583 17.2708 8 16.9167 8 16.5V7.5C8 7.08333 8.14583 6.72917 8.4375 6.4375C8.72917 6.14583 9.08333 6 9.5 6C9.91667 6 10.2708 6.14583 10.5625 6.4375C10.8542 6.72917 11 7.08333 11 7.5V16.5C11 16.9167 10.8542 17.2708 10.5625 17.5625C10.2708 17.8542 9.91667 18 9.5 18ZM14.5 18C14.0833 18 13.7292 17.8542 13.4375 17.5625C13.1458 17.2708 13 16.9167 13 16.5V10.5C13 10.0833 13.1458 9.72917 13.4375 9.4375C13.7292 9.14583 14.0833 9 14.5 9C14.9167 9 15.2708 9.14583 15.5625 9.4375C15.8542 9.72917 16 10.0833 16 10.5V16.5C16 16.9167 15.8542 17.2708 15.5625 17.5625C15.2708 17.8542 14.9167 18 14.5 18ZM19.5 18C19.0833 18 18.7292 17.8542 18.4375 17.5625C18.1458 17.2708 18 16.9167 18 16.5V4.5C18 4.08333 18.1458 3.72917 18.4375 3.4375C18.7292 3.14583 19.0833 3 19.5 3C19.9167 3 20.2708 3.14583 20.5625 3.4375C20.8542 3.72917 21 4.08333 21 4.5V16.5C21 16.9167 20.8542 17.2708 20.5625 17.5625C20.2708 17.8542 19.9167 18 19.5 18Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M3.50004 24.5C3.16949 24.5 2.8924 24.3882 2.66879 24.1646C2.44518 23.941 2.33337 23.6639 2.33337 23.3333C2.33337 23.0028 2.44518 22.7257 2.66879 22.5021C2.8924 22.2785 3.16949 22.1667 3.50004 22.1667H24.5C24.8306 22.1667 25.1077 22.2785 25.3313 22.5021C25.5549 22.7257 25.6667 23.0028 25.6667 23.3333C25.6667 23.6639 25.5549 23.941 25.3313 24.1646C25.1077 24.3882 24.8306 24.5 24.5 24.5H3.50004ZM5.25004 21C4.76393 21 4.35074 20.8299 4.01046 20.4896C3.67018 20.1493 3.50004 19.7361 3.50004 19.25V14.5833C3.50004 14.0972 3.67018 13.684 4.01046 13.3437C4.35074 13.0035 4.76393 12.8333 5.25004 12.8333C5.73615 12.8333 6.14935 13.0035 6.48962 13.3437C6.8299 13.684 7.00004 14.0972 7.00004 14.5833V19.25C7.00004 19.7361 6.8299 20.1493 6.48962 20.4896C6.14935 20.8299 5.73615 21 5.25004 21ZM11.0834 21C10.5973 21 10.1841 20.8299 9.84379 20.4896C9.50351 20.1493 9.33337 19.7361 9.33337 19.25V8.75C9.33337 8.26389 9.50351 7.85069 9.84379 7.51042C10.1841 7.17014 10.5973 7 11.0834 7C11.5695 7 11.9827 7.17014 12.323 7.51042C12.6632 7.85069 12.8334 8.26389 12.8334 8.75V19.25C12.8334 19.7361 12.6632 20.1493 12.323 20.4896C11.9827 20.8299 11.5695 21 11.0834 21ZM16.9167 21C16.4306 21 16.0174 20.8299 15.6771 20.4896C15.3368 20.1493 15.1667 19.7361 15.1667 19.25V12.25C15.1667 11.7639 15.3368 11.3507 15.6771 11.0104C16.0174 10.6701 16.4306 10.5 16.9167 10.5C17.4028 10.5 17.816 10.6701 18.1563 11.0104C18.4966 11.3507 18.6667 11.7639 18.6667 12.25V19.25C18.6667 19.7361 18.4966 20.1493 18.1563 20.4896C17.816 20.8299 17.4028 21 16.9167 21ZM22.75 21C22.2639 21 21.8507 20.8299 21.5105 20.4896C21.1702 20.1493 21 19.7361 21 19.25V5.25C21 4.76389 21.1702 4.35069 21.5105 4.01042C21.8507 3.67014 22.2639 3.5 22.75 3.5C23.2362 3.5 23.6493 3.67014 23.9896 4.01042C24.3299 4.35069 24.5 4.76389 24.5 5.25V19.25C24.5 19.7361 24.3299 20.1493 23.9896 20.4896C23.6493 20.8299 23.2362 21 22.75 21Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1K; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-bar-chart",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1J = "/*!@:host*/.sc-swirl-icon-block-h{display:inline-flex}";

class SwirlIconBlock {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 14.6666C7.07778 14.6666 6.21111 14.4915 5.4 14.1413C4.58889 13.7915 3.88334 13.3166 3.28334 12.7166C2.68334 12.1166 2.20845 11.411 1.85867 10.5999C1.50845 9.78881 1.33334 8.92214 1.33334 7.99992C1.33334 7.0777 1.50845 6.21103 1.85867 5.39992C2.20845 4.58881 2.68334 3.88325 3.28334 3.28325C3.88334 2.68325 4.58889 2.20814 5.4 1.85792C6.21111 1.50814 7.07778 1.33325 8 1.33325C8.92222 1.33325 9.78889 1.50814 10.6 1.85792C11.4111 2.20814 12.1167 2.68325 12.7167 3.28325C13.3167 3.88325 13.7916 4.58881 14.1413 5.39992C14.4916 6.21103 14.6667 7.0777 14.6667 7.99992C14.6667 8.92214 14.4916 9.78881 14.1413 10.5999C13.7916 11.411 13.3167 12.1166 12.7167 12.7166C12.1167 13.3166 11.4111 13.7915 10.6 14.1413C9.78889 14.4915 8.92222 14.6666 8 14.6666ZM8 13.3333C9.48889 13.3333 10.75 12.8166 11.7833 11.7833C12.8167 10.7499 13.3333 9.48881 13.3333 7.99992C13.3333 7.39992 13.236 6.82214 13.0413 6.26658C12.8471 5.71103 12.5667 5.19992 12.2 4.73325L4.73334 12.1999C5.2 12.5666 5.71111 12.847 6.26667 13.0413C6.82222 13.2359 7.4 13.3333 8 13.3333ZM3.8 11.2666L11.2667 3.79992C10.8 3.43325 10.2889 3.15281 9.73334 2.95859C9.17778 2.76392 8.6 2.66659 8 2.66659C6.51111 2.66659 5.25 3.18325 4.21667 4.21658C3.18334 5.24992 2.66667 6.51103 2.66667 7.99992C2.66667 8.59992 2.764 9.1777 2.95867 9.73325C3.15289 10.2888 3.43334 10.7999 3.8 11.2666Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 22C10.6167 22 9.31667 21.7373 8.1 21.212C6.88333 20.6873 5.825 19.975 4.925 19.075C4.025 18.175 3.31267 17.1167 2.788 15.9C2.26267 14.6833 2 13.3833 2 12C2 10.6167 2.26267 9.31667 2.788 8.1C3.31267 6.88333 4.025 5.825 4.925 4.925C5.825 4.025 6.88333 3.31233 8.1 2.787C9.31667 2.26233 10.6167 2 12 2C13.3833 2 14.6833 2.26233 15.9 2.787C17.1167 3.31233 18.175 4.025 19.075 4.925C19.975 5.825 20.6873 6.88333 21.212 8.1C21.7373 9.31667 22 10.6167 22 12C22 13.3833 21.7373 14.6833 21.212 15.9C20.6873 17.1167 19.975 18.175 19.075 19.075C18.175 19.975 17.1167 20.6873 15.9 21.212C14.6833 21.7373 13.3833 22 12 22ZM12 20C14.2333 20 16.125 19.225 17.675 17.675C19.225 16.125 20 14.2333 20 12C20 11.1 19.854 10.2333 19.562 9.4C19.2707 8.56667 18.85 7.8 18.3 7.1L7.1 18.3C7.8 18.85 8.56667 19.2707 9.4 19.562C10.2333 19.854 11.1 20 12 20ZM5.7 16.9L16.9 5.7C16.2 5.15 15.4333 4.72933 14.6 4.438C13.7667 4.146 12.9 4 12 4C9.76667 4 7.875 4.775 6.325 6.325C4.775 7.875 4 9.76667 4 12C4 12.9 4.146 13.7667 4.438 14.6C4.72933 15.4333 5.15 16.2 5.7 16.9Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 25.6666C12.3861 25.6666 10.8694 25.3601 9.45 24.7473C8.03056 24.1351 6.79584 23.3041 5.74584 22.2541C4.69584 21.2041 3.86478 19.9694 3.25267 18.5499C2.63978 17.1305 2.33334 15.6138 2.33334 13.9999C2.33334 12.386 2.63978 10.8694 3.25267 9.44992C3.86478 8.03048 4.69584 6.79575 5.74584 5.74575C6.79584 4.69575 8.03056 3.86431 9.45 3.25142C10.8694 2.63931 12.3861 2.33325 14 2.33325C15.6139 2.33325 17.1306 2.63931 18.55 3.25142C19.9694 3.86431 21.2042 4.69575 22.2542 5.74575C23.3042 6.79575 24.1352 8.03048 24.7473 9.44992C25.3602 10.8694 25.6667 12.386 25.6667 13.9999C25.6667 15.6138 25.3602 17.1305 24.7473 18.5499C24.1352 19.9694 23.3042 21.2041 22.2542 22.2541C21.2042 23.3041 19.9694 24.1351 18.55 24.7473C17.1306 25.3601 15.6139 25.6666 14 25.6666ZM14 23.3333C16.6056 23.3333 18.8125 22.4291 20.6208 20.6208C22.4292 18.8124 23.3333 16.6055 23.3333 13.9999C23.3333 12.9499 23.163 11.9388 22.8223 10.9666C22.4824 9.99436 21.9917 9.09992 21.35 8.28325L8.28334 21.3499C9.1 21.9916 9.99445 22.4824 10.9667 22.8223C11.9389 23.1629 12.95 23.3333 14 23.3333ZM6.65 19.7166L19.7167 6.64992C18.9 6.00825 18.0056 5.51747 17.0333 5.17759C16.0611 4.83692 15.05 4.66659 14 4.66659C11.3944 4.66659 9.1875 5.57075 7.37917 7.37909C5.57084 9.18742 4.66667 11.3944 4.66667 13.9999C4.66667 15.0499 4.837 16.061 5.17767 17.0333C5.51756 18.0055 6.00834 18.8999 6.65 19.7166Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1J; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-block",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1I = "/*!@:host*/.sc-swirl-icon-bookmark-h{display:inline-flex}";

class SwirlIconBookmark {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66666 11.9667L7.99999 10.5333L11.3333 11.9667V3.33333H4.66666V11.9667ZM4.26666 13.6C4.04444 13.6889 3.83333 13.6693 3.63333 13.5413C3.43333 13.4138 3.33333 13.2278 3.33333 12.9833V3.33333C3.33333 2.96667 3.46399 2.65267 3.72533 2.39133C3.98622 2.13044 4.29999 2 4.66666 2H11.3333C11.7 2 12.014 2.13044 12.2753 2.39133C12.5362 2.65267 12.6667 2.96667 12.6667 3.33333V12.9833C12.6667 13.2278 12.5667 13.4138 12.3667 13.5413C12.1667 13.6693 11.9556 13.6889 11.7333 13.6L7.99999 12L4.26666 13.6Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M7 17.95L12 15.8L17 17.95V5H7V17.95ZM6.4 20.4C6.06667 20.5333 5.75 20.504 5.45 20.312C5.15 20.1207 5 19.8417 5 19.475V5C5 4.45 5.196 3.979 5.588 3.587C5.97933 3.19567 6.45 3 7 3H17C17.55 3 18.021 3.19567 18.413 3.587C18.8043 3.979 19 4.45 19 5V19.475C19 19.8417 18.85 20.1207 18.55 20.312C18.25 20.504 17.9333 20.5333 17.6 20.4L12 18L6.4 20.4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M8.16666 20.9417L14 18.4333L19.8333 20.9417V5.83333H8.16666V20.9417ZM7.46666 23.8C7.07777 23.9556 6.70833 23.9213 6.35833 23.6973C6.00833 23.4741 5.83333 23.1486 5.83333 22.7208V5.83333C5.83333 5.19167 6.06199 4.64217 6.51933 4.18483C6.97588 3.72828 7.525 3.5 8.16666 3.5H19.8333C20.475 3.5 21.0245 3.72828 21.4818 4.18483C21.9384 4.64217 22.1667 5.19167 22.1667 5.83333V22.7208C22.1667 23.1486 21.9917 23.4741 21.6417 23.6973C21.2917 23.9213 20.9222 23.9556 20.5333 23.8L14 21L7.46666 23.8Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1I; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-bookmark",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1H = "/*!@:host*/.sc-swirl-icon-cancel-h{display:inline-flex}";

class SwirlIconCancel {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 1.33337C4.31334 1.33337 1.33334 4.31337 1.33334 8.00004C1.33334 11.6867 4.31334 14.6667 8 14.6667C11.6867 14.6667 14.6667 11.6867 14.6667 8.00004C14.6667 4.31337 11.6867 1.33337 8 1.33337ZM10.8667 10.8667C10.6067 11.1267 10.1867 11.1267 9.92667 10.8667L8 8.94004L6.07334 10.8667C5.81334 11.1267 5.39334 11.1267 5.13334 10.8667C4.87334 10.6067 4.87334 10.1867 5.13334 9.92671L7.06 8.00004L5.13334 6.07337C4.87334 5.81337 4.87334 5.39337 5.13334 5.13337C5.39334 4.87337 5.81334 4.87337 6.07334 5.13337L8 7.06004L9.92667 5.13337C10.1867 4.87337 10.6067 4.87337 10.8667 5.13337C11.1267 5.39337 11.1267 5.81337 10.8667 6.07337L8.94 8.00004L10.8667 9.92671C11.12 10.18 11.12 10.6067 10.8667 10.8667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 2C6.47 2 2 6.47 2 12C2 17.53 6.47 22 12 22C17.53 22 22 17.53 22 12C22 6.47 17.53 2 12 2ZM16.3 16.3C15.91 16.69 15.28 16.69 14.89 16.3L12 13.41L9.11 16.3C8.72 16.69 8.09 16.69 7.7 16.3C7.31 15.91 7.31 15.28 7.7 14.89L10.59 12L7.7 9.11C7.31 8.72 7.31 8.09 7.7 7.7C8.09 7.31 8.72 7.31 9.11 7.7L12 10.59L14.89 7.7C15.28 7.31 15.91 7.31 16.3 7.7C16.69 8.09 16.69 8.72 16.3 9.11L13.41 12L16.3 14.89C16.68 15.27 16.68 15.91 16.3 16.3Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 2.33337C7.54834 2.33337 2.33334 7.54837 2.33334 14C2.33334 20.4517 7.54834 25.6667 14 25.6667C20.4517 25.6667 25.6667 20.4517 25.6667 14C25.6667 7.54837 20.4517 2.33337 14 2.33337ZM19.0167 19.0167C18.5617 19.4717 17.8267 19.4717 17.3717 19.0167L14 15.645L10.6283 19.0167C10.1733 19.4717 9.43834 19.4717 8.98334 19.0167C8.52834 18.5617 8.52834 17.8267 8.98334 17.3717L12.355 14L8.98334 10.6284C8.52834 10.1734 8.52834 9.43837 8.98334 8.98337C9.43834 8.52837 10.1733 8.52837 10.6283 8.98337L14 12.355L17.3717 8.98337C17.8267 8.52837 18.5617 8.52837 19.0167 8.98337C19.4717 9.43837 19.4717 10.1734 19.0167 10.6284L15.645 14L19.0167 17.3717C19.46 17.815 19.46 18.5617 19.0167 19.0167Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1H; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-cancel",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1G = "/*!@:host*/.sc-swirl-icon-chat-bubble-h{display:inline-flex}";

class SwirlIconChatBubble {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.5 2C2.67157 2 2 2.67157 2 3.5V9.5C2 10.3284 2.67157 11 3.5 11H5V13.7929C5 14.2383 5.53857 14.4614 5.85355 14.1464L9 11H12.5C13.3284 11 14 10.3284 14 9.5V3.5C14 2.67157 13.3284 2 12.5 2H3.5Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5.25 3C4.00736 3 3 4.00736 3 5.25V14.25C3 15.4926 4.00736 16.5 5.25 16.5H7.5V20.6893C7.5 21.3575 8.30786 21.6921 8.78033 21.2197L13.5 16.5H18.75C19.9926 16.5 21 15.4926 21 14.25V5.25C21 4.00736 19.9926 3 18.75 3H5.25Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M6.125 3.5C4.67525 3.5 3.5 4.67525 3.5 6.125V16.625C3.5 18.0747 4.67525 19.25 6.125 19.25H8.75V24.1376C8.75 24.9171 9.6925 25.3075 10.2437 24.7563L15.75 19.25H21.875C23.3247 19.25 24.5 18.0747 24.5 16.625V6.125C24.5 4.67525 23.3247 3.5 21.875 3.5H6.125Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1G; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-chat-bubble",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1F = "/*!@:host*/.sc-swirl-icon-chats-filled-h{display:inline-flex}";

class SwirlIconChatsFilled {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 2C6.4087 2 4.88258 2.63214 3.75736 3.75736C2.63214 4.88258 2 6.4087 2 8V12.5C2 12.8978 2.15804 13.2794 2.43934 13.5607C2.72064 13.842 3.10218 14 3.5 14H8C9.5913 14 11.1174 13.3679 12.2426 12.2426C13.3679 11.1174 14 9.5913 14 8C14 6.4087 13.3679 4.88258 12.2426 3.75736C11.1174 2.63214 9.5913 2 8 2V2ZM5.665 9.335C5.40096 9.335 5.14285 9.2567 4.92331 9.11001C4.70377 8.96332 4.53266 8.75482 4.43162 8.51088C4.33058 8.26694 4.30414 7.99852 4.35565 7.73955C4.40716 7.48059 4.53431 7.24272 4.72101 7.05601C4.90772 6.86931 5.14559 6.74216 5.40455 6.69065C5.66352 6.63914 5.93194 6.66558 6.17588 6.76662C6.41982 6.86766 6.62832 7.03877 6.77501 7.25831C6.9217 7.47785 7 7.73596 7 8C7 8.35406 6.85935 8.69363 6.60899 8.94399C6.35863 9.19435 6.01906 9.335 5.665 9.335V9.335ZM10.165 9.335C9.90096 9.335 9.64285 9.2567 9.42331 9.11001C9.20377 8.96332 9.03266 8.75482 8.93162 8.51088C8.83058 8.26694 8.80414 7.99852 8.85565 7.73955C8.90716 7.48059 9.03431 7.24272 9.22101 7.05601C9.40772 6.86931 9.64559 6.74216 9.90455 6.69065C10.1635 6.63914 10.4319 6.66558 10.6759 6.76662C10.9198 6.86766 11.1283 7.03877 11.275 7.25831C11.4217 7.47785 11.5 7.73596 11.5 8C11.5 8.17531 11.4655 8.34891 11.3984 8.51088C11.3313 8.67285 11.233 8.82002 11.109 8.94399C10.985 9.06795 10.8379 9.16629 10.6759 9.23338C10.5139 9.30047 10.3403 9.335 10.165 9.335V9.335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 3C9.61305 3 7.32387 3.94821 5.63604 5.63604C3.94821 7.32387 3 9.61305 3 12V18.75C3 19.3467 3.23705 19.919 3.65901 20.341C4.08097 20.7629 4.65326 21 5.25 21H12C14.3869 21 16.6761 20.0518 18.364 18.364C20.0518 16.6761 21 14.3869 21 12C21 9.61305 20.0518 7.32387 18.364 5.63604C16.6761 3.94821 14.3869 3 12 3V3ZM8.4975 14.0025C8.10144 14.0025 7.71428 13.8851 7.38497 13.665C7.05566 13.445 6.799 13.1322 6.64743 12.7663C6.49587 12.4004 6.45621 11.9978 6.53348 11.6093C6.61074 11.2209 6.80146 10.8641 7.08152 10.584C7.36157 10.304 7.71838 10.1132 8.10683 10.036C8.49528 9.95871 8.89791 9.99837 9.26382 10.1499C9.62973 10.3015 9.94248 10.5582 10.1625 10.8875C10.3826 11.2168 10.5 11.6039 10.5 12C10.5 12.5311 10.289 13.0404 9.91348 13.416C9.53794 13.7915 9.0286 14.0025 8.4975 14.0025V14.0025ZM15.2475 14.0025C14.8514 14.0025 14.4643 13.8851 14.135 13.665C13.8057 13.445 13.549 13.1322 13.3974 12.7663C13.2459 12.4004 13.2062 11.9978 13.2835 11.6093C13.3607 11.2209 13.5515 10.8641 13.8315 10.584C14.1116 10.304 14.4684 10.1132 14.8568 10.036C15.2453 9.95871 15.6479 9.99837 16.0138 10.1499C16.3797 10.3015 16.6925 10.5582 16.9125 10.8875C17.1326 11.2168 17.25 11.6039 17.25 12C17.25 12.263 17.1982 12.5234 17.0976 12.7663C16.9969 13.0093 16.8494 13.23 16.6635 13.416C16.4775 13.6019 16.2568 13.7494 16.0138 13.8501C15.7709 13.9507 15.5105 14.0025 15.2475 14.0025V14.0025Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 3.5C11.2152 3.5 8.54451 4.60625 6.57538 6.57538C4.60625 8.54451 3.5 11.2152 3.5 14V21.875C3.5 22.5712 3.77656 23.2389 4.26884 23.7312C4.76113 24.2234 5.42881 24.5 6.125 24.5H14C16.7848 24.5 19.4555 23.3938 21.4246 21.4246C23.3938 19.4555 24.5 16.7848 24.5 14C24.5 11.2152 23.3938 8.54451 21.4246 6.57538C19.4555 4.60625 16.7848 3.5 14 3.5V3.5ZM9.91375 16.3363C9.45168 16.3363 8.99999 16.1992 8.6158 15.9425C8.2316 15.6858 7.93216 15.3209 7.75534 14.894C7.57851 14.4672 7.53225 13.9974 7.62239 13.5442C7.71254 13.091 7.93504 12.6748 8.26177 12.348C8.5885 12.0213 9.00478 11.7988 9.45797 11.7086C9.91116 11.6185 10.3809 11.6648 10.8078 11.8416C11.2347 12.0184 11.5996 12.3179 11.8563 12.702C12.113 13.0862 12.25 13.5379 12.25 14C12.25 14.6196 12.0039 15.2138 11.5657 15.652C11.1276 16.0901 10.5334 16.3363 9.91375 16.3363V16.3363ZM17.7887 16.3363C17.3267 16.3363 16.875 16.1992 16.4908 15.9425C16.1066 15.6858 15.8072 15.3209 15.6303 14.894C15.4535 14.4672 15.4072 13.9974 15.4974 13.5442C15.5875 13.091 15.81 12.6748 16.1368 12.348C16.4635 12.0213 16.8798 11.7988 17.333 11.7086C17.7862 11.6185 18.2559 11.6648 18.6828 11.8416C19.1097 12.0184 19.4746 12.3179 19.7313 12.702C19.988 13.0862 20.125 13.5379 20.125 14C20.125 14.3068 20.0646 14.6106 19.9472 14.894C19.8298 15.1775 19.6577 15.435 19.4407 15.652C19.2238 15.8689 18.9662 16.041 18.6828 16.1584C18.3993 16.2758 18.0956 16.3363 17.7887 16.3363V16.3363Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1F; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-chats-filled",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1E = "/*!@:host*/.sc-swirl-icon-chats-outlined-h{display:inline-flex}";

class SwirlIconChatsOutlined {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 3C9.32608 3 10.5979 3.52678 11.5355 4.46447C12.4732 5.40215 13 6.67392 13 8C13 9.32608 12.4732 10.5979 11.5355 11.5355C10.5979 12.4732 9.32608 13 8 13H3.5C3.36739 13 3.24021 12.9473 3.14645 12.8536C3.05268 12.7598 3 12.6326 3 12.5V8C3 6.67392 3.52678 5.40215 4.46447 4.46447C5.40215 3.52678 6.67392 3 8 3ZM8 2C6.4087 2 4.88258 2.63214 3.75736 3.75736C2.63214 4.88258 2 6.4087 2 8V12.5C2 12.8978 2.15804 13.2794 2.43934 13.5607C2.72064 13.842 3.10218 14 3.5 14H8C9.5913 14 11.1174 13.3679 12.2426 12.2426C13.3679 11.1174 14 9.5913 14 8C14 6.4087 13.3679 4.88258 12.2426 3.75736C11.1174 2.63214 9.5913 2 8 2Z", fill: "currentColor" }), hAsync("path", { d: "M6.005 6.835H6C5.35659 6.835 4.835 7.35659 4.835 8V8.005C4.835 8.64841 5.35659 9.17 6 9.17H6.005C6.64841 9.17 7.17 8.64841 7.17 8.005V8C7.17 7.35659 6.64841 6.835 6.005 6.835Z", fill: "currentColor" }), hAsync("path", { d: "M9.835 6.835H9.83C9.18659 6.835 8.665 7.35659 8.665 8V8.005C8.665 8.64841 9.18659 9.17 9.83 9.17H9.835C10.4784 9.17 11 8.64841 11 8.005V8C11 7.35659 10.4784 6.835 9.835 6.835Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 4.5C13.9891 4.5 15.8968 5.29018 17.3033 6.6967C18.7098 8.10322 19.5 10.0109 19.5 12C19.5 13.9891 18.7098 15.8968 17.3033 17.3033C15.8968 18.7098 13.9891 19.5 12 19.5H5.25C5.05109 19.5 4.86032 19.421 4.71967 19.2803C4.57902 19.1397 4.5 18.9489 4.5 18.75V12C4.5 10.0109 5.29018 8.10322 6.6967 6.6967C8.10322 5.29018 10.0109 4.5 12 4.5ZM12 3C9.61305 3 7.32387 3.94821 5.63604 5.63604C3.94821 7.32387 3 9.61305 3 12V18.75C3 19.3467 3.23705 19.919 3.65901 20.341C4.08097 20.7629 4.65326 21 5.25 21H12C14.3869 21 16.6761 20.0518 18.364 18.364C20.0518 16.6761 21 14.3869 21 12C21 9.61305 20.0518 7.32387 18.364 5.63604C16.6761 3.94821 14.3869 3 12 3Z", fill: "currentColor" }), hAsync("path", { d: "M9.0075 10.2525H9C8.03488 10.2525 7.2525 11.0349 7.2525 12V12.0075C7.2525 12.9726 8.03488 13.755 9 13.755H9.0075C9.97262 13.755 10.755 12.9726 10.755 12.0075V12C10.755 11.0349 9.97262 10.2525 9.0075 10.2525Z", fill: "currentColor" }), hAsync("path", { d: "M14.7525 10.2525H14.745C13.7799 10.2525 12.9975 11.0349 12.9975 12V12.0075C12.9975 12.9726 13.7799 13.755 14.745 13.755H14.7525C15.7176 13.755 16.5 12.9726 16.5 12.0075V12C16.5 11.0349 15.7176 10.2525 14.7525 10.2525Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 5.25C16.3206 5.25 18.5462 6.17187 20.1872 7.81282C21.8281 9.45376 22.75 11.6794 22.75 14C22.75 16.3206 21.8281 18.5462 20.1872 20.1872C18.5462 21.8281 16.3206 22.75 14 22.75H6.125C5.89294 22.75 5.67038 22.6578 5.50628 22.4937C5.34219 22.3296 5.25 22.1071 5.25 21.875V14C5.25 11.6794 6.17187 9.45376 7.81282 7.81282C9.45376 6.17187 11.6794 5.25 14 5.25ZM14 3.5C11.2152 3.5 8.54451 4.60625 6.57538 6.57538C4.60625 8.54451 3.5 11.2152 3.5 14V21.875C3.5 22.5712 3.77656 23.2389 4.26884 23.7312C4.76113 24.2234 5.42881 24.5 6.125 24.5H14C16.7848 24.5 19.4555 23.3938 21.4246 21.4246C23.3938 19.4555 24.5 16.7848 24.5 14C24.5 11.2152 23.3938 8.54451 21.4246 6.57538C19.4555 4.60625 16.7848 3.5 14 3.5Z", fill: "currentColor" }), hAsync("path", { d: "M10.5088 11.9613H10.5C9.37403 11.9613 8.46125 12.874 8.46125 14V14.0088C8.46125 15.1347 9.37403 16.0475 10.5 16.0475H10.5088C11.6347 16.0475 12.5475 15.1347 12.5475 14.0088V14C12.5475 12.874 11.6347 11.9613 10.5088 11.9613Z", fill: "currentColor" }), hAsync("path", { d: "M17.2113 11.9613H17.2025C16.0765 11.9613 15.1637 12.874 15.1637 14V14.0088C15.1637 15.1347 16.0765 16.0475 17.2025 16.0475H17.2113C18.3372 16.0475 19.25 15.1347 19.25 14.0088V14C19.25 12.874 18.3372 11.9613 17.2113 11.9613Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1E; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-chats-outlined",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1D = "/*!@:host*/.sc-swirl-icon-check-h{display:inline-flex}";

class SwirlIconCheck {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6.36666 11.8166C6.26666 11.8166 6.17222 11.8 6.08333 11.7666C5.99444 11.7333 5.91111 11.6777 5.83333 11.6L2.96666 8.73329C2.82222 8.58885 2.75289 8.40818 2.75866 8.19129C2.764 7.97485 2.83889 7.7944 2.98333 7.64996C3.12778 7.50551 3.30844 7.43329 3.52533 7.43329C3.74178 7.43329 3.91666 7.50551 4.05 7.64996L6.36666 9.96663L11.95 4.38329C12.0833 4.23885 12.2611 4.16663 12.4833 4.16663C12.7056 4.16663 12.8889 4.23885 13.0333 4.38329C13.1667 4.52774 13.2333 4.70818 13.2333 4.92463C13.2333 5.14151 13.1667 5.32218 13.0333 5.46663L6.9 11.6C6.82222 11.6777 6.73889 11.7333 6.65 11.7666C6.56111 11.8 6.46667 11.8166 6.36666 11.8166V11.8166Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9.55001 17.725C9.40001 17.725 9.25835 17.7 9.12501 17.65C8.99168 17.6 8.86668 17.5167 8.75001 17.4L4.45001 13.1C4.23335 12.8833 4.12935 12.6123 4.13801 12.287C4.14601 11.9623 4.25835 11.6917 4.47501 11.475C4.69168 11.2583 4.96268 11.15 5.28801 11.15C5.61268 11.15 5.87501 11.2583 6.07501 11.475L9.55001 14.95L17.925 6.575C18.125 6.35833 18.3917 6.25 18.725 6.25C19.0583 6.25 19.3333 6.35833 19.55 6.575C19.75 6.79167 19.85 7.06233 19.85 7.387C19.85 7.71233 19.75 7.98333 19.55 8.2L10.35 17.4C10.2333 17.5167 10.1083 17.6 9.97501 17.65C9.84168 17.7 9.70001 17.725 9.55001 17.725Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M11.1417 20.6791C10.9667 20.6791 10.8014 20.65 10.6458 20.5916C10.4903 20.5333 10.3444 20.4361 10.2083 20.3L5.19167 15.2833C4.93889 15.0305 4.81756 14.7143 4.82767 14.3348C4.837 13.956 4.96806 13.6402 5.22084 13.3875C5.47362 13.1347 5.78978 13.0083 6.16934 13.0083C6.54812 13.0083 6.85417 13.1347 7.0875 13.3875L11.1417 17.4416L20.9125 7.67079C21.1458 7.41801 21.457 7.29163 21.8458 7.29163C22.2347 7.29163 22.5556 7.41801 22.8083 7.67079C23.0417 7.92357 23.1583 8.23935 23.1583 8.61813C23.1583 8.99768 23.0417 9.31385 22.8083 9.56663L12.075 20.3C11.9389 20.4361 11.7931 20.5333 11.6375 20.5916C11.4819 20.65 11.3167 20.6791 11.1417 20.6791V20.6791Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1D; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-check",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1C = "/*!@:host*/.sc-swirl-icon-check-circle-h{display:inline-flex}";

class SwirlIconCheckCircle {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.00001 1.33337C4.32001 1.33337 1.33334 4.32004 1.33334 8.00004C1.33334 11.68 4.32001 14.6667 8.00001 14.6667C11.68 14.6667 14.6667 11.68 14.6667 8.00004C14.6667 4.32004 11.68 1.33337 8.00001 1.33337ZM6.19334 10.86L3.80001 8.46671C3.54001 8.20671 3.54001 7.78671 3.80001 7.52671C4.06001 7.26671 4.48001 7.26671 4.74001 7.52671L6.66668 9.44671L11.2533 4.86004C11.5133 4.60004 11.9333 4.60004 12.1933 4.86004C12.4533 5.12004 12.4533 5.54004 12.1933 5.80004L7.13334 10.86C6.88001 11.12 6.45334 11.12 6.19334 10.86Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM9.29 16.29L5.7 12.7C5.31 12.31 5.31 11.68 5.7 11.29C6.09 10.9 6.72 10.9 7.11 11.29L10 14.17L16.88 7.29C17.27 6.9 17.9 6.9 18.29 7.29C18.68 7.68 18.68 8.31 18.29 8.7L10.7 16.29C10.32 16.68 9.68 16.68 9.29 16.29Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 2.33337C7.56001 2.33337 2.33334 7.56004 2.33334 14C2.33334 20.44 7.56001 25.6667 14 25.6667C20.44 25.6667 25.6667 20.44 25.6667 14C25.6667 7.56004 20.44 2.33337 14 2.33337ZM10.8383 19.005L6.65001 14.8167C6.19501 14.3617 6.19501 13.6267 6.65001 13.1717C7.10501 12.7167 7.84001 12.7167 8.29501 13.1717L11.6667 16.5317L19.6933 8.50504C20.1483 8.05004 20.8833 8.05004 21.3383 8.50504C21.7933 8.96004 21.7933 9.69504 21.3383 10.15L12.4833 19.005C12.04 19.46 11.2933 19.46 10.8383 19.005Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1C; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-check-circle",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1B = "/*!@:host*/.sc-swirl-icon-check-small-h{display:inline-flex}";

class SwirlIconCheckSmall {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12.4142 4.91924C12.8047 5.30976 12.8047 5.94293 12.4142 6.33345L7.08086 11.6667C6.69033 12.0572 6.05717 12.0572 5.66664 11.6667L3.70711 9.70707C3.31658 9.31655 3.31658 8.68338 3.70711 8.29286C4.09763 7.90233 4.7308 7.90233 5.12132 8.29286L6.37375 9.54539L11 4.91924C11.3905 4.52871 12.0237 4.52871 12.4142 4.91924Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M18.6213 7.37879C19.2071 7.96458 19.2071 8.91433 18.6213 9.50011L10.6213 17.5C10.0355 18.0858 9.08577 18.0858 8.49998 17.5L5.56068 14.5605C4.97489 13.9748 4.97489 13.025 5.56068 12.4392C6.14646 11.8534 7.09621 11.8534 7.682 12.4392L9.56064 14.318L16.5 7.37879C17.0858 6.79301 18.0355 6.79301 18.6213 7.37879Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M21.7248 8.60863C22.4083 9.29205 22.4083 10.4001 21.7248 11.0835L12.3915 20.4167C11.7081 21.1001 10.6001 21.1001 9.91663 20.4167L6.48744 16.9873C5.80403 16.3039 5.80403 15.1959 6.48744 14.5125C7.17086 13.8291 8.2789 13.8291 8.96232 14.5125L11.1541 16.7044L19.25 8.60863C19.9334 7.92521 21.0414 7.92521 21.7248 8.60863Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1B; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-check-small",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1A = "/*!@:host*/.sc-swirl-icon-check-strong-h{display:inline-flex}";

class SwirlIconCheckStrong {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M13.0404 4.29289C13.431 4.68342 13.431 5.31658 13.0404 5.70711L6.7071 12.0404C6.31657 12.431 5.68341 12.431 5.29288 12.0404L2.95955 9.70711C2.56903 9.31658 2.56903 8.68342 2.95955 8.29289C3.35007 7.90237 3.98324 7.90237 4.37376 8.29289L5.99999 9.91912L11.6262 4.29289C12.0167 3.90237 12.6499 3.90237 13.0404 4.29289Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M19.5607 6.43934C20.1464 7.02513 20.1464 7.97487 19.5607 8.56066L10.0607 18.0607C9.47487 18.6464 8.52513 18.6464 7.93934 18.0607L4.43934 14.5607C3.85355 13.9749 3.85355 13.0251 4.43934 12.4393C5.02513 11.8536 5.97487 11.8536 6.56066 12.4393L9 14.8787L17.4393 6.43934C18.0251 5.85355 18.9749 5.85355 19.5607 6.43934Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M22.8208 7.51256C23.5042 8.19598 23.5042 9.30402 22.8208 9.98744L11.7374 21.0708C11.054 21.7542 9.94597 21.7542 9.26255 21.0708L5.17922 16.9874C4.4958 16.304 4.4958 15.196 5.17922 14.5126C5.86264 13.8291 6.97068 13.8291 7.65409 14.5126L10.5 17.3585L20.3459 7.51256C21.0293 6.82915 22.1373 6.82915 22.8208 7.51256Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1A; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-check-strong",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1z = "/*!@:host*/.sc-swirl-icon-chevron-left-h{display:inline-flex}";

class SwirlIconChevronLeft {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.8 11.6L5.73333 8.53335C5.65555 8.45557 5.6 8.37224 5.56666 8.28335C5.53333 8.19446 5.51666 8.10002 5.51666 8.00002C5.51666 7.90002 5.53333 7.80557 5.56666 7.71668C5.6 7.62779 5.65555 7.54446 5.73333 7.46668L8.8 4.40002C8.94444 4.25557 9.12222 4.18335 9.33333 4.18335C9.54444 4.18335 9.72222 4.25557 9.86666 4.40002C10.0111 4.54446 10.0833 4.72224 10.0833 4.93335C10.0833 5.14446 10.0111 5.32224 9.86666 5.46668L7.33333 8.00002L9.86666 10.5333C10.0111 10.6778 10.0833 10.8556 10.0833 11.0667C10.0833 11.2778 10.0111 11.4556 9.86666 11.6C9.72222 11.7445 9.54444 11.8167 9.33333 11.8167C9.12222 11.8167 8.94444 11.7445 8.8 11.6V11.6Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M13.2 17.4L8.59999 12.8C8.48333 12.6834 8.39999 12.5584 8.34999 12.425C8.29999 12.2917 8.27499 12.15 8.27499 12C8.27499 11.85 8.29999 11.7084 8.34999 11.575C8.39999 11.4417 8.48333 11.3167 8.59999 11.2L13.2 6.60002C13.4167 6.38336 13.6833 6.27502 14 6.27502C14.3167 6.27502 14.5833 6.38336 14.8 6.60002C15.0167 6.81669 15.125 7.08336 15.125 7.40002C15.125 7.71669 15.0167 7.98336 14.8 8.20002L11 12L14.8 15.8C15.0167 16.0167 15.125 16.2834 15.125 16.6C15.125 16.9167 15.0167 17.1834 14.8 17.4C14.5833 17.6167 14.3167 17.725 14 17.725C13.6833 17.725 13.4167 17.6167 13.2 17.4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M15.4 20.3L10.0333 14.9333C9.89723 14.7972 9.80001 14.6514 9.74168 14.4958C9.68334 14.3402 9.65417 14.175 9.65417 14C9.65417 13.825 9.68334 13.6597 9.74168 13.5041C9.80001 13.3486 9.89723 13.2027 10.0333 13.0666L15.4 7.69997C15.6528 7.44719 15.9639 7.3208 16.3333 7.3208C16.7028 7.3208 17.0139 7.44719 17.2667 7.69997C17.5195 7.95275 17.6458 8.26386 17.6458 8.6333C17.6458 9.00275 17.5195 9.31386 17.2667 9.56663L12.8333 14L17.2667 18.4333C17.5195 18.6861 17.6458 18.9972 17.6458 19.3666C17.6458 19.7361 17.5195 20.0472 17.2667 20.3C17.0139 20.5527 16.7028 20.6791 16.3333 20.6791C15.9639 20.6791 15.6528 20.5527 15.4 20.3V20.3Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1z; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-chevron-left",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1y = "/*!@:host*/.sc-swirl-icon-chevron-right-h{display:inline-flex}";

class SwirlIconChevronRight {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M5.73333 11.6C5.58889 11.4556 5.51666 11.2778 5.51666 11.0667C5.51666 10.8556 5.58889 10.6778 5.73333 10.5333L8.26666 8.00002L5.73333 5.46668C5.58889 5.32224 5.51666 5.14446 5.51666 4.93335C5.51666 4.72224 5.58889 4.54446 5.73333 4.40002C5.87777 4.25557 6.05555 4.18335 6.26666 4.18335C6.47777 4.18335 6.65555 4.25557 6.8 4.40002L9.86666 7.46668C9.94444 7.54446 10 7.62779 10.0333 7.71668C10.0667 7.80557 10.0833 7.90002 10.0833 8.00002C10.0833 8.10002 10.0667 8.19446 10.0333 8.28335C10 8.37224 9.94444 8.45557 9.86666 8.53335L6.8 11.6C6.65555 11.7445 6.47777 11.8167 6.26666 11.8167C6.05555 11.8167 5.87777 11.7445 5.73333 11.6V11.6Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M8.59999 17.4C8.38333 17.1834 8.27499 16.9167 8.27499 16.6C8.27499 16.2834 8.38333 16.0167 8.59999 15.8L12.4 12L8.59999 8.20002C8.38333 7.98336 8.27499 7.71669 8.27499 7.40002C8.27499 7.08336 8.38333 6.81669 8.59999 6.60002C8.81666 6.38336 9.08333 6.27502 9.39999 6.27502C9.71666 6.27502 9.98333 6.38336 10.2 6.60002L14.8 11.2C14.9167 11.3167 15 11.4417 15.05 11.575C15.1 11.7084 15.125 11.85 15.125 12C15.125 12.15 15.1 12.2917 15.05 12.425C15 12.5584 14.9167 12.6834 14.8 12.8L10.2 17.4C9.98333 17.6167 9.71666 17.725 9.39999 17.725C9.08333 17.725 8.81666 17.6167 8.59999 17.4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M10.0333 20.3C9.78056 20.0472 9.65417 19.7361 9.65417 19.3666C9.65417 18.9972 9.78056 18.6861 10.0333 18.4333L14.4667 14L10.0333 9.56663C9.78056 9.31386 9.65417 9.00275 9.65417 8.6333C9.65417 8.26386 9.78056 7.95275 10.0333 7.69997C10.2861 7.44719 10.5972 7.3208 10.9667 7.3208C11.3361 7.3208 11.6472 7.44719 11.9 7.69997L17.2667 13.0666C17.4028 13.2027 17.5 13.3486 17.5583 13.5041C17.6167 13.6597 17.6458 13.825 17.6458 14C17.6458 14.175 17.6167 14.3402 17.5583 14.4958C17.5 14.6514 17.4028 14.7972 17.2667 14.9333L11.9 20.3C11.6472 20.5527 11.3361 20.6791 10.9667 20.6791C10.5972 20.6791 10.2861 20.5527 10.0333 20.3V20.3Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1y; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-chevron-right",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1x = "/*!@:host*/.sc-swirl-icon-close-h{display:inline-flex}";

class SwirlIconClose {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 9.06672L4.8 12.2667C4.65555 12.4112 4.47777 12.4834 4.26666 12.4834C4.05555 12.4834 3.87777 12.4112 3.73333 12.2667C3.58888 12.1223 3.51666 11.9445 3.51666 11.7334C3.51666 11.5223 3.58888 11.3445 3.73333 11.2001L6.93333 8.00006L3.73333 4.80006C3.58888 4.65561 3.51666 4.47783 3.51666 4.26672C3.51666 4.05561 3.58888 3.87783 3.73333 3.73339C3.87777 3.58895 4.05555 3.51672 4.26666 3.51672C4.47777 3.51672 4.65555 3.58895 4.8 3.73339L8 6.93339L11.2 3.73339C11.3444 3.58895 11.5222 3.51672 11.7333 3.51672C11.9444 3.51672 12.1222 3.58895 12.2667 3.73339C12.4111 3.87783 12.4833 4.05561 12.4833 4.26672C12.4833 4.47783 12.4111 4.65561 12.2667 4.80006L9.06666 8.00006L12.2667 11.2001C12.4111 11.3445 12.4833 11.5223 12.4833 11.7334C12.4833 11.9445 12.4111 12.1223 12.2667 12.2667C12.1222 12.4112 11.9444 12.4834 11.7333 12.4834C11.5222 12.4834 11.3444 12.4112 11.2 12.2667L8 9.06672Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 13.6L7.19999 18.4C6.98333 18.6167 6.71666 18.725 6.39999 18.725C6.08333 18.725 5.81666 18.6167 5.59999 18.4C5.38333 18.1834 5.27499 17.9167 5.27499 17.6C5.27499 17.2834 5.38333 17.0167 5.59999 16.8L10.4 12L5.59999 7.20002C5.38333 6.98336 5.27499 6.71669 5.27499 6.40002C5.27499 6.08336 5.38333 5.81669 5.59999 5.60002C5.81666 5.38336 6.08333 5.27502 6.39999 5.27502C6.71666 5.27502 6.98333 5.38336 7.19999 5.60002L12 10.4L16.8 5.60002C17.0167 5.38336 17.2833 5.27502 17.6 5.27502C17.9167 5.27502 18.1833 5.38336 18.4 5.60002C18.6167 5.81669 18.725 6.08336 18.725 6.40002C18.725 6.71669 18.6167 6.98336 18.4 7.20002L13.6 12L18.4 16.8C18.6167 17.0167 18.725 17.2834 18.725 17.6C18.725 17.9167 18.6167 18.1834 18.4 18.4C18.1833 18.6167 17.9167 18.725 17.6 18.725C17.2833 18.725 17.0167 18.6167 16.8 18.4L12 13.6Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 15.8667L8.40001 21.4667C8.14723 21.7195 7.83612 21.8458 7.46667 21.8458C7.09723 21.8458 6.78612 21.7195 6.53334 21.4667C6.28056 21.2139 6.15417 20.9028 6.15417 20.5333C6.15417 20.1639 6.28056 19.8528 6.53334 19.6L12.1333 14L6.53334 8.40001C6.28056 8.14723 6.15417 7.83612 6.15417 7.46667C6.15417 7.09723 6.28056 6.78612 6.53334 6.53334C6.78612 6.28056 7.09723 6.15417 7.46667 6.15417C7.83612 6.15417 8.14723 6.28056 8.40001 6.53334L14 12.1333L19.6 6.53334C19.8528 6.28056 20.1639 6.15417 20.5333 6.15417C20.9028 6.15417 21.2139 6.28056 21.4667 6.53334C21.7195 6.78612 21.8458 7.09723 21.8458 7.46667C21.8458 7.83612 21.7195 8.14723 21.4667 8.40001L15.8667 14L21.4667 19.6C21.7195 19.8528 21.8458 20.1639 21.8458 20.5333C21.8458 20.9028 21.7195 21.2139 21.4667 21.4667C21.2139 21.7195 20.9028 21.8458 20.5333 21.8458C20.1639 21.8458 19.8528 21.7195 19.6 21.4667L14 15.8667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1x; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-close",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1w = "/*!@:host*/.sc-swirl-icon-close-small-h{display:inline-flex}";

class SwirlIconCloseSmall {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.99999 9.06671L5.33326 11.7333C5.18882 11.8778 5.01104 11.95 4.79993 11.95C4.58882 11.95 4.41104 11.8778 4.26659 11.7333C4.12215 11.5889 4.04993 11.4111 4.04993 11.2C4.04993 10.9889 4.12215 10.8111 4.26659 10.6666L6.93332 8.00005L4.26672 5.33338C4.12228 5.18894 4.05006 5.01116 4.05006 4.80005C4.05006 4.58894 4.12228 4.41116 4.26672 4.26672C4.41117 4.12227 4.58895 4.05005 4.80006 4.05005C5.01117 4.05005 5.18895 4.12227 5.33339 4.26672L7.99999 6.93338L10.6666 4.26678C10.811 4.12234 10.9888 4.05011 11.1999 4.05011C11.411 4.05011 11.5888 4.12234 11.7333 4.26678C11.8777 4.41122 11.9499 4.589 11.9499 4.80011C11.9499 5.01122 11.8777 5.189 11.7333 5.33345L9.06666 8.00005L11.7335 10.6666C11.8779 10.8111 11.9501 10.9889 11.9501 11.2C11.9501 11.4111 11.8779 11.5889 11.7335 11.7333C11.589 11.8778 11.4112 11.95 11.2001 11.95C10.989 11.95 10.8112 11.8778 10.6668 11.7333L7.99999 9.06671Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 13.5999L7.99989 17.5998C7.78322 17.8165 7.51656 17.9248 7.19989 17.9248C6.88322 17.9248 6.61656 17.8165 6.39989 17.5998C6.18322 17.3832 6.07489 17.1165 6.07489 16.7998C6.07489 16.4832 6.18322 16.2165 6.39989 15.9998L10.4 11.9999L6.40008 7.99995C6.18342 7.78328 6.07509 7.51662 6.07509 7.19995C6.07509 6.88328 6.18342 6.61662 6.40008 6.39995C6.61675 6.18328 6.88342 6.07495 7.20009 6.07495C7.51675 6.07495 7.78342 6.18328 8.00008 6.39995L12 10.3999L15.9999 6.40005C16.2166 6.18338 16.4832 6.07505 16.7999 6.07505C17.1166 6.07505 17.3832 6.18338 17.5999 6.40005C17.8166 6.61671 17.9249 6.88338 17.9249 7.20005C17.9249 7.51671 17.8166 7.78338 17.5999 8.00005L13.6 11.9999L17.6002 15.9998C17.8168 16.2165 17.9252 16.4832 17.9252 16.7998C17.9252 17.1165 17.8168 17.3832 17.6002 17.5998C17.3835 17.8165 17.1168 17.9248 16.8002 17.9248C16.4835 17.9248 16.2168 17.8165 16.0002 17.5998L12 13.5999Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 15.8667L9.33324 20.5332C9.08046 20.786 8.76935 20.9124 8.3999 20.9124C8.03046 20.9124 7.71935 20.786 7.46657 20.5332C7.21379 20.2805 7.0874 19.9694 7.0874 19.5999C7.0874 19.2305 7.21379 18.9193 7.46657 18.6666L12.1333 14L7.4668 9.33336C7.21402 9.08058 7.08763 8.76947 7.08763 8.40002C7.08763 8.03058 7.21402 7.71947 7.4668 7.46669C7.71957 7.21391 8.03069 7.08752 8.40013 7.08752C8.76957 7.08752 9.08069 7.21391 9.33346 7.46669L14 12.1334L18.6666 7.4668C18.9193 7.21403 19.2305 7.08764 19.5999 7.08764C19.9693 7.08764 20.2805 7.21403 20.5332 7.4668C20.786 7.71958 20.9124 8.03069 20.9124 8.40014C20.9124 8.76958 20.786 9.08069 20.5332 9.33347L15.8667 14L20.5336 18.6666C20.7864 18.9193 20.9127 19.2305 20.9127 19.5999C20.9127 19.9694 20.7864 20.2805 20.5336 20.5332C20.2808 20.786 19.9697 20.9124 19.6002 20.9124C19.2308 20.9124 18.9197 20.786 18.6669 20.5332L14 15.8667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1w; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-close-small",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1v = "/*!@:host*/.sc-swirl-icon-cloud-upload-h{display:inline-flex}";

class SwirlIconCloudUpload {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4.33333 13.3333C3.32222 13.3333 2.45844 12.9833 1.742 12.2833C1.02511 11.5833 0.666664 10.7277 0.666664 9.71663C0.666664 8.84996 0.927775 8.07774 1.45 7.39996C1.97222 6.72218 2.65555 6.28885 3.5 6.09996C3.77778 5.07774 4.33333 4.24996 5.16666 3.61663C6 2.98329 6.94444 2.66663 8 2.66663C9.3 2.66663 10.4027 3.11929 11.308 4.02463C12.2138 4.9304 12.6667 6.03329 12.6667 7.33329C13.4333 7.42218 14.0696 7.75263 14.5753 8.32463C15.0807 8.89707 15.3333 9.56663 15.3333 10.3333C15.3333 11.1666 15.0418 11.8751 14.4587 12.4586C13.8751 13.0417 13.1667 13.3333 12.3333 13.3333H8.66666V8.56663L9.26666 9.14996C9.38889 9.27218 9.54178 9.33329 9.72533 9.33329C9.90844 9.33329 10.0667 9.26663 10.2 9.13329C10.3222 9.01107 10.3833 8.85552 10.3833 8.66663C10.3833 8.47774 10.3222 8.32218 10.2 8.19996L8.46666 6.46663C8.33333 6.33329 8.17778 6.26663 8 6.26663C7.82222 6.26663 7.66666 6.33329 7.53333 6.46663L5.8 8.19996C5.67778 8.32218 5.614 8.47485 5.60866 8.65796C5.60289 8.84152 5.66666 8.99996 5.8 9.13329C5.92222 9.25551 6.07489 9.31952 6.258 9.32529C6.44155 9.33063 6.6 9.27218 6.73333 9.14996L7.33333 8.56663V13.3333H4.33333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M6.5 20C4.98333 20 3.68767 19.475 2.613 18.425C1.53767 17.375 1 16.0917 1 14.575C1 13.275 1.39167 12.1167 2.175 11.1C2.95833 10.0833 3.98333 9.43333 5.25 9.15C5.66667 7.61667 6.5 6.375 7.75 5.425C9 4.475 10.4167 4 12 4C13.95 4 15.604 4.679 16.962 6.037C18.3207 7.39567 19 9.05 19 11C20.15 11.1333 21.1043 11.629 21.863 12.487C22.621 13.3457 23 14.35 23 15.5C23 16.75 22.5627 17.8127 21.688 18.688C20.8127 19.5627 19.75 20 18.5 20H13V12.85L13.9 13.725C14.0833 13.9083 14.3127 14 14.588 14C14.8627 14 15.1 13.9 15.3 13.7C15.4833 13.5167 15.575 13.2833 15.575 13C15.575 12.7167 15.4833 12.4833 15.3 12.3L12.7 9.7C12.5 9.5 12.2667 9.4 12 9.4C11.7333 9.4 11.5 9.5 11.3 9.7L8.7 12.3C8.51667 12.4833 8.421 12.7123 8.413 12.987C8.40433 13.2623 8.5 13.5 8.7 13.7C8.88333 13.8833 9.11233 13.9793 9.387 13.988C9.66233 13.996 9.9 13.9083 10.1 13.725L11 12.85V20H6.5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M7.58333 23.3333C5.81389 23.3333 4.30227 22.7208 3.0485 21.4958C1.79394 20.2708 1.16666 18.7736 1.16666 17.0041C1.16666 15.4875 1.62361 14.1361 2.5375 12.95C3.45139 11.7638 4.64722 11.0055 6.125 10.675C6.61111 8.88607 7.58333 7.43746 9.04166 6.32913C10.5 5.22079 12.1528 4.66663 14 4.66663C16.275 4.66663 18.2047 5.45879 19.789 7.04313C21.3741 8.62824 22.1667 10.5583 22.1667 12.8333C23.5083 12.9888 24.6217 13.5671 25.5068 14.5681C26.3912 15.5699 26.8333 16.7416 26.8333 18.0833C26.8333 19.5416 26.3231 20.7814 25.3027 21.8026C24.2814 22.8231 23.0417 23.3333 21.5833 23.3333H15.1667V14.9916L16.2167 16.0125C16.4306 16.2263 16.6981 16.3333 17.0193 16.3333C17.3398 16.3333 17.6167 16.2166 17.85 15.9833C18.0639 15.7694 18.1708 15.4972 18.1708 15.1666C18.1708 14.8361 18.0639 14.5638 17.85 14.35L14.8167 11.3166C14.5833 11.0833 14.3111 10.9666 14 10.9666C13.6889 10.9666 13.4167 11.0833 13.1833 11.3166L10.15 14.35C9.93611 14.5638 9.8245 14.831 9.81516 15.1515C9.80505 15.4727 9.91666 15.75 10.15 15.9833C10.3639 16.1972 10.6311 16.3092 10.9515 16.3193C11.2727 16.3286 11.55 16.2263 11.7833 16.0125L12.8333 14.9916V23.3333H7.58333Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1v; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-cloud-upload",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1u = "/*!@:host*/.sc-swirl-icon-column-h{display:inline-flex}";

class SwirlIconColumn {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M2.66667 12.0001H5.33334V4.00008H2.66667V12.0001ZM6.66667 12.0001H9.33334V4.00008H6.66667V12.0001ZM10.6667 12.0001H13.3333V4.00008H10.6667V12.0001ZM2.66667 13.3334C2.3 13.3334 1.98622 13.203 1.72534 12.9421C1.464 12.6807 1.33334 12.3667 1.33334 12.0001V4.00008C1.33334 3.63341 1.464 3.31964 1.72534 3.05875C1.98622 2.79741 2.3 2.66675 2.66667 2.66675H13.3333C13.7 2.66675 14.014 2.79741 14.2753 3.05875C14.5362 3.31964 14.6667 3.63341 14.6667 4.00008V12.0001C14.6667 12.3667 14.5362 12.6807 14.2753 12.9421C14.014 13.203 13.7 13.3334 13.3333 13.3334H2.66667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M4 18H8V6H4V18ZM10 18H14V6H10V18ZM16 18H20V6H16V18ZM4 20C3.45 20 2.97933 19.8043 2.588 19.413C2.196 19.021 2 18.55 2 18V6C2 5.45 2.196 4.97933 2.588 4.588C2.97933 4.196 3.45 4 4 4H20C20.55 4 21.021 4.196 21.413 4.588C21.8043 4.97933 22 5.45 22 6V18C22 18.55 21.8043 19.021 21.413 19.413C21.021 19.8043 20.55 20 20 20H4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66667 21.0001H9.33334V7.00008H4.66667V21.0001ZM11.6667 21.0001H16.3333V7.00008H11.6667V21.0001ZM18.6667 21.0001H23.3333V7.00008H18.6667V21.0001ZM4.66667 23.3334C4.025 23.3334 3.47589 23.1051 3.01934 22.6486C2.562 22.1912 2.33334 21.6417 2.33334 21.0001V7.00008C2.33334 6.35841 2.562 5.8093 3.01934 5.35275C3.47589 4.89541 4.025 4.66675 4.66667 4.66675H23.3333C23.975 4.66675 24.5245 4.89541 24.9818 5.35275C25.4384 5.8093 25.6667 6.35841 25.6667 7.00008V21.0001C25.6667 21.6417 25.4384 22.1912 24.9818 22.6486C24.5245 23.1051 23.975 23.3334 23.3333 23.3334H4.66667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1u; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-column",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1t = "/*!@:host*/.sc-swirl-icon-comment-h{display:inline-flex}";

class SwirlIconComment {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M11.3333 2.66659V7.33325C11.3333 8.06963 10.7364 8.66659 10 8.66659H4.00001L1.90238 10.7642C1.69239 10.9742 1.33334 10.8255 1.33334 10.5285V2.66659C1.33334 1.93021 1.9303 1.33325 2.66668 1.33325H10C10.7364 1.33325 11.3333 1.93021 11.3333 2.66659Z", fill: "currentColor" }), hAsync("path", { d: "M4.00001 9.99992H12.6667V3.99992H13.3333C14.0697 3.99992 14.6667 4.59687 14.6667 5.33325V13.8618C14.6667 14.1588 14.3076 14.3075 14.0976 14.0976L12 11.9999H5.33334C4.59696 11.9999 4.00001 11.403 4.00001 10.6666V9.99992Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M17 4V11C17 12.1046 16.1046 13 15 13H6L2.85355 16.1464C2.53857 16.4614 2 16.2383 2 15.7929V4C2 2.89543 2.89543 2 4 2H15C16.1046 2 17 2.89543 17 4Z", fill: "currentColor" }), hAsync("path", { d: "M6 15H19V6H20C21.1046 6 22 6.89543 22 8V20.7929C22 21.2383 21.4614 21.4614 21.1464 21.1464L18 18H8C6.89543 18 6 17.1046 6 16V15Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M19.8333 4.66659V12.8333C19.8333 14.1219 18.7887 15.1666 17.5 15.1666H7.00001L3.32916 18.8374C2.96168 19.2049 2.33334 18.9447 2.33334 18.425V4.66659C2.33334 3.37792 3.37801 2.33325 4.66668 2.33325H17.5C18.7887 2.33325 19.8333 3.37792 19.8333 4.66659Z", fill: "currentColor" }), hAsync("path", { d: "M7.00001 17.4999H22.1667V6.99992H23.3333C24.622 6.99992 25.6667 8.04459 25.6667 9.33325V24.2583C25.6667 24.778 25.0383 25.0383 24.6709 24.6708L21 20.9999H9.33334C8.04468 20.9999 7.00001 19.9552 7.00001 18.6666V17.4999Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1t; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-comment",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1s = "/*!@:host*/.sc-swirl-icon-copy-h{display:inline-flex}";

class SwirlIconCopy {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6 12C5.63333 12 5.31956 11.8696 5.05867 11.6087C4.79733 11.3473 4.66667 11.0333 4.66667 10.6667V2.66668C4.66667 2.30001 4.79733 1.98601 5.05867 1.72468C5.31956 1.46379 5.63333 1.33334 6 1.33334H12C12.3667 1.33334 12.6807 1.46379 12.942 1.72468C13.2029 1.98601 13.3333 2.30001 13.3333 2.66668V10.6667C13.3333 11.0333 13.2029 11.3473 12.942 11.6087C12.6807 11.8696 12.3667 12 12 12H6ZM3.33333 14.6667C2.96667 14.6667 2.65267 14.5362 2.39133 14.2753C2.13044 14.014 2 13.7 2 13.3333V4.66668C2 4.47779 2.064 4.31934 2.192 4.19134C2.31956 4.06379 2.47778 4.00001 2.66667 4.00001C2.85556 4.00001 3.014 4.06379 3.142 4.19134C3.26956 4.31934 3.33333 4.47779 3.33333 4.66668V13.3333H10C10.1889 13.3333 10.3473 13.3973 10.4753 13.5253C10.6029 13.6529 10.6667 13.8111 10.6667 14C10.6667 14.1889 10.6029 14.3471 10.4753 14.4747C10.3473 14.6027 10.1889 14.6667 10 14.6667H3.33333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9 18C8.45 18 7.97933 17.8043 7.588 17.413C7.196 17.021 7 16.55 7 16V4C7 3.45 7.196 2.979 7.588 2.587C7.97933 2.19567 8.45 2 9 2H18C18.55 2 19.021 2.19567 19.413 2.587C19.8043 2.979 20 3.45 20 4V16C20 16.55 19.8043 17.021 19.413 17.413C19.021 17.8043 18.55 18 18 18H9ZM5 22C4.45 22 3.979 21.8043 3.587 21.413C3.19567 21.021 3 20.55 3 20V7C3 6.71667 3.096 6.479 3.288 6.287C3.47933 6.09567 3.71667 6 4 6C4.28333 6 4.521 6.09567 4.713 6.287C4.90433 6.479 5 6.71667 5 7V20H15C15.2833 20 15.521 20.096 15.713 20.288C15.9043 20.4793 16 20.7167 16 21C16 21.2833 15.9043 21.5207 15.713 21.712C15.521 21.904 15.2833 22 15 22H5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M10.5 21C9.85833 21 9.30922 20.7717 8.85267 20.3152C8.39533 19.8578 8.16667 19.3083 8.16667 18.6667V4.66668C8.16667 4.02501 8.39533 3.47551 8.85267 3.01818C9.30922 2.56162 9.85833 2.33334 10.5 2.33334H21C21.6417 2.33334 22.1912 2.56162 22.6485 3.01818C23.1051 3.47551 23.3333 4.02501 23.3333 4.66668V18.6667C23.3333 19.3083 23.1051 19.8578 22.6485 20.3152C22.1912 20.7717 21.6417 21 21 21H10.5ZM5.83333 25.6667C5.19167 25.6667 4.64217 25.4384 4.18483 24.9818C3.72828 24.5245 3.5 23.975 3.5 23.3333V8.16668C3.5 7.83612 3.612 7.55884 3.836 7.33484C4.05922 7.11162 4.33611 7.00001 4.66667 7.00001C4.99722 7.00001 5.2745 7.11162 5.4985 7.33484C5.72172 7.55884 5.83333 7.83612 5.83333 8.16668V23.3333H17.5C17.8306 23.3333 18.1078 23.4453 18.3318 23.6693C18.5551 23.8926 18.6667 24.1695 18.6667 24.5C18.6667 24.8306 18.5551 25.1075 18.3318 25.3307C18.1078 25.5547 17.8306 25.6667 17.5 25.6667H5.83333Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1s; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-copy",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1r = "/*!@:host*/.sc-swirl-icon-date-range-h{display:inline-flex}";

class SwirlIconDateRange {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.6667 2.66671H12V2.00004C12 1.63337 11.7 1.33337 11.3333 1.33337C10.9667 1.33337 10.6667 1.63337 10.6667 2.00004V2.66671H5.33333V2.00004C5.33333 1.63337 5.03333 1.33337 4.66667 1.33337C4.3 1.33337 4 1.63337 4 2.00004V2.66671H3.33333C2.59333 2.66671 2.00667 3.26671 2.00667 4.00004L2 13.3334C2 14.0667 2.59333 14.6667 3.33333 14.6667H12.6667C13.4 14.6667 14 14.0667 14 13.3334V4.00004C14 3.26671 13.4 2.66671 12.6667 2.66671ZM12.6667 12.6667C12.6667 13.0334 12.3667 13.3334 12 13.3334H4C3.63333 13.3334 3.33333 13.0334 3.33333 12.6667V6.00004H12.6667V12.6667ZM4.66667 7.33337H6V8.66671H4.66667V7.33337ZM7.33333 7.33337H8.66667V8.66671H7.33333V7.33337ZM10 7.33337H11.3333V8.66671H10V7.33337Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M19 4H18V3C18 2.45 17.55 2 17 2C16.45 2 16 2.45 16 3V4H8V3C8 2.45 7.55 2 7 2C6.45 2 6 2.45 6 3V4H5C3.89 4 3.01 4.9 3.01 6L3 20C3 21.1 3.89 22 5 22H19C20.1 22 21 21.1 21 20V6C21 4.9 20.1 4 19 4ZM19 19C19 19.55 18.55 20 18 20H6C5.45 20 5 19.55 5 19V9H19V19ZM7 11H9V13H7V11ZM11 11H13V13H11V11ZM15 11H17V13H15V11Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M22.1667 4.66671H21V3.50004C21 2.85837 20.475 2.33337 19.8333 2.33337C19.1917 2.33337 18.6667 2.85837 18.6667 3.50004V4.66671H9.33333V3.50004C9.33333 2.85837 8.80833 2.33337 8.16667 2.33337C7.525 2.33337 7 2.85837 7 3.50004V4.66671H5.83333C4.53833 4.66671 3.51167 5.71671 3.51167 7.00004L3.5 23.3334C3.5 24.6167 4.53833 25.6667 5.83333 25.6667H22.1667C23.45 25.6667 24.5 24.6167 24.5 23.3334V7.00004C24.5 5.71671 23.45 4.66671 22.1667 4.66671ZM22.1667 22.1667C22.1667 22.8084 21.6417 23.3334 21 23.3334H7C6.35833 23.3334 5.83333 22.8084 5.83333 22.1667V10.5H22.1667V22.1667ZM8.16667 12.8334H10.5V15.1667H8.16667V12.8334ZM12.8333 12.8334H15.1667V15.1667H12.8333V12.8334ZM17.5 12.8334H19.8333V15.1667H17.5V12.8334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1r; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-date-range",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1q = "/*!@:host*/.sc-swirl-icon-delete-h{display:inline-flex}";

class SwirlIconDelete {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M5.66668 2.66667H4.16668C3.70644 2.66667 3.33334 3.03976 3.33334 3.5C3.33334 3.96024 3.70644 4.33333 4.16668 4.33333H11.8333C12.2936 4.33333 12.6667 3.96024 12.6667 3.5C12.6667 3.03976 12.2936 2.66667 11.8333 2.66667H10.3333L9.86194 2.19526C9.73691 2.07024 9.56734 2 9.39053 2H6.60949C6.43267 2 6.26311 2.07024 6.13808 2.19526L5.66668 2.66667Z", fill: "currentColor" }), hAsync("path", { d: "M5.33334 5.33333H10.6667C11.4031 5.33333 12 5.93029 12 6.66667V12.6667C12 13.403 11.4031 14 10.6667 14H5.33334C4.59696 14 4.00001 13.403 4.00001 12.6667V6.66667C4.00001 5.93029 4.59696 5.33333 5.33334 5.33333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M8.5 4H6.25C5.55964 4 5 4.55964 5 5.25C5 5.94036 5.55964 6.5 6.25 6.5H17.75C18.4404 6.5 19 5.94036 19 5.25C19 4.55964 18.4404 4 17.75 4H15.5L14.7929 3.29289C14.6054 3.10536 14.351 3 14.0858 3H9.91421C9.649 3 9.39464 3.10536 9.20711 3.29289L8.5 4Z", fill: "currentColor" }), hAsync("path", { d: "M8 8H16C17.1046 8 18 8.89543 18 10V19C18 20.1046 17.1046 21 16 21H8C6.89543 21 6 20.1046 6 19V10C6 8.89543 6.89543 8 8 8Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M9.91668 4.66667H7.29168C6.48626 4.66667 5.83334 5.31958 5.83334 6.125C5.83334 6.93042 6.48626 7.58333 7.29168 7.58333H20.7083C21.5138 7.58333 22.1667 6.93042 22.1667 6.125C22.1667 5.31958 21.5138 4.66667 20.7083 4.66667H18.0833L17.2584 3.84171C17.0396 3.62292 16.7428 3.5 16.4334 3.5H11.5666C11.2572 3.5 10.9604 3.62292 10.7416 3.84171L9.91668 4.66667Z", fill: "currentColor" }), hAsync("path", { d: "M9.33334 9.33333H18.6667C19.9553 9.33333 21 10.378 21 11.6667V22.1667C21 23.4553 19.9553 24.5 18.6667 24.5H9.33334C8.04468 24.5 7.00001 23.4553 7.00001 22.1667V11.6667C7.00001 10.378 8.04468 9.33333 9.33334 9.33333Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1q; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-delete",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1p = "/*!@:host*/.sc-swirl-icon-description-h{display:inline-flex}";

class SwirlIconDescription {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M9.72666 1.72668C9.47332 1.47334 9.13332 1.33334 8.77999 1.33334H3.99999C3.26666 1.33334 2.66666 1.93334 2.66666 2.66668V13.3333C2.66666 14.0667 3.25999 14.6667 3.99332 14.6667H12C12.7333 14.6667 13.3333 14.0667 13.3333 13.3333V5.88668C13.3333 5.53334 13.1933 5.19334 12.94 4.94668L9.72666 1.72668ZM9.99999 12H5.99999C5.63332 12 5.33332 11.7 5.33332 11.3333C5.33332 10.9667 5.63332 10.6667 5.99999 10.6667H9.99999C10.3667 10.6667 10.6667 10.9667 10.6667 11.3333C10.6667 11.7 10.3667 12 9.99999 12ZM9.99999 9.33334H5.99999C5.63332 9.33334 5.33332 9.03334 5.33332 8.66668C5.33332 8.30001 5.63332 8.00001 5.99999 8.00001H9.99999C10.3667 8.00001 10.6667 8.30001 10.6667 8.66668C10.6667 9.03334 10.3667 9.33334 9.99999 9.33334ZM8.66666 5.33334V2.33334L12.3333 6.00001H9.33332C8.96666 6.00001 8.66666 5.70001 8.66666 5.33334Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M14.59 2.59C14.21 2.21 13.7 2 13.17 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.89 22 5.99 22H18C19.1 22 20 21.1 20 20V8.83C20 8.3 19.79 7.79 19.41 7.42L14.59 2.59ZM15 18H9C8.45 18 8 17.55 8 17C8 16.45 8.45 16 9 16H15C15.55 16 16 16.45 16 17C16 17.55 15.55 18 15 18ZM15 14H9C8.45 14 8 13.55 8 13C8 12.45 8.45 12 9 12H15C15.55 12 16 12.45 16 13C16 13.55 15.55 14 15 14ZM13 8V3.5L18.5 9H14C13.45 9 13 8.55 13 8Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M17.0217 3.02168C16.5783 2.57834 15.9833 2.33334 15.365 2.33334H6.99999C5.71666 2.33334 4.66666 3.38334 4.66666 4.66668V23.3333C4.66666 24.6167 5.70499 25.6667 6.98832 25.6667H21C22.2833 25.6667 23.3333 24.6167 23.3333 23.3333V10.3017C23.3333 9.68334 23.0883 9.08834 22.645 8.65668L17.0217 3.02168ZM17.5 21H10.5C9.85832 21 9.33332 20.475 9.33332 19.8333C9.33332 19.1917 9.85832 18.6667 10.5 18.6667H17.5C18.1417 18.6667 18.6667 19.1917 18.6667 19.8333C18.6667 20.475 18.1417 21 17.5 21ZM17.5 16.3333H10.5C9.85832 16.3333 9.33332 15.8083 9.33332 15.1667C9.33332 14.525 9.85832 14 10.5 14H17.5C18.1417 14 18.6667 14.525 18.6667 15.1667C18.6667 15.8083 18.1417 16.3333 17.5 16.3333ZM15.1667 9.33334V4.08334L21.5833 10.5H16.3333C15.6917 10.5 15.1667 9.97501 15.1667 9.33334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1p; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-description",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1o = "/*!@:host*/.sc-swirl-icon-double-arrow-left-h{display:inline-flex}";

class SwirlIconDoubleArrowLeft {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M10.9833 11.5378L7.91667 8.47112C7.85 8.40445 7.80289 8.33223 7.77534 8.25445C7.74734 8.17667 7.73334 8.09334 7.73334 8.00445C7.73334 7.91556 7.74734 7.83223 7.77534 7.75445C7.80289 7.67667 7.85 7.60445 7.91667 7.53778L10.9833 4.47112C11.1056 4.34889 11.2582 4.28489 11.4413 4.27912C11.6249 4.27378 11.7833 4.33778 11.9167 4.47112C12.0389 4.59334 12.1 4.74889 12.1 4.93778C12.1 5.12667 12.0389 5.28223 11.9167 5.40445L9.33334 8.00445L11.9167 10.6044C12.0389 10.7267 12.1027 10.8793 12.108 11.0624C12.1138 11.246 12.05 11.4044 11.9167 11.5378C11.7944 11.66 11.6389 11.7211 11.45 11.7211C11.2611 11.7211 11.1056 11.66 10.9833 11.5378ZM6.58334 11.5378L3.51667 8.47112C3.45 8.40445 3.40289 8.33223 3.37534 8.25445C3.34734 8.17667 3.33334 8.09334 3.33334 8.00445C3.33334 7.91556 3.34734 7.83223 3.37534 7.75445C3.40289 7.67667 3.45 7.60445 3.51667 7.53778L6.58334 4.47112C6.70556 4.34889 6.85845 4.28489 7.042 4.27912C7.22511 4.27378 7.38334 4.33778 7.51667 4.47112C7.63889 4.59334 7.7 4.74889 7.7 4.93778C7.7 5.12667 7.63889 5.28223 7.51667 5.40445L4.93334 8.00445L7.51667 10.6044C7.63889 10.7267 7.70289 10.8793 7.70867 11.0624C7.714 11.246 7.65 11.4044 7.51667 11.5378C7.39445 11.66 7.23889 11.7211 7.05 11.7211C6.86111 11.7211 6.70556 11.66 6.58334 11.5378Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M16.475 17.3067L11.875 12.7067C11.775 12.6067 11.7043 12.4983 11.663 12.3817C11.621 12.265 11.6 12.14 11.6 12.0067C11.6 11.8733 11.621 11.7483 11.663 11.6317C11.7043 11.515 11.775 11.4067 11.875 11.3067L16.475 6.70667C16.6583 6.52334 16.8873 6.42734 17.162 6.41867C17.4373 6.41067 17.675 6.50667 17.875 6.70667C18.0583 6.89001 18.15 7.12334 18.15 7.40667C18.15 7.69001 18.0583 7.92334 17.875 8.10667L14 12.0067L17.875 15.9067C18.0583 16.09 18.154 16.319 18.162 16.5937C18.1707 16.869 18.075 17.1067 17.875 17.3067C17.6917 17.49 17.4583 17.5817 17.175 17.5817C16.8917 17.5817 16.6583 17.49 16.475 17.3067ZM9.875 17.3067L5.275 12.7067C5.175 12.6067 5.10433 12.4983 5.063 12.3817C5.021 12.265 5 12.14 5 12.0067C5 11.8733 5.021 11.7483 5.063 11.6317C5.10433 11.515 5.175 11.4067 5.275 11.3067L9.875 6.70667C10.0583 6.52334 10.2877 6.42734 10.563 6.41867C10.8377 6.41067 11.075 6.50667 11.275 6.70667C11.4583 6.89001 11.55 7.12334 11.55 7.40667C11.55 7.69001 11.4583 7.92334 11.275 8.10667L7.4 12.0067L11.275 15.9067C11.4583 16.09 11.5543 16.319 11.563 16.5937C11.571 16.869 11.475 17.1067 11.275 17.3067C11.0917 17.49 10.8583 17.5817 10.575 17.5817C10.2917 17.5817 10.0583 17.49 9.875 17.3067Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M19.2208 20.191L13.8542 14.8243C13.7375 14.7077 13.6551 14.5813 13.6068 14.4452C13.5578 14.3091 13.5333 14.1632 13.5333 14.0077C13.5333 13.8521 13.5578 13.7063 13.6068 13.5702C13.6551 13.4341 13.7375 13.3077 13.8542 13.191L19.2208 7.82433C19.4347 7.61044 19.7019 7.49844 20.0223 7.48833C20.3436 7.479 20.6208 7.591 20.8542 7.82433C21.0681 8.03822 21.175 8.31044 21.175 8.641C21.175 8.97155 21.0681 9.24378 20.8542 9.45766L16.3333 14.0077L20.8542 18.5577C21.0681 18.7716 21.1797 19.0387 21.189 19.3592C21.1991 19.6804 21.0875 19.9577 20.8542 20.191C20.6403 20.4049 20.3681 20.5118 20.0375 20.5118C19.7069 20.5118 19.4347 20.4049 19.2208 20.191ZM11.5208 20.191L6.15417 14.8243C6.0375 14.7077 5.95506 14.5813 5.90684 14.4452C5.85784 14.3091 5.83334 14.1632 5.83334 14.0077C5.83334 13.8521 5.85784 13.7063 5.90684 13.5702C5.95506 13.4341 6.0375 13.3077 6.15417 13.191L11.5208 7.82433C11.7347 7.61044 12.0023 7.49844 12.3235 7.48833C12.6439 7.479 12.9208 7.591 13.1542 7.82433C13.3681 8.03822 13.475 8.31044 13.475 8.641C13.475 8.97155 13.3681 9.24378 13.1542 9.45766L8.63334 14.0077L13.1542 18.5577C13.3681 18.7716 13.4801 19.0387 13.4902 19.3592C13.4995 19.6804 13.3875 19.9577 13.1542 20.191C12.9403 20.4049 12.6681 20.5118 12.3375 20.5118C12.0069 20.5118 11.7347 20.4049 11.5208 20.191Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1o; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-double-arrow-left",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1n = "/*!@:host*/.sc-swirl-icon-double-arrow-right-h{display:inline-flex}";

class SwirlIconDoubleArrowRight {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4.08503 11.5291C3.9628 11.4068 3.90169 11.2513 3.90169 11.0624C3.90169 10.8735 3.9628 10.7179 4.08503 10.5957L6.66836 7.99572L4.08503 5.39572C3.9628 5.2735 3.89903 5.12061 3.89369 4.93705C3.88792 4.75394 3.95169 4.59572 4.08503 4.46239C4.20725 4.34016 4.3628 4.27905 4.55169 4.27905C4.74058 4.27905 4.89614 4.34016 5.01836 4.46239L8.08503 7.52905C8.15169 7.59572 8.19903 7.66794 8.22703 7.74572C8.25458 7.8235 8.26836 7.90683 8.26836 7.99572C8.26836 8.08461 8.25458 8.16794 8.22703 8.24572C8.19903 8.3235 8.15169 8.39572 8.08503 8.46239L5.01836 11.5291C4.89614 11.6513 4.74325 11.7151 4.55969 11.7204C4.37658 11.7262 4.21836 11.6624 4.08503 11.5291ZM8.48503 11.5291C8.3628 11.4068 8.30169 11.2513 8.30169 11.0624C8.30169 10.8735 8.3628 10.7179 8.48503 10.5957L11.0684 7.99572L8.48503 5.39572C8.3628 5.2735 8.2988 5.12061 8.29303 4.93705C8.28769 4.75394 8.35169 4.59572 8.48503 4.46239C8.60725 4.34016 8.7628 4.27905 8.95169 4.27905C9.14058 4.27905 9.29614 4.34016 9.41836 4.46239L12.485 7.52905C12.5517 7.59572 12.5988 7.66794 12.6264 7.74572C12.6544 7.8235 12.6684 7.90683 12.6684 7.99572C12.6684 8.08461 12.6544 8.16794 12.6264 8.24572C12.5988 8.3235 12.5517 8.39572 12.485 8.46239L9.41836 11.5291C9.29614 11.6513 9.14347 11.7151 8.96036 11.7204C8.7768 11.7262 8.61836 11.6624 8.48503 11.5291Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M6.12754 17.2937C5.94421 17.1104 5.85254 16.877 5.85254 16.5937C5.85254 16.3104 5.94421 16.077 6.12754 15.8937L10.0025 11.9937L6.12754 8.0937C5.94421 7.91037 5.84854 7.68103 5.84054 7.4057C5.83187 7.13103 5.92754 6.8937 6.12754 6.6937C6.31087 6.51037 6.54421 6.4187 6.82754 6.4187C7.11087 6.4187 7.34421 6.51037 7.52754 6.6937L12.1275 11.2937C12.2275 11.3937 12.2985 11.502 12.3405 11.6187C12.3819 11.7354 12.4025 11.8604 12.4025 11.9937C12.4025 12.127 12.3819 12.252 12.3405 12.3687C12.2985 12.4854 12.2275 12.5937 12.1275 12.6937L7.52754 17.2937C7.34421 17.477 7.11487 17.5727 6.83954 17.5807C6.56487 17.5894 6.32754 17.4937 6.12754 17.2937ZM12.7275 17.2937C12.5442 17.1104 12.4525 16.877 12.4525 16.5937C12.4525 16.3104 12.5442 16.077 12.7275 15.8937L16.6025 11.9937L12.7275 8.0937C12.5442 7.91037 12.4482 7.68103 12.4395 7.4057C12.4315 7.13103 12.5275 6.8937 12.7275 6.6937C12.9109 6.51037 13.1442 6.4187 13.4275 6.4187C13.7109 6.4187 13.9442 6.51037 14.1275 6.6937L18.7275 11.2937C18.8275 11.3937 18.8982 11.502 18.9395 11.6187C18.9815 11.7354 19.0025 11.8604 19.0025 11.9937C19.0025 12.127 18.9815 12.252 18.9395 12.3687C18.8982 12.4854 18.8275 12.5937 18.7275 12.6937L14.1275 17.2937C13.9442 17.477 13.7152 17.5727 13.4405 17.5807C13.1652 17.5894 12.9275 17.4937 12.7275 17.2937Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M7.14879 20.176C6.93491 19.9621 6.82796 19.6899 6.82796 19.3594C6.82796 19.0288 6.93491 18.7566 7.14879 18.5427L11.6696 13.9927L7.14879 9.44269C6.93491 9.2288 6.82329 8.96125 6.81396 8.64003C6.80385 8.31958 6.91546 8.04269 7.14879 7.80936C7.36268 7.59547 7.63491 7.48853 7.96546 7.48853C8.29602 7.48853 8.56824 7.59547 8.78213 7.80936L14.1488 13.176C14.2655 13.2927 14.3483 13.4191 14.3973 13.5552C14.4455 13.6913 14.4696 13.8371 14.4696 13.9927C14.4696 14.1482 14.4455 14.2941 14.3973 14.4302C14.3483 14.5663 14.2655 14.6927 14.1488 14.8094L8.78213 20.176C8.56824 20.3899 8.30068 20.5015 7.97946 20.5109C7.65902 20.521 7.38213 20.4094 7.14879 20.176ZM14.8488 20.176C14.6349 19.9621 14.528 19.6899 14.528 19.3594C14.528 19.0288 14.6349 18.7566 14.8488 18.5427L19.3696 13.9927L14.8488 9.44269C14.6349 9.2288 14.5229 8.96125 14.5128 8.64003C14.5035 8.31958 14.6155 8.04269 14.8488 7.80936C15.0627 7.59547 15.3349 7.48853 15.6655 7.48853C15.996 7.48853 16.2682 7.59547 16.4821 7.80936L21.8488 13.176C21.9655 13.2927 22.0479 13.4191 22.0961 13.5552C22.1451 13.6913 22.1696 13.8371 22.1696 13.9927C22.1696 14.1482 22.1451 14.2941 22.0961 14.4302C22.0479 14.5663 21.9655 14.6927 21.8488 14.8094L16.4821 20.176C16.2682 20.3899 16.0011 20.5015 15.6806 20.5109C15.3594 20.521 15.0821 20.4094 14.8488 20.176Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1n; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-double-arrow-right",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1m = "/*!@:host*/.sc-swirl-icon-download-h{display:inline-flex}";

class SwirlIconDownload {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.99999 10.2333C7.89999 10.2333 7.80555 10.2167 7.71666 10.1833C7.62777 10.15 7.54444 10.0944 7.46666 10.0167L5.01666 7.56665C4.87222 7.42221 4.79999 7.24443 4.79999 7.03332C4.79999 6.82221 4.87222 6.64443 5.01666 6.49999C5.14999 6.36665 5.32488 6.29732 5.54133 6.29199C5.75822 6.28621 5.93888 6.34999 6.08333 6.48332L7.23333 7.64999V3.04999C7.23333 2.83888 7.30844 2.6611 7.45866 2.51665C7.60844 2.37221 7.78888 2.29999 7.99999 2.29999C8.2111 2.29999 8.39155 2.37221 8.54133 2.51665C8.69155 2.6611 8.76666 2.83888 8.76666 3.04999V7.64999L9.91666 6.48332C10.0611 6.34999 10.2418 6.28621 10.4587 6.29199C10.6751 6.29732 10.85 6.36665 10.9833 6.49999C11.1278 6.64443 11.2 6.82221 11.2 7.03332C11.2 7.24443 11.1278 7.42221 10.9833 7.56665L8.53333 10.0167C8.45555 10.0944 8.37222 10.15 8.28333 10.1833C8.19444 10.2167 8.09999 10.2333 7.99999 10.2333ZM3.91666 13.5833C3.49444 13.5833 3.13622 13.436 2.84199 13.1413C2.54733 12.8471 2.39999 12.4889 2.39999 12.0667V10.5833C2.39999 10.3722 2.47511 10.1944 2.62533 10.05C2.77511 9.90554 2.95555 9.83332 3.16666 9.83332C3.37777 9.83332 3.55555 9.90554 3.69999 10.05C3.84444 10.1944 3.91666 10.3722 3.91666 10.5833V12.0667H12.0667V10.5833C12.0667 10.3722 12.1418 10.1944 12.292 10.05C12.4418 9.90554 12.6222 9.83332 12.8333 9.83332C13.0444 9.83332 13.2222 9.90554 13.3667 10.05C13.5111 10.1944 13.5833 10.3722 13.5833 10.5833V12.0667C13.5833 12.4889 13.436 12.8471 13.1413 13.1413C12.8471 13.436 12.4889 13.5833 12.0667 13.5833H3.91666Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 15.35C11.85 15.35 11.7083 15.325 11.575 15.275C11.4417 15.225 11.3167 15.1417 11.2 15.025L7.52501 11.35C7.30834 11.1333 7.20001 10.8667 7.20001 10.55C7.20001 10.2333 7.30834 9.96668 7.52501 9.75001C7.72501 9.55001 7.98734 9.44601 8.31201 9.43801C8.63734 9.42935 8.90834 9.52501 9.12501 9.72501L10.85 11.475V4.57501C10.85 4.25835 10.9627 3.99168 11.188 3.77501C11.4127 3.55835 11.6833 3.45001 12 3.45001C12.3167 3.45001 12.5873 3.55835 12.812 3.77501C13.0373 3.99168 13.15 4.25835 13.15 4.57501V11.475L14.875 9.72501C15.0917 9.52501 15.3627 9.42935 15.688 9.43801C16.0127 9.44601 16.275 9.55001 16.475 9.75001C16.6917 9.96668 16.8 10.2333 16.8 10.55C16.8 10.8667 16.6917 11.1333 16.475 11.35L12.8 15.025C12.6833 15.1417 12.5583 15.225 12.425 15.275C12.2917 15.325 12.15 15.35 12 15.35ZM5.87501 20.375C5.24167 20.375 4.70434 20.154 4.26301 19.712C3.82101 19.2707 3.60001 18.7333 3.60001 18.1V15.875C3.60001 15.5583 3.71267 15.2917 3.93801 15.075C4.16267 14.8583 4.43334 14.75 4.75001 14.75C5.06667 14.75 5.33334 14.8583 5.55001 15.075C5.76667 15.2917 5.87501 15.5583 5.87501 15.875V18.1H18.1V15.875C18.1 15.5583 18.2127 15.2917 18.438 15.075C18.6627 14.8583 18.9333 14.75 19.25 14.75C19.5667 14.75 19.8333 14.8583 20.05 15.075C20.2667 15.2917 20.375 15.5583 20.375 15.875V18.1C20.375 18.7333 20.154 19.2707 19.712 19.712C19.2707 20.154 18.7333 20.375 18.1 20.375H5.87501Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 17.9084C13.825 17.9084 13.6597 17.8792 13.5042 17.8209C13.3486 17.7625 13.2028 17.6653 13.0667 17.5292L8.77918 13.2417C8.5264 12.9889 8.40001 12.6778 8.40001 12.3084C8.40001 11.9389 8.5264 11.6278 8.77918 11.375C9.01251 11.1417 9.31857 11.0204 9.69735 11.011C10.0769 11.0009 10.3931 11.1125 10.6458 11.3459L12.6583 13.3875V5.33752C12.6583 4.96808 12.7898 4.65697 13.0527 4.40419C13.3148 4.15141 13.6306 4.02502 14 4.02502C14.3695 4.02502 14.6852 4.15141 14.9473 4.40419C15.2102 4.65697 15.3417 4.96808 15.3417 5.33752V13.3875L17.3542 11.3459C17.607 11.1125 17.9231 11.0009 18.3027 11.011C18.6815 11.0204 18.9875 11.1417 19.2208 11.375C19.4736 11.6278 19.6 11.9389 19.6 12.3084C19.6 12.6778 19.4736 12.9889 19.2208 13.2417L14.9333 17.5292C14.7972 17.6653 14.6514 17.7625 14.4958 17.8209C14.3403 17.8792 14.175 17.9084 14 17.9084ZM6.85418 23.7709C6.11529 23.7709 5.4884 23.513 4.97351 22.9974C4.45785 22.4825 4.20001 21.8556 4.20001 21.1167V18.5209C4.20001 18.1514 4.33146 17.8403 4.59435 17.5875C4.85646 17.3347 5.17223 17.2084 5.54168 17.2084C5.91112 17.2084 6.22223 17.3347 6.47501 17.5875C6.72779 17.8403 6.85418 18.1514 6.85418 18.5209V21.1167H21.1167V18.5209C21.1167 18.1514 21.2481 17.8403 21.511 17.5875C21.7731 17.3347 22.0889 17.2084 22.4583 17.2084C22.8278 17.2084 23.1389 17.3347 23.3917 17.5875C23.6445 17.8403 23.7708 18.1514 23.7708 18.5209V21.1167C23.7708 21.8556 23.513 22.4825 22.9973 22.9974C22.4825 23.513 21.8556 23.7709 21.1167 23.7709H6.85418Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1m; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-download",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1l = "/*!@:host*/.sc-swirl-icon-drag-handle-h{display:inline-flex}";

class SwirlIconDragHandle {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("rect", { x: "9", y: "3", width: "2", height: "2", rx: "1", fill: "currentColor" }), hAsync("rect", { x: "9", y: "7", width: "2", height: "2", rx: "1", fill: "currentColor" }), hAsync("rect", { x: "9", y: "11", width: "2", height: "2", rx: "1", fill: "currentColor" }), hAsync("rect", { x: "5", y: "3", width: "2", height: "2", rx: "1", fill: "currentColor" }), hAsync("rect", { x: "5", y: "7", width: "2", height: "2", rx: "1", fill: "currentColor" }), hAsync("rect", { x: "5", y: "11", width: "2", height: "2", rx: "1", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("rect", { x: "13.5", y: "4.5", width: "3", height: "3", rx: "1.5", fill: "currentColor" }), hAsync("rect", { x: "13.5", y: "10.5", width: "3", height: "3", rx: "1.5", fill: "currentColor" }), hAsync("rect", { x: "13.5", y: "16.5", width: "3", height: "3", rx: "1.5", fill: "currentColor" }), hAsync("rect", { x: "7.5", y: "4.5", width: "3", height: "3", rx: "1.5", fill: "currentColor" }), hAsync("rect", { x: "7.5", y: "10.5", width: "3", height: "3", rx: "1.5", fill: "currentColor" }), hAsync("rect", { x: "7.5", y: "16.5", width: "3", height: "3", rx: "1.5", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("rect", { x: "15.75", y: "5.25", width: "3.5", height: "3.5", rx: "1.75", fill: "currentColor" }), hAsync("rect", { x: "15.75", y: "12.25", width: "3.5", height: "3.5", rx: "1.75", fill: "currentColor" }), hAsync("rect", { x: "15.75", y: "19.25", width: "3.5", height: "3.5", rx: "1.75", fill: "currentColor" }), hAsync("rect", { x: "8.75", y: "5.25", width: "3.5", height: "3.5", rx: "1.75", fill: "currentColor" }), hAsync("rect", { x: "8.75", y: "12.25", width: "3.5", height: "3.5", rx: "1.75", fill: "currentColor" }), hAsync("rect", { x: "8.75", y: "19.25", width: "3.5", height: "3.5", rx: "1.75", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1l; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-drag-handle",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1k = "/*!@:host*/.sc-swirl-icon-edit-h{display:inline-flex}";

class SwirlIconEdit {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.7025 6.06027L9.912 3.29863L10.8312 2.37808C11.0829 2.12603 11.3922 2 11.759 2C12.1254 2 12.4344 2.12603 12.6861 2.37808L13.6054 3.29863C13.8571 3.55068 13.9884 3.8549 13.9993 4.21129C14.0103 4.56723 13.8899 4.87123 13.6382 5.12329L12.7025 6.06027ZM2.6566 14C2.47056 14 2.31473 13.9369 2.1891 13.8106C2.06303 13.6848 2 13.5288 2 13.3425V11.4849C2 11.3973 2.01641 11.3124 2.04924 11.2305C2.08207 11.1481 2.13132 11.074 2.19698 11.0082L8.95993 4.23562L11.7505 7.03014L4.98752 13.8027C4.92186 13.8685 4.8481 13.9178 4.76624 13.9507C4.68395 13.9836 4.59903 14 4.51148 14H2.6566Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M19.0538 9.09041L14.868 4.94795L16.2469 3.56712C16.6244 3.18904 17.0883 3 17.6385 3C18.1881 3 18.6516 3.18904 19.0292 3.56712L20.408 4.94795C20.7856 5.32603 20.9826 5.78236 20.999 6.31693C21.0154 6.85085 20.8348 7.30685 20.4573 7.68493L19.0538 9.09041ZM3.9849 21C3.70584 21 3.47209 20.9053 3.28365 20.7159C3.09455 20.5272 3 20.2931 3 20.0137V17.2274C3 17.0959 3.02462 16.9687 3.07387 16.8457C3.12311 16.7221 3.19698 16.611 3.29547 16.5123L13.4399 6.35342L17.6257 10.5452L7.48128 20.7041C7.38279 20.8027 7.27215 20.8767 7.14937 20.926C7.02593 20.9753 6.89855 21 6.76723 21H3.9849Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M22.2294 10.6055L17.346 5.7726L18.9547 4.16164C19.3951 3.72055 19.9363 3.5 20.5783 3.5C21.2194 3.5 21.7602 3.72055 22.2007 4.16164L23.8094 5.7726C24.2498 6.2137 24.4797 6.74608 24.4988 7.36975C24.518 7.99266 24.3073 8.52466 23.8668 8.96575L22.2294 10.6055ZM4.64905 24.5C4.32348 24.5 4.05078 24.3895 3.83093 24.1686C3.61031 23.9484 3.5 23.6753 3.5 23.3493V20.0986C3.5 19.9452 3.52873 19.7968 3.58618 19.6533C3.64363 19.5091 3.72981 19.3795 3.84471 19.2644L15.6799 7.41233L20.5633 12.3027L8.72816 24.1548C8.61325 24.2699 8.48418 24.3562 8.34093 24.4137C8.19691 24.4712 8.0483 24.5 7.8951 24.5H4.64905Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1k; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-edit",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1j = "/*!@:host*/.sc-swirl-icon-emoji-mood-h{display:inline-flex}";

class SwirlIconEmojiMood {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M10.3 7.36668C10.6 7.36668 10.8471 7.26935 11.0413 7.07468C11.236 6.88046 11.3333 6.63335 11.3333 6.33335C11.3333 6.03335 11.236 5.78601 11.0413 5.59135C10.8471 5.39712 10.6 5.30001 10.3 5.30001C10 5.30001 9.7529 5.39712 9.55868 5.59135C9.36401 5.78601 9.26668 6.03335 9.26668 6.33335C9.26668 6.63335 9.36401 6.88046 9.55868 7.07468C9.7529 7.26935 10 7.36668 10.3 7.36668V7.36668ZM5.70001 7.36668C6.00001 7.36668 6.24735 7.26935 6.44201 7.07468C6.63623 6.88046 6.73335 6.63335 6.73335 6.33335C6.73335 6.03335 6.63623 5.78601 6.44201 5.59135C6.24735 5.39712 6.00001 5.30001 5.70001 5.30001C5.40001 5.30001 5.1529 5.39712 4.95868 5.59135C4.76401 5.78601 4.66668 6.03335 4.66668 6.33335C4.66668 6.63335 4.76401 6.88046 4.95868 7.07468C5.1529 7.26935 5.40001 7.36668 5.70001 7.36668V7.36668ZM8.00001 11.6667C8.6889 11.6667 9.30557 11.5 9.85001 11.1667C10.3945 10.8333 10.8278 10.3945 11.15 9.85001C11.2389 9.70557 11.2445 9.57512 11.1667 9.45868C11.0889 9.34179 10.9611 9.28335 10.7833 9.28335H5.21668C5.0389 9.28335 4.91112 9.34179 4.83335 9.45868C4.75557 9.57512 4.76112 9.70557 4.85001 9.85001C5.17223 10.3945 5.60557 10.8333 6.15001 11.1667C6.69446 11.5 7.31112 11.6667 8.00001 11.6667ZM8.00001 14.8C7.05557 14.8 6.16935 14.6222 5.34135 14.2667C4.51379 13.9111 3.79446 13.4278 3.18335 12.8167C2.57223 12.2056 2.0889 11.4862 1.73335 10.6587C1.37779 9.83068 1.20001 8.94446 1.20001 8.00001C1.20001 7.05557 1.37779 6.16935 1.73335 5.34135C2.0889 4.51379 2.57223 3.79446 3.18335 3.18335C3.79446 2.57223 4.51379 2.0889 5.34135 1.73335C6.16935 1.37779 7.05557 1.20001 8.00001 1.20001C8.94446 1.20001 9.83068 1.37779 10.6587 1.73335C11.4862 2.0889 12.2056 2.57223 12.8167 3.18335C13.4278 3.79446 13.9111 4.51379 14.2667 5.34135C14.6222 6.16935 14.8 7.05557 14.8 8.00001C14.8 8.94446 14.6222 9.83068 14.2667 10.6587C13.9111 11.4862 13.4278 12.2056 12.8167 12.8167C12.2056 13.4278 11.4862 13.9111 10.6587 14.2667C9.83068 14.6222 8.94446 14.8 8.00001 14.8ZM8.00001 13.2833C9.46668 13.2833 10.714 12.7696 11.742 11.742C12.7696 10.714 13.2833 9.46668 13.2833 8.00001C13.2833 6.53335 12.7696 5.28601 11.742 4.25801C10.714 3.23046 9.46668 2.71668 8.00001 2.71668C6.53335 2.71668 5.28623 3.23046 4.25868 4.25801C3.23068 5.28601 2.71668 6.53335 2.71668 8.00001C2.71668 9.46668 3.23068 10.714 4.25868 11.742C5.28623 12.7696 6.53335 13.2833 8.00001 13.2833Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M15.45 11.05C15.9 11.05 16.2707 10.904 16.562 10.612C16.854 10.3207 17 9.94999 17 9.49999C17 9.04999 16.854 8.67899 16.562 8.38699C16.2707 8.09565 15.9 7.94999 15.45 7.94999C15 7.94999 14.6293 8.09565 14.338 8.38699C14.046 8.67899 13.9 9.04999 13.9 9.49999C13.9 9.94999 14.046 10.3207 14.338 10.612C14.6293 10.904 15 11.05 15.45 11.05ZM8.54999 11.05C8.99999 11.05 9.37099 10.904 9.66299 10.612C9.95432 10.3207 10.1 9.94999 10.1 9.49999C10.1 9.04999 9.95432 8.67899 9.66299 8.38699C9.37099 8.09565 8.99999 7.94999 8.54999 7.94999C8.09999 7.94999 7.72932 8.09565 7.43799 8.38699C7.14599 8.67899 6.99999 9.04999 6.99999 9.49999C6.99999 9.94999 7.14599 10.3207 7.43799 10.612C7.72932 10.904 8.09999 11.05 8.54999 11.05ZM12 17.5C13.0333 17.5 13.9583 17.25 14.775 16.75C15.5917 16.25 16.2417 15.5917 16.725 14.775C16.8583 14.5583 16.8667 14.3627 16.75 14.188C16.6333 14.0127 16.4417 13.925 16.175 13.925H7.82499C7.55832 13.925 7.36665 14.0127 7.24999 14.188C7.13332 14.3627 7.14165 14.5583 7.27499 14.775C7.75832 15.5917 8.40832 16.25 9.22499 16.75C10.0417 17.25 10.9667 17.5 12 17.5ZM12 22.2C10.5833 22.2 9.25399 21.9333 8.01199 21.4C6.77065 20.8667 5.69165 20.1417 4.77499 19.225C3.85832 18.3083 3.13332 17.2293 2.59999 15.988C2.06665 14.746 1.79999 13.4167 1.79999 12C1.79999 10.5833 2.06665 9.25399 2.59999 8.01199C3.13332 6.77065 3.85832 5.69165 4.77499 4.77499C5.69165 3.85832 6.77065 3.13332 8.01199 2.59999C9.25399 2.06665 10.5833 1.79999 12 1.79999C13.4167 1.79999 14.746 2.06665 15.988 2.59999C17.2293 3.13332 18.3083 3.85832 19.225 4.77499C20.1417 5.69165 20.8667 6.77065 21.4 8.01199C21.9333 9.25399 22.2 10.5833 22.2 12C22.2 13.4167 21.9333 14.746 21.4 15.988C20.8667 17.2293 20.1417 18.3083 19.225 19.225C18.3083 20.1417 17.2293 20.8667 15.988 21.4C14.746 21.9333 13.4167 22.2 12 22.2ZM12 19.925C14.2 19.925 16.071 19.1543 17.613 17.613C19.1543 16.071 19.925 14.2 19.925 12C19.925 9.79999 19.1543 7.92899 17.613 6.38699C16.071 4.84565 14.2 4.07499 12 4.07499C9.79999 4.07499 7.92932 4.84565 6.38799 6.38699C4.84599 7.92899 4.07499 9.79999 4.07499 12C4.07499 14.2 4.84599 16.071 6.38799 17.613C7.92932 19.1543 9.79999 19.925 12 19.925Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M18.025 12.8916C18.55 12.8916 18.9825 12.7213 19.3223 12.3806C19.663 12.0408 19.8333 11.6083 19.8333 11.0833C19.8333 10.5583 19.663 10.1255 19.3223 9.78481C18.9825 9.44492 18.55 9.27497 18.025 9.27497C17.5 9.27497 17.0676 9.44492 16.7277 9.78481C16.387 10.1255 16.2167 10.5583 16.2167 11.0833C16.2167 11.6083 16.387 12.0408 16.7277 12.3806C17.0676 12.7213 17.5 12.8916 18.025 12.8916V12.8916ZM9.97501 12.8916C10.5 12.8916 10.9328 12.7213 11.2735 12.3806C11.6134 12.0408 11.7833 11.6083 11.7833 11.0833C11.7833 10.5583 11.6134 10.1255 11.2735 9.78481C10.9328 9.44492 10.5 9.27497 9.97501 9.27497C9.45001 9.27497 9.01756 9.44492 8.67767 9.78481C8.33701 10.1255 8.16667 10.5583 8.16667 11.0833C8.16667 11.6083 8.33701 12.0408 8.67767 12.3806C9.01756 12.7213 9.45001 12.8916 9.97501 12.8916V12.8916ZM14 20.4166C15.2056 20.4166 16.2847 20.125 17.2375 19.5416C18.1903 18.9583 18.9486 18.1903 19.5125 17.2375C19.6681 16.9847 19.6778 16.7564 19.5417 16.5526C19.4056 16.3481 19.1819 16.2458 18.8708 16.2458H9.12917C8.81806 16.2458 8.59445 16.3481 8.45834 16.5526C8.32223 16.7564 8.33195 16.9847 8.48751 17.2375C9.0514 18.1903 9.80973 18.9583 10.7625 19.5416C11.7153 20.125 12.7944 20.4166 14 20.4166ZM14 25.9C12.3472 25.9 10.7963 25.5889 9.34734 24.9666C7.89912 24.3444 6.64028 23.4986 5.57084 22.4291C4.5014 21.3597 3.65556 20.1009 3.03334 18.6526C2.41112 17.2036 2.10001 15.6528 2.10001 14C2.10001 12.3472 2.41112 10.7963 3.03334 9.34731C3.65556 7.89909 4.5014 6.64025 5.57084 5.57081C6.64028 4.50136 7.89912 3.65553 9.34734 3.03331C10.7963 2.41109 12.3472 2.09998 14 2.09998C15.6528 2.09998 17.2037 2.41109 18.6527 3.03331C20.1009 3.65553 21.3597 4.50136 22.4292 5.57081C23.4986 6.64025 24.3445 7.89909 24.9667 9.34731C25.5889 10.7963 25.9 12.3472 25.9 14C25.9 15.6528 25.5889 17.2036 24.9667 18.6526C24.3445 20.1009 23.4986 21.3597 22.4292 22.4291C21.3597 23.4986 20.1009 24.3444 18.6527 24.9666C17.2037 25.5889 15.6528 25.9 14 25.9ZM14 23.2458C16.5667 23.2458 18.7495 22.3467 20.5485 20.5485C22.3467 18.7495 23.2458 16.5666 23.2458 14C23.2458 11.4333 22.3467 9.25048 20.5485 7.45148C18.7495 5.65325 16.5667 4.75414 14 4.75414C11.4333 4.75414 9.2509 5.65325 7.45267 7.45148C5.65367 9.25048 4.75417 11.4333 4.75417 14C4.75417 16.5666 5.65367 18.7495 7.45267 20.5485C9.2509 22.3467 11.4333 23.2458 14 23.2458Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1j; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-emoji-mood",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1i = "/*!@:host*/.sc-swirl-icon-emoji-satisfied-h{display:inline-flex}";

class SwirlIconEmojiSatisfied {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M10.3 7.36668C10.6 7.36668 10.8471 7.26935 11.0413 7.07468C11.236 6.88046 11.3333 6.63335 11.3333 6.33335C11.3333 6.03335 11.236 5.78601 11.0413 5.59135C10.8471 5.39712 10.6 5.30001 10.3 5.30001C10 5.30001 9.7529 5.39712 9.55868 5.59135C9.36401 5.78601 9.26668 6.03335 9.26668 6.33335C9.26668 6.63335 9.36401 6.88046 9.55868 7.07468C9.7529 7.26935 10 7.36668 10.3 7.36668V7.36668ZM5.70001 7.36668C6.00001 7.36668 6.24735 7.26935 6.44201 7.07468C6.63623 6.88046 6.73335 6.63335 6.73335 6.33335C6.73335 6.03335 6.63623 5.78601 6.44201 5.59135C6.24735 5.39712 6.00001 5.30001 5.70001 5.30001C5.40001 5.30001 5.1529 5.39712 4.95868 5.59135C4.76401 5.78601 4.66668 6.03335 4.66668 6.33335C4.66668 6.63335 4.76401 6.88046 4.95868 7.07468C5.1529 7.26935 5.40001 7.36668 5.70001 7.36668V7.36668ZM8.00001 11.6667C8.62223 11.6667 9.19157 11.5278 9.70801 11.25C10.2249 10.9722 10.6278 10.6278 10.9167 10.2167C11.0611 10.0056 11.0833 9.80557 10.9833 9.61668C10.8833 9.42779 10.7278 9.33335 10.5167 9.33335C10.4389 9.33335 10.3556 9.35846 10.2667 9.40868C10.1778 9.45846 10.1056 9.51668 10.05 9.58335C9.81668 9.89446 9.52512 10.1418 9.17535 10.3253C8.82512 10.5085 8.43335 10.6 8.00001 10.6C7.56668 10.6 7.17512 10.5085 6.82535 10.3253C6.47512 10.1418 6.18335 9.89446 5.95001 9.58335C5.89446 9.51668 5.81957 9.45846 5.72535 9.40868C5.63068 9.35846 5.54446 9.33335 5.46668 9.33335C5.26668 9.33335 5.11668 9.4249 5.01668 9.60801C4.91668 9.79157 4.9389 9.9889 5.08335 10.2C5.37223 10.6222 5.77512 10.9722 6.29201 11.25C6.80846 11.5278 7.37779 11.6667 8.00001 11.6667ZM8.00001 14.8C7.05557 14.8 6.16935 14.6222 5.34135 14.2667C4.51379 13.9111 3.79446 13.4278 3.18335 12.8167C2.57223 12.2056 2.0889 11.4862 1.73335 10.6587C1.37779 9.83068 1.20001 8.94446 1.20001 8.00001C1.20001 7.05557 1.37779 6.16935 1.73335 5.34135C2.0889 4.51379 2.57223 3.79446 3.18335 3.18335C3.79446 2.57223 4.51379 2.0889 5.34135 1.73335C6.16935 1.37779 7.05557 1.20001 8.00001 1.20001C8.94446 1.20001 9.83068 1.37779 10.6587 1.73335C11.4862 2.0889 12.2056 2.57223 12.8167 3.18335C13.4278 3.79446 13.9111 4.51379 14.2667 5.34135C14.6222 6.16935 14.8 7.05557 14.8 8.00001C14.8 8.94446 14.6222 9.83068 14.2667 10.6587C13.9111 11.4862 13.4278 12.2056 12.8167 12.8167C12.2056 13.4278 11.4862 13.9111 10.6587 14.2667C9.83068 14.6222 8.94446 14.8 8.00001 14.8ZM8.00001 13.2833C9.46668 13.2833 10.714 12.7696 11.742 11.742C12.7696 10.714 13.2833 9.46668 13.2833 8.00001C13.2833 6.53335 12.7696 5.28601 11.742 4.25801C10.714 3.23046 9.46668 2.71668 8.00001 2.71668C6.53335 2.71668 5.28623 3.23046 4.25868 4.25801C3.23068 5.28601 2.71668 6.53335 2.71668 8.00001C2.71668 9.46668 3.23068 10.714 4.25868 11.742C5.28623 12.7696 6.53335 13.2833 8.00001 13.2833Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M15.45 11.05C15.9 11.05 16.2707 10.904 16.562 10.612C16.854 10.3207 17 9.94999 17 9.49999C17 9.04999 16.854 8.67899 16.562 8.38699C16.2707 8.09565 15.9 7.94999 15.45 7.94999C15 7.94999 14.6293 8.09565 14.338 8.38699C14.046 8.67899 13.9 9.04999 13.9 9.49999C13.9 9.94999 14.046 10.3207 14.338 10.612C14.6293 10.904 15 11.05 15.45 11.05ZM8.54999 11.05C8.99999 11.05 9.37099 10.904 9.66299 10.612C9.95432 10.3207 10.1 9.94999 10.1 9.49999C10.1 9.04999 9.95432 8.67899 9.66299 8.38699C9.37099 8.09565 8.99999 7.94999 8.54999 7.94999C8.09999 7.94999 7.72932 8.09565 7.43799 8.38699C7.14599 8.67899 6.99999 9.04999 6.99999 9.49999C6.99999 9.94999 7.14599 10.3207 7.43799 10.612C7.72932 10.904 8.09999 11.05 8.54999 11.05ZM12 17.5C12.9333 17.5 13.7873 17.2917 14.562 16.875C15.3373 16.4583 15.9417 15.9417 16.375 15.325C16.5917 15.0083 16.625 14.7083 16.475 14.425C16.325 14.1417 16.0917 14 15.775 14C15.6583 14 15.5333 14.0377 15.4 14.113C15.2667 14.1877 15.1583 14.275 15.075 14.375C14.725 14.8417 14.2877 15.2127 13.763 15.488C13.2377 15.7627 12.65 15.9 12 15.9C11.35 15.9 10.7627 15.7627 10.238 15.488C9.71265 15.2127 9.27499 14.8417 8.92499 14.375C8.84165 14.275 8.72932 14.1877 8.58799 14.113C8.44599 14.0377 8.31665 14 8.19999 14C7.89999 14 7.67499 14.1373 7.52499 14.412C7.37499 14.6873 7.40832 14.9833 7.62499 15.3C8.05832 15.9333 8.66265 16.4583 9.43799 16.875C10.2127 17.2917 11.0667 17.5 12 17.5ZM12 22.2C10.5833 22.2 9.25399 21.9333 8.01199 21.4C6.77065 20.8667 5.69165 20.1417 4.77499 19.225C3.85832 18.3083 3.13332 17.2293 2.59999 15.988C2.06665 14.746 1.79999 13.4167 1.79999 12C1.79999 10.5833 2.06665 9.25399 2.59999 8.01199C3.13332 6.77065 3.85832 5.69165 4.77499 4.77499C5.69165 3.85832 6.77065 3.13332 8.01199 2.59999C9.25399 2.06665 10.5833 1.79999 12 1.79999C13.4167 1.79999 14.746 2.06665 15.988 2.59999C17.2293 3.13332 18.3083 3.85832 19.225 4.77499C20.1417 5.69165 20.8667 6.77065 21.4 8.01199C21.9333 9.25399 22.2 10.5833 22.2 12C22.2 13.4167 21.9333 14.746 21.4 15.988C20.8667 17.2293 20.1417 18.3083 19.225 19.225C18.3083 20.1417 17.2293 20.8667 15.988 21.4C14.746 21.9333 13.4167 22.2 12 22.2ZM12 19.925C14.2 19.925 16.071 19.1543 17.613 17.613C19.1543 16.071 19.925 14.2 19.925 12C19.925 9.79999 19.1543 7.92899 17.613 6.38699C16.071 4.84565 14.2 4.07499 12 4.07499C9.79999 4.07499 7.92932 4.84565 6.38799 6.38699C4.84599 7.92899 4.07499 9.79999 4.07499 12C4.07499 14.2 4.84599 16.071 6.38799 17.613C7.92932 19.1543 9.79999 19.925 12 19.925Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M18.025 12.8916C18.55 12.8916 18.9825 12.7213 19.3223 12.3806C19.663 12.0408 19.8333 11.6083 19.8333 11.0833C19.8333 10.5583 19.663 10.1255 19.3223 9.78481C18.9825 9.44492 18.55 9.27497 18.025 9.27497C17.5 9.27497 17.0676 9.44492 16.7277 9.78481C16.387 10.1255 16.2167 10.5583 16.2167 11.0833C16.2167 11.6083 16.387 12.0408 16.7277 12.3806C17.0676 12.7213 17.5 12.8916 18.025 12.8916V12.8916ZM9.97501 12.8916C10.5 12.8916 10.9328 12.7213 11.2735 12.3806C11.6134 12.0408 11.7833 11.6083 11.7833 11.0833C11.7833 10.5583 11.6134 10.1255 11.2735 9.78481C10.9328 9.44492 10.5 9.27497 9.97501 9.27497C9.45001 9.27497 9.01756 9.44492 8.67767 9.78481C8.33701 10.1255 8.16667 10.5583 8.16667 11.0833C8.16667 11.6083 8.33701 12.0408 8.67767 12.3806C9.01756 12.7213 9.45001 12.8916 9.97501 12.8916V12.8916ZM14 20.4166C15.0889 20.4166 16.0852 20.1736 16.989 19.6875C17.8936 19.2014 18.5986 18.5986 19.1042 17.8791C19.3569 17.5097 19.3958 17.1597 19.2208 16.8291C19.0458 16.4986 18.7736 16.3333 18.4042 16.3333C18.2681 16.3333 18.1222 16.3773 17.9667 16.4651C17.8111 16.5523 17.6847 16.6541 17.5875 16.7708C17.1792 17.3153 16.6689 17.7481 16.0568 18.0693C15.4439 18.3898 14.7583 18.55 14 18.55C13.2417 18.55 12.5564 18.3898 11.9443 18.0693C11.3314 17.7481 10.8208 17.3153 10.4125 16.7708C10.3153 16.6541 10.1842 16.5523 10.0193 16.4651C9.85367 16.3773 9.70278 16.3333 9.56667 16.3333C9.21667 16.3333 8.95417 16.4935 8.77917 16.814C8.60417 17.1352 8.64306 17.4805 8.89584 17.85C9.40139 18.5889 10.1064 19.2014 11.011 19.6875C11.9148 20.1736 12.9111 20.4166 14 20.4166ZM14 25.9C12.3472 25.9 10.7963 25.5889 9.34734 24.9666C7.89912 24.3444 6.64028 23.4986 5.57084 22.4291C4.5014 21.3597 3.65556 20.1009 3.03334 18.6526C2.41112 17.2036 2.10001 15.6528 2.10001 14C2.10001 12.3472 2.41112 10.7963 3.03334 9.34731C3.65556 7.89909 4.5014 6.64025 5.57084 5.57081C6.64028 4.50136 7.89912 3.65553 9.34734 3.03331C10.7963 2.41109 12.3472 2.09998 14 2.09998C15.6528 2.09998 17.2037 2.41109 18.6527 3.03331C20.1009 3.65553 21.3597 4.50136 22.4292 5.57081C23.4986 6.64025 24.3445 7.89909 24.9667 9.34731C25.5889 10.7963 25.9 12.3472 25.9 14C25.9 15.6528 25.5889 17.2036 24.9667 18.6526C24.3445 20.1009 23.4986 21.3597 22.4292 22.4291C21.3597 23.4986 20.1009 24.3444 18.6527 24.9666C17.2037 25.5889 15.6528 25.9 14 25.9ZM14 23.2458C16.5667 23.2458 18.7495 22.3467 20.5485 20.5485C22.3467 18.7495 23.2458 16.5666 23.2458 14C23.2458 11.4333 22.3467 9.25048 20.5485 7.45148C18.7495 5.65325 16.5667 4.75414 14 4.75414C11.4333 4.75414 9.2509 5.65325 7.45267 7.45148C5.65367 9.25048 4.75417 11.4333 4.75417 14C4.75417 16.5666 5.65367 18.7495 7.45267 20.5485C9.2509 22.3467 11.4333 23.2458 14 23.2458Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1i; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-emoji-satisfied",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1h = "/*!@:host*/.sc-swirl-icon-error-h{display:inline-flex}";

class SwirlIconError {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6.05 14C5.87222 14 5.70267 13.9667 5.54133 13.9C5.38044 13.8333 5.23889 13.7389 5.11667 13.6167L2.38333 10.8833C2.26111 10.7611 2.16667 10.6196 2.1 10.4587C2.03333 10.2973 2 10.1278 2 9.95V6.05C2 5.87222 2.03333 5.70267 2.1 5.54133C2.16667 5.38044 2.26111 5.23889 2.38333 5.11667L5.11667 2.38333C5.23889 2.26111 5.38044 2.16667 5.54133 2.1C5.70267 2.03333 5.87222 2 6.05 2H9.95C10.1278 2 10.2973 2.03333 10.4587 2.1C10.6196 2.16667 10.7611 2.26111 10.8833 2.38333L13.6167 5.11667C13.7389 5.23889 13.8333 5.38044 13.9 5.54133C13.9667 5.70267 14 5.87222 14 6.05V9.95C14 10.1278 13.9667 10.2973 13.9 10.4587C13.8333 10.6196 13.7389 10.7611 13.6167 10.8833L10.8833 13.6167C10.7611 13.7389 10.6196 13.8333 10.4587 13.9C10.2973 13.9667 10.1278 14 9.95 14H6.05ZM8 11.3333C8.18889 11.3333 8.34733 11.2693 8.47533 11.1413C8.60289 11.0138 8.66667 10.8556 8.66667 10.6667C8.66667 10.4778 8.60289 10.3193 8.47533 10.1913C8.34733 10.0638 8.18889 10 8 10C7.81111 10 7.65289 10.0638 7.52533 10.1913C7.39733 10.3193 7.33333 10.4778 7.33333 10.6667C7.33333 10.8556 7.39733 11.0138 7.52533 11.1413C7.65289 11.2693 7.81111 11.3333 8 11.3333ZM8 8.66667C8.18889 8.66667 8.34733 8.60267 8.47533 8.47467C8.60289 8.34711 8.66667 8.18889 8.66667 8V5.33333C8.66667 5.14444 8.60289 4.986 8.47533 4.858C8.34733 4.73044 8.18889 4.66667 8 4.66667C7.81111 4.66667 7.65289 4.73044 7.52533 4.858C7.39733 4.986 7.33333 5.14444 7.33333 5.33333V8C7.33333 8.18889 7.39733 8.34711 7.52533 8.47467C7.65289 8.60267 7.81111 8.66667 8 8.66667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9.075 21C8.80833 21 8.554 20.95 8.312 20.85C8.07067 20.75 7.85833 20.6083 7.675 20.425L3.575 16.325C3.39167 16.1417 3.25 15.9293 3.15 15.688C3.05 15.446 3 15.1917 3 14.925V9.075C3 8.80833 3.05 8.554 3.15 8.312C3.25 8.07067 3.39167 7.85833 3.575 7.675L7.675 3.575C7.85833 3.39167 8.07067 3.25 8.312 3.15C8.554 3.05 8.80833 3 9.075 3H14.925C15.1917 3 15.446 3.05 15.688 3.15C15.9293 3.25 16.1417 3.39167 16.325 3.575L20.425 7.675C20.6083 7.85833 20.75 8.07067 20.85 8.312C20.95 8.554 21 8.80833 21 9.075V14.925C21 15.1917 20.95 15.446 20.85 15.688C20.75 15.9293 20.6083 16.1417 20.425 16.325L16.325 20.425C16.1417 20.6083 15.9293 20.75 15.688 20.85C15.446 20.95 15.1917 21 14.925 21H9.075ZM12 17C12.2833 17 12.521 16.904 12.713 16.712C12.9043 16.5207 13 16.2833 13 16C13 15.7167 12.9043 15.479 12.713 15.287C12.521 15.0957 12.2833 15 12 15C11.7167 15 11.4793 15.0957 11.288 15.287C11.096 15.479 11 15.7167 11 16C11 16.2833 11.096 16.5207 11.288 16.712C11.4793 16.904 11.7167 17 12 17ZM12 13C12.2833 13 12.521 12.904 12.713 12.712C12.9043 12.5207 13 12.2833 13 12V8C13 7.71667 12.9043 7.479 12.713 7.287C12.521 7.09567 12.2833 7 12 7C11.7167 7 11.4793 7.09567 11.288 7.287C11.096 7.479 11 7.71667 11 8V12C11 12.2833 11.096 12.5207 11.288 12.712C11.4793 12.904 11.7167 13 12 13Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M10.5875 24.5C10.2764 24.5 9.97967 24.4417 9.69733 24.325C9.41578 24.2083 9.16806 24.0431 8.95417 23.8292L4.17083 19.0458C3.95694 18.8319 3.79167 18.5842 3.675 18.3027C3.55833 18.0203 3.5 17.7236 3.5 17.4125V10.5875C3.5 10.2764 3.55833 9.97967 3.675 9.69733C3.79167 9.41578 3.95694 9.16806 4.17083 8.95417L8.95417 4.17083C9.16806 3.95694 9.41578 3.79167 9.69733 3.675C9.97967 3.55833 10.2764 3.5 10.5875 3.5H17.4125C17.7236 3.5 18.0203 3.55833 18.3027 3.675C18.5842 3.79167 18.8319 3.95694 19.0458 4.17083L23.8292 8.95417C24.0431 9.16806 24.2083 9.41578 24.325 9.69733C24.4417 9.97967 24.5 10.2764 24.5 10.5875V17.4125C24.5 17.7236 24.4417 18.0203 24.325 18.3027C24.2083 18.5842 24.0431 18.8319 23.8292 19.0458L19.0458 23.8292C18.8319 24.0431 18.5842 24.2083 18.3027 24.325C18.0203 24.4417 17.7236 24.5 17.4125 24.5H10.5875ZM14 19.8333C14.3306 19.8333 14.6078 19.7213 14.8318 19.4973C15.0551 19.2741 15.1667 18.9972 15.1667 18.6667C15.1667 18.3361 15.0551 18.0588 14.8318 17.8348C14.6078 17.6116 14.3306 17.5 14 17.5C13.6694 17.5 13.3926 17.6116 13.1693 17.8348C12.9453 18.0588 12.8333 18.3361 12.8333 18.6667C12.8333 18.9972 12.9453 19.2741 13.1693 19.4973C13.3926 19.7213 13.6694 19.8333 14 19.8333ZM14 15.1667C14.3306 15.1667 14.6078 15.0547 14.8318 14.8307C15.0551 14.6074 15.1667 14.3306 15.1667 14V9.33333C15.1667 9.00278 15.0551 8.7255 14.8318 8.5015C14.6078 8.27828 14.3306 8.16667 14 8.16667C13.6694 8.16667 13.3926 8.27828 13.1693 8.5015C12.9453 8.7255 12.8333 9.00278 12.8333 9.33333V14C12.8333 14.3306 12.9453 14.6074 13.1693 14.8307C13.3926 15.0547 13.6694 15.1667 14 15.1667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1h; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-error",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1g = "/*!@:host*/.sc-swirl-icon-expand-less-h{display:inline-flex}";

class SwirlIconExpandLess {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4.39999 9.85C4.25554 9.70556 4.18332 9.52778 4.18332 9.31667C4.18332 9.10556 4.25554 8.92778 4.39999 8.78333L7.46665 5.71667C7.54443 5.63889 7.62776 5.58333 7.71665 5.55C7.80554 5.51667 7.89999 5.5 7.99999 5.5C8.09999 5.5 8.19443 5.51667 8.28332 5.55C8.37221 5.58333 8.45554 5.63889 8.53332 5.71667L11.6167 8.8C11.7611 8.94444 11.8307 9.11667 11.8253 9.31667C11.8195 9.51667 11.7444 9.69444 11.6 9.85C11.4555 9.98333 11.2778 10.05 11.0667 10.05C10.8555 10.05 10.6778 9.98333 10.5333 9.85L7.99999 7.3L5.44999 9.86667C5.30554 10 5.13332 10.0667 4.93332 10.0667C4.73332 10.0667 4.55554 9.99444 4.39999 9.85V9.85Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M6.59999 14.775C6.38333 14.5583 6.27499 14.2917 6.27499 13.975C6.27499 13.6583 6.38333 13.3917 6.59999 13.175L11.2 8.575C11.3167 8.45833 11.4417 8.375 11.575 8.325C11.7083 8.275 11.85 8.25 12 8.25C12.15 8.25 12.2917 8.275 12.425 8.325C12.5583 8.375 12.6833 8.45833 12.8 8.575L17.425 13.2C17.6417 13.4167 17.746 13.675 17.738 13.975C17.7293 14.275 17.6167 14.5417 17.4 14.775C17.1833 14.975 16.9167 15.075 16.6 15.075C16.2833 15.075 16.0167 14.975 15.8 14.775L12 10.95L8.17499 14.8C7.95833 15 7.69999 15.1 7.39999 15.1C7.09999 15.1 6.83333 14.9917 6.59999 14.775Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M7.7 17.2375C7.44722 16.9847 7.32083 16.6736 7.32083 16.3042C7.32083 15.9347 7.44722 15.6236 7.7 15.3708L13.0667 10.0042C13.2028 9.86806 13.3486 9.77083 13.5042 9.7125C13.6597 9.65417 13.825 9.625 14 9.625C14.175 9.625 14.3403 9.65417 14.4958 9.7125C14.6514 9.77083 14.7972 9.86806 14.9333 10.0042L20.3292 15.4C20.5819 15.6528 20.7037 15.9542 20.6943 16.3042C20.6842 16.6542 20.5528 16.9653 20.3 17.2375C20.0472 17.4708 19.7361 17.5875 19.3667 17.5875C18.9972 17.5875 18.6861 17.4708 18.4333 17.2375L14 12.775L9.5375 17.2667C9.28472 17.5 8.98333 17.6167 8.63333 17.6167C8.28333 17.6167 7.97222 17.4903 7.7 17.2375V17.2375Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1g; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-expand-less",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1f = "/*!@:host*/.sc-swirl-icon-expand-more-h{display:inline-flex}";

class SwirlIconExpandMore {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.99999 10.05C7.89999 10.05 7.80554 10.0334 7.71665 10C7.62777 9.9667 7.54443 9.9167 7.46665 9.85003L4.38332 6.7667C4.23888 6.62225 4.16954 6.44714 4.17532 6.24137C4.18065 6.03603 4.25554 5.86114 4.39999 5.7167C4.54443 5.57225 4.72221 5.50003 4.93332 5.50003C5.14443 5.50003 5.32221 5.57225 5.46665 5.7167L7.99999 8.25003L10.55 5.70003C10.6944 5.55559 10.8695 5.48625 11.0753 5.49203C11.2807 5.49737 11.4555 5.57225 11.6 5.7167C11.7444 5.86114 11.8167 6.03892 11.8167 6.25003C11.8167 6.46114 11.7444 6.63892 11.6 6.78337L8.53332 9.85003C8.45554 9.9167 8.37221 9.9667 8.28332 10C8.19443 10.0334 8.09999 10.05 7.99999 10.05V10.05Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 15.075C11.85 15.075 11.7083 15.05 11.575 15C11.4417 14.95 11.3167 14.875 11.2 14.775L6.57501 10.15C6.35835 9.93338 6.25435 9.67072 6.26301 9.36205C6.27101 9.05405 6.38335 8.79172 6.60001 8.57505C6.81668 8.35838 7.08335 8.25005 7.40001 8.25005C7.71668 8.25005 7.98335 8.35838 8.20001 8.57505L12 12.375L15.825 8.55005C16.0417 8.33338 16.3043 8.22938 16.613 8.23805C16.921 8.24605 17.1833 8.35838 17.4 8.57505C17.6167 8.79172 17.725 9.05838 17.725 9.37505C17.725 9.69172 17.6167 9.95838 17.4 10.175L12.8 14.775C12.6833 14.875 12.5583 14.95 12.425 15C12.2917 15.05 12.15 15.075 12 15.075Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 17.5876C13.825 17.5876 13.6597 17.5584 13.5042 17.5001C13.3486 17.4417 13.2028 17.3542 13.0667 17.2376L7.67083 11.8417C7.41805 11.5889 7.29672 11.2825 7.30683 10.9224C7.31616 10.5631 7.44722 10.257 7.69999 10.0042C7.95277 9.75145 8.26388 9.62506 8.63333 9.62506C9.00277 9.62506 9.31388 9.75145 9.56666 10.0042L14 14.4376L18.4625 9.97506C18.7153 9.72228 19.0217 9.60095 19.3818 9.61106C19.7412 9.62039 20.0472 9.75145 20.3 10.0042C20.5528 10.257 20.6792 10.5681 20.6792 10.9376C20.6792 11.307 20.5528 11.6181 20.3 11.8709L14.9333 17.2376C14.7972 17.3542 14.6514 17.4417 14.4958 17.5001C14.3403 17.5584 14.175 17.5876 14 17.5876V17.5876Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1f; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-expand-more",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1e = "/*!@:host*/.sc-swirl-icon-file-h{display:inline-flex}";

class SwirlIconFile {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.99999 1.33334C3.26666 1.33334 2.67332 1.93334 2.67332 2.66668L2.66666 13.3333C2.66666 14.0667 3.25999 14.6667 3.99332 14.6667H12C12.7333 14.6667 13.3333 14.0667 13.3333 13.3333V5.88668C13.3333 5.53334 13.1933 5.19334 12.94 4.94668L9.71999 1.72668C9.47332 1.47334 9.13332 1.33334 8.77999 1.33334H3.99999ZM8.66666 5.33334V2.33334L12.3333 6.00001H9.33332C8.96666 6.00001 8.66666 5.70001 8.66666 5.33334Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M6 2C4.9 2 4.01 2.9 4.01 4L4 20C4 21.1 4.89 22 5.99 22H18C19.1 22 20 21.1 20 20V8.83C20 8.3 19.79 7.79 19.41 7.42L14.58 2.59C14.21 2.21 13.7 2 13.17 2H6ZM13 8V3.5L18.5 9H14C13.45 9 13 8.55 13 8Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M6.99999 2.33334C5.71666 2.33334 4.67832 3.38334 4.67832 4.66668L4.66666 23.3333C4.66666 24.6167 5.70499 25.6667 6.98832 25.6667H21C22.2833 25.6667 23.3333 24.6167 23.3333 23.3333V10.3017C23.3333 9.68334 23.0883 9.08834 22.645 8.65668L17.01 3.02168C16.5783 2.57834 15.9833 2.33334 15.365 2.33334H6.99999ZM15.1667 9.33334V4.08334L21.5833 10.5H16.3333C15.6917 10.5 15.1667 9.97501 15.1667 9.33334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1e; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-file",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1d = "/*!@:host*/.sc-swirl-icon-file-copy-h{display:inline-flex}";

class SwirlIconFileCopy {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.6667 12.6667H5.33334C4.96667 12.6667 4.65278 12.5362 4.39167 12.2751C4.13056 12.014 4 11.7001 4 11.3334V2.00008C4 1.63341 4.13056 1.31953 4.39167 1.05841C4.65278 0.797304 4.96667 0.666748 5.33334 0.666748H9.45C9.62778 0.666748 9.79723 0.700081 9.95834 0.766748C10.1194 0.833415 10.2611 0.927859 10.3833 1.05008L13.6167 4.28341C13.7389 4.40564 13.8333 4.5473 13.9 4.70841C13.9667 4.86953 14 5.03897 14 5.21675V11.3334C14 11.7001 13.8694 12.014 13.6083 12.2751C13.3472 12.5362 13.0333 12.6667 12.6667 12.6667ZM9.33334 2.00008H5.33334V11.3334H12.6667V5.33341H10C9.81111 5.33341 9.65278 5.26953 9.525 5.14175C9.39723 5.01397 9.33334 4.85564 9.33334 4.66675V2.00008ZM2.66667 15.3334C2.3 15.3334 1.98611 15.2029 1.725 14.9417C1.46389 14.6806 1.33334 14.3667 1.33334 14.0001V5.33341C1.33334 5.14453 1.39722 4.98619 1.525 4.85841C1.65278 4.73064 1.81111 4.66675 2 4.66675C2.18889 4.66675 2.34722 4.73064 2.475 4.85841C2.60278 4.98619 2.66667 5.14453 2.66667 5.33341V14.0001H9.33334C9.52223 14.0001 9.68056 14.064 9.80834 14.1917C9.93611 14.3195 10 14.4779 10 14.6667C10 14.8556 9.93611 15.014 9.80834 15.1417C9.68056 15.2695 9.52223 15.3334 9.33334 15.3334H2.66667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M19 19H8C7.45 19 6.97917 18.8042 6.5875 18.4125C6.19583 18.0208 6 17.55 6 17V3C6 2.45 6.19583 1.97917 6.5875 1.5875C6.97917 1.19583 7.45 1 8 1H14.175C14.4417 1 14.6958 1.05 14.9375 1.15C15.1792 1.25 15.3917 1.39167 15.575 1.575L20.425 6.425C20.6083 6.60833 20.75 6.82083 20.85 7.0625C20.95 7.30417 21 7.55833 21 7.825V17C21 17.55 20.8042 18.0208 20.4125 18.4125C20.0208 18.8042 19.55 19 19 19ZM14 3H8V17H19V8H15C14.7167 8 14.4792 7.90417 14.2875 7.7125C14.0958 7.52083 14 7.28333 14 7V3ZM4 23C3.45 23 2.97917 22.8042 2.5875 22.4125C2.19583 22.0208 2 21.55 2 21V8C2 7.71667 2.09583 7.47917 2.2875 7.2875C2.47917 7.09583 2.71667 7 3 7C3.28333 7 3.52083 7.09583 3.7125 7.2875C3.90417 7.47917 4 7.71667 4 8V21H14C14.2833 21 14.5208 21.0958 14.7125 21.2875C14.9042 21.4792 15 21.7167 15 22C15 22.2833 14.9042 22.5208 14.7125 22.7125C14.5208 22.9042 14.2833 23 14 23H4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M22.1667 22.1667H9.33334C8.69167 22.1667 8.14236 21.9383 7.68542 21.4813C7.22847 21.0244 7 20.4751 7 19.8334V3.50008C7 2.85841 7.22847 2.30911 7.68542 1.85216C8.14236 1.39522 8.69167 1.16675 9.33334 1.16675H16.5375C16.8486 1.16675 17.1451 1.22508 17.4271 1.34175C17.709 1.45841 17.9569 1.62369 18.1708 1.83758L23.8292 7.49591C24.0431 7.7098 24.2083 7.95772 24.325 8.23966C24.4417 8.52161 24.5 8.81814 24.5 9.12925V19.8334C24.5 20.4751 24.2715 21.0244 23.8146 21.4813C23.3576 21.9383 22.8083 22.1667 22.1667 22.1667ZM16.3333 3.50008H9.33334V19.8334H22.1667V9.33341H17.5C17.1694 9.33341 16.8924 9.22161 16.6688 8.998C16.4451 8.77439 16.3333 8.4973 16.3333 8.16675V3.50008ZM4.66667 26.8334C4.025 26.8334 3.4757 26.6049 3.01875 26.148C2.56181 25.6911 2.33334 25.1417 2.33334 24.5001V9.33341C2.33334 9.00286 2.44514 8.72578 2.66875 8.50216C2.89236 8.27855 3.16945 8.16675 3.5 8.16675C3.83056 8.16675 4.10764 8.27855 4.33125 8.50216C4.55486 8.72578 4.66667 9.00286 4.66667 9.33341V24.5001H16.3333C16.6639 24.5001 16.941 24.6119 17.1646 24.8355C17.3882 25.0591 17.5 25.3362 17.5 25.6667C17.5 25.9973 17.3882 26.2744 17.1646 26.498C16.941 26.7216 16.6639 26.8334 16.3333 26.8334H4.66667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1d; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-file-copy",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1c = "/*!@:host*/.sc-swirl-icon-filter-h{display:inline-flex}";

class SwirlIconFilter {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.33333 12C7.14444 12 6.98622 11.936 6.85867 11.808C6.73067 11.6804 6.66667 11.5222 6.66667 11.3333C6.66667 11.1444 6.73067 10.9862 6.85867 10.8587C6.98622 10.7307 7.14444 10.6667 7.33333 10.6667H8.66667C8.85556 10.6667 9.014 10.7307 9.142 10.8587C9.26956 10.9862 9.33333 11.1444 9.33333 11.3333C9.33333 11.5222 9.26956 11.6804 9.142 11.808C9.014 11.936 8.85556 12 8.66667 12H7.33333ZM2.66667 5.33333C2.47778 5.33333 2.31956 5.26956 2.192 5.142C2.064 5.014 2 4.85556 2 4.66667C2 4.47778 2.064 4.31933 2.192 4.19133C2.31956 4.06378 2.47778 4 2.66667 4H13.3333C13.5222 4 13.6804 4.06378 13.808 4.19133C13.936 4.31933 14 4.47778 14 4.66667C14 4.85556 13.936 5.014 13.808 5.142C13.6804 5.26956 13.5222 5.33333 13.3333 5.33333H2.66667ZM4.66667 8.66667C4.47778 8.66667 4.31933 8.60267 4.19133 8.47467C4.06378 8.34711 4 8.18889 4 8C4 7.81111 4.06378 7.65267 4.19133 7.52467C4.31933 7.39711 4.47778 7.33333 4.66667 7.33333H11.3333C11.5222 7.33333 11.6804 7.39711 11.808 7.52467C11.936 7.65267 12 7.81111 12 8C12 8.18889 11.936 8.34711 11.808 8.47467C11.6804 8.60267 11.5222 8.66667 11.3333 8.66667H4.66667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M11 18C10.7167 18 10.4793 17.904 10.288 17.712C10.096 17.5207 10 17.2833 10 17C10 16.7167 10.096 16.4793 10.288 16.288C10.4793 16.096 10.7167 16 11 16H13C13.2833 16 13.521 16.096 13.713 16.288C13.9043 16.4793 14 16.7167 14 17C14 17.2833 13.9043 17.5207 13.713 17.712C13.521 17.904 13.2833 18 13 18H11ZM4 8C3.71667 8 3.47933 7.90433 3.288 7.713C3.096 7.521 3 7.28333 3 7C3 6.71667 3.096 6.479 3.288 6.287C3.47933 6.09567 3.71667 6 4 6H20C20.2833 6 20.5207 6.09567 20.712 6.287C20.904 6.479 21 6.71667 21 7C21 7.28333 20.904 7.521 20.712 7.713C20.5207 7.90433 20.2833 8 20 8H4ZM7 13C6.71667 13 6.479 12.904 6.287 12.712C6.09567 12.5207 6 12.2833 6 12C6 11.7167 6.09567 11.479 6.287 11.287C6.479 11.0957 6.71667 11 7 11H17C17.2833 11 17.5207 11.0957 17.712 11.287C17.904 11.479 18 11.7167 18 12C18 12.2833 17.904 12.5207 17.712 12.712C17.5207 12.904 17.2833 13 17 13H7Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M12.8333 21C12.5028 21 12.2259 20.888 12.0027 20.664C11.7787 20.4408 11.6667 20.1639 11.6667 19.8333C11.6667 19.5028 11.7787 19.2259 12.0027 19.0027C12.2259 18.7787 12.5028 18.6667 12.8333 18.6667H15.1667C15.4972 18.6667 15.7745 18.7787 15.9985 19.0027C16.2217 19.2259 16.3333 19.5028 16.3333 19.8333C16.3333 20.1639 16.2217 20.4408 15.9985 20.664C15.7745 20.888 15.4972 21 15.1667 21H12.8333ZM4.66667 9.33333C4.33611 9.33333 4.05922 9.22172 3.836 8.9985C3.612 8.7745 3.5 8.49722 3.5 8.16667C3.5 7.83611 3.612 7.55883 3.836 7.33483C4.05922 7.11161 4.33611 7 4.66667 7H23.3333C23.6639 7 23.9408 7.11161 24.164 7.33483C24.388 7.55883 24.5 7.83611 24.5 8.16667C24.5 8.49722 24.388 8.7745 24.164 8.9985C23.9408 9.22172 23.6639 9.33333 23.3333 9.33333H4.66667ZM8.16667 15.1667C7.83611 15.1667 7.55883 15.0547 7.33483 14.8307C7.11161 14.6074 7 14.3306 7 14C7 13.6694 7.11161 13.3922 7.33483 13.1682C7.55883 12.9449 7.83611 12.8333 8.16667 12.8333H19.8333C20.1639 12.8333 20.4408 12.9449 20.664 13.1682C20.888 13.3922 21 13.6694 21 14C21 14.3306 20.888 14.6074 20.664 14.8307C20.4408 15.0547 20.1639 15.1667 19.8333 15.1667H8.16667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1c; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-filter",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1b = "/*!@:host*/.sc-swirl-icon-folder-h{display:inline-flex}";

class SwirlIconFolder {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M2.66668 14.1482C2.30001 14.1482 1.98623 14.0177 1.72534 13.7568C1.46401 13.4955 1.33334 13.1815 1.33334 12.8148V4.81484C1.33334 4.44817 1.46401 4.1344 1.72534 3.87351C1.98623 3.61217 2.30001 3.48151 2.66668 3.48151H6.11668C6.29445 3.48151 6.46401 3.51484 6.62534 3.58151C6.78623 3.64817 6.92779 3.74262 7.05001 3.86484L8.00001 4.81484H13.3333C13.7 4.81484 14.014 4.94551 14.2753 5.20684C14.5362 5.46773 14.6667 5.78151 14.6667 6.14817V12.8148C14.6667 13.1815 14.5362 13.4955 14.2753 13.7568C14.014 14.0177 13.7 14.1482 13.3333 14.1482H2.66668Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M4 20C3.45 20 2.97933 19.8043 2.588 19.413C2.196 19.021 2 18.55 2 18V6C2 5.45 2.196 4.97933 2.588 4.588C2.97933 4.196 3.45 4 4 4H9.175C9.44167 4 9.696 4.05 9.938 4.15C10.1793 4.25 10.3917 4.39167 10.575 4.575L12 6H20C20.55 6 21.021 6.196 21.413 6.588C21.8043 6.97933 22 7.45 22 8V18C22 18.55 21.8043 19.021 21.413 19.413C21.021 19.8043 20.55 20 20 20H4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66668 23.3334C4.02501 23.3334 3.4759 23.1051 3.01934 22.6485C2.56201 22.1912 2.33334 21.6417 2.33334 21V7.00002C2.33334 6.35835 2.56201 5.80924 3.01934 5.35269C3.4759 4.89535 4.02501 4.66669 4.66668 4.66669H10.7042C11.0153 4.66669 11.312 4.72502 11.5943 4.84169C11.8759 4.95835 12.1236 5.12363 12.3375 5.33752L14 7.00002H23.3333C23.975 7.00002 24.5245 7.22869 24.9818 7.68602C25.4384 8.14258 25.6667 8.69169 25.6667 9.33335V21C25.6667 21.6417 25.4384 22.1912 24.9818 22.6485C24.5245 23.1051 23.975 23.3334 23.3333 23.3334H4.66668Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1b; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-folder",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1a = "/*!@:host*/.sc-swirl-icon-folder-shared-h{display:inline-flex}";

class SwirlIconFolderShared {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M13.3333 3.99996H8.00001L7.06001 3.05996C6.80668 2.80663 6.46668 2.66663 6.11334 2.66663H2.66668C1.93334 2.66663 1.34001 3.26663 1.34001 3.99996L1.33334 12C1.33334 12.7333 1.93334 13.3333 2.66668 13.3333H13.3333C14.0667 13.3333 14.6667 12.7333 14.6667 12V5.33329C14.6667 4.59996 14.0667 3.99996 13.3333 3.99996ZM10 5.99996C10.7333 5.99996 11.3333 6.59996 11.3333 7.33329C11.3333 8.06663 10.7333 8.66663 10 8.66663C9.26668 8.66663 8.66668 8.06663 8.66668 7.33329C8.66668 6.59996 9.26668 5.99996 10 5.99996ZM12.6667 11.3333H7.33334V10.6666C7.33334 9.77996 9.11334 9.33329 10 9.33329C10.8867 9.33329 12.6667 9.77996 12.6667 10.6666V11.3333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M20 6H12L10.59 4.59C10.21 4.21 9.7 4 9.17 4H4C2.9 4 2.01 4.9 2.01 6L2 18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6ZM15 9C16.1 9 17 9.9 17 11C17 12.1 16.1 13 15 13C13.9 13 13 12.1 13 11C13 9.9 13.9 9 15 9ZM19 17H11V16C11 14.67 13.67 14 15 14C16.33 14 19 14.67 19 16V17Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M23.3333 6.99996H14L12.355 5.35496C11.9117 4.91163 11.3167 4.66663 10.6983 4.66663H4.66668C3.38334 4.66663 2.34501 5.71663 2.34501 6.99996L2.33334 21C2.33334 22.2833 3.38334 23.3333 4.66668 23.3333H23.3333C24.6167 23.3333 25.6667 22.2833 25.6667 21V9.33329C25.6667 8.04996 24.6167 6.99996 23.3333 6.99996ZM17.5 10.5C18.7833 10.5 19.8333 11.55 19.8333 12.8333C19.8333 14.1166 18.7833 15.1666 17.5 15.1666C16.2167 15.1666 15.1667 14.1166 15.1667 12.8333C15.1667 11.55 16.2167 10.5 17.5 10.5ZM22.1667 19.8333H12.8333V18.6666C12.8333 17.115 15.9483 16.3333 17.5 16.3333C19.0517 16.3333 22.1667 17.115 22.1667 18.6666V19.8333Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1a; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-folder-shared",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$19 = "/*!@:host*/.sc-swirl-icon-fullscreen-h{display:inline-flex}";

class SwirlIconFullscreen {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.93333 12.8167C3.72222 12.8167 3.54445 12.7445 3.4 12.6C3.25556 12.4556 3.18333 12.2778 3.18333 12.0667V10C3.18333 9.78891 3.25556 9.60846 3.4 9.45868C3.54445 9.30846 3.72222 9.23335 3.93333 9.23335C4.15556 9.23335 4.33889 9.30846 4.48333 9.45868C4.62778 9.60846 4.7 9.78891 4.7 10V11.3H6C6.21111 11.3 6.39156 11.3722 6.54133 11.5167C6.69156 11.6611 6.76667 11.8445 6.76667 12.0667C6.76667 12.2778 6.69156 12.4556 6.54133 12.6C6.39156 12.7445 6.21111 12.8167 6 12.8167H3.93333ZM3.93333 6.76668C3.72222 6.76668 3.54445 6.69157 3.4 6.54135C3.25556 6.39157 3.18333 6.21113 3.18333 6.00002V3.93335C3.18333 3.72224 3.25556 3.54446 3.4 3.40002C3.54445 3.25557 3.72222 3.18335 3.93333 3.18335H6C6.21111 3.18335 6.39156 3.25557 6.54133 3.40002C6.69156 3.54446 6.76667 3.72224 6.76667 3.93335C6.76667 4.15557 6.69156 4.33891 6.54133 4.48335C6.39156 4.62779 6.21111 4.70002 6 4.70002H4.7V6.00002C4.7 6.21113 4.62778 6.39157 4.48333 6.54135C4.33889 6.69157 4.15556 6.76668 3.93333 6.76668V6.76668ZM10 12.8167C9.78889 12.8167 9.60845 12.7445 9.45867 12.6C9.30845 12.4556 9.23334 12.2778 9.23334 12.0667C9.23334 11.8445 9.30845 11.6611 9.45867 11.5167C9.60845 11.3722 9.78889 11.3 10 11.3H11.3V10C11.3 9.78891 11.3722 9.60846 11.5167 9.45868C11.6611 9.30846 11.8444 9.23335 12.0667 9.23335C12.2778 9.23335 12.4556 9.30846 12.6 9.45868C12.7444 9.60846 12.8167 9.78891 12.8167 10V12.0667C12.8167 12.2778 12.7444 12.4556 12.6 12.6C12.4556 12.7445 12.2778 12.8167 12.0667 12.8167H10ZM12.0667 6.76668C11.8444 6.76668 11.6611 6.69157 11.5167 6.54135C11.3722 6.39157 11.3 6.21113 11.3 6.00002V4.70002H10C9.78889 4.70002 9.60845 4.62779 9.45867 4.48335C9.30845 4.33891 9.23334 4.15557 9.23334 3.93335C9.23334 3.72224 9.30845 3.54446 9.45867 3.40002C9.60845 3.25557 9.78889 3.18335 10 3.18335H12.0667C12.2778 3.18335 12.4556 3.25557 12.6 3.40002C12.7444 3.54446 12.8167 3.72224 12.8167 3.93335V6.00002C12.8167 6.21113 12.7444 6.39157 12.6 6.54135C12.4556 6.69157 12.2778 6.76668 12.0667 6.76668V6.76668Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5.9 19.225C5.58333 19.225 5.31667 19.1167 5.1 18.9C4.88333 18.6834 4.775 18.4167 4.775 18.1V15C4.775 14.6834 4.88333 14.4127 5.1 14.188C5.31667 13.9627 5.58333 13.85 5.9 13.85C6.23333 13.85 6.50833 13.9627 6.725 14.188C6.94167 14.4127 7.05 14.6834 7.05 15V16.95H9C9.31667 16.95 9.58733 17.0584 9.812 17.275C10.0373 17.4917 10.15 17.7667 10.15 18.1C10.15 18.4167 10.0373 18.6834 9.812 18.9C9.58733 19.1167 9.31667 19.225 9 19.225H5.9ZM5.9 10.15C5.58333 10.15 5.31667 10.0374 5.1 9.81202C4.88333 9.58736 4.775 9.31669 4.775 9.00002V5.90002C4.775 5.58336 4.88333 5.31669 5.1 5.10002C5.31667 4.88336 5.58333 4.77502 5.9 4.77502H9C9.31667 4.77502 9.58733 4.88336 9.812 5.10002C10.0373 5.31669 10.15 5.58336 10.15 5.90002C10.15 6.23336 10.0373 6.50836 9.812 6.72502C9.58733 6.94169 9.31667 7.05002 9 7.05002H7.05V9.00002C7.05 9.31669 6.94167 9.58736 6.725 9.81202C6.50833 10.0374 6.23333 10.15 5.9 10.15V10.15ZM15 19.225C14.6833 19.225 14.4127 19.1167 14.188 18.9C13.9627 18.6834 13.85 18.4167 13.85 18.1C13.85 17.7667 13.9627 17.4917 14.188 17.275C14.4127 17.0584 14.6833 16.95 15 16.95H16.95V15C16.95 14.6834 17.0583 14.4127 17.275 14.188C17.4917 13.9627 17.7667 13.85 18.1 13.85C18.4167 13.85 18.6833 13.9627 18.9 14.188C19.1167 14.4127 19.225 14.6834 19.225 15V18.1C19.225 18.4167 19.1167 18.6834 18.9 18.9C18.6833 19.1167 18.4167 19.225 18.1 19.225H15ZM18.1 10.15C17.7667 10.15 17.4917 10.0374 17.275 9.81202C17.0583 9.58736 16.95 9.31669 16.95 9.00002V7.05002H15C14.6833 7.05002 14.4127 6.94169 14.188 6.72502C13.9627 6.50836 13.85 6.23336 13.85 5.90002C13.85 5.58336 13.9627 5.31669 14.188 5.10002C14.4127 4.88336 14.6833 4.77502 15 4.77502H18.1C18.4167 4.77502 18.6833 4.88336 18.9 5.10002C19.1167 5.31669 19.225 5.58336 19.225 5.90002V9.00002C19.225 9.31669 19.1167 9.58736 18.9 9.81202C18.6833 10.0374 18.4167 10.15 18.1 10.15V10.15Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M6.88333 22.4291C6.51389 22.4291 6.20278 22.3027 5.95 22.05C5.69722 21.7972 5.57083 21.4861 5.57083 21.1166V17.5C5.57083 17.1305 5.69722 16.8147 5.95 16.5526C6.20278 16.2897 6.51389 16.1583 6.88333 16.1583C7.27222 16.1583 7.59305 16.2897 7.84583 16.5526C8.09861 16.8147 8.225 17.1305 8.225 17.5V19.775H10.5C10.8694 19.775 11.1852 19.9014 11.4473 20.1541C11.7102 20.4069 11.8417 20.7277 11.8417 21.1166C11.8417 21.4861 11.7102 21.7972 11.4473 22.05C11.1852 22.3027 10.8694 22.4291 10.5 22.4291H6.88333ZM6.88333 11.8416C6.51389 11.8416 6.20278 11.7102 5.95 11.4473C5.69722 11.1852 5.57083 10.8694 5.57083 10.5V6.8833C5.57083 6.51386 5.69722 6.20274 5.95 5.94997C6.20278 5.69719 6.51389 5.5708 6.88333 5.5708H10.5C10.8694 5.5708 11.1852 5.69719 11.4473 5.94997C11.7102 6.20274 11.8417 6.51386 11.8417 6.8833C11.8417 7.27219 11.7102 7.59302 11.4473 7.8458C11.1852 8.09858 10.8694 8.22497 10.5 8.22497H8.225V10.5C8.225 10.8694 8.09861 11.1852 7.84583 11.4473C7.59305 11.7102 7.27222 11.8416 6.88333 11.8416V11.8416ZM17.5 22.4291C17.1306 22.4291 16.8148 22.3027 16.5527 22.05C16.2898 21.7972 16.1583 21.4861 16.1583 21.1166C16.1583 20.7277 16.2898 20.4069 16.5527 20.1541C16.8148 19.9014 17.1306 19.775 17.5 19.775H19.775V17.5C19.775 17.1305 19.9014 16.8147 20.1542 16.5526C20.4069 16.2897 20.7278 16.1583 21.1167 16.1583C21.4861 16.1583 21.7972 16.2897 22.05 16.5526C22.3028 16.8147 22.4292 17.1305 22.4292 17.5V21.1166C22.4292 21.4861 22.3028 21.7972 22.05 22.05C21.7972 22.3027 21.4861 22.4291 21.1167 22.4291H17.5ZM21.1167 11.8416C20.7278 11.8416 20.4069 11.7102 20.1542 11.4473C19.9014 11.1852 19.775 10.8694 19.775 10.5V8.22497H17.5C17.1306 8.22497 16.8148 8.09858 16.5527 7.8458C16.2898 7.59302 16.1583 7.27219 16.1583 6.8833C16.1583 6.51386 16.2898 6.20274 16.5527 5.94997C16.8148 5.69719 17.1306 5.5708 17.5 5.5708H21.1167C21.4861 5.5708 21.7972 5.69719 22.05 5.94997C22.3028 6.20274 22.4292 6.51386 22.4292 6.8833V10.5C22.4292 10.8694 22.3028 11.1852 22.05 11.4473C21.7972 11.7102 21.4861 11.8416 21.1167 11.8416V11.8416Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$19; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-fullscreen",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$18 = "/*!@:host*/.sc-swirl-icon-fullscreen-exit-h{display:inline-flex}";

class SwirlIconFullscreenExit {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6 12.8167C5.78889 12.8167 5.60845 12.7445 5.45867 12.6C5.30845 12.4556 5.23333 12.2778 5.23333 12.0667V10.7667H3.93333C3.72222 10.7667 3.54445 10.6916 3.4 10.5414C3.25556 10.3916 3.18333 10.2111 3.18333 10C3.18333 9.78891 3.25556 9.60846 3.4 9.45868C3.54445 9.30846 3.72222 9.23335 3.93333 9.23335H6C6.21111 9.23335 6.39156 9.30846 6.54133 9.45868C6.69156 9.60846 6.76667 9.78891 6.76667 10V12.0667C6.76667 12.2778 6.69156 12.4556 6.54133 12.6C6.39156 12.7445 6.21111 12.8167 6 12.8167V12.8167ZM3.93333 6.76668C3.72222 6.76668 3.54445 6.69157 3.4 6.54135C3.25556 6.39157 3.18333 6.21113 3.18333 6.00002C3.18333 5.78891 3.25556 5.60824 3.4 5.45802C3.54445 5.30824 3.72222 5.23335 3.93333 5.23335H5.23333V3.93335C5.23333 3.72224 5.30845 3.54446 5.45867 3.40002C5.60845 3.25557 5.78889 3.18335 6 3.18335C6.21111 3.18335 6.39156 3.25557 6.54133 3.40002C6.69156 3.54446 6.76667 3.72224 6.76667 3.93335V6.00002C6.76667 6.21113 6.69156 6.39157 6.54133 6.54135C6.39156 6.69157 6.21111 6.76668 6 6.76668H3.93333ZM10 12.8167C9.78889 12.8167 9.60845 12.7445 9.45867 12.6C9.30845 12.4556 9.23334 12.2778 9.23334 12.0667V10C9.23334 9.78891 9.30845 9.60846 9.45867 9.45868C9.60845 9.30846 9.78889 9.23335 10 9.23335H12.0667C12.2778 9.23335 12.4556 9.30846 12.6 9.45868C12.7444 9.60846 12.8167 9.78891 12.8167 10C12.8167 10.2111 12.7444 10.3916 12.6 10.5414C12.4556 10.6916 12.2778 10.7667 12.0667 10.7667H10.7667V12.0667C10.7667 12.2778 10.6918 12.4556 10.542 12.6C10.3918 12.7445 10.2111 12.8167 10 12.8167V12.8167ZM10 6.76668C9.78889 6.76668 9.60845 6.69157 9.45867 6.54135C9.30845 6.39157 9.23334 6.21113 9.23334 6.00002V3.93335C9.23334 3.72224 9.30845 3.54446 9.45867 3.40002C9.60845 3.25557 9.78889 3.18335 10 3.18335C10.2111 3.18335 10.3918 3.25557 10.542 3.40002C10.6918 3.54446 10.7667 3.72224 10.7667 3.93335V5.23335H12.0667C12.2778 5.23335 12.4556 5.30824 12.6 5.45802C12.7444 5.60824 12.8167 5.78891 12.8167 6.00002C12.8167 6.21113 12.7444 6.39157 12.6 6.54135C12.4556 6.69157 12.2778 6.76668 12.0667 6.76668H10Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9 19.225C8.68333 19.225 8.41267 19.1167 8.188 18.9C7.96267 18.6834 7.85 18.4167 7.85 18.1V16.15H5.9C5.58333 16.15 5.31667 16.0374 5.1 15.812C4.88333 15.5874 4.775 15.3167 4.775 15C4.775 14.6834 4.88333 14.4127 5.1 14.188C5.31667 13.9627 5.58333 13.85 5.9 13.85H9C9.31667 13.85 9.58733 13.9627 9.812 14.188C10.0373 14.4127 10.15 14.6834 10.15 15V18.1C10.15 18.4167 10.0373 18.6834 9.812 18.9C9.58733 19.1167 9.31667 19.225 9 19.225V19.225ZM5.9 10.15C5.58333 10.15 5.31667 10.0374 5.1 9.81202C4.88333 9.58736 4.775 9.31669 4.775 9.00002C4.775 8.68336 4.88333 8.41236 5.1 8.18702C5.31667 7.96236 5.58333 7.85002 5.9 7.85002H7.85V5.90002C7.85 5.58336 7.96267 5.31669 8.188 5.10002C8.41267 4.88336 8.68333 4.77502 9 4.77502C9.31667 4.77502 9.58733 4.88336 9.812 5.10002C10.0373 5.31669 10.15 5.58336 10.15 5.90002V9.00002C10.15 9.31669 10.0373 9.58736 9.812 9.81202C9.58733 10.0374 9.31667 10.15 9 10.15H5.9ZM15 19.225C14.6833 19.225 14.4127 19.1167 14.188 18.9C13.9627 18.6834 13.85 18.4167 13.85 18.1V15C13.85 14.6834 13.9627 14.4127 14.188 14.188C14.4127 13.9627 14.6833 13.85 15 13.85H18.1C18.4167 13.85 18.6833 13.9627 18.9 14.188C19.1167 14.4127 19.225 14.6834 19.225 15C19.225 15.3167 19.1167 15.5874 18.9 15.812C18.6833 16.0374 18.4167 16.15 18.1 16.15H16.15V18.1C16.15 18.4167 16.0377 18.6834 15.813 18.9C15.5877 19.1167 15.3167 19.225 15 19.225V19.225ZM15 10.15C14.6833 10.15 14.4127 10.0374 14.188 9.81202C13.9627 9.58736 13.85 9.31669 13.85 9.00002V5.90002C13.85 5.58336 13.9627 5.31669 14.188 5.10002C14.4127 4.88336 14.6833 4.77502 15 4.77502C15.3167 4.77502 15.5877 4.88336 15.813 5.10002C16.0377 5.31669 16.15 5.58336 16.15 5.90002V7.85002H18.1C18.4167 7.85002 18.6833 7.96236 18.9 8.18702C19.1167 8.41236 19.225 8.68336 19.225 9.00002C19.225 9.31669 19.1167 9.58736 18.9 9.81202C18.6833 10.0374 18.4167 10.15 18.1 10.15H15Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M10.5 22.4291C10.1306 22.4291 9.81478 22.3027 9.55266 22.05C9.28978 21.7972 9.15833 21.4861 9.15833 21.1166V18.8416H6.88333C6.51389 18.8416 6.20278 18.7102 5.95 18.4473C5.69722 18.1852 5.57083 17.8694 5.57083 17.5C5.57083 17.1305 5.69722 16.8147 5.95 16.5526C6.20278 16.2897 6.51389 16.1583 6.88333 16.1583H10.5C10.8694 16.1583 11.1852 16.2897 11.4473 16.5526C11.7102 16.8147 11.8417 17.1305 11.8417 17.5V21.1166C11.8417 21.4861 11.7102 21.7972 11.4473 22.05C11.1852 22.3027 10.8694 22.4291 10.5 22.4291V22.4291ZM6.88333 11.8416C6.51389 11.8416 6.20278 11.7102 5.95 11.4473C5.69722 11.1852 5.57083 10.8694 5.57083 10.5C5.57083 10.1305 5.69722 9.81436 5.95 9.55147C6.20278 9.28936 6.51389 9.1583 6.88333 9.1583H9.15833V6.8833C9.15833 6.51386 9.28978 6.20274 9.55266 5.94997C9.81478 5.69719 10.1306 5.5708 10.5 5.5708C10.8694 5.5708 11.1852 5.69719 11.4473 5.94997C11.7102 6.20274 11.8417 6.51386 11.8417 6.8833V10.5C11.8417 10.8694 11.7102 11.1852 11.4473 11.4473C11.1852 11.7102 10.8694 11.8416 10.5 11.8416H6.88333ZM17.5 22.4291C17.1306 22.4291 16.8148 22.3027 16.5527 22.05C16.2898 21.7972 16.1583 21.4861 16.1583 21.1166V17.5C16.1583 17.1305 16.2898 16.8147 16.5527 16.5526C16.8148 16.2897 17.1306 16.1583 17.5 16.1583H21.1167C21.4861 16.1583 21.7972 16.2897 22.05 16.5526C22.3028 16.8147 22.4292 17.1305 22.4292 17.5C22.4292 17.8694 22.3028 18.1852 22.05 18.4473C21.7972 18.7102 21.4861 18.8416 21.1167 18.8416H18.8417V21.1166C18.8417 21.4861 18.7106 21.7972 18.4485 22.05C18.1856 22.3027 17.8694 22.4291 17.5 22.4291V22.4291ZM17.5 11.8416C17.1306 11.8416 16.8148 11.7102 16.5527 11.4473C16.2898 11.1852 16.1583 10.8694 16.1583 10.5V6.8833C16.1583 6.51386 16.2898 6.20274 16.5527 5.94997C16.8148 5.69719 17.1306 5.5708 17.5 5.5708C17.8694 5.5708 18.1856 5.69719 18.4485 5.94997C18.7106 6.20274 18.8417 6.51386 18.8417 6.8833V9.1583H21.1167C21.4861 9.1583 21.7972 9.28936 22.05 9.55147C22.3028 9.81436 22.4292 10.1305 22.4292 10.5C22.4292 10.8694 22.3028 11.1852 22.05 11.4473C21.7972 11.7102 21.4861 11.8416 21.1167 11.8416H17.5Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$18; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-fullscreen-exit",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$17 = "/*!@:host*/.sc-swirl-icon-gif-h{display:inline-flex}";

class SwirlIconGif {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.16671 10C8.02226 10 7.90282 9.95278 7.80837 9.85833C7.71393 9.76389 7.66671 9.64444 7.66671 9.5V6.5C7.66671 6.35556 7.71393 6.23611 7.80837 6.14167C7.90282 6.04722 8.02226 6 8.16671 6C8.31115 6 8.4306 6.04722 8.52504 6.14167C8.61948 6.23611 8.66671 6.35556 8.66671 6.5V9.5C8.66671 9.64444 8.61948 9.76389 8.52504 9.85833C8.4306 9.95278 8.31115 10 8.16671 10ZM4.00004 10C3.80004 10 3.63893 9.93056 3.51671 9.79167C3.39449 9.65278 3.33337 9.5 3.33337 9.33333V6.66667C3.33337 6.5 3.39449 6.34722 3.51671 6.20833C3.63893 6.06944 3.80004 6 4.00004 6H6.16671C6.31115 6 6.4306 6.04722 6.52504 6.14167C6.61948 6.23611 6.66671 6.35556 6.66671 6.5C6.66671 6.64444 6.61948 6.76389 6.52504 6.85833C6.4306 6.95278 6.31115 7 6.16671 7H4.33337V9H5.66671V8.5C5.66671 8.35556 5.71393 8.23611 5.80837 8.14167C5.90282 8.04722 6.02226 8 6.16671 8C6.31115 8 6.4306 8.04722 6.52504 8.14167C6.61948 8.23611 6.66671 8.35556 6.66671 8.5V9.33333C6.66671 9.5 6.6056 9.65278 6.48337 9.79167C6.36115 9.93056 6.20004 10 6.00004 10H4.00004ZM10.1667 10C10.0223 10 9.90282 9.95278 9.80837 9.85833C9.71393 9.76389 9.66671 9.64444 9.66671 9.5V6.66667C9.66671 6.47778 9.7306 6.31944 9.85837 6.19167C9.98615 6.06389 10.1445 6 10.3334 6H12.1667C12.3112 6 12.4306 6.04722 12.525 6.14167C12.6195 6.23611 12.6667 6.35556 12.6667 6.5C12.6667 6.64444 12.6195 6.76389 12.525 6.85833C12.4306 6.95278 12.3112 7 12.1667 7H10.6667V7.66667H11.5C11.6445 7.66667 11.7639 7.71389 11.8584 7.80833C11.9528 7.90278 12 8.02222 12 8.16667C12 8.31111 11.9528 8.43056 11.8584 8.525C11.7639 8.61944 11.6445 8.66667 11.5 8.66667H10.6667V9.5C10.6667 9.64444 10.6195 9.76389 10.525 9.85833C10.4306 9.95278 10.3112 10 10.1667 10Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12.25 15C12.0333 15 11.8542 14.9292 11.7125 14.7875C11.5708 14.6458 11.5 14.4667 11.5 14.25V9.75C11.5 9.53333 11.5708 9.35417 11.7125 9.2125C11.8542 9.07083 12.0333 9 12.25 9C12.4667 9 12.6458 9.07083 12.7875 9.2125C12.9292 9.35417 13 9.53333 13 9.75V14.25C13 14.4667 12.9292 14.6458 12.7875 14.7875C12.6458 14.9292 12.4667 15 12.25 15ZM6 15C5.7 15 5.45833 14.8958 5.275 14.6875C5.09167 14.4792 5 14.25 5 14V10C5 9.75 5.09167 9.52083 5.275 9.3125C5.45833 9.10417 5.7 9 6 9H9.25C9.46667 9 9.64583 9.07083 9.7875 9.2125C9.92917 9.35417 10 9.53333 10 9.75C10 9.96667 9.92917 10.1458 9.7875 10.2875C9.64583 10.4292 9.46667 10.5 9.25 10.5H6.5V13.5H8.5V12.75C8.5 12.5333 8.57083 12.3542 8.7125 12.2125C8.85417 12.0708 9.03333 12 9.25 12C9.46667 12 9.64583 12.0708 9.7875 12.2125C9.92917 12.3542 10 12.5333 10 12.75V14C10 14.25 9.90833 14.4792 9.725 14.6875C9.54167 14.8958 9.3 15 9 15H6ZM15.25 15C15.0333 15 14.8542 14.9292 14.7125 14.7875C14.5708 14.6458 14.5 14.4667 14.5 14.25V10C14.5 9.71667 14.5958 9.47917 14.7875 9.2875C14.9792 9.09583 15.2167 9 15.5 9H18.25C18.4667 9 18.6458 9.07083 18.7875 9.2125C18.9292 9.35417 19 9.53333 19 9.75C19 9.96667 18.9292 10.1458 18.7875 10.2875C18.6458 10.4292 18.4667 10.5 18.25 10.5H16V11.5H17.25C17.4667 11.5 17.6458 11.5708 17.7875 11.7125C17.9292 11.8542 18 12.0333 18 12.25C18 12.4667 17.9292 12.6458 17.7875 12.7875C17.6458 12.9292 17.4667 13 17.25 13H16V14.25C16 14.4667 15.9292 14.6458 15.7875 14.7875C15.6458 14.9292 15.4667 15 15.25 15Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14.2917 17.5C14.0389 17.5 13.8299 17.4174 13.6646 17.2521C13.4993 17.0868 13.4167 16.8778 13.4167 16.625V11.375C13.4167 11.1222 13.4993 10.9132 13.6646 10.7479C13.8299 10.5826 14.0389 10.5 14.2917 10.5C14.5445 10.5 14.7535 10.5826 14.9188 10.7479C15.0841 10.9132 15.1667 11.1222 15.1667 11.375V16.625C15.1667 16.8778 15.0841 17.0868 14.9188 17.2521C14.7535 17.4174 14.5445 17.5 14.2917 17.5ZM7.00004 17.5C6.65004 17.5 6.3681 17.3785 6.15421 17.1354C5.94032 16.8924 5.83337 16.625 5.83337 16.3333V11.6667C5.83337 11.375 5.94032 11.1076 6.15421 10.8646C6.3681 10.6215 6.65004 10.5 7.00004 10.5H10.7917C11.0445 10.5 11.2535 10.5826 11.4188 10.7479C11.5841 10.9132 11.6667 11.1222 11.6667 11.375C11.6667 11.6278 11.5841 11.8368 11.4188 12.0021C11.2535 12.1674 11.0445 12.25 10.7917 12.25H7.58337V15.75H9.91671V14.875C9.91671 14.6222 9.99935 14.4132 10.1646 14.2479C10.3299 14.0826 10.5389 14 10.7917 14C11.0445 14 11.2535 14.0826 11.4188 14.2479C11.5841 14.4132 11.6667 14.6222 11.6667 14.875V16.3333C11.6667 16.625 11.5598 16.8924 11.3459 17.1354C11.132 17.3785 10.85 17.5 10.5 17.5H7.00004ZM17.7917 17.5C17.5389 17.5 17.3299 17.4174 17.1646 17.2521C16.9993 17.0868 16.9167 16.8778 16.9167 16.625V11.6667C16.9167 11.3361 17.0285 11.059 17.2521 10.8354C17.4757 10.6118 17.7528 10.5 18.0834 10.5H21.2917C21.5445 10.5 21.7535 10.5826 21.9188 10.7479C22.0841 10.9132 22.1667 11.1222 22.1667 11.375C22.1667 11.6278 22.0841 11.8368 21.9188 12.0021C21.7535 12.1674 21.5445 12.25 21.2917 12.25H18.6667V13.4167H20.125C20.3778 13.4167 20.5868 13.4993 20.7521 13.6646C20.9174 13.8299 21 14.0389 21 14.2917C21 14.5444 20.9174 14.7535 20.7521 14.9187C20.5868 15.084 20.3778 15.1667 20.125 15.1667H18.6667V16.625C18.6667 16.8778 18.5841 17.0868 18.4188 17.2521C18.2535 17.4174 18.0445 17.5 17.7917 17.5Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$17; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-gif",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$16 = "/*!@:host*/.sc-swirl-icon-group-assign-h{display:inline-flex}";

class SwirlIconGroupAssign {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M13.9661 11.9999C13.9894 11.8903 14.001 11.7786 14.0013 11.6666V10.6666C13.9969 10.3024 13.9118 9.94346 13.7526 9.61581C13.5934 9.28816 13.3643 9.00001 13.0807 8.77141C14.4221 9.00408 16.0013 9.63793 16.0013 10.6666V11.6666C16.002 11.7106 15.9944 11.7541 15.9779 11.7948C15.9614 11.8356 15.936 11.8731 15.9049 11.9042C15.8738 11.9353 15.8376 11.9593 15.7969 11.9758C15.7561 11.9923 15.7119 12.0006 15.668 11.9999H13.9661ZM5.33333 11.9999C5.15652 11.9999 4.987 11.9296 4.86198 11.8046C4.73695 11.6796 4.66667 11.5101 4.66667 11.3333V10.6666C4.66667 9.33326 7.33333 8.66659 8.66667 8.66659C10 8.66659 12.6667 9.33326 12.6667 10.6666V11.3333C12.6667 11.5101 12.5964 11.6796 12.4714 11.8046C12.3463 11.9296 12.1768 11.9999 12 11.9999H5.33333ZM2.66667 8.71477V7.99993H0.666667C0.490179 7.99888 0.321412 7.92811 0.196615 7.80331C0.0718171 7.67851 0.00104951 7.50975 0 7.33326C0 7.15645 0.0702882 6.98693 0.195312 6.8619C0.320337 6.73688 0.489856 6.66659 0.666667 6.66659H2.66667V5.955C2.66645 5.84964 2.69691 5.74654 2.75521 5.65878C2.81351 5.57102 2.89759 5.50282 2.99479 5.46217C3.092 5.42151 3.19866 5.41078 3.30208 5.43092C3.4055 5.45105 3.50067 5.5013 3.57552 5.57545L4.95573 6.955C5.05567 7.05501 5.11198 7.19057 5.11198 7.33196C5.11198 7.47334 5.05567 7.60955 4.95573 7.70956L3.57552 9.08912C3.52736 9.13893 3.47005 9.17862 3.40625 9.20565C3.34245 9.23269 3.27371 9.24672 3.20443 9.24667C3.13405 9.2472 3.06387 9.23352 2.9987 9.20696C2.93353 9.18039 2.87417 9.1413 2.82422 9.09172C2.77427 9.04214 2.73408 8.98351 2.70703 8.91855C2.67998 8.85358 2.66666 8.78384 2.66667 8.71347V8.71477ZM11.3945 7.24276C11.7838 6.68255 11.9934 6.01677 11.9948 5.33456C11.9974 4.65195 11.7875 3.98518 11.3945 3.42701C11.5908 3.36532 11.7956 3.33449 12.0013 3.33521C12.2636 3.33503 12.5233 3.38701 12.7656 3.48756C13.0079 3.5881 13.2276 3.73529 13.4128 3.92115C13.5979 4.10701 13.7442 4.32755 13.8437 4.57024C13.9433 4.81292 13.9947 5.0729 13.9935 5.33521C13.9944 5.59743 13.9434 5.85701 13.8437 6.09953C13.7441 6.34206 13.5978 6.56284 13.4128 6.74862C13.2277 6.93441 13.0077 7.08155 12.7656 7.18222C12.5235 7.28289 12.2635 7.33504 12.0013 7.33521C11.7959 7.33515 11.5916 7.30369 11.3958 7.24146L11.3945 7.24276ZM6.66667 5.33326C6.66596 5.07042 6.71745 4.80995 6.81771 4.56698C6.91797 4.32401 7.06544 4.1031 7.2513 3.91724C7.43716 3.73139 7.65807 3.58456 7.90104 3.4843C8.14401 3.38404 8.40383 3.33256 8.66667 3.33326C8.92915 3.33273 9.18977 3.3839 9.43229 3.4843C9.67481 3.5847 9.89414 3.73263 10.0794 3.91855C10.2647 4.10446 10.4121 4.32478 10.5117 4.56763C10.6113 4.81049 10.6616 5.07078 10.6602 5.33326C10.6613 5.59566 10.6101 5.8555 10.5104 6.09823C10.4107 6.34096 10.2647 6.56211 10.0794 6.74797C9.89419 6.93383 9.67339 7.08107 9.43099 7.18157C9.18859 7.28206 8.92907 7.33352 8.66667 7.33326C8.13623 7.33326 7.62768 7.12239 7.2526 6.74732C6.87753 6.37225 6.66667 5.86369 6.66667 5.33326Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M20.9492 18C20.984 17.8356 21.0015 17.6681 21.002 17.5V16C20.9954 15.4537 20.8676 14.9153 20.6289 14.4238C20.3902 13.9324 20.0465 13.5001 19.6211 13.1572C21.6331 13.5062 24.002 14.457 24.002 16V17.5C24.003 17.566 23.9915 17.6312 23.9668 17.6924C23.9421 17.7535 23.9041 17.8098 23.8574 17.8565C23.8108 17.9031 23.7565 17.9391 23.6953 17.9639C23.6342 17.9886 23.5679 18.0011 23.502 18H20.9492ZM8 18C7.73478 18 7.4805 17.8946 7.29297 17.707C7.10543 17.5195 7 17.2652 7 17V16C7 14 11 13 13 13C15 13 19 14 19 16V17C19 17.2652 18.8946 17.5195 18.707 17.707C18.5195 17.8946 18.2652 18 18 18H8ZM4 13.0723V12H1C0.735269 11.9984 0.482118 11.8923 0.294922 11.7051C0.107726 11.5179 0.00157426 11.2647 0 11C0 10.7348 0.105432 10.4805 0.292969 10.293C0.480505 10.1054 0.734784 10 1 10H4V8.93263C3.99968 8.77459 4.04537 8.61994 4.13281 8.48829C4.22026 8.35665 4.34638 8.25435 4.49219 8.19337C4.63799 8.13239 4.798 8.11629 4.95312 8.1465C5.10825 8.1767 5.251 8.25207 5.36328 8.36329L7.43359 10.4326C7.58351 10.5826 7.66797 10.786 7.66797 10.9981C7.66797 11.2101 7.58351 11.4144 7.43359 11.5645L5.36328 13.6338C5.29104 13.7085 5.20507 13.7681 5.10938 13.8086C5.01368 13.8492 4.91057 13.8702 4.80664 13.8701C4.70108 13.8709 4.5958 13.8504 4.49805 13.8106C4.40029 13.7707 4.31125 13.7121 4.23633 13.6377C4.1614 13.5633 4.10113 13.4754 4.06055 13.3779C4.01997 13.2805 4 13.1759 4 13.0703V13.0723ZM17.0918 10.8643C17.6758 10.0239 17.9901 9.02527 17.9922 8.00196C17.9961 6.97804 17.6812 5.9779 17.0918 5.14064C17.3862 5.0481 17.6933 5.00186 18.002 5.00294C18.3954 5.00267 18.785 5.08064 19.1484 5.23146C19.5119 5.38227 19.8415 5.60306 20.1191 5.88185C20.3968 6.16063 20.6163 6.49145 20.7656 6.85548C20.915 7.21951 20.9921 7.60947 20.9902 8.00294C20.9916 8.39627 20.9152 8.78564 20.7656 9.14942C20.6161 9.51321 20.3967 9.84438 20.1191 10.1231C19.8416 10.4017 19.5116 10.6224 19.1484 10.7734C18.7853 10.9245 18.3953 11.0027 18.002 11.0029C17.6938 11.0028 17.3874 10.9557 17.0938 10.8623L17.0918 10.8643ZM10 8.00001C9.99894 7.60575 10.0762 7.21505 10.2266 6.8506C10.377 6.48614 10.5982 6.15477 10.877 5.87599C11.1557 5.5972 11.4871 5.37696 11.8516 5.22657C12.216 5.07618 12.6057 4.99896 13 5.00001C13.3937 4.99921 13.7847 5.07597 14.1484 5.22657C14.5122 5.37718 14.8412 5.59907 15.1191 5.87794C15.3971 6.15681 15.6182 6.4873 15.7676 6.85157C15.917 7.21585 15.9923 7.6063 15.9902 8.00001C15.9919 8.39361 15.9152 8.78337 15.7656 9.14747C15.6161 9.51157 15.397 9.84329 15.1191 10.1221C14.8413 10.4009 14.5101 10.6217 14.1465 10.7725C13.7829 10.9232 13.3936 11.0004 13 11C12.2044 11 11.4415 10.6837 10.8789 10.1211C10.3163 9.5585 10 8.79566 10 8.00001Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M24.4408 20.9999C24.4814 20.8081 24.5018 20.6127 24.5023 20.4166V18.6666C24.4946 18.0292 24.3456 17.4011 24.0671 16.8277C23.7885 16.2543 23.3876 15.7501 22.8913 15.35C25.2386 15.7572 28.0023 16.8664 28.0023 18.6666V20.4166C28.0035 20.4935 27.9901 20.5697 27.9613 20.641C27.9324 20.7124 27.8881 20.778 27.8337 20.8324C27.7792 20.8869 27.7159 20.9289 27.6445 20.9578C27.5732 20.9866 27.4959 21.0012 27.4189 20.9999H24.4408ZM9.33333 20.9999C9.02391 20.9999 8.72726 20.8769 8.50846 20.6581C8.28967 20.4393 8.16667 20.1427 8.16667 19.8333V18.6666C8.16667 16.3333 12.8333 15.1666 15.1667 15.1666C17.5 15.1666 22.1667 16.3333 22.1667 18.6666V19.8333C22.1667 20.1427 22.0437 20.4393 21.8249 20.6581C21.6061 20.8769 21.3094 20.9999 21 20.9999H9.33333ZM4.66667 15.2509V13.9999H1.16667C0.857814 13.9981 0.562471 13.8743 0.344076 13.6559C0.12568 13.4375 0.00183663 13.1421 0 12.8333C0 12.5238 0.123004 12.2272 0.341797 12.0084C0.560589 11.7896 0.857247 11.6666 1.16667 11.6666H4.66667V10.4213C4.66629 10.2369 4.71959 10.0565 4.82161 9.90293C4.92363 9.74934 5.07078 9.62999 5.24089 9.55885C5.41099 9.48771 5.59766 9.46893 5.77865 9.50416C5.95963 9.5394 6.12617 9.62733 6.25716 9.75709L8.67253 12.1713C8.84743 12.3463 8.94596 12.5836 8.94596 12.831C8.94596 13.0784 8.84743 13.3168 8.67253 13.4918L6.25716 15.906C6.17288 15.9932 6.07258 16.0627 5.96094 16.11C5.84929 16.1573 5.729 16.1818 5.60775 16.1817C5.48459 16.1827 5.36177 16.1587 5.24772 16.1122C5.13367 16.0657 5.02979 15.9973 4.94238 15.9106C4.85497 15.8238 4.78465 15.7212 4.7373 15.6075C4.68996 15.4938 4.66666 15.3718 4.66667 15.2486V15.2509ZM19.9404 12.6749C20.6217 11.6945 20.9885 10.5294 20.9909 9.33554C20.9955 8.14097 20.6281 6.97413 19.9404 5.99733C20.2839 5.88937 20.6422 5.83542 21.0023 5.83668C21.4613 5.83637 21.9158 5.92733 22.3398 6.10328C22.7638 6.27924 23.1484 6.53682 23.4723 6.86207C23.7963 7.18732 24.0523 7.57328 24.2266 7.99798C24.4008 8.42268 24.4908 8.87763 24.4886 9.33668C24.4901 9.79556 24.401 10.2498 24.2266 10.6742C24.0521 11.0987 23.7962 11.485 23.4723 11.8102C23.1485 12.1353 22.7636 12.3928 22.3398 12.5689C21.9161 12.7451 21.4612 12.8364 21.0023 12.8367C20.6428 12.8366 20.2853 12.7815 19.9427 12.6726L19.9404 12.6749ZM11.6667 9.33326C11.6654 8.87329 11.7555 8.41748 11.931 7.99228C12.1064 7.56709 12.3645 7.18049 12.6898 6.85524C13.015 6.52999 13.4016 6.27304 13.8268 6.09759C14.252 5.92213 14.7067 5.83203 15.1667 5.83326C15.626 5.83233 16.0821 5.92188 16.5065 6.09759C16.9309 6.27329 17.3147 6.53217 17.639 6.85752C17.9633 7.18286 18.2212 7.56843 18.3955 7.99342C18.5698 8.41841 18.6577 8.87393 18.6553 9.33326C18.6573 9.79247 18.5677 10.2472 18.3932 10.672C18.2188 11.0967 17.9632 11.4838 17.639 11.809C17.3148 12.1343 16.9284 12.3919 16.5042 12.5678C16.08 12.7437 15.6259 12.8337 15.1667 12.8333C14.2384 12.8333 13.3484 12.4643 12.6921 11.8079C12.0357 11.1515 11.6667 10.2615 11.6667 9.33326Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$16; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-group-assign",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$15 = "/*!@:host*/.sc-swirl-icon-groups-h{display:inline-flex}";

class SwirlIconGroups {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 8.5C9.08667 8.5 10.0467 8.76 10.8267 9.1C11.5467 9.42 12 10.14 12 10.92V11.3333C12 11.7 11.7 12 11.3333 12H4.66667C4.3 12 4 11.7 4 11.3333V10.9267C4 10.14 4.45333 9.42 5.17333 9.10667C5.95333 8.76 6.91333 8.5 8 8.5ZM2.66667 8.66667C3.4 8.66667 4 8.06667 4 7.33333C4 6.6 3.4 6 2.66667 6C1.93333 6 1.33333 6.6 1.33333 7.33333C1.33333 8.06667 1.93333 8.66667 2.66667 8.66667ZM3.42 9.4C3.17333 9.36 2.92667 9.33333 2.66667 9.33333C2.00667 9.33333 1.38 9.47333 0.813333 9.72C0.32 9.93333 0 10.4133 0 10.9533V11.3333C0 11.7 0.3 12 0.666667 12H3V10.9267C3 10.3733 3.15333 9.85333 3.42 9.4ZM13.3333 8.66667C14.0667 8.66667 14.6667 8.06667 14.6667 7.33333C14.6667 6.6 14.0667 6 13.3333 6C12.6 6 12 6.6 12 7.33333C12 8.06667 12.6 8.66667 13.3333 8.66667ZM16 10.9533C16 10.4133 15.68 9.93333 15.1867 9.72C14.62 9.47333 13.9933 9.33333 13.3333 9.33333C13.0733 9.33333 12.8267 9.36 12.58 9.4C12.8467 9.85333 13 10.3733 13 10.9267V12H15.3333C15.7 12 16 11.7 16 11.3333V10.9533ZM8 4C9.10667 4 10 4.89333 10 6C10 7.10667 9.10667 8 8 8C6.89333 8 6 7.10667 6 6C6 4.89333 6.89333 4 8 4Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 12.75C13.63 12.75 15.07 13.14 16.24 13.65C17.32 14.13 18 15.21 18 16.38V17C18 17.55 17.55 18 17 18H7C6.45 18 6 17.55 6 17V16.39C6 15.21 6.68 14.13 7.76 13.66C8.93 13.14 10.37 12.75 12 12.75ZM4 13C5.1 13 6 12.1 6 11C6 9.9 5.1 9 4 9C2.9 9 2 9.9 2 11C2 12.1 2.9 13 4 13ZM5.13 14.1C4.76 14.04 4.39 14 4 14C3.01 14 2.07 14.21 1.22 14.58C0.48 14.9 0 15.62 0 16.43V17C0 17.55 0.45 18 1 18H4.5V16.39C4.5 15.56 4.73 14.78 5.13 14.1ZM20 13C21.1 13 22 12.1 22 11C22 9.9 21.1 9 20 9C18.9 9 18 9.9 18 11C18 12.1 18.9 13 20 13ZM24 16.43C24 15.62 23.52 14.9 22.78 14.58C21.93 14.21 20.99 14 20 14C19.61 14 19.24 14.04 18.87 14.1C19.27 14.78 19.5 15.56 19.5 16.39V18H23C23.55 18 24 17.55 24 17V16.43ZM12 6C13.66 6 15 7.34 15 9C15 10.66 13.66 12 12 12C10.34 12 9 10.66 9 9C9 7.34 10.34 6 12 6Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 14.875C15.9017 14.875 17.5817 15.33 18.9467 15.925C20.2067 16.485 21 17.745 21 19.11V19.8333C21 20.475 20.475 21 19.8333 21H8.16667C7.525 21 7 20.475 7 19.8333V19.1217C7 17.745 7.79333 16.485 9.05333 15.9367C10.4183 15.33 12.0983 14.875 14 14.875ZM4.66667 15.1667C5.95 15.1667 7 14.1167 7 12.8333C7 11.55 5.95 10.5 4.66667 10.5C3.38333 10.5 2.33333 11.55 2.33333 12.8333C2.33333 14.1167 3.38333 15.1667 4.66667 15.1667ZM5.985 16.45C5.55333 16.38 5.12167 16.3333 4.66667 16.3333C3.51167 16.3333 2.415 16.5783 1.42333 17.01C0.56 17.3833 0 18.2233 0 19.1683V19.8333C0 20.475 0.525 21 1.16667 21H5.25V19.1217C5.25 18.1533 5.51833 17.2433 5.985 16.45ZM23.3333 15.1667C24.6167 15.1667 25.6667 14.1167 25.6667 12.8333C25.6667 11.55 24.6167 10.5 23.3333 10.5C22.05 10.5 21 11.55 21 12.8333C21 14.1167 22.05 15.1667 23.3333 15.1667ZM28 19.1683C28 18.2233 27.44 17.3833 26.5767 17.01C25.585 16.5783 24.4883 16.3333 23.3333 16.3333C22.8783 16.3333 22.4467 16.38 22.015 16.45C22.4817 17.2433 22.75 18.1533 22.75 19.1217V21H26.8333C27.475 21 28 20.475 28 19.8333V19.1683ZM14 7C15.9367 7 17.5 8.56333 17.5 10.5C17.5 12.4367 15.9367 14 14 14C12.0633 14 10.5 12.4367 10.5 10.5C10.5 8.56333 12.0633 7 14 7Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$15; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-groups",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$14 = "/*!@:host*/.sc-swirl-icon-groups-custom-h{display:inline-flex}";

class SwirlIconGroupsCustom {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4.00001 7C3.7693 7 3.54377 6.93159 3.35194 6.80341C3.16011 6.67523 3.01059 6.49305 2.9223 6.2799C2.83401 6.06675 2.81091 5.83221 2.85592 5.60593C2.90093 5.37965 3.01203 5.1718 3.17517 5.00866C3.33831 4.84552 3.54616 4.73442 3.77243 4.68941C3.99871 4.64441 4.23326 4.66751 4.44641 4.7558C4.65956 4.84408 4.84174 4.9936 4.96992 5.18543C5.09809 5.37726 5.16651 5.60279 5.16651 5.8335C5.16657 5.98671 5.13645 6.13842 5.07785 6.27998C5.01925 6.42153 4.93333 6.55016 4.82499 6.65849C4.71666 6.76682 4.58804 6.85274 4.44649 6.91134C4.30493 6.96994 4.15321 7.00007 4.00001 7Z", fill: "currentColor" }), hAsync("path", { d: "M12 7C11.7693 7 11.5438 6.93159 11.3519 6.80341C11.1601 6.67523 11.0106 6.49305 10.9223 6.2799C10.834 6.06675 10.8109 5.83221 10.8559 5.60593C10.9009 5.37965 11.012 5.1718 11.1752 5.00866C11.3383 4.84552 11.5462 4.73442 11.7724 4.68941C11.9987 4.64441 12.2333 4.66751 12.4464 4.7558C12.6596 4.84408 12.8417 4.9936 12.9699 5.18543C13.0981 5.37726 13.1665 5.60279 13.1665 5.8335C13.1666 5.98671 13.1364 6.13842 13.0778 6.27998C13.0192 6.42153 12.9333 6.55016 12.825 6.65849C12.7167 6.76682 12.588 6.85274 12.4465 6.91134C12.3049 6.96994 12.1532 7.00007 12 7Z", fill: "currentColor" }), hAsync("path", { d: "M12.6665 8H11.5215C11.7767 8.23248 11.9807 8.51559 12.1204 8.83127C12.2601 9.14695 12.3325 9.48828 12.333 9.8335V12H13.4165C13.5807 12 13.7432 11.9677 13.8949 11.9049C14.0465 11.842 14.1843 11.75 14.3004 11.6339C14.4165 11.5178 14.5085 11.38 14.5714 11.2284C14.6342 11.0767 14.6665 10.9142 14.6665 10.75V10C14.6665 9.46957 14.4558 8.96086 14.0807 8.58579C13.7056 8.21072 13.1969 8 12.6665 8Z", fill: "currentColor" }), hAsync("path", { d: "M8.00001 7C7.60445 7 7.21777 6.8827 6.88887 6.66294C6.55997 6.44318 6.30362 6.13082 6.15225 5.76537C6.00087 5.39992 5.96127 4.99778 6.03844 4.60982C6.11561 4.22186 6.30609 3.86549 6.58579 3.58579C6.8655 3.30608 7.22187 3.1156 7.60983 3.03843C7.99779 2.96126 8.39992 3.00087 8.76537 3.15224C9.13083 3.30362 9.44318 3.55996 9.66295 3.88886C9.88271 4.21776 10 4.60444 10 5C10 5.53043 9.78929 6.03914 9.41422 6.41421C9.03915 6.78929 8.53044 7 8.00001 7Z", fill: "currentColor" }), hAsync("path", { d: "M9.83351 13H6.16701C5.76918 13 5.38765 12.842 5.10635 12.5607C4.82504 12.2794 4.66701 11.8978 4.66701 11.5V10.4165C4.66701 9.68716 4.95674 8.98768 5.47246 8.47196C5.98819 7.95623 6.68766 7.6665 7.41701 7.6665H8.58351C9.31285 7.6665 10.0123 7.95623 10.5281 8.47196C11.0438 8.98768 11.3335 9.68716 11.3335 10.4165V11.5C11.3335 11.8978 11.1755 12.2794 10.8942 12.5607C10.6129 12.842 10.2313 13 9.83351 13Z", fill: "currentColor" }), hAsync("path", { d: "M3.66651 9.8335C3.66709 9.48825 3.73959 9.14691 3.8794 8.83123C4.0192 8.51555 4.22324 8.23246 4.47851 8H3.33301C2.80257 8 2.29387 8.21072 1.91879 8.58579C1.54372 8.96086 1.33301 9.46957 1.33301 10V10.75C1.33301 10.9142 1.36534 11.0767 1.42816 11.2284C1.49098 11.38 1.58305 11.5178 1.69912 11.6339C1.8152 11.75 1.953 11.842 2.10465 11.9049C2.25631 11.9677 2.41886 12 2.58301 12H3.66651V9.8335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M6.00001 10.5C5.65394 10.5 5.31565 10.3974 5.0279 10.2051C4.74016 10.0128 4.51589 9.73958 4.38345 9.41985C4.25102 9.10013 4.21637 8.74831 4.28388 8.40889C4.3514 8.06947 4.51804 7.7577 4.76275 7.51299C5.00746 7.26828 5.31923 7.10164 5.65865 7.03412C5.99807 6.96661 6.34989 7.00126 6.66961 7.13369C6.98934 7.26613 7.26261 7.4904 7.45488 7.77814C7.64714 8.06589 7.74976 8.40418 7.74976 8.75025C7.74986 8.98006 7.70467 9.20763 7.61677 9.41997C7.52887 9.6323 7.39999 9.82523 7.23749 9.98773C7.07499 10.1502 6.88206 10.2791 6.66973 10.367C6.45739 10.4549 6.22982 10.5001 6.00001 10.5Z", fill: "currentColor" }), hAsync("path", { d: "M18 10.5C17.6539 10.5 17.3156 10.3974 17.0279 10.2051C16.7402 10.0128 16.5159 9.73958 16.3835 9.41985C16.251 9.10013 16.2164 8.74831 16.2839 8.40889C16.3514 8.06947 16.518 7.7577 16.7628 7.51299C17.0075 7.26828 17.3192 7.10164 17.6587 7.03412C17.9981 6.96661 18.3499 7.00126 18.6696 7.13369C18.9893 7.26613 19.2626 7.4904 19.4549 7.77814C19.6471 8.06589 19.7498 8.40418 19.7498 8.75025C19.7499 8.98006 19.7047 9.20763 19.6168 9.41997C19.5289 9.6323 19.4 9.82523 19.2375 9.98773C19.075 10.1502 18.8821 10.2791 18.6697 10.367C18.4574 10.4549 18.2298 10.5001 18 10.5Z", fill: "currentColor" }), hAsync("path", { d: "M18.9998 12H17.2823C17.6651 12.3487 17.971 12.7734 18.1806 13.2469C18.3902 13.7204 18.4988 14.2324 18.4995 14.7503V18H20.1248C20.371 18 20.6148 17.9515 20.8423 17.8573C21.0698 17.763 21.2765 17.6249 21.4506 17.4508C21.6247 17.2767 21.7628 17.07 21.857 16.8425C21.9513 16.615 21.9998 16.3712 21.9998 16.125V15C21.9998 14.2044 21.6837 13.4413 21.1211 12.8787C20.5585 12.3161 19.7954 12 18.9998 12Z", fill: "currentColor" }), hAsync("path", { d: "M12 10.5C11.4067 10.5 10.8266 10.3241 10.3333 9.99441C9.83995 9.66477 9.45544 9.19623 9.22837 8.64805C9.00131 8.09987 8.9419 7.49667 9.05766 6.91473C9.17341 6.33279 9.45913 5.79824 9.87869 5.37868C10.2982 4.95912 10.8328 4.6734 11.4147 4.55765C11.9967 4.44189 12.5999 4.5013 13.1481 4.72836C13.6962 4.95543 14.1648 5.33994 14.4944 5.83329C14.8241 6.32664 15 6.90666 15 7.5C15 8.29565 14.6839 9.05871 14.1213 9.62132C13.5587 10.1839 12.7957 10.5 12 10.5Z", fill: "currentColor" }), hAsync("path", { d: "M14.7503 19.5H9.25051C8.65377 19.5 8.08148 19.2629 7.65952 18.841C7.23757 18.419 7.00051 17.8467 7.00051 17.25V15.6248C7.00051 14.5307 7.43511 13.4815 8.2087 12.7079C8.98228 11.9343 10.0315 11.4998 11.1255 11.4998H12.8753C13.9693 11.4998 15.0185 11.9343 15.7921 12.7079C16.5657 13.4815 17.0003 14.5307 17.0003 15.6248V17.25C17.0003 17.8467 16.7632 18.419 16.3413 18.841C15.9193 19.2629 15.347 19.5 14.7503 19.5Z", fill: "currentColor" }), hAsync("path", { d: "M5.49976 14.7503C5.50064 14.2324 5.60939 13.7204 5.8191 13.2468C6.0288 12.7733 6.33486 12.3487 6.71776 12H4.99951C4.20386 12 3.4408 12.3161 2.87819 12.8787C2.31558 13.4413 1.99951 14.2044 1.99951 15V16.125C1.99951 16.3712 2.04801 16.615 2.14224 16.8425C2.23647 17.07 2.37458 17.2767 2.54869 17.4508C2.7228 17.6249 2.92949 17.763 3.15698 17.8573C3.38447 17.9515 3.62828 18 3.87451 18H5.49976V14.7503Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M7.00001 12.25C6.59627 12.25 6.20159 12.1303 5.86589 11.906C5.53018 11.6817 5.26854 11.3628 5.11403 10.9898C4.95952 10.6168 4.9191 10.2064 4.99786 9.81037C5.07663 9.41439 5.27105 9.05065 5.55654 8.76516C5.84204 8.47966 6.20577 8.28524 6.60176 8.20648C6.99775 8.12771 7.4082 8.16814 7.78121 8.32264C8.15423 8.47715 8.47305 8.7388 8.69736 9.0745C8.92166 9.4102 9.04139 9.80488 9.04139 10.2086C9.0415 10.4767 8.98878 10.7422 8.88623 10.99C8.78369 11.2377 8.63332 11.4628 8.44374 11.6524C8.25416 11.8419 8.02907 11.9923 7.78135 12.0948C7.53363 12.1974 7.26812 12.2501 7.00001 12.25Z", fill: "currentColor" }), hAsync("path", { d: "M21 12.25C20.5963 12.25 20.2016 12.1303 19.8659 11.906C19.5302 11.6817 19.2685 11.3628 19.114 10.9898C18.9595 10.6168 18.9191 10.2064 18.9979 9.81037C19.0766 9.41439 19.2711 9.05065 19.5565 8.76516C19.842 8.47966 20.2058 8.28524 20.6018 8.20648C20.9978 8.12771 21.4082 8.16814 21.7812 8.32264C22.1542 8.47715 22.473 8.7388 22.6974 9.0745C22.9217 9.4102 23.0414 9.80488 23.0414 10.2086C23.0415 10.4767 22.9888 10.7422 22.8862 10.99C22.7837 11.2377 22.6333 11.4628 22.4437 11.6524C22.2542 11.8419 22.0291 11.9923 21.7814 12.0948C21.5336 12.1974 21.2681 12.2501 21 12.25Z", fill: "currentColor" }), hAsync("path", { d: "M22.1664 14H20.1626C20.6092 14.4068 20.9662 14.9023 21.2107 15.4547C21.4552 16.0072 21.5819 16.6045 21.5828 17.2086V21H23.4789C23.7662 21 24.0506 20.9434 24.316 20.8335C24.5814 20.7236 24.8226 20.5624 25.0257 20.3593C25.2288 20.1562 25.3899 19.915 25.4999 19.6496C25.6098 19.3842 25.6664 19.0998 25.6664 18.8125V17.5C25.6664 16.5717 25.2976 15.6815 24.6413 15.0251C23.9849 14.3688 23.0946 14 22.1664 14Z", fill: "currentColor" }), hAsync("path", { d: "M14 12.25C13.3078 12.25 12.6311 12.0447 12.0555 11.6601C11.4799 11.2756 11.0313 10.7289 10.7664 10.0894C10.5015 9.44985 10.4322 8.74612 10.5673 8.06719C10.7023 7.38825 11.0357 6.76461 11.5251 6.27513C12.0146 5.78564 12.6383 5.4523 13.3172 5.31725C13.9961 5.1822 14.6999 5.25152 15.3394 5.51642C15.9789 5.78133 16.5256 6.22993 16.9102 6.80551C17.2947 7.38108 17.5 8.05777 17.5 8.75C17.5 9.67826 17.1313 10.5685 16.4749 11.2249C15.8185 11.8813 14.9283 12.25 14 12.25Z", fill: "currentColor" }), hAsync("path", { d: "M17.2086 22.75H10.7923C10.0961 22.75 9.42839 22.4734 8.93611 21.9812C8.44383 21.4889 8.16726 20.8212 8.16726 20.125V18.2289C8.16726 16.9525 8.67429 15.7284 9.57681 14.8259C10.4793 13.9234 11.7034 13.4164 12.9798 13.4164H15.0211C16.2975 13.4164 17.5216 13.9234 18.4241 14.8259C19.3266 15.7284 19.8336 16.9525 19.8336 18.2289V20.125C19.8336 20.8212 19.5571 21.4889 19.0648 21.9812C18.5725 22.4734 17.9048 22.75 17.2086 22.75Z", fill: "currentColor" }), hAsync("path", { d: "M6.41639 17.2086C6.41741 16.6044 6.54429 16.0071 6.78895 15.4547C7.03361 14.9022 7.39067 14.4068 7.83739 14H5.83276C4.90451 14 4.01427 14.3688 3.35789 15.0251C2.70151 15.6815 2.33276 16.5717 2.33276 17.5V18.8125C2.33276 19.0998 2.38935 19.3842 2.49928 19.6496C2.60921 19.915 2.77034 20.1562 2.97347 20.3593C3.1766 20.5624 3.41774 20.7236 3.68314 20.8335C3.94854 20.9434 4.233 21 4.52026 21H6.41639V17.2086Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$14; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-groups-custom",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$13 = "/*!@:host*/.sc-swirl-icon-groups-filled-h{display:inline-flex}";

class SwirlIconGroupsFilled {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4.00001 7C3.7693 7 3.54377 6.93159 3.35194 6.80341C3.16011 6.67523 3.01059 6.49305 2.9223 6.2799C2.83401 6.06675 2.81091 5.83221 2.85592 5.60593C2.90093 5.37965 3.01203 5.1718 3.17517 5.00866C3.33831 4.84552 3.54616 4.73442 3.77243 4.68941C3.99871 4.64441 4.23326 4.66751 4.44641 4.7558C4.65956 4.84408 4.84174 4.9936 4.96992 5.18543C5.09809 5.37726 5.16651 5.60279 5.16651 5.8335C5.16657 5.98671 5.13645 6.13842 5.07785 6.27998C5.01925 6.42153 4.93333 6.55016 4.82499 6.65849C4.71666 6.76682 4.58804 6.85274 4.44649 6.91134C4.30493 6.96994 4.15321 7.00007 4.00001 7Z", fill: "currentColor" }), hAsync("path", { d: "M12 7C11.7693 7 11.5438 6.93159 11.3519 6.80341C11.1601 6.67523 11.0106 6.49305 10.9223 6.2799C10.834 6.06675 10.8109 5.83221 10.8559 5.60593C10.9009 5.37965 11.012 5.1718 11.1752 5.00866C11.3383 4.84552 11.5462 4.73442 11.7724 4.68941C11.9987 4.64441 12.2333 4.66751 12.4464 4.7558C12.6596 4.84408 12.8417 4.9936 12.9699 5.18543C13.0981 5.37726 13.1665 5.60279 13.1665 5.8335C13.1666 5.98671 13.1364 6.13842 13.0778 6.27998C13.0192 6.42153 12.9333 6.55016 12.825 6.65849C12.7167 6.76682 12.588 6.85274 12.4465 6.91134C12.3049 6.96994 12.1532 7.00007 12 7Z", fill: "currentColor" }), hAsync("path", { d: "M12.6665 8H11.5215C11.7767 8.23248 11.9807 8.51559 12.1204 8.83127C12.2601 9.14695 12.3325 9.48828 12.333 9.8335V12H13.4165C13.5807 12 13.7432 11.9677 13.8949 11.9049C14.0465 11.842 14.1843 11.75 14.3004 11.6339C14.4165 11.5178 14.5085 11.38 14.5714 11.2284C14.6342 11.0767 14.6665 10.9142 14.6665 10.75V10C14.6665 9.46957 14.4558 8.96086 14.0807 8.58579C13.7056 8.21072 13.1969 8 12.6665 8Z", fill: "currentColor" }), hAsync("path", { d: "M8.00001 7C7.60445 7 7.21777 6.8827 6.88887 6.66294C6.55997 6.44318 6.30362 6.13082 6.15225 5.76537C6.00087 5.39992 5.96127 4.99778 6.03844 4.60982C6.11561 4.22186 6.30609 3.86549 6.58579 3.58579C6.8655 3.30608 7.22187 3.1156 7.60983 3.03843C7.99779 2.96126 8.39992 3.00087 8.76537 3.15224C9.13083 3.30362 9.44318 3.55996 9.66295 3.88886C9.88271 4.21776 10 4.60444 10 5C10 5.53043 9.78929 6.03914 9.41422 6.41421C9.03915 6.78929 8.53044 7 8.00001 7Z", fill: "currentColor" }), hAsync("path", { d: "M9.83351 13H6.16701C5.76918 13 5.38765 12.842 5.10635 12.5607C4.82504 12.2794 4.66701 11.8978 4.66701 11.5V10.4165C4.66701 9.68716 4.95674 8.98768 5.47246 8.47196C5.98819 7.95623 6.68766 7.6665 7.41701 7.6665H8.58351C9.31285 7.6665 10.0123 7.95623 10.5281 8.47196C11.0438 8.98768 11.3335 9.68716 11.3335 10.4165V11.5C11.3335 11.8978 11.1755 12.2794 10.8942 12.5607C10.6129 12.842 10.2313 13 9.83351 13Z", fill: "currentColor" }), hAsync("path", { d: "M3.66651 9.8335C3.66709 9.48825 3.73959 9.14691 3.8794 8.83123C4.0192 8.51555 4.22324 8.23246 4.47851 8H3.33301C2.80257 8 2.29387 8.21072 1.91879 8.58579C1.54372 8.96086 1.33301 9.46957 1.33301 10V10.75C1.33301 10.9142 1.36534 11.0767 1.42816 11.2284C1.49098 11.38 1.58305 11.5178 1.69912 11.6339C1.8152 11.75 1.953 11.842 2.10465 11.9049C2.25631 11.9677 2.41886 12 2.58301 12H3.66651V9.8335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M6.00001 10.5C5.65394 10.5 5.31565 10.3974 5.0279 10.2051C4.74016 10.0128 4.51589 9.73958 4.38345 9.41985C4.25102 9.10013 4.21637 8.74831 4.28388 8.40889C4.3514 8.06947 4.51804 7.7577 4.76275 7.51299C5.00746 7.26828 5.31923 7.10164 5.65865 7.03412C5.99807 6.96661 6.34989 7.00126 6.66961 7.13369C6.98934 7.26613 7.26261 7.4904 7.45488 7.77814C7.64714 8.06589 7.74976 8.40418 7.74976 8.75025C7.74986 8.98006 7.70467 9.20763 7.61677 9.41997C7.52887 9.6323 7.39999 9.82523 7.23749 9.98773C7.07499 10.1502 6.88206 10.2791 6.66973 10.367C6.45739 10.4549 6.22982 10.5001 6.00001 10.5Z", fill: "currentColor" }), hAsync("path", { d: "M18 10.5C17.6539 10.5 17.3156 10.3974 17.0279 10.2051C16.7402 10.0128 16.5159 9.73958 16.3835 9.41985C16.251 9.10013 16.2164 8.74831 16.2839 8.40889C16.3514 8.06947 16.518 7.7577 16.7628 7.51299C17.0075 7.26828 17.3192 7.10164 17.6587 7.03412C17.9981 6.96661 18.3499 7.00126 18.6696 7.13369C18.9893 7.26613 19.2626 7.4904 19.4549 7.77814C19.6471 8.06589 19.7498 8.40418 19.7498 8.75025C19.7499 8.98006 19.7047 9.20763 19.6168 9.41997C19.5289 9.6323 19.4 9.82523 19.2375 9.98773C19.075 10.1502 18.8821 10.2791 18.6697 10.367C18.4574 10.4549 18.2298 10.5001 18 10.5Z", fill: "currentColor" }), hAsync("path", { d: "M18.9998 12H17.2823C17.6651 12.3487 17.971 12.7734 18.1806 13.2469C18.3902 13.7204 18.4988 14.2324 18.4995 14.7503V18H20.1248C20.371 18 20.6148 17.9515 20.8423 17.8573C21.0698 17.763 21.2765 17.6249 21.4506 17.4508C21.6247 17.2767 21.7628 17.07 21.857 16.8425C21.9513 16.615 21.9998 16.3712 21.9998 16.125V15C21.9998 14.2044 21.6837 13.4413 21.1211 12.8787C20.5585 12.3161 19.7954 12 18.9998 12Z", fill: "currentColor" }), hAsync("path", { d: "M12 10.5C11.4067 10.5 10.8266 10.3241 10.3333 9.99441C9.83995 9.66477 9.45544 9.19623 9.22837 8.64805C9.00131 8.09987 8.9419 7.49667 9.05766 6.91473C9.17341 6.33279 9.45913 5.79824 9.87869 5.37868C10.2982 4.95912 10.8328 4.6734 11.4147 4.55765C11.9967 4.44189 12.5999 4.5013 13.1481 4.72836C13.6962 4.95543 14.1648 5.33994 14.4944 5.83329C14.8241 6.32664 15 6.90666 15 7.5C15 8.29565 14.6839 9.05871 14.1213 9.62132C13.5587 10.1839 12.7957 10.5 12 10.5Z", fill: "currentColor" }), hAsync("path", { d: "M14.7503 19.5H9.25051C8.65377 19.5 8.08148 19.2629 7.65952 18.841C7.23756 18.419 7.00051 17.8467 7.00051 17.25V15.6248C7.00051 14.5307 7.43511 13.4815 8.2087 12.7079C8.98228 11.9343 10.0315 11.4998 11.1255 11.4998H12.8753C13.9693 11.4998 15.0185 11.9343 15.7921 12.7079C16.5657 13.4815 17.0003 14.5307 17.0003 15.6248V17.25C17.0003 17.8467 16.7632 18.419 16.3413 18.841C15.9193 19.2629 15.347 19.5 14.7503 19.5Z", fill: "currentColor" }), hAsync("path", { d: "M5.49976 14.7503C5.50064 14.2324 5.60939 13.7204 5.8191 13.2468C6.0288 12.7733 6.33486 12.3487 6.71776 12H4.99951C4.20386 12 3.4408 12.3161 2.87819 12.8787C2.31558 13.4413 1.99951 14.2044 1.99951 15V16.125C1.99951 16.3712 2.04801 16.615 2.14224 16.8425C2.23647 17.07 2.37458 17.2767 2.54869 17.4508C2.7228 17.6249 2.92949 17.763 3.15698 17.8573C3.38447 17.9515 3.62828 18 3.87451 18H5.49976V14.7503Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M7.00001 12.25C6.59627 12.25 6.20159 12.1303 5.86589 11.906C5.53018 11.6817 5.26854 11.3628 5.11403 10.9898C4.95952 10.6168 4.9191 10.2064 4.99786 9.81037C5.07663 9.41439 5.27105 9.05065 5.55654 8.76516C5.84204 8.47966 6.20577 8.28524 6.60176 8.20648C6.99775 8.12771 7.4082 8.16814 7.78121 8.32264C8.15423 8.47715 8.47305 8.7388 8.69736 9.0745C8.92166 9.4102 9.04139 9.80488 9.04139 10.2086C9.0415 10.4767 8.98878 10.7422 8.88623 10.99C8.78369 11.2377 8.63332 11.4628 8.44374 11.6524C8.25416 11.8419 8.02907 11.9923 7.78135 12.0948C7.53363 12.1974 7.26812 12.2501 7.00001 12.25Z", fill: "currentColor" }), hAsync("path", { d: "M21 12.25C20.5963 12.25 20.2016 12.1303 19.8659 11.906C19.5302 11.6817 19.2685 11.3628 19.114 10.9898C18.9595 10.6168 18.9191 10.2064 18.9979 9.81037C19.0766 9.41439 19.2711 9.05065 19.5565 8.76516C19.842 8.47966 20.2058 8.28524 20.6018 8.20648C20.9978 8.12771 21.4082 8.16814 21.7812 8.32264C22.1542 8.47715 22.473 8.7388 22.6974 9.0745C22.9217 9.4102 23.0414 9.80488 23.0414 10.2086C23.0415 10.4767 22.9888 10.7422 22.8862 10.99C22.7837 11.2377 22.6333 11.4628 22.4437 11.6524C22.2542 11.8419 22.0291 11.9923 21.7814 12.0948C21.5336 12.1974 21.2681 12.2501 21 12.25Z", fill: "currentColor" }), hAsync("path", { d: "M22.1664 14H20.1626C20.6092 14.4068 20.9662 14.9023 21.2107 15.4547C21.4552 16.0072 21.5819 16.6045 21.5828 17.2086V21H23.4789C23.7662 21 24.0506 20.9434 24.316 20.8335C24.5814 20.7236 24.8226 20.5624 25.0257 20.3593C25.2288 20.1562 25.3899 19.915 25.4999 19.6496C25.6098 19.3842 25.6664 19.0998 25.6664 18.8125V17.5C25.6664 16.5717 25.2976 15.6815 24.6413 15.0251C23.9849 14.3688 23.0946 14 22.1664 14Z", fill: "currentColor" }), hAsync("path", { d: "M14 12.25C13.3078 12.25 12.6311 12.0447 12.0555 11.6601C11.4799 11.2756 11.0313 10.7289 10.7664 10.0894C10.5015 9.44985 10.4322 8.74612 10.5673 8.06719C10.7023 7.38825 11.0357 6.76461 11.5251 6.27513C12.0146 5.78564 12.6383 5.4523 13.3172 5.31725C13.9961 5.1822 14.6999 5.25152 15.3394 5.51642C15.9789 5.78133 16.5256 6.22993 16.9102 6.80551C17.2947 7.38108 17.5 8.05777 17.5 8.75C17.5 9.67826 17.1313 10.5685 16.4749 11.2249C15.8185 11.8813 14.9283 12.25 14 12.25Z", fill: "currentColor" }), hAsync("path", { d: "M17.2086 22.75H10.7923C10.0961 22.75 9.42839 22.4734 8.93611 21.9812C8.44383 21.4889 8.16726 20.8212 8.16726 20.125V18.2289C8.16726 16.9525 8.67429 15.7284 9.57681 14.8259C10.4793 13.9234 11.7034 13.4164 12.9798 13.4164H15.0211C16.2975 13.4164 17.5216 13.9234 18.4241 14.8259C19.3266 15.7284 19.8336 16.9525 19.8336 18.2289V20.125C19.8336 20.8212 19.5571 21.4889 19.0648 21.9812C18.5725 22.4734 17.9048 22.75 17.2086 22.75Z", fill: "currentColor" }), hAsync("path", { d: "M6.41639 17.2086C6.41741 16.6044 6.54429 16.0071 6.78895 15.4547C7.03361 14.9022 7.39067 14.4068 7.83739 14H5.83276C4.90451 14 4.01427 14.3688 3.35789 15.0251C2.70151 15.6815 2.33276 16.5717 2.33276 17.5V18.8125C2.33276 19.0998 2.38935 19.3842 2.49928 19.6496C2.60921 19.915 2.77034 20.1562 2.97347 20.3593C3.1766 20.5624 3.41774 20.7236 3.68314 20.8335C3.94854 20.9434 4.233 21 4.52026 21H6.41639V17.2086Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$13; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-groups-filled",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$12 = "/*!@:host*/.sc-swirl-icon-groups-outlined-h{display:inline-flex}";

class SwirlIconGroupsOutlined {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 4C8.19778 4 8.39112 4.05865 8.55557 4.16853C8.72002 4.27841 8.84819 4.43459 8.92388 4.61732C8.99956 4.80004 9.01937 5.00111 8.98078 5.19509C8.9422 5.38907 8.84696 5.56725 8.7071 5.70711C8.56725 5.84696 8.38907 5.9422 8.19509 5.98079C8.00111 6.01937 7.80004 5.99957 7.61731 5.92388C7.43459 5.84819 7.27841 5.72002 7.16853 5.55557C7.05865 5.39112 7 5.19778 7 5C7 4.73478 7.10535 4.48043 7.29289 4.29289C7.48043 4.10536 7.73478 4 8 4ZM8 3C7.60443 3 7.21775 3.1173 6.88886 3.33706C6.55996 3.55682 6.30361 3.86918 6.15224 4.23463C6.00086 4.60009 5.96126 5.00222 6.03843 5.39018C6.1156 5.77814 6.30608 6.13451 6.58578 6.41421C6.86549 6.69392 7.22185 6.8844 7.60982 6.96157C7.99778 7.03874 8.39991 6.99913 8.76536 6.84776C9.13081 6.69638 9.44317 6.44004 9.66294 6.11114C9.8827 5.78224 10 5.39556 10 5C10 4.46957 9.78928 3.96086 9.41421 3.58579C9.03914 3.21071 8.53043 3 8 3Z", fill: "currentColor" }), hAsync("path", { d: "M8.583 8.6665C9.04713 8.6665 9.49224 8.85087 9.82043 9.17906C10.1486 9.50725 10.333 9.95237 10.333 10.4165V11.5C10.333 11.6326 10.2803 11.7598 10.1865 11.8536C10.0928 11.9473 9.9656 12 9.833 12H6.1665C6.03389 12 5.90671 11.9473 5.81294 11.8536C5.71917 11.7598 5.6665 11.6326 5.6665 11.5V10.4165C5.6665 9.95237 5.85087 9.50725 6.17906 9.17906C6.50725 8.85087 6.95237 8.6665 7.4165 8.6665H8.583ZM8.583 7.6665H7.4165C6.68715 7.6665 5.98768 7.95623 5.47195 8.47196C4.95623 8.98768 4.6665 9.68715 4.6665 10.4165V11.5C4.6665 11.8978 4.82453 12.2794 5.10584 12.5607C5.38714 12.842 5.76867 13 6.1665 13H9.833C10.2308 13 10.6124 12.842 10.8937 12.5607C11.175 12.2794 11.333 11.8978 11.333 11.5V10.4165C11.333 9.68715 11.0433 8.98768 10.5275 8.47196C10.0118 7.95623 9.31234 7.6665 8.583 7.6665Z", fill: "currentColor" }), hAsync("path", { d: "M13.4165 12H12.6665C12.5339 12 12.4067 11.9473 12.3129 11.8536C12.2192 11.7598 12.1665 11.6326 12.1665 11.5C12.1665 11.3674 12.2192 11.2402 12.3129 11.1464C12.4067 11.0527 12.5339 11 12.6665 11H13.4165C13.4828 11 13.5464 10.9737 13.5933 10.9268C13.6402 10.8799 13.6665 10.8163 13.6665 10.75V10C13.6665 9.73478 13.5611 9.48043 13.3736 9.29289C13.1861 9.10536 12.9317 9 12.6665 9H12.1665C12.0339 9 11.9067 8.94732 11.8129 8.85355C11.7192 8.75979 11.6665 8.63261 11.6665 8.5C11.6665 8.36739 11.7192 8.24021 11.8129 8.14645C11.9067 8.05268 12.0339 8 12.1665 8H12.6665C13.1969 8 13.7056 8.21071 14.0807 8.58579C14.4558 8.96086 14.6665 9.46957 14.6665 10V10.75C14.6665 10.9142 14.6342 11.0767 14.5713 11.2284C14.5085 11.38 14.4165 11.5178 14.3004 11.6339C14.1843 11.75 14.0465 11.842 13.8949 11.9048C13.7432 11.9677 13.5806 12 13.4165 12Z", fill: "currentColor" }), hAsync("path", { d: "M3.3335 12H2.5835C2.41934 12 2.2568 11.9677 2.10514 11.9048C1.95348 11.842 1.81569 11.75 1.69961 11.6339C1.58354 11.5178 1.49147 11.38 1.42865 11.2284C1.36583 11.0767 1.3335 10.9142 1.3335 10.75V10C1.3335 9.46957 1.54421 8.96086 1.91928 8.58579C2.29436 8.21071 2.80306 8 3.3335 8H3.8335C3.9661 8 4.09328 8.05268 4.18705 8.14645C4.28082 8.24021 4.3335 8.36739 4.3335 8.5C4.3335 8.63261 4.28082 8.75979 4.18705 8.85355C4.09328 8.94732 3.9661 9 3.8335 9H3.3335C3.06828 9 2.81393 9.10536 2.62639 9.29289C2.43885 9.48043 2.3335 9.73478 2.3335 10V10.75C2.3335 10.8163 2.35984 10.8799 2.40672 10.9268C2.4536 10.9737 2.51719 11 2.5835 11H3.3335C3.4661 11 3.59328 11.0527 3.68705 11.1464C3.78082 11.2402 3.8335 11.3674 3.8335 11.5C3.8335 11.6326 3.78082 11.7598 3.68705 11.8536C3.59328 11.9473 3.4661 12 3.3335 12Z", fill: "currentColor" }), hAsync("path", { d: "M4 7C3.80221 7 3.60888 6.94135 3.44443 6.83147C3.27998 6.72159 3.1518 6.56541 3.07612 6.38268C3.00043 6.19996 2.98063 5.99889 3.01921 5.80491C3.0578 5.61093 3.15304 5.43275 3.29289 5.29289C3.43274 5.15304 3.61092 5.0578 3.80491 5.01921C3.99889 4.98063 4.19995 5.00043 4.38268 5.07612C4.56541 5.15181 4.72158 5.27998 4.83147 5.44443C4.94135 5.60888 5 5.80222 5 6C5 6.26522 4.89464 6.51957 4.7071 6.70711C4.51957 6.89464 4.26521 7 4 7Z", fill: "currentColor" }), hAsync("path", { d: "M12 7C11.8022 7 11.6089 6.94135 11.4444 6.83147C11.28 6.72159 11.1518 6.56541 11.0761 6.38268C11.0004 6.19996 10.9806 5.99889 11.0192 5.80491C11.0578 5.61093 11.153 5.43275 11.2929 5.29289C11.4327 5.15304 11.6109 5.0578 11.8049 5.01921C11.9989 4.98063 12.2 5.00043 12.3827 5.07612C12.5654 5.15181 12.7216 5.27998 12.8315 5.44443C12.9413 5.60888 13 5.80222 13 6C13 6.26522 12.8946 6.51957 12.7071 6.70711C12.5196 6.89464 12.2652 7 12 7Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 6C12.2967 6 12.5867 6.08797 12.8334 6.2528C13.08 6.41762 13.2723 6.65189 13.3858 6.92598C13.4993 7.20006 13.5291 7.50166 13.4712 7.79264C13.4133 8.08361 13.2704 8.35088 13.0607 8.56066C12.8509 8.77044 12.5836 8.9133 12.2926 8.97118C12.0017 9.02906 11.7001 8.99935 11.426 8.88582C11.1519 8.77229 10.9176 8.58003 10.7528 8.33336C10.588 8.08668 10.5 7.79667 10.5 7.5C10.5 7.10218 10.658 6.72064 10.9393 6.43934C11.2206 6.15804 11.6022 6 12 6ZM12 4.5C11.4067 4.5 10.8266 4.67595 10.3333 5.00559C9.83994 5.33524 9.45542 5.80377 9.22836 6.35195C9.00129 6.90013 8.94188 7.50333 9.05764 8.08527C9.17339 8.66721 9.45912 9.20176 9.87867 9.62132C10.2982 10.0409 10.8328 10.3266 11.4147 10.4424C11.9967 10.5581 12.5999 10.4987 13.148 10.2716C13.6962 10.0446 14.1648 9.66006 14.4944 9.16671C14.824 8.67336 15 8.09334 15 7.5C15 6.70435 14.6839 5.94129 14.1213 5.37868C13.5587 4.81607 12.7956 4.5 12 4.5Z", fill: "currentColor" }), hAsync("path", { d: "M12.8745 12.9998C13.5707 12.9998 14.2384 13.2763 14.7306 13.7686C15.2229 14.2609 15.4995 14.9286 15.4995 15.6248V17.25C15.4995 17.4489 15.4205 17.6397 15.2798 17.7803C15.1392 17.921 14.9484 18 14.7495 18H9.24974C9.05083 18 8.86007 17.921 8.71941 17.7803C8.57876 17.6397 8.49974 17.4489 8.49974 17.25V15.6248C8.49974 14.9286 8.77631 14.2609 9.26859 13.7686C9.76087 13.2763 10.4286 12.9998 11.1247 12.9998H12.8745ZM12.8745 11.4998H11.1247C10.0307 11.4998 8.98152 11.9343 8.20793 12.7079C7.43434 13.4815 6.99974 14.5307 6.99974 15.6248V17.25C6.99974 17.8467 7.2368 18.419 7.65875 18.841C8.08071 19.2629 8.65301 19.5 9.24974 19.5H14.7495C15.3462 19.5 15.9185 19.2629 16.3405 18.841C16.7624 18.419 16.9995 17.8467 16.9995 17.25V15.6248C16.9995 14.5307 16.5649 13.4815 15.7913 12.7079C15.0177 11.9343 13.9685 11.4998 12.8745 11.4998Z", fill: "currentColor" }), hAsync("path", { d: "M20.1247 18H18.9997C18.8008 18 18.6101 17.921 18.4694 17.7803C18.3288 17.6397 18.2497 17.4489 18.2497 17.25C18.2497 17.0511 18.3288 16.8603 18.4694 16.7197C18.6101 16.579 18.8008 16.5 18.9997 16.5H20.1247C20.2242 16.5 20.3196 16.4605 20.3899 16.3902C20.4602 16.3198 20.4997 16.2245 20.4997 16.125V15C20.4997 14.6022 20.3417 14.2206 20.0604 13.9393C19.7791 13.658 19.3976 13.5 18.9997 13.5H18.2497C18.0508 13.5 17.8601 13.421 17.7194 13.2803C17.5788 13.1397 17.4997 12.9489 17.4997 12.75C17.4997 12.5511 17.5788 12.3603 17.7194 12.2197C17.8601 12.079 18.0508 12 18.2497 12H18.9997C19.7954 12 20.5585 12.3161 21.1211 12.8787C21.6837 13.4413 21.9997 14.2044 21.9997 15V16.125C21.9997 16.3712 21.9512 16.615 21.857 16.8425C21.7628 17.07 21.6247 17.2767 21.4506 17.4508C21.2765 17.6249 21.0698 17.763 20.8423 17.8573C20.6148 17.9515 20.371 18 20.1247 18Z", fill: "currentColor" }), hAsync("path", { d: "M5.00024 18H3.87524C3.62902 18 3.3852 17.9515 3.15771 17.8573C2.93023 17.763 2.72353 17.6249 2.54942 17.4508C2.37531 17.2767 2.2372 17.07 2.14297 16.8425C2.04874 16.615 2.00024 16.3712 2.00024 16.125V15C2.00024 14.2044 2.31631 13.4413 2.87892 12.8787C3.44153 12.3161 4.20459 12 5.00024 12H5.75024C5.94916 12 6.13992 12.079 6.28057 12.2197C6.42123 12.3603 6.50024 12.5511 6.50024 12.75C6.50024 12.9489 6.42123 13.1397 6.28057 13.2803C6.13992 13.421 5.94916 13.5 5.75024 13.5H5.00024C4.60242 13.5 4.22089 13.658 3.93958 13.9393C3.65828 14.2206 3.50024 14.6022 3.50024 15V16.125C3.50024 16.2245 3.53975 16.3198 3.61008 16.3902C3.68041 16.4605 3.77579 16.5 3.87524 16.5H5.00024C5.19916 16.5 5.38992 16.579 5.53057 16.7197C5.67123 16.8603 5.75024 17.0511 5.75024 17.25C5.75024 17.4489 5.67123 17.6397 5.53057 17.7803C5.38992 17.921 5.19916 18 5.00024 18Z", fill: "currentColor" }), hAsync("path", { d: "M5.99999 10.5C5.70332 10.5 5.41331 10.412 5.16664 10.2472C4.91997 10.0824 4.72771 9.84811 4.61417 9.57402C4.50064 9.29994 4.47094 8.99834 4.52882 8.70736C4.58669 8.41639 4.72956 8.14912 4.93933 7.93934C5.14911 7.72956 5.41639 7.5867 5.70736 7.52882C5.99833 7.47094 6.29993 7.50065 6.57402 7.61418C6.84811 7.72771 7.08238 7.91997 7.2472 8.16664C7.41202 8.41332 7.49999 8.70333 7.49999 9C7.49999 9.39782 7.34196 9.77936 7.06065 10.0607C6.77935 10.342 6.39782 10.5 5.99999 10.5Z", fill: "currentColor" }), hAsync("path", { d: "M18 10.5C17.7033 10.5 17.4133 10.412 17.1666 10.2472C16.92 10.0824 16.7277 9.84811 16.6142 9.57402C16.5006 9.29994 16.4709 8.99834 16.5288 8.70736C16.5867 8.41639 16.7296 8.14912 16.9393 7.93934C17.1491 7.72956 17.4164 7.5867 17.7074 7.52882C17.9983 7.47094 18.2999 7.50065 18.574 7.61418C18.8481 7.72771 19.0824 7.91997 19.2472 8.16664C19.412 8.41332 19.5 8.70333 19.5 9C19.5 9.39782 19.342 9.77936 19.0607 10.0607C18.7793 10.342 18.3978 10.5 18 10.5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 7C14.3461 7 14.6845 7.10264 14.9722 7.29493C15.26 7.48722 15.4843 7.76053 15.6168 8.0803C15.7492 8.40007 15.7839 8.75194 15.7164 9.09141C15.6488 9.43087 15.4822 9.74269 15.2374 9.98744C14.9927 10.2322 14.6809 10.3989 14.3414 10.4664C14.0019 10.5339 13.6501 10.4992 13.3303 10.3668C13.0105 10.2343 12.7372 10.01 12.5449 9.72225C12.3526 9.43446 12.25 9.09612 12.25 8.75C12.25 8.28587 12.4344 7.84075 12.7626 7.51256C13.0907 7.18437 13.5359 7 14 7ZM14 5.25C13.3078 5.25 12.6311 5.45527 12.0555 5.83986C11.4799 6.22444 11.0313 6.77107 10.7664 7.41061C10.5015 8.05015 10.4322 8.75388 10.5672 9.43282C10.7023 10.1117 11.0356 10.7354 11.5251 11.2249C12.0146 11.7144 12.6382 12.0477 13.3172 12.1827C13.9961 12.3178 14.6998 12.2485 15.3394 11.9836C15.9789 11.7187 16.5256 11.2701 16.9101 10.6945C17.2947 10.1189 17.5 9.44223 17.5 8.75C17.5 7.82174 17.1312 6.9315 16.4749 6.27513C15.8185 5.61875 14.9283 5.25 14 5.25Z", fill: "currentColor" }), hAsync("path", { d: "M15.0202 15.1664C15.8325 15.1664 16.6114 15.489 17.1858 16.0634C17.7601 16.6377 18.0827 17.4166 18.0827 18.2289V20.125C18.0827 20.3571 17.9906 20.5796 17.8265 20.7437C17.6624 20.9078 17.4398 21 17.2077 21H10.7914C10.5593 21 10.3367 20.9078 10.1727 20.7437C10.0086 20.5796 9.91637 20.3571 9.91637 20.125V18.2289C9.91637 17.4166 10.239 16.6377 10.8134 16.0634C11.3877 15.489 12.1666 15.1664 12.9789 15.1664H15.0202ZM15.0202 13.4164H12.9789C11.7025 13.4164 10.4784 13.9234 9.57592 14.8259C8.6734 15.7284 8.16637 16.9525 8.16637 18.2289V20.125C8.16637 20.8212 8.44293 21.4889 8.93521 21.9812C9.4275 22.4734 10.0952 22.75 10.7914 22.75H17.2077C17.9039 22.75 18.5716 22.4734 19.0639 21.9812C19.5562 21.4889 19.8327 20.8212 19.8327 20.125V18.2289C19.8327 16.9525 19.3257 15.7284 18.4232 14.8259C17.5207 13.9234 16.2966 13.4164 15.0202 13.4164Z", fill: "currentColor" }), hAsync("path", { d: "M23.4789 21H22.1664C21.9343 21 21.7117 20.9078 21.5476 20.7437C21.3836 20.5796 21.2914 20.3571 21.2914 20.125C21.2914 19.8929 21.3836 19.6704 21.5476 19.5063C21.7117 19.3422 21.9343 19.25 22.1664 19.25H23.4789C23.5949 19.25 23.7062 19.2039 23.7882 19.1219C23.8703 19.0398 23.9164 18.9285 23.9164 18.8125V17.5C23.9164 17.0359 23.732 16.5908 23.4038 16.2626C23.0756 15.9344 22.6305 15.75 22.1664 15.75H21.2914C21.0593 15.75 20.8367 15.6578 20.6726 15.4937C20.5086 15.3296 20.4164 15.1071 20.4164 14.875C20.4164 14.6429 20.5086 14.4204 20.6726 14.2563C20.8367 14.0922 21.0593 14 21.2914 14H22.1664C23.0946 14 23.9849 14.3687 24.6412 15.0251C25.2976 15.6815 25.6664 16.5717 25.6664 17.5V18.8125C25.6664 19.0998 25.6098 19.3842 25.4999 19.6496C25.3899 19.915 25.2288 20.1562 25.0257 20.3593C24.8225 20.5624 24.5814 20.7236 24.316 20.8335C24.0506 20.9434 23.7661 21 23.4789 21Z", fill: "currentColor" }), hAsync("path", { d: "M5.83362 21H4.52112C4.23385 21 3.9494 20.9434 3.684 20.8335C3.4186 20.7236 3.17745 20.5624 2.97432 20.3593C2.77119 20.1562 2.61006 19.915 2.50013 19.6496C2.3902 19.3842 2.33362 19.0998 2.33362 18.8125V17.5C2.33362 16.5717 2.70237 15.6815 3.35874 15.0251C4.01512 14.3687 4.90536 14 5.83362 14H6.70862C6.94068 14 7.16324 14.0922 7.32734 14.2563C7.49143 14.4204 7.58362 14.6429 7.58362 14.875C7.58362 15.1071 7.49143 15.3296 7.32734 15.4937C7.16324 15.6578 6.94068 15.75 6.70862 15.75H5.83362C5.36949 15.75 4.92437 15.9344 4.59618 16.2626C4.26799 16.5908 4.08362 17.0359 4.08362 17.5V18.8125C4.08362 18.9285 4.12971 19.0398 4.21176 19.1219C4.29381 19.2039 4.40509 19.25 4.52112 19.25H5.83362C6.06568 19.25 6.28824 19.3422 6.45234 19.5063C6.61643 19.6704 6.70862 19.8929 6.70862 20.125C6.70862 20.3571 6.61643 20.5796 6.45234 20.7437C6.28824 20.9078 6.06568 21 5.83362 21Z", fill: "currentColor" }), hAsync("path", { d: "M6.99999 12.25C6.65388 12.25 6.31553 12.1474 6.02775 11.9551C5.73996 11.7628 5.51566 11.4895 5.3832 11.1697C5.25075 10.8499 5.21609 10.4981 5.28362 10.1586C5.35114 9.81913 5.51781 9.50731 5.76256 9.26256C6.0073 9.01782 6.31912 8.85115 6.65859 8.78363C6.99805 8.7161 7.34992 8.75076 7.66969 8.88321C7.98946 9.01566 8.26277 9.23997 8.45507 9.52775C8.64736 9.81554 8.74999 10.1539 8.74999 10.5C8.74999 10.9641 8.56562 11.4092 8.23743 11.7374C7.90924 12.0656 7.46412 12.25 6.99999 12.25Z", fill: "currentColor" }), hAsync("path", { d: "M21 12.25C20.6539 12.25 20.3155 12.1474 20.0277 11.9551C19.74 11.7628 19.5157 11.4895 19.3832 11.1697C19.2507 10.8499 19.2161 10.4981 19.2836 10.1586C19.3511 9.81913 19.5178 9.50731 19.7626 9.26256C20.0073 9.01782 20.3191 8.85115 20.6586 8.78363C20.9981 8.7161 21.3499 8.75076 21.6697 8.88321C21.9895 9.01566 22.2628 9.23997 22.4551 9.52775C22.6474 9.81554 22.75 10.1539 22.75 10.5C22.75 10.9641 22.5656 11.4092 22.2374 11.7374C21.9092 12.0656 21.4641 12.25 21 12.25Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$12; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-groups-outlined",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$11 = "/*!@:host*/.sc-swirl-icon-help-h{display:inline-flex}";

class SwirlIconHelp {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.96665 11.9987C8.19998 11.9987 8.39731 11.918 8.55865 11.7567C8.71953 11.5958 8.79998 11.3987 8.79998 11.1654C8.79998 10.932 8.71953 10.7349 8.55865 10.574C8.39731 10.4127 8.19998 10.332 7.96665 10.332C7.73331 10.332 7.53598 10.4127 7.37465 10.574C7.21376 10.7349 7.13331 10.932 7.13331 11.1654C7.13331 11.3987 7.21376 11.5958 7.37465 11.7567C7.53598 11.918 7.73331 11.9987 7.96665 11.9987ZM8.06665 5.13203C8.37776 5.13203 8.62776 5.21803 8.81665 5.39003C9.00554 5.56248 9.09998 5.78759 9.09998 6.06536C9.09998 6.25425 9.0362 6.44581 8.90865 6.64003C8.78065 6.8347 8.59998 7.03759 8.36665 7.2487C8.03331 7.53759 7.78887 7.81536 7.63331 8.08203C7.47776 8.3487 7.39998 8.61536 7.39998 8.88203C7.39998 9.03759 7.45842 9.16803 7.57531 9.27336C7.69176 9.37914 7.82776 9.43203 7.98331 9.43203C8.13887 9.43203 8.27776 9.37648 8.39998 9.26536C8.5222 9.15425 8.59998 9.01536 8.63331 8.8487C8.66665 8.65981 8.74176 8.48492 8.85865 8.32403C8.97509 8.1627 9.16665 7.95425 9.43331 7.6987C9.77776 7.37648 10.0195 7.08203 10.1586 6.81536C10.2973 6.5487 10.3666 6.25425 10.3666 5.93203C10.3666 5.36536 10.1529 4.90136 9.72531 4.54003C9.29731 4.17914 8.74442 3.9987 8.06665 3.9987C7.59998 3.9987 7.1862 4.08759 6.82531 4.26536C6.46398 4.44314 6.18331 4.71536 5.98331 5.08203C5.90554 5.22648 5.87776 5.36803 5.89998 5.5067C5.9222 5.64581 5.99998 5.75981 6.13331 5.8487C6.27776 5.93759 6.4362 5.96536 6.60865 5.93203C6.78065 5.8987 6.9222 5.80425 7.03331 5.6487C7.15554 5.48203 7.30287 5.35425 7.47531 5.26536C7.64731 5.17648 7.84442 5.13203 8.06665 5.13203ZM7.99998 14.6654C7.08887 14.6654 6.22776 14.4903 5.41665 14.14C4.60554 13.7903 3.89731 13.3154 3.29198 12.7154C2.6862 12.1154 2.20842 11.4098 1.85865 10.5987C1.50842 9.78759 1.33331 8.92092 1.33331 7.9987C1.33331 7.07648 1.50842 6.20981 1.85865 5.3987C2.20842 4.58759 2.6862 3.88203 3.29198 3.28203C3.89731 2.68203 4.60554 2.20692 5.41665 1.8567C6.22776 1.50692 7.08887 1.33203 7.99998 1.33203C8.93331 1.33203 9.80553 1.50692 10.6166 1.8567C11.4278 2.20692 12.1333 2.68203 12.7333 3.28203C13.3333 3.88203 13.8055 4.58759 14.15 5.3987C14.4944 6.20981 14.6666 7.07648 14.6666 7.9987C14.6666 8.92092 14.4944 9.78759 14.15 10.5987C13.8055 11.4098 13.3333 12.1154 12.7333 12.7154C12.1333 13.3154 11.4278 13.7903 10.6166 14.14C9.80553 14.4903 8.93331 14.6654 7.99998 14.6654ZM7.99998 13.332C9.48887 13.332 10.75 12.8127 11.7833 11.774C12.8166 10.7349 13.3333 9.47647 13.3333 7.9987C13.3333 6.52092 12.8166 5.26248 11.7833 4.22336C10.75 3.1847 9.48887 2.66536 7.99998 2.66536C6.54442 2.66536 5.29153 3.1847 4.24131 4.22336C3.19154 5.26248 2.66665 6.52092 2.66665 7.9987C2.66665 9.47647 3.19154 10.7349 4.24131 11.774C5.29153 12.8127 6.54442 13.332 7.99998 13.332Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M11.95 18C12.3 18 12.596 17.879 12.838 17.637C13.0793 17.3957 13.2 17.1 13.2 16.75C13.2 16.4 13.0793 16.1043 12.838 15.863C12.596 15.621 12.3 15.5 11.95 15.5C11.6 15.5 11.304 15.621 11.062 15.863C10.8207 16.1043 10.7 16.4 10.7 16.75C10.7 17.1 10.8207 17.3957 11.062 17.637C11.304 17.879 11.6 18 11.95 18ZM12.1 7.7C12.5667 7.7 12.9417 7.829 13.225 8.087C13.5083 8.34567 13.65 8.68333 13.65 9.1C13.65 9.38333 13.5543 9.67067 13.363 9.962C13.171 10.254 12.9 10.5583 12.55 10.875C12.05 11.3083 11.6833 11.725 11.45 12.125C11.2167 12.525 11.1 12.925 11.1 13.325C11.1 13.5583 11.1877 13.754 11.363 13.912C11.5377 14.0707 11.7417 14.15 11.975 14.15C12.2083 14.15 12.4167 14.0667 12.6 13.9C12.7833 13.7333 12.9 13.525 12.95 13.275C13 12.9917 13.1127 12.7293 13.288 12.488C13.4627 12.246 13.75 11.9333 14.15 11.55C14.6667 11.0667 15.0293 10.625 15.238 10.225C15.446 9.825 15.55 9.38333 15.55 8.9C15.55 8.05 15.2293 7.354 14.588 6.812C13.946 6.27067 13.1167 6 12.1 6C11.4 6 10.7793 6.13333 10.238 6.4C9.696 6.66667 9.275 7.075 8.975 7.625C8.85833 7.84167 8.81667 8.054 8.85 8.262C8.88333 8.47067 9 8.64167 9.2 8.775C9.41667 8.90833 9.65433 8.95 9.913 8.9C10.171 8.85 10.3833 8.70833 10.55 8.475C10.7333 8.225 10.9543 8.03333 11.213 7.9C11.471 7.76667 11.7667 7.7 12.1 7.7ZM12 22C10.6333 22 9.34167 21.7373 8.125 21.212C6.90833 20.6873 5.846 19.975 4.938 19.075C4.02933 18.175 3.31267 17.1167 2.788 15.9C2.26267 14.6833 2 13.3833 2 12C2 10.6167 2.26267 9.31667 2.788 8.1C3.31267 6.88333 4.02933 5.825 4.938 4.925C5.846 4.025 6.90833 3.31233 8.125 2.787C9.34167 2.26233 10.6333 2 12 2C13.4 2 14.7083 2.26233 15.925 2.787C17.1417 3.31233 18.2 4.025 19.1 4.925C20 5.825 20.7083 6.88333 21.225 8.1C21.7417 9.31667 22 10.6167 22 12C22 13.3833 21.7417 14.6833 21.225 15.9C20.7083 17.1167 20 18.175 19.1 19.075C18.2 19.975 17.1417 20.6873 15.925 21.212C14.7083 21.7373 13.4 22 12 22ZM12 20C14.2333 20 16.125 19.221 17.675 17.663C19.225 16.1043 20 14.2167 20 12C20 9.78333 19.225 7.89567 17.675 6.337C16.125 4.779 14.2333 4 12 4C9.81667 4 7.93733 4.779 6.362 6.337C4.78733 7.89567 4 9.78333 4 12C4 14.2167 4.78733 16.1043 6.362 17.663C7.93733 19.221 9.81667 20 12 20Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M13.9417 20.9999C14.35 20.9999 14.6953 20.8588 14.9777 20.5764C15.2592 20.2949 15.4 19.9499 15.4 19.5416C15.4 19.1333 15.2592 18.7883 14.9777 18.5068C14.6953 18.2244 14.35 18.0833 13.9417 18.0833C13.5333 18.0833 13.188 18.2244 12.9057 18.5068C12.6241 18.7883 12.4833 19.1333 12.4833 19.5416C12.4833 19.9499 12.6241 20.2949 12.9057 20.5764C13.188 20.8588 13.5333 20.9999 13.9417 20.9999ZM14.1167 8.98325C14.6611 8.98325 15.0986 9.13375 15.4292 9.43475C15.7597 9.73653 15.925 10.1305 15.925 10.6166C15.925 10.9471 15.8134 11.2824 15.5902 11.6223C15.3662 11.9629 15.05 12.318 14.6417 12.6874C14.0583 13.193 13.6306 13.6791 13.3583 14.1458C13.0861 14.6124 12.95 15.0791 12.95 15.5458C12.95 15.818 13.0523 16.0463 13.2568 16.2306C13.4606 16.4157 13.6986 16.5083 13.9708 16.5083C14.2431 16.5083 14.4861 16.411 14.7 16.2166C14.9139 16.0221 15.05 15.7791 15.1083 15.4874C15.1667 15.1569 15.2981 14.8508 15.5027 14.5693C15.7064 14.2869 16.0417 13.9221 16.5083 13.4749C17.1111 12.911 17.5342 12.3958 17.7777 11.9291C18.0203 11.4624 18.1417 10.9471 18.1417 10.3833C18.1417 9.39159 17.7676 8.57959 17.0193 7.94725C16.2703 7.3157 15.3028 6.99992 14.1167 6.99992C13.3 6.99992 12.5759 7.15547 11.9443 7.46659C11.312 7.7777 10.8208 8.25409 10.4708 8.89575C10.3347 9.14853 10.2861 9.39625 10.325 9.63892C10.3639 9.88236 10.5 10.0819 10.7333 10.2374C10.9861 10.393 11.2634 10.4416 11.5652 10.3833C11.8662 10.3249 12.1139 10.1596 12.3083 9.88742C12.5222 9.59575 12.7801 9.37214 13.0818 9.21659C13.3828 9.06103 13.7278 8.98325 14.1167 8.98325ZM14 25.6666C12.4056 25.6666 10.8986 25.3601 9.47917 24.7473C8.05973 24.1351 6.82034 23.3041 5.761 22.2541C4.70089 21.2041 3.86478 19.9694 3.25267 18.5499C2.63978 17.1305 2.33334 15.6138 2.33334 13.9999C2.33334 12.386 2.63978 10.8694 3.25267 9.44992C3.86478 8.03048 4.70089 6.79575 5.761 5.74575C6.82034 4.69575 8.05973 3.86431 9.47917 3.25142C10.8986 2.63931 12.4056 2.33325 14 2.33325C15.6333 2.33325 17.1597 2.63931 18.5792 3.25142C19.9986 3.86431 21.2333 4.69575 22.2833 5.74575C23.3333 6.79575 24.1597 8.03048 24.7625 9.44992C25.3653 10.8694 25.6667 12.386 25.6667 13.9999C25.6667 15.6138 25.3653 17.1305 24.7625 18.5499C24.1597 19.9694 23.3333 21.2041 22.2833 22.2541C21.2333 23.3041 19.9986 24.1351 18.5792 24.7473C17.1597 25.3601 15.6333 25.6666 14 25.6666ZM14 23.3333C16.6056 23.3333 18.8125 22.4244 20.6208 20.6068C22.4292 18.7883 23.3333 16.586 23.3333 13.9999C23.3333 11.4138 22.4292 9.21153 20.6208 7.39309C18.8125 5.57542 16.6056 4.66659 14 4.66659C11.4528 4.66659 9.26023 5.57542 7.42234 7.39309C5.58523 9.21153 4.66667 11.4138 4.66667 13.9999C4.66667 16.586 5.58523 18.7883 7.42234 20.6068C9.26023 22.4244 11.4528 23.3333 14 23.3333Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$11; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-help",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$10 = "/*!@:host*/.sc-swirl-icon-highlight-h{display:inline-flex}";

class SwirlIconHighlight {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.6667 8.66665C12.4778 8.66665 12.3195 8.60277 12.1917 8.47499C12.0639 8.34721 12 8.18888 12 7.99999C12 7.8111 12.0639 7.65277 12.1917 7.52499C12.3195 7.39721 12.4778 7.33332 12.6667 7.33332H14C14.1889 7.33332 14.3473 7.39721 14.475 7.52499C14.6028 7.65277 14.6667 7.8111 14.6667 7.99999C14.6667 8.18888 14.6028 8.34721 14.475 8.47499C14.3473 8.60277 14.1889 8.66665 14 8.66665H12.6667ZM12.2667 12.9333L11.2 12.1333C11.0445 12.0222 10.9556 11.8778 10.9334 11.7C10.9112 11.5222 10.9556 11.3555 11.0667 11.2C11.1778 11.0444 11.3223 10.9555 11.5 10.9333C11.6778 10.9111 11.8445 10.9555 12 11.0667L13.0667 11.8667C13.2223 11.9778 13.3112 12.1222 13.3334 12.3C13.3556 12.4778 13.3112 12.6444 13.2 12.8C13.0889 12.9555 12.9445 13.0444 12.7667 13.0667C12.5889 13.0889 12.4223 13.0444 12.2667 12.9333ZM12 4.93332C11.8445 5.04443 11.6778 5.08888 11.5 5.06665C11.3223 5.04443 11.1778 4.95554 11.0667 4.79999C10.9556 4.64443 10.9112 4.47776 10.9334 4.29999C10.9556 4.12221 11.0445 3.97776 11.2 3.86665L12.2667 3.06665C12.4223 2.95554 12.5889 2.9111 12.7667 2.93332C12.9445 2.95554 13.0889 3.04443 13.2 3.19999C13.3112 3.35554 13.3556 3.52221 13.3334 3.69999C13.3112 3.87776 13.2223 4.02221 13.0667 4.13332L12 4.93332ZM3.33337 12.6667V9.99999H2.66671C2.30004 9.99999 1.98615 9.86943 1.72504 9.60832C1.46393 9.34721 1.33337 9.03332 1.33337 8.66665V7.33332C1.33337 6.96665 1.46393 6.65277 1.72504 6.39165C1.98615 6.13054 2.30004 5.99999 2.66671 5.99999H5.33337L7.65004 4.59999C7.87226 4.46665 8.09726 4.46665 8.32504 4.59999C8.55282 4.73332 8.66671 4.92776 8.66671 5.18332V10.8167C8.66671 11.0722 8.55282 11.2667 8.32504 11.4C8.09726 11.5333 7.87226 11.5333 7.65004 11.4L5.33337 9.99999H4.66671V12.6667H3.33337ZM9.33337 10.2333V5.76665C9.63337 6.03332 9.87504 6.35832 10.0584 6.74165C10.2417 7.12499 10.3334 7.54443 10.3334 7.99999C10.3334 8.45554 10.2417 8.87499 10.0584 9.25832C9.87504 9.64165 9.63337 9.96665 9.33337 10.2333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M19 13C18.7167 13 18.4792 12.9042 18.2875 12.7125C18.0958 12.5208 18 12.2833 18 12C18 11.7167 18.0958 11.4792 18.2875 11.2875C18.4792 11.0958 18.7167 11 19 11H21C21.2833 11 21.5208 11.0958 21.7125 11.2875C21.9042 11.4792 22 11.7167 22 12C22 12.2833 21.9042 12.5208 21.7125 12.7125C21.5208 12.9042 21.2833 13 21 13H19ZM18.4 19.4L16.8 18.2C16.5667 18.0333 16.4333 17.8167 16.4 17.55C16.3667 17.2833 16.4333 17.0333 16.6 16.8C16.7667 16.5667 16.9833 16.4333 17.25 16.4C17.5167 16.3667 17.7667 16.4333 18 16.6L19.6 17.8C19.8333 17.9667 19.9667 18.1833 20 18.45C20.0333 18.7167 19.9667 18.9667 19.8 19.2C19.6333 19.4333 19.4167 19.5667 19.15 19.6C18.8833 19.6333 18.6333 19.5667 18.4 19.4ZM18 7.4C17.7667 7.56666 17.5167 7.63333 17.25 7.6C16.9833 7.56666 16.7667 7.43333 16.6 7.2C16.4333 6.96666 16.3667 6.71666 16.4 6.45C16.4333 6.18333 16.5667 5.96666 16.8 5.8L18.4 4.6C18.6333 4.43333 18.8833 4.36666 19.15 4.4C19.4167 4.43333 19.6333 4.56666 19.8 4.8C19.9667 5.03333 20.0333 5.28333 20 5.55C19.9667 5.81666 19.8333 6.03333 19.6 6.2L18 7.4ZM5 19V15H4C3.45 15 2.97917 14.8042 2.5875 14.4125C2.19583 14.0208 2 13.55 2 13V11C2 10.45 2.19583 9.97916 2.5875 9.5875C2.97917 9.19583 3.45 9 4 9H8L11.475 6.9C11.8083 6.7 12.1458 6.7 12.4875 6.9C12.8292 7.1 13 7.39166 13 7.775V16.225C13 16.6083 12.8292 16.9 12.4875 17.1C12.1458 17.3 11.8083 17.3 11.475 17.1L8 15H7V19H5ZM14 15.35V8.65C14.45 9.05 14.8125 9.5375 15.0875 10.1125C15.3625 10.6875 15.5 11.3167 15.5 12C15.5 12.6833 15.3625 13.3125 15.0875 13.8875C14.8125 14.4625 14.45 14.95 14 15.35Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M22.1667 15.1667C21.8362 15.1667 21.5591 15.0548 21.3355 14.8312C21.1118 14.6076 21 14.3305 21 14C21 13.6694 21.1118 13.3923 21.3355 13.1687C21.5591 12.9451 21.8362 12.8333 22.1667 12.8333H24.5C24.8306 12.8333 25.1077 12.9451 25.3313 13.1687C25.5549 13.3923 25.6667 13.6694 25.6667 14C25.6667 14.3305 25.5549 14.6076 25.3313 14.8312C25.1077 15.0548 24.8306 15.1667 24.5 15.1667H22.1667ZM21.4667 22.6333L19.6 21.2333C19.3278 21.0389 19.1723 20.7861 19.1334 20.475C19.0945 20.1639 19.1723 19.8722 19.3667 19.6C19.5612 19.3278 19.8139 19.1722 20.125 19.1333C20.4362 19.0944 20.7278 19.1722 21 19.3667L22.8667 20.7667C23.1389 20.9611 23.2945 21.2139 23.3334 21.525C23.3723 21.8361 23.2945 22.1278 23.1 22.4C22.9056 22.6722 22.6528 22.8278 22.3417 22.8667C22.0306 22.9055 21.7389 22.8278 21.4667 22.6333ZM21 8.63332C20.7278 8.82776 20.4362 8.90554 20.125 8.86665C19.8139 8.82776 19.5612 8.67221 19.3667 8.39999C19.1723 8.12776 19.0945 7.8361 19.1334 7.52499C19.1723 7.21387 19.3278 6.9611 19.6 6.76665L21.4667 5.36665C21.7389 5.17221 22.0306 5.09443 22.3417 5.13332C22.6528 5.17221 22.9056 5.32776 23.1 5.59999C23.2945 5.87221 23.3723 6.16387 23.3334 6.47499C23.2945 6.7861 23.1389 7.03887 22.8667 7.23332L21 8.63332ZM5.83337 22.1667V17.5H4.66671C4.02504 17.5 3.47574 17.2715 3.01879 16.8146C2.56185 16.3576 2.33337 15.8083 2.33337 15.1667V12.8333C2.33337 12.1917 2.56185 11.6423 3.01879 11.1854C3.47574 10.7285 4.02504 10.5 4.66671 10.5H9.33337L13.3875 8.04999C13.7764 7.81665 14.1702 7.81665 14.5688 8.04999C14.9674 8.28332 15.1667 8.6236 15.1667 9.07082V18.9292C15.1667 19.3764 14.9674 19.7167 14.5688 19.95C14.1702 20.1833 13.7764 20.1833 13.3875 19.95L9.33337 17.5H8.16671V22.1667H5.83337ZM16.3334 17.9083V10.0917C16.8584 10.5583 17.2813 11.1271 17.6021 11.7979C17.923 12.4687 18.0834 13.2028 18.0834 14C18.0834 14.7972 17.923 15.5312 17.6021 16.2021C17.2813 16.8729 16.8584 17.4417 16.3334 17.9083Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$10; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-highlight",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$$ = "/*!@:host*/.sc-swirl-icon-home-h{display:inline-flex}";

class SwirlIconHome {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.99996 14C3.63329 14 3.3194 13.8694 3.05829 13.6083C2.79718 13.3472 2.66663 13.0333 2.66663 12.6667V6.66667C2.66663 6.45556 2.71385 6.25556 2.80829 6.06667C2.90274 5.87778 3.03329 5.72222 3.19996 5.6L7.19996 2.6C7.32218 2.51111 7.44996 2.44445 7.58329 2.4C7.71663 2.35556 7.85552 2.33334 7.99996 2.33334C8.1444 2.33334 8.28329 2.35556 8.41663 2.4C8.54996 2.44445 8.67774 2.51111 8.79996 2.6L12.8 5.6C12.9666 5.72222 13.0972 5.87778 13.1916 6.06667C13.2861 6.25556 13.3333 6.45556 13.3333 6.66667V12.6667C13.3333 13.0333 13.2027 13.3472 12.9416 13.6083C12.6805 13.8694 12.3666 14 12 14H9.33329V9.33334H6.66663V14H3.99996Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M6 21C5.45 21 4.97917 20.8042 4.5875 20.4125C4.19583 20.0208 4 19.55 4 19V10C4 9.68333 4.07083 9.38333 4.2125 9.1C4.35417 8.81667 4.55 8.58333 4.8 8.4L10.8 3.9C10.9833 3.76667 11.175 3.66667 11.375 3.6C11.575 3.53333 11.7833 3.5 12 3.5C12.2167 3.5 12.425 3.53333 12.625 3.6C12.825 3.66667 13.0167 3.76667 13.2 3.9L19.2 8.4C19.45 8.58333 19.6458 8.81667 19.7875 9.1C19.9292 9.38333 20 9.68333 20 10V19C20 19.55 19.8042 20.0208 19.4125 20.4125C19.0208 20.8042 18.55 21 18 21H14V14H10V21H6Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M6 21C5.45 21 4.97917 20.8042 4.5875 20.4125C4.19583 20.0208 4 19.55 4 19V10C4 9.68333 4.07083 9.38333 4.2125 9.1C4.35417 8.81667 4.55 8.58333 4.8 8.4L10.8 3.9C10.9833 3.76667 11.175 3.66667 11.375 3.6C11.575 3.53333 11.7833 3.5 12 3.5C12.2167 3.5 12.425 3.53333 12.625 3.6C12.825 3.66667 13.0167 3.76667 13.2 3.9L19.2 8.4C19.45 8.58333 19.6458 8.81667 19.7875 9.1C19.9292 9.38333 20 9.68333 20 10V19C20 19.55 19.8042 20.0208 19.4125 20.4125C19.0208 20.8042 18.55 21 18 21H14V14H10V21H6Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$$; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-home",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$_ = "/*!@:host*/.sc-swirl-icon-image-h{display:inline-flex}";

class SwirlIconImage {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66667 11.3333H11.3333C11.4667 11.3333 11.5667 11.2722 11.6333 11.15C11.7 11.0278 11.6889 10.9111 11.6 10.8L9.76667 8.35C9.7 8.26111 9.61111 8.21667 9.5 8.21667C9.38889 8.21667 9.3 8.26111 9.23333 8.35L7.5 10.6667L6.26667 9.01667C6.2 8.92778 6.11111 8.88333 6 8.88333C5.88889 8.88333 5.8 8.92778 5.73333 9.01667L4.4 10.8C4.31111 10.9111 4.3 11.0278 4.36667 11.15C4.43333 11.2722 4.53333 11.3333 4.66667 11.3333ZM3.33333 14C2.96667 14 2.65267 13.8696 2.39133 13.6087C2.13044 13.3473 2 13.0333 2 12.6667V3.33333C2 2.96667 2.13044 2.65267 2.39133 2.39133C2.65267 2.13044 2.96667 2 3.33333 2H12.6667C13.0333 2 13.3473 2.13044 13.6087 2.39133C13.8696 2.65267 14 2.96667 14 3.33333V12.6667C14 13.0333 13.8696 13.3473 13.6087 13.6087C13.3473 13.8696 13.0333 14 12.6667 14H3.33333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M7 17H17C17.2 17 17.35 16.9083 17.45 16.725C17.55 16.5417 17.5333 16.3667 17.4 16.2L14.65 12.525C14.55 12.3917 14.4167 12.325 14.25 12.325C14.0833 12.325 13.95 12.3917 13.85 12.525L11.25 16L9.4 13.525C9.3 13.3917 9.16667 13.325 9 13.325C8.83333 13.325 8.7 13.3917 8.6 13.525L6.6 16.2C6.46667 16.3667 6.45 16.5417 6.55 16.725C6.65 16.9083 6.8 17 7 17ZM5 21C4.45 21 3.979 20.8043 3.587 20.413C3.19567 20.021 3 19.55 3 19V5C3 4.45 3.19567 3.979 3.587 3.587C3.979 3.19567 4.45 3 5 3H19C19.55 3 20.021 3.19567 20.413 3.587C20.8043 3.979 21 4.45 21 5V19C21 19.55 20.8043 20.021 20.413 20.413C20.021 20.8043 19.55 21 19 21H5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M8.16667 19.8333H19.8333C20.0667 19.8333 20.2417 19.7264 20.3583 19.5125C20.475 19.2986 20.4556 19.0944 20.3 18.9L17.0917 14.6125C16.975 14.4569 16.8194 14.3792 16.625 14.3792C16.4306 14.3792 16.275 14.4569 16.1583 14.6125L13.125 18.6667L10.9667 15.7792C10.85 15.6236 10.6944 15.5458 10.5 15.5458C10.3056 15.5458 10.15 15.6236 10.0333 15.7792L7.7 18.9C7.54444 19.0944 7.525 19.2986 7.64167 19.5125C7.75833 19.7264 7.93333 19.8333 8.16667 19.8333ZM5.83333 24.5C5.19167 24.5 4.64217 24.2717 4.18483 23.8152C3.72828 23.3578 3.5 22.8083 3.5 22.1667V5.83333C3.5 5.19167 3.72828 4.64217 4.18483 4.18483C4.64217 3.72828 5.19167 3.5 5.83333 3.5H22.1667C22.8083 3.5 23.3578 3.72828 23.8152 4.18483C24.2717 4.64217 24.5 5.19167 24.5 5.83333V22.1667C24.5 22.8083 24.2717 23.3578 23.8152 23.8152C23.3578 24.2717 22.8083 24.5 22.1667 24.5H5.83333Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$_; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-image",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$Z = "/*!@:host*/.sc-swirl-icon-improve-text-h{display:inline-flex}";

class SwirlIconImproveText {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M2.66667 6C2.47778 6 2.31944 5.93611 2.19167 5.80833C2.06389 5.68056 2 5.52222 2 5.33333C2 5.14444 2.06389 4.98611 2.19167 4.85833C2.31944 4.73056 2.47778 4.66667 2.66667 4.66667H13.3333C13.5222 4.66667 13.6806 4.73056 13.8083 4.85833C13.9361 4.98611 14 5.14444 14 5.33333C14 5.52222 13.9361 5.68056 13.8083 5.80833C13.6806 5.93611 13.5222 6 13.3333 6H2.66667ZM2.66667 8.66667C2.47778 8.66667 2.31944 8.60278 2.19167 8.475C2.06389 8.34722 2 8.18889 2 8C2 7.81111 2.06389 7.65278 2.19167 7.525C2.31944 7.39722 2.47778 7.33333 2.66667 7.33333H13.3333C13.5222 7.33333 13.6806 7.39722 13.8083 7.525C13.9361 7.65278 14 7.81111 14 8C14 8.18889 13.9361 8.34722 13.8083 8.475C13.6806 8.60278 13.5222 8.66667 13.3333 8.66667H2.66667ZM2.66667 11.3333C2.47778 11.3333 2.31944 11.2694 2.19167 11.1417C2.06389 11.0139 2 10.8556 2 10.6667C2 10.4778 2.06389 10.3194 2.19167 10.1917C2.31944 10.0639 2.47778 10 2.66667 10H7.33333C7.52222 10 7.68056 10.0639 7.80833 10.1917C7.93611 10.3194 8 10.4778 8 10.6667C8 10.8556 7.93611 11.0139 7.80833 11.1417C7.68056 11.2694 7.52222 11.3333 7.33333 11.3333H2.66667ZM2.66667 14C2.47778 14 2.31944 13.9361 2.19167 13.8083C2.06389 13.6806 2 13.5222 2 13.3333C2 13.1444 2.06389 12.9861 2.19167 12.8583C2.31944 12.7306 2.47778 12.6667 2.66667 12.6667H7.33333C7.52222 12.6667 7.68056 12.7306 7.80833 12.8583C7.93611 12.9861 8 13.1444 8 13.3333C8 13.5222 7.93611 13.6806 7.80833 13.8083C7.68056 13.9361 7.52222 14 7.33333 14H2.66667ZM2.66667 3.33333C2.47778 3.33333 2.31944 3.26944 2.19167 3.14167C2.06389 3.01389 2 2.85556 2 2.66667C2 2.47778 2.06389 2.31944 2.19167 2.19167C2.31944 2.06389 2.47778 2 2.66667 2H13.3333C13.5222 2 13.6806 2.06389 13.8083 2.19167C13.9361 2.31944 14 2.47778 14 2.66667C14 2.85556 13.9361 3.01389 13.8083 3.14167C13.6806 3.26944 13.5222 3.33333 13.3333 3.33333H2.66667Z", fill: "currentColor" }), hAsync("path", { d: "M11.1667 12.8333L12 14.6667L12.8333 12.8333L14.6667 12L12.8333 11.1667L12 9.33333L11.1667 11.1667L9.33333 12L11.1667 12.8333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M4 9C3.71667 9 3.47917 8.90417 3.2875 8.7125C3.09583 8.52083 3 8.28333 3 8C3 7.71667 3.09583 7.47917 3.2875 7.2875C3.47917 7.09583 3.71667 7 4 7H20C20.2833 7 20.5208 7.09583 20.7125 7.2875C20.9042 7.47917 21 7.71667 21 8C21 8.28333 20.9042 8.52083 20.7125 8.7125C20.5208 8.90417 20.2833 9 20 9H4ZM4 13C3.71667 13 3.47917 12.9042 3.2875 12.7125C3.09583 12.5208 3 12.2833 3 12C3 11.7167 3.09583 11.4792 3.2875 11.2875C3.47917 11.0958 3.71667 11 4 11H20C20.2833 11 20.5208 11.0958 20.7125 11.2875C20.9042 11.4792 21 11.7167 21 12C21 12.2833 20.9042 12.5208 20.7125 12.7125C20.5208 12.9042 20.2833 13 20 13H4ZM4 17C3.71667 17 3.47917 16.9042 3.2875 16.7125C3.09583 16.5208 3 16.2833 3 16C3 15.7167 3.09583 15.4792 3.2875 15.2875C3.47917 15.0958 3.71667 15 4 15H11C11.2833 15 11.5208 15.0958 11.7125 15.2875C11.9042 15.4792 12 15.7167 12 16C12 16.2833 11.9042 16.5208 11.7125 16.7125C11.5208 16.9042 11.2833 17 11 17H4ZM4 21C3.71667 21 3.47917 20.9042 3.2875 20.7125C3.09583 20.5208 3 20.2833 3 20C3 19.7167 3.09583 19.4792 3.2875 19.2875C3.47917 19.0958 3.71667 19 4 19H11C11.2833 19 11.5208 19.0958 11.7125 19.2875C11.9042 19.4792 12 19.7167 12 20C12 20.2833 11.9042 20.5208 11.7125 20.7125C11.5208 20.9042 11.2833 21 11 21H4ZM4 5C3.71667 5 3.47917 4.90417 3.2875 4.7125C3.09583 4.52083 3 4.28333 3 4C3 3.71667 3.09583 3.47917 3.2875 3.2875C3.47917 3.09583 3.71667 3 4 3H20C20.2833 3 20.5208 3.09583 20.7125 3.2875C20.9042 3.47917 21 3.71667 21 4C21 4.28333 20.9042 4.52083 20.7125 4.7125C20.5208 4.90417 20.2833 5 20 5H4Z", fill: "currentColor" }), hAsync("path", { d: "M16.75 19.25L18 22L19.25 19.25L22 18L19.25 16.75L18 14L16.75 16.75L14 18L16.75 19.25Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66667 10.5C4.33611 10.5 4.05903 10.3882 3.83542 10.1646C3.61181 9.94097 3.5 9.66389 3.5 9.33333C3.5 9.00278 3.61181 8.72569 3.83542 8.50208C4.05903 8.27847 4.33611 8.16667 4.66667 8.16667H23.3333C23.6639 8.16667 23.941 8.27847 24.1646 8.50208C24.3882 8.72569 24.5 9.00278 24.5 9.33333C24.5 9.66389 24.3882 9.94097 24.1646 10.1646C23.941 10.3882 23.6639 10.5 23.3333 10.5H4.66667ZM4.66667 15.1667C4.33611 15.1667 4.05903 15.0549 3.83542 14.8313C3.61181 14.6076 3.5 14.3306 3.5 14C3.5 13.6694 3.61181 13.3924 3.83542 13.1688C4.05903 12.9451 4.33611 12.8333 4.66667 12.8333H23.3333C23.6639 12.8333 23.941 12.9451 24.1646 13.1688C24.3882 13.3924 24.5 13.6694 24.5 14C24.5 14.3306 24.3882 14.6076 24.1646 14.8313C23.941 15.0549 23.6639 15.1667 23.3333 15.1667H4.66667ZM4.66667 19.8333C4.33611 19.8333 4.05903 19.7215 3.83542 19.4979C3.61181 19.2743 3.5 18.9972 3.5 18.6667C3.5 18.3361 3.61181 18.059 3.83542 17.8354C4.05903 17.6118 4.33611 17.5 4.66667 17.5H12.8333C13.1639 17.5 13.441 17.6118 13.6646 17.8354C13.8882 18.059 14 18.3361 14 18.6667C14 18.9972 13.8882 19.2743 13.6646 19.4979C13.441 19.7215 13.1639 19.8333 12.8333 19.8333H4.66667ZM4.66667 24.5C4.33611 24.5 4.05903 24.3882 3.83542 24.1646C3.61181 23.941 3.5 23.6639 3.5 23.3333C3.5 23.0028 3.61181 22.7257 3.83542 22.5021C4.05903 22.2785 4.33611 22.1667 4.66667 22.1667H12.8333C13.1639 22.1667 13.441 22.2785 13.6646 22.5021C13.8882 22.7257 14 23.0028 14 23.3333C14 23.6639 13.8882 23.941 13.6646 24.1646C13.441 24.3882 13.1639 24.5 12.8333 24.5H4.66667ZM4.66667 5.83333C4.33611 5.83333 4.05903 5.72153 3.83542 5.49792C3.61181 5.27431 3.5 4.99722 3.5 4.66667C3.5 4.33611 3.61181 4.05903 3.83542 3.83542C4.05903 3.61181 4.33611 3.5 4.66667 3.5H23.3333C23.6639 3.5 23.941 3.61181 24.1646 3.83542C24.3882 4.05903 24.5 4.33611 24.5 4.66667C24.5 4.99722 24.3882 5.27431 24.1646 5.49792C23.941 5.72153 23.6639 5.83333 23.3333 5.83333H4.66667Z", fill: "currentColor" }), hAsync("path", { d: "M19.5417 22.4583L21 25.6667L22.4583 22.4583L25.6667 21L22.4583 19.5417L21 16.3333L19.5417 19.5417L16.3333 21L19.5417 22.4583Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$Z; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-improve-text",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$Y = "/*!@:host*/.sc-swirl-icon-info-h{display:inline-flex}";

class SwirlIconInfo {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.00001 1.33333C4.32001 1.33333 1.33334 4.32 1.33334 8C1.33334 11.68 4.32001 14.6667 8.00001 14.6667C11.68 14.6667 14.6667 11.68 14.6667 8C14.6667 4.32 11.68 1.33333 8.00001 1.33333ZM8.00001 11.3333C7.63334 11.3333 7.33334 11.0333 7.33334 10.6667V8C7.33334 7.63333 7.63334 7.33333 8.00001 7.33333C8.36668 7.33333 8.66668 7.63333 8.66668 8V10.6667C8.66668 11.0333 8.36668 11.3333 8.00001 11.3333ZM8.66668 5.33333C8.66668 5.70152 8.3682 6 8.00001 6C7.63182 6 7.33334 5.70152 7.33334 5.33333C7.33334 4.96514 7.63182 4.66667 8.00001 4.66667C8.3682 4.66667 8.66668 4.96514 8.66668 5.33333Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 17C11.45 17 11 16.55 11 16V12C11 11.45 11.45 11 12 11C12.55 11 13 11.45 13 12V16C13 16.55 12.55 17 12 17ZM13 8C13 8.55228 12.5523 9 12 9C11.4477 9 11 8.55228 11 8C11 7.44772 11.4477 7 12 7C12.5523 7 13 7.44772 13 8Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 2.33333C7.56001 2.33333 2.33334 7.56 2.33334 14C2.33334 20.44 7.56001 25.6667 14 25.6667C20.44 25.6667 25.6667 20.44 25.6667 14C25.6667 7.56 20.44 2.33333 14 2.33333ZM14 19.8333C13.3583 19.8333 12.8333 19.3083 12.8333 18.6667V14C12.8333 13.3583 13.3583 12.8333 14 12.8333C14.6417 12.8333 15.1667 13.3583 15.1667 14V18.6667C15.1667 19.3083 14.6417 19.8333 14 19.8333ZM15.1667 9.33333C15.1667 9.97767 14.6443 10.5 14 10.5C13.3557 10.5 12.8333 9.97767 12.8333 9.33333C12.8333 8.689 13.3557 8.16667 14 8.16667C14.6443 8.16667 15.1667 8.689 15.1667 9.33333Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$Y; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-info",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$X = "/*!@:host*/.sc-swirl-icon-insert-below-h{display:inline-flex}";

class SwirlIconInsertBelow {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.33335 8.3335C3.14446 8.3335 2.98613 8.26961 2.85835 8.14183C2.73058 8.01405 2.66669 7.85572 2.66669 7.66683C2.66669 7.47794 2.73058 7.31961 2.85835 7.19183C2.98613 7.06405 3.14446 7.00016 3.33335 7.00016H11.5C12.2 7.00016 12.7917 7.24183 13.275 7.72516C13.7584 8.2085 14 8.80016 14 9.50016C14 10.2002 13.7584 10.7918 13.275 11.2752C12.7917 11.7585 12.2 12.0002 11.5 12.0002H9.90002L10.2667 12.3668C10.4 12.5002 10.4667 12.6585 10.4667 12.8418C10.4667 13.0252 10.4 13.1835 10.2667 13.3168C10.1334 13.4502 9.97502 13.5168 9.79169 13.5168C9.60835 13.5168 9.45002 13.4502 9.31669 13.3168L7.80002 11.8002C7.73335 11.7335 7.68613 11.6613 7.65835 11.5835C7.63058 11.5057 7.61669 11.4224 7.61669 11.3335C7.61669 11.2446 7.63058 11.1613 7.65835 11.0835C7.68613 11.0057 7.73335 10.9335 7.80002 10.8668L9.33335 9.3335C9.45558 9.21127 9.60835 9.15016 9.79169 9.15016C9.97502 9.15016 10.1334 9.21683 10.2667 9.35016C10.4 9.4835 10.4639 9.64461 10.4584 9.8335C10.4528 10.0224 10.3834 10.1835 10.25 10.3168L9.90002 10.6668H11.5C11.8222 10.6668 12.0972 10.5529 12.325 10.3252C12.5528 10.0974 12.6667 9.82239 12.6667 9.50016C12.6667 9.17794 12.5528 8.90294 12.325 8.67516C12.0972 8.44739 11.8222 8.3335 11.5 8.3335H3.33335ZM3.33335 4.66683C3.14446 4.66683 2.98613 4.60294 2.85835 4.47516C2.73058 4.34738 2.66669 4.18905 2.66669 4.00016C2.66669 3.81127 2.73058 3.65294 2.85835 3.52516C2.98613 3.39738 3.14446 3.3335 3.33335 3.3335H12.6667C12.8556 3.3335 13.0139 3.39738 13.1417 3.52516C13.2695 3.65294 13.3334 3.81127 13.3334 4.00016C13.3334 4.18905 13.2695 4.34738 13.1417 4.47516C13.0139 4.60294 12.8556 4.66683 12.6667 4.66683H3.33335ZM3.33335 12.0002C3.14446 12.0002 2.98613 11.9363 2.85835 11.8085C2.73058 11.6807 2.66669 11.5224 2.66669 11.3335C2.66669 11.1446 2.73058 10.9863 2.85835 10.8585C2.98613 10.7307 3.14446 10.6668 3.33335 10.6668H5.35002C5.53891 10.6668 5.69446 10.7307 5.81669 10.8585C5.93891 10.9863 6.00002 11.1446 6.00002 11.3335C6.00002 11.5224 5.93613 11.6807 5.80835 11.8085C5.68058 11.9363 5.52224 12.0002 5.33335 12.0002H3.33335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5 12.5C4.71667 12.5 4.47917 12.4042 4.2875 12.2125C4.09583 12.0208 4 11.7833 4 11.5C4 11.2167 4.09583 10.9792 4.2875 10.7875C4.47917 10.5958 4.71667 10.5 5 10.5H17.25C18.3 10.5 19.1875 10.8625 19.9125 11.5875C20.6375 12.3125 21 13.2 21 14.25C21 15.3 20.6375 16.1875 19.9125 16.9125C19.1875 17.6375 18.3 18 17.25 18H14.85L15.4 18.55C15.6 18.75 15.7 18.9875 15.7 19.2625C15.7 19.5375 15.6 19.775 15.4 19.975C15.2 20.175 14.9625 20.275 14.6875 20.275C14.4125 20.275 14.175 20.175 13.975 19.975L11.7 17.7C11.6 17.6 11.5292 17.4917 11.4875 17.375C11.4458 17.2583 11.425 17.1333 11.425 17C11.425 16.8667 11.4458 16.7417 11.4875 16.625C11.5292 16.5083 11.6 16.4 11.7 16.3L14 14C14.1833 13.8167 14.4125 13.725 14.6875 13.725C14.9625 13.725 15.2 13.825 15.4 14.025C15.6 14.225 15.6958 14.4667 15.6875 14.75C15.6792 15.0333 15.575 15.275 15.375 15.475L14.85 16H17.25C17.7333 16 18.1458 15.8292 18.4875 15.4875C18.8292 15.1458 19 14.7333 19 14.25C19 13.7667 18.8292 13.3542 18.4875 13.0125C18.1458 12.6708 17.7333 12.5 17.25 12.5H5ZM5 7C4.71667 7 4.47917 6.90417 4.2875 6.7125C4.09583 6.52083 4 6.28333 4 6C4 5.71667 4.09583 5.47917 4.2875 5.2875C4.47917 5.09583 4.71667 5 5 5H19C19.2833 5 19.5208 5.09583 19.7125 5.2875C19.9042 5.47917 20 5.71667 20 6C20 6.28333 19.9042 6.52083 19.7125 6.7125C19.5208 6.90417 19.2833 7 19 7H5ZM5 18C4.71667 18 4.47917 17.9042 4.2875 17.7125C4.09583 17.5208 4 17.2833 4 17C4 16.7167 4.09583 16.4792 4.2875 16.2875C4.47917 16.0958 4.71667 16 5 16H8.025C8.30833 16 8.54167 16.0958 8.725 16.2875C8.90833 16.4792 9 16.7167 9 17C9 17.2833 8.90417 17.5208 8.7125 17.7125C8.52083 17.9042 8.28333 18 8 18H5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M5.83332 14.5835C5.50277 14.5835 5.22568 14.4717 5.00207 14.2481C4.77846 14.0245 4.66666 13.7474 4.66666 13.4168C4.66666 13.0863 4.77846 12.8092 5.00207 12.5856C5.22568 12.362 5.50277 12.2502 5.83332 12.2502H20.125C21.35 12.2502 22.3854 12.6731 23.2312 13.5189C24.0771 14.3647 24.5 15.4002 24.5 16.6252C24.5 17.8502 24.0771 18.8856 23.2312 19.7314C22.3854 20.5772 21.35 21.0002 20.125 21.0002H17.325L17.9667 21.6418C18.2 21.8752 18.3167 22.1522 18.3167 22.4731C18.3167 22.7939 18.2 23.071 17.9667 23.3043C17.7333 23.5377 17.4562 23.6543 17.1354 23.6543C16.8146 23.6543 16.5375 23.5377 16.3042 23.3043L13.65 20.6502C13.5333 20.5335 13.4507 20.4071 13.4021 20.271C13.3535 20.1349 13.3292 19.9891 13.3292 19.8335C13.3292 19.6779 13.3535 19.5321 13.4021 19.396C13.4507 19.2599 13.5333 19.1335 13.65 19.0168L16.3333 16.3335C16.5472 16.1196 16.8146 16.0127 17.1354 16.0127C17.4562 16.0127 17.7333 16.1293 17.9667 16.3627C18.2 16.596 18.3118 16.8779 18.3021 17.2085C18.2924 17.5391 18.1708 17.821 17.9375 18.0543L17.325 18.6668H20.125C20.6889 18.6668 21.1701 18.4675 21.5687 18.0689C21.9674 17.6703 22.1667 17.1891 22.1667 16.6252C22.1667 16.0613 21.9674 15.58 21.5687 15.1814C21.1701 14.7828 20.6889 14.5835 20.125 14.5835H5.83332ZM5.83332 8.16683C5.50277 8.16683 5.22568 8.05502 5.00207 7.83141C4.77846 7.6078 4.66666 7.33072 4.66666 7.00016C4.66666 6.66961 4.77846 6.39252 5.00207 6.16891C5.22568 5.9453 5.50277 5.8335 5.83332 5.8335H22.1667C22.4972 5.8335 22.7743 5.9453 22.9979 6.16891C23.2215 6.39252 23.3333 6.66961 23.3333 7.00016C23.3333 7.33072 23.2215 7.6078 22.9979 7.83141C22.7743 8.05502 22.4972 8.16683 22.1667 8.16683H5.83332ZM5.83332 21.0002C5.50277 21.0002 5.22568 20.8884 5.00207 20.6647C4.77846 20.4411 4.66666 20.1641 4.66666 19.8335C4.66666 19.5029 4.77846 19.2259 5.00207 19.0022C5.22568 18.7786 5.50277 18.6668 5.83332 18.6668H9.36249C9.69305 18.6668 9.96527 18.7786 10.1792 19.0022C10.393 19.2259 10.5 19.5029 10.5 19.8335C10.5 20.1641 10.3882 20.4411 10.1646 20.6647C9.94096 20.8884 9.66388 21.0002 9.33332 21.0002H5.83332Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$X; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-insert-below",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$W = "/*!@:host*/.sc-swirl-icon-insert-on-top-h{display:inline-flex}";

class SwirlIconInsertOnTop {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.33335 8C3.14446 8 2.98613 8.06389 2.85835 8.19167C2.73058 8.31944 2.66669 8.47778 2.66669 8.66667C2.66669 8.85556 2.73058 9.01389 2.85835 9.14167C2.98613 9.26944 3.14446 9.33333 3.33335 9.33333H11.5C12.2 9.33333 12.7917 9.09167 13.275 8.60833C13.7584 8.125 14 7.53333 14 6.83333C14 6.13333 13.7584 5.54167 13.275 5.05833C12.7917 4.575 12.2 4.33333 11.5 4.33333H9.90002L10.2667 3.96667C10.4 3.83333 10.4667 3.675 10.4667 3.49167C10.4667 3.30833 10.4 3.15 10.2667 3.01667C10.1334 2.88333 9.97502 2.81667 9.79169 2.81667C9.60835 2.81667 9.45002 2.88333 9.31669 3.01667L7.80002 4.53333C7.73335 4.6 7.68613 4.67222 7.65835 4.75C7.63058 4.82778 7.61669 4.91111 7.61669 5C7.61669 5.08889 7.63058 5.17222 7.65835 5.25C7.68613 5.32778 7.73335 5.4 7.80002 5.46667L9.33335 7C9.45558 7.12222 9.60835 7.18333 9.79169 7.18333C9.97502 7.18333 10.1334 7.11667 10.2667 6.98333C10.4 6.85 10.4639 6.68889 10.4584 6.5C10.4528 6.31111 10.3834 6.15 10.25 6.01667L9.90002 5.66667H11.5C11.8222 5.66667 12.0972 5.78056 12.325 6.00833C12.5528 6.23611 12.6667 6.51111 12.6667 6.83333C12.6667 7.15556 12.5528 7.43056 12.325 7.65833C12.0972 7.88611 11.8222 8 11.5 8H3.33335ZM3.33335 11.6667C3.14446 11.6667 2.98613 11.7306 2.85835 11.8583C2.73058 11.9861 2.66669 12.1444 2.66669 12.3333C2.66669 12.5222 2.73058 12.6806 2.85835 12.8083C2.98613 12.9361 3.14446 13 3.33335 13H12.6667C12.8556 13 13.0139 12.9361 13.1417 12.8083C13.2695 12.6806 13.3334 12.5222 13.3334 12.3333C13.3334 12.1444 13.2695 11.9861 13.1417 11.8583C13.0139 11.7306 12.8556 11.6667 12.6667 11.6667H3.33335ZM3.33335 4.33333C3.14446 4.33333 2.98613 4.39722 2.85835 4.525C2.73058 4.65278 2.66669 4.81111 2.66669 5C2.66669 5.18889 2.73058 5.34722 2.85835 5.475C2.98613 5.60278 3.14446 5.66667 3.33335 5.66667H5.35002C5.53891 5.66667 5.69446 5.60278 5.81669 5.475C5.93891 5.34722 6.00002 5.18889 6.00002 5C6.00002 4.81111 5.93613 4.65278 5.80835 4.525C5.68058 4.39722 5.52224 4.33333 5.33335 4.33333H3.33335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5 11.5C4.71667 11.5 4.47917 11.5958 4.2875 11.7875C4.09583 11.9792 4 12.2167 4 12.5C4 12.7833 4.09583 13.0208 4.2875 13.2125C4.47917 13.4042 4.71667 13.5 5 13.5H17.25C18.3 13.5 19.1875 13.1375 19.9125 12.4125C20.6375 11.6875 21 10.8 21 9.75C21 8.7 20.6375 7.8125 19.9125 7.0875C19.1875 6.3625 18.3 6 17.25 6H14.85L15.4 5.45C15.6 5.25 15.7 5.0125 15.7 4.7375C15.7 4.4625 15.6 4.225 15.4 4.025C15.2 3.825 14.9625 3.725 14.6875 3.725C14.4125 3.725 14.175 3.825 13.975 4.025L11.7 6.3C11.6 6.4 11.5292 6.50833 11.4875 6.625C11.4458 6.74167 11.425 6.86667 11.425 7C11.425 7.13333 11.4458 7.25833 11.4875 7.375C11.5292 7.49167 11.6 7.6 11.7 7.7L14 10C14.1833 10.1833 14.4125 10.275 14.6875 10.275C14.9625 10.275 15.2 10.175 15.4 9.975C15.6 9.775 15.6958 9.53333 15.6875 9.25C15.6792 8.96667 15.575 8.725 15.375 8.525L14.85 8H17.25C17.7333 8 18.1458 8.17083 18.4875 8.5125C18.8292 8.85417 19 9.26667 19 9.75C19 10.2333 18.8292 10.6458 18.4875 10.9875C18.1458 11.3292 17.7333 11.5 17.25 11.5H5ZM5 17C4.71667 17 4.47917 17.0958 4.2875 17.2875C4.09583 17.4792 4 17.7167 4 18C4 18.2833 4.09583 18.5208 4.2875 18.7125C4.47917 18.9042 4.71667 19 5 19H19C19.2833 19 19.5208 18.9042 19.7125 18.7125C19.9042 18.5208 20 18.2833 20 18C20 17.7167 19.9042 17.4792 19.7125 17.2875C19.5208 17.0958 19.2833 17 19 17H5ZM5 6C4.71667 6 4.47917 6.09583 4.2875 6.2875C4.09583 6.47917 4 6.71667 4 7C4 7.28333 4.09583 7.52083 4.2875 7.7125C4.47917 7.90417 4.71667 8 5 8H8.025C8.30833 8 8.54167 7.90417 8.725 7.7125C8.90833 7.52083 9 7.28333 9 7C9 6.71667 8.90417 6.47917 8.7125 6.2875C8.52083 6.09583 8.28333 6 8 6H5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M5.83332 14.25C5.50277 14.25 5.22568 14.3618 5.00207 14.5854C4.77846 14.809 4.66666 15.0861 4.66666 15.4167C4.66666 15.7472 4.77846 16.0243 5.00207 16.2479C5.22568 16.4715 5.50277 16.5833 5.83332 16.5833H20.125C21.35 16.5833 22.3854 16.1604 23.2312 15.3146C24.0771 14.4687 24.5 13.4333 24.5 12.2083C24.5 10.9833 24.0771 9.94792 23.2312 9.10208C22.3854 8.25625 21.35 7.83333 20.125 7.83333H17.325L17.9667 7.19167C18.2 6.95833 18.3167 6.68125 18.3167 6.36042C18.3167 6.03958 18.2 5.7625 17.9667 5.52917C17.7333 5.29583 17.4562 5.17917 17.1354 5.17917C16.8146 5.17917 16.5375 5.29583 16.3042 5.52917L13.65 8.18333C13.5333 8.3 13.4507 8.42639 13.4021 8.5625C13.3535 8.69861 13.3292 8.84444 13.3292 9C13.3292 9.15556 13.3535 9.30139 13.4021 9.4375C13.4507 9.57361 13.5333 9.7 13.65 9.81667L16.3333 12.5C16.5472 12.7139 16.8146 12.8208 17.1354 12.8208C17.4562 12.8208 17.7333 12.7042 17.9667 12.4708C18.2 12.2375 18.3118 11.9556 18.3021 11.625C18.2924 11.2944 18.1708 11.0125 17.9375 10.7792L17.325 10.1667H20.125C20.6889 10.1667 21.1701 10.366 21.5687 10.7646C21.9674 11.1632 22.1667 11.6444 22.1667 12.2083C22.1667 12.7722 21.9674 13.2535 21.5687 13.6521C21.1701 14.0507 20.6889 14.25 20.125 14.25H5.83332ZM5.83332 20.6667C5.50277 20.6667 5.22568 20.7785 5.00207 21.0021C4.77846 21.2257 4.66666 21.5028 4.66666 21.8333C4.66666 22.1639 4.77846 22.441 5.00207 22.6646C5.22568 22.8882 5.50277 23 5.83332 23H22.1667C22.4972 23 22.7743 22.8882 22.9979 22.6646C23.2215 22.441 23.3333 22.1639 23.3333 21.8333C23.3333 21.5028 23.2215 21.2257 22.9979 21.0021C22.7743 20.7785 22.4972 20.6667 22.1667 20.6667H5.83332ZM5.83332 7.83333C5.50277 7.83333 5.22568 7.94514 5.00207 8.16875C4.77846 8.39236 4.66666 8.66944 4.66666 9C4.66666 9.33056 4.77846 9.60764 5.00207 9.83125C5.22568 10.0549 5.50277 10.1667 5.83332 10.1667H9.36249C9.69305 10.1667 9.96527 10.0549 10.1792 9.83125C10.393 9.60764 10.5 9.33056 10.5 9C10.5 8.66944 10.3882 8.39236 10.1646 8.16875C9.94096 7.94514 9.66388 7.83333 9.33332 7.83333H5.83332Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$W; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-insert-on-top",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$V = "/*!@:host*/.sc-swirl-icon-inventory-h{display:inline-flex}";

class SwirlIconInventory {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M13.3333 1.33334H2.66668C2.00001 1.33334 1.33334 1.93334 1.33334 2.66668V4.67334C1.33334 5.15334 1.62001 5.56668 2.00001 5.80001V13.3333C2.00001 14.0667 2.73334 14.6667 3.33334 14.6667H12.6667C13.2667 14.6667 14 14.0667 14 13.3333V5.80001C14.38 5.56668 14.6667 5.15334 14.6667 4.67334V2.66668C14.6667 1.93334 14 1.33334 13.3333 1.33334ZM9.33334 9.33334H6.66668C6.30001 9.33334 6.00001 9.03334 6.00001 8.66668C6.00001 8.30001 6.30001 8.00001 6.66668 8.00001H9.33334C9.70001 8.00001 10 8.30001 10 8.66668C10 9.03334 9.70001 9.33334 9.33334 9.33334ZM13.3333 4.66668H2.66668V2.66668H13.3333V4.66668Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M20 2H4C3 2 2 2.9 2 4V7.01C2 7.73 2.43 8.35 3 8.7V20C3 21.1 4.1 22 5 22H19C19.9 22 21 21.1 21 20V8.7C21.57 8.35 22 7.73 22 7.01V4C22 2.9 21 2 20 2ZM14 14H10C9.45 14 9 13.55 9 13C9 12.45 9.45 12 10 12H14C14.55 12 15 12.45 15 13C15 13.55 14.55 14 14 14ZM20 7H4V4H20V7Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M23.3333 2.33334H4.66668C3.50001 2.33334 2.33334 3.38334 2.33334 4.66668V8.17834C2.33334 9.01834 2.83501 9.74168 3.50001 10.15V23.3333C3.50001 24.6167 4.78334 25.6667 5.83334 25.6667H22.1667C23.2167 25.6667 24.5 24.6167 24.5 23.3333V10.15C25.165 9.74168 25.6667 9.01834 25.6667 8.17834V4.66668C25.6667 3.38334 24.5 2.33334 23.3333 2.33334ZM16.3333 16.3333H11.6667C11.025 16.3333 10.5 15.8083 10.5 15.1667C10.5 14.525 11.025 14 11.6667 14H16.3333C16.975 14 17.5 14.525 17.5 15.1667C17.5 15.8083 16.975 16.3333 16.3333 16.3333ZM23.3333 8.16668H4.66668V4.66668H23.3333V8.16668Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$V; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-inventory",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$U = "/*!@:host*/.sc-swirl-icon-like-h{display:inline-flex}";

class SwirlIconLike {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M5.72387 4.94293L9.27694 1.38986C10.0419 0.62488 11.3284 1.35327 11.066 2.40281L10.4369 4.91927C10.3843 5.12966 10.5434 5.33345 10.7603 5.33345H14C14.7364 5.33345 15.3333 5.93041 15.3333 6.66679V6.86831C15.3333 7.61454 15.1767 8.35247 14.8737 9.03438L13.0186 13.2083C12.8046 13.6898 12.3271 14.0001 11.8002 14.0001H6.66668C5.9303 14.0001 5.33334 13.4032 5.33334 12.6668V5.88574C5.33334 5.53212 5.47382 5.19298 5.72387 4.94293Z", fill: "currentColor" }), hAsync("path", { d: "M4.00001 12.6668V6.66679C4.00001 5.93041 3.40306 5.33345 2.66668 5.33345C1.9303 5.33345 1.33334 5.93041 1.33334 6.66679V12.6668C1.33334 13.4032 1.9303 14.0001 2.66668 14.0001C3.40306 14.0001 4.00001 13.4032 4.00001 12.6668Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M8.58579 7.41427L13.9154 2.08466C15.0629 0.937198 16.9926 2.02979 16.599 3.60409L15.6553 7.37879C15.5764 7.69436 15.8151 8.00006 16.1404 8.00006H21C22.1046 8.00006 23 8.89549 23 10.0001V10.3023C23 11.4217 22.7651 12.5286 22.3105 13.5514L19.5279 19.8123C19.2069 20.5346 18.4906 21.0001 17.7003 21.0001H10C8.89543 21.0001 8 20.1046 8 19.0001V8.82848C8 8.29805 8.21071 7.78934 8.58579 7.41427Z", fill: "currentColor" }), hAsync("path", { d: "M6 19.0001V10.0001C6 8.89549 5.10457 8.00006 4 8.00006C2.89543 8.00006 2 8.89549 2 10.0001V19.0001C2 20.1046 2.89543 21.0001 4 21.0001C5.10457 21.0001 6 20.1046 6 19.0001Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M10.0168 8.64994L16.2346 2.43206C17.5733 1.09336 19.8247 2.36804 19.3655 4.20473L18.2645 8.60855C18.1725 8.97672 18.451 9.33336 18.8305 9.33336H24.5C25.7887 9.33336 26.8333 10.378 26.8333 11.6667V12.0194C26.8333 13.3253 26.5593 14.6166 26.0289 15.81L22.7825 23.1143C22.408 23.957 21.5724 24.5 20.6503 24.5H11.6667C10.378 24.5 9.33334 23.4554 9.33334 22.1667V10.2999C9.33334 9.68102 9.57918 9.08753 10.0168 8.64994Z", fill: "currentColor" }), hAsync("path", { d: "M7.00001 22.1667V11.6667C7.00001 10.378 5.95534 9.33336 4.66668 9.33336C3.37801 9.33336 2.33334 10.378 2.33334 11.6667V22.1667C2.33334 23.4554 3.37801 24.5 4.66668 24.5C5.95534 24.5 7.00001 23.4554 7.00001 22.1667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$U; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-like",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$T = "/*!@:host*/.sc-swirl-icon-link-h{display:inline-flex}";

class SwirlIconLink {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.09414 12.8082C7.41846 13.4838 6.60136 13.8217 5.64283 13.8217C4.68431 13.8217 3.86721 13.4838 3.19153 12.8082C2.51585 12.1325 2.17801 11.3154 2.17801 10.3568C2.17801 9.39832 2.51585 8.58122 3.19153 7.90554L4.49968 6.5974C4.64895 6.44812 4.82573 6.37348 5.03001 6.37348C5.23428 6.37348 5.41106 6.44812 5.56034 6.5974C5.71747 6.75453 5.79604 6.93524 5.79604 7.13951C5.79604 7.34379 5.7214 7.52056 5.57212 7.66984L4.26397 8.97799C3.87899 9.36297 3.6865 9.82259 3.6865 10.3568C3.6865 10.8911 3.87899 11.3507 4.26397 11.7357C4.64895 12.1207 5.10857 12.3132 5.64283 12.3132C6.17709 12.3132 6.63671 12.1207 7.02169 11.7357L8.32984 10.4276C8.47912 10.2783 8.65589 10.2036 8.86017 10.2036C9.06444 10.2036 9.24515 10.2822 9.40228 10.4393C9.55156 10.5886 9.6262 10.7654 9.6262 10.9697C9.6262 11.1739 9.55156 11.3507 9.40228 11.5L8.09414 12.8082ZM7.03348 9.95615C6.89991 10.0897 6.7368 10.1585 6.54416 10.1626C6.35182 10.1664 6.18495 10.0976 6.04353 9.95615C5.9021 9.81473 5.83328 9.64786 5.83705 9.45552C5.84114 9.26287 5.90996 9.09977 6.04353 8.9662L8.96623 6.0435C9.0998 5.90993 9.2629 5.84111 9.45555 5.83702C9.64789 5.83325 9.81476 5.90207 9.95618 6.0435C10.0976 6.18492 10.1664 6.35179 10.1627 6.54413C10.1586 6.73677 10.0897 6.89988 9.95618 7.03345L7.03348 9.95615ZM11.5 9.40225C11.3508 9.55153 11.174 9.62617 10.9697 9.62617C10.7654 9.62617 10.5887 9.55153 10.4394 9.40225C10.2822 9.24512 10.2037 9.06441 10.2037 8.86014C10.2037 8.65586 10.2783 8.47909 10.4276 8.32981L11.7357 7.02166C12.1207 6.63668 12.3132 6.17706 12.3132 5.6428C12.3132 5.10854 12.1207 4.64892 11.7357 4.26394C11.3508 3.87896 10.8911 3.68647 10.3569 3.68647C9.82262 3.68647 9.363 3.87896 8.97802 4.26394L7.66987 5.57209C7.52059 5.72137 7.34382 5.79601 7.13954 5.79601C6.93527 5.79601 6.75456 5.71744 6.59743 5.56031C6.44815 5.41103 6.37351 5.23425 6.37351 5.02998C6.37351 4.8257 6.44815 4.64892 6.59743 4.49965L7.90557 3.1915C8.58125 2.51582 9.39835 2.17798 10.3569 2.17798C11.3154 2.17798 12.1325 2.51582 12.8082 3.1915C13.4839 3.86718 13.8217 4.68428 13.8217 5.6428C13.8217 6.60132 13.4839 7.41843 12.8082 8.09411L11.5 9.40225Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12.1412 19.2123C11.1277 20.2259 9.90205 20.7326 8.46426 20.7326C7.02648 20.7326 5.80083 20.2259 4.78731 19.2123C3.77379 18.1988 3.26703 16.9732 3.26703 15.5354C3.26703 14.0976 3.77379 12.872 4.78731 11.8584L6.74953 9.89622C6.97345 9.6723 7.23861 9.56034 7.54502 9.56034C7.85144 9.56034 8.1166 9.6723 8.34052 9.89622C8.57622 10.1319 8.69407 10.403 8.69407 10.7094C8.69407 11.0158 8.58211 11.281 8.3582 11.5049L6.39598 13.4671C5.81851 14.0446 5.52977 14.734 5.52977 15.5354C5.52977 16.3368 5.81851 17.0262 6.39598 17.6037C6.97345 18.1812 7.66288 18.4699 8.46426 18.4699C9.26565 18.4699 9.95508 18.1812 10.5326 17.6037L12.4948 15.6415C12.7187 15.4175 12.9839 15.3056 13.2903 15.3056C13.5967 15.3056 13.8677 15.4234 14.1034 15.6591C14.3274 15.8831 14.4393 16.1482 14.4393 16.4546C14.4393 16.761 14.3274 17.0262 14.1034 17.2501L12.1412 19.2123ZM10.5502 14.9344C10.3499 15.1347 10.1052 15.2379 9.81625 15.2441C9.52775 15.2497 9.27744 15.1465 9.0653 14.9344C8.85317 14.7222 8.74993 14.4719 8.75559 14.1834C8.76172 13.8944 8.86496 13.6498 9.0653 13.4494L13.4494 9.06537C13.6497 8.86502 13.8944 8.76178 14.1833 8.75565C14.4718 8.75 14.7222 8.85323 14.9343 9.06537C15.1464 9.2775 15.2497 9.52781 15.244 9.81631C15.2379 10.1053 15.1346 10.3499 14.9343 10.5503L10.5502 14.9344ZM17.2501 14.1035C17.0261 14.3274 16.761 14.4394 16.4546 14.4394C16.1482 14.4394 15.883 14.3274 15.6591 14.1035C15.4234 13.8678 15.3055 13.5967 15.3055 13.2903C15.3055 12.9839 15.4175 12.7188 15.6414 12.4948L17.6036 10.5326C18.1811 9.95514 18.4698 9.26571 18.4698 8.46432C18.4698 7.66294 18.1811 6.97351 17.6036 6.39604C17.0261 5.81857 16.3367 5.52983 15.5353 5.52983C14.7339 5.52983 14.0445 5.81857 13.467 6.39604L11.5048 8.35826C11.2809 8.58218 11.0157 8.69413 10.7093 8.69413C10.4029 8.69413 10.1319 8.57628 9.89615 8.34058C9.67224 8.11666 9.56028 7.8515 9.56028 7.54509C9.56028 7.23867 9.67224 6.97351 9.89615 6.74959L11.8584 4.78737C12.8719 3.77385 14.0975 3.26709 15.5353 3.26709C16.9731 3.26709 18.1988 3.77385 19.2123 4.78737C20.2258 5.80089 20.7326 7.02654 20.7326 8.46432C20.7326 9.90211 20.2258 11.1278 19.2123 12.1413L17.2501 14.1035Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14.1648 22.4143C12.9823 23.5968 11.5524 24.188 9.87499 24.188C8.19758 24.188 6.76765 23.5968 5.58521 22.4143C4.40277 21.2319 3.81155 19.802 3.81155 18.1245C3.81155 16.4471 4.40277 15.0172 5.58521 13.8348L7.87447 11.5455C8.13571 11.2843 8.44507 11.1536 8.80255 11.1536C9.16003 11.1536 9.46939 11.2843 9.73063 11.5455C10.0056 11.8205 10.1431 12.1367 10.1431 12.4942C10.1431 12.8517 10.0125 13.161 9.75125 13.4223L7.46199 15.7115C6.78828 16.3853 6.45142 17.1896 6.45142 18.1245C6.45142 19.0595 6.78828 19.8638 7.46199 20.5375C8.13571 21.2113 8.94004 21.5481 9.87499 21.5481C10.8099 21.5481 11.6143 21.2113 12.288 20.5375L14.5773 18.2483C14.8385 17.987 15.1478 17.8564 15.5053 17.8564C15.8628 17.8564 16.179 17.9939 16.454 18.2689C16.7153 18.5301 16.8459 18.8395 16.8459 19.197C16.8459 19.5545 16.7153 19.8638 16.454 20.1251L14.1648 22.4143ZM12.3086 17.4233C12.0749 17.6571 11.7894 17.7775 11.4523 17.7847C11.1157 17.7913 10.8237 17.6708 10.5762 17.4233C10.3287 17.1758 10.2083 16.8838 10.2149 16.5472C10.222 16.2101 10.3425 15.9247 10.5762 15.6909L15.6909 10.5762C15.9247 10.3424 16.2101 10.222 16.5473 10.2148C16.8838 10.2082 17.1759 10.3287 17.4234 10.5762C17.6708 10.8237 17.7913 11.1157 17.7847 11.4523C17.7775 11.7894 17.6571 12.0749 17.4234 12.3086L12.3086 17.4233ZM20.1251 16.454C19.8639 16.7152 19.5545 16.8459 19.197 16.8459C18.8395 16.8459 18.5302 16.7152 18.2689 16.454C17.994 16.179 17.8565 15.8628 17.8565 15.5053C17.8565 15.1478 17.9871 14.8385 18.2483 14.5772L20.5376 12.288C21.2113 11.6143 21.5481 10.8099 21.5481 9.87496C21.5481 8.94001 21.2113 8.13568 20.5376 7.46196C19.8639 6.78825 19.0595 6.45139 18.1246 6.45139C17.1896 6.45139 16.3853 6.78825 15.7116 7.46196L13.4223 9.75122C13.1611 10.0125 12.8517 10.1431 12.4942 10.1431C12.1368 10.1431 11.8205 10.0056 11.5455 9.7306C11.2843 9.46936 11.1537 9.16 11.1537 8.80252C11.1537 8.44504 11.2843 8.13568 11.5455 7.87444L13.8348 5.58518C15.0172 4.40274 16.4472 3.81152 18.1246 3.81152C19.802 3.81152 21.2319 4.40274 22.4144 5.58518C23.5968 6.76762 24.188 8.19755 24.188 9.87496C24.188 11.5524 23.5968 12.9823 22.4144 14.1647L20.1251 16.454Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$T; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-link",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$S = "/*!@:host*/.sc-swirl-icon-lock-h{display:inline-flex}";

class SwirlIconLock {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12 5.66667H11.3333V4.33333C11.3333 2.49333 9.83999 1 7.99999 1C6.15999 1 4.66666 2.49333 4.66666 4.33333V5.66667H3.99999C3.26666 5.66667 2.66666 6.26667 2.66666 7V13.6667C2.66666 14.4 3.26666 15 3.99999 15H12C12.7333 15 13.3333 14.4 13.3333 13.6667V7C13.3333 6.26667 12.7333 5.66667 12 5.66667ZM7.99999 11.6667C7.26666 11.6667 6.66666 11.0667 6.66666 10.3333C6.66666 9.6 7.26666 9 7.99999 9C8.73332 9 9.33332 9.6 9.33332 10.3333C9.33332 11.0667 8.73332 11.6667 7.99999 11.6667ZM5.99999 5.66667V4.33333C5.99999 3.22667 6.89332 2.33333 7.99999 2.33333C9.10666 2.33333 9.99999 3.22667 9.99999 4.33333V5.66667H5.99999Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M18 8.5H17V6.5C17 3.74 14.76 1.5 12 1.5C9.24 1.5 7 3.74 7 6.5V8.5H6C4.9 8.5 4 9.4 4 10.5V20.5C4 21.6 4.9 22.5 6 22.5H18C19.1 22.5 20 21.6 20 20.5V10.5C20 9.4 19.1 8.5 18 8.5ZM12 17.5C10.9 17.5 10 16.6 10 15.5C10 14.4 10.9 13.5 12 13.5C13.1 13.5 14 14.4 14 15.5C14 16.6 13.1 17.5 12 17.5ZM9 8.5V6.5C9 4.84 10.34 3.5 12 3.5C13.66 3.5 15 4.84 15 6.5V8.5H9Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M21 9.91667H19.8333V7.58333C19.8333 4.36333 17.22 1.75 14 1.75C10.78 1.75 8.16666 4.36333 8.16666 7.58333V9.91667H6.99999C5.71666 9.91667 4.66666 10.9667 4.66666 12.25V23.9167C4.66666 25.2 5.71666 26.25 6.99999 26.25H21C22.2833 26.25 23.3333 25.2 23.3333 23.9167V12.25C23.3333 10.9667 22.2833 9.91667 21 9.91667ZM14 20.4167C12.7167 20.4167 11.6667 19.3667 11.6667 18.0833C11.6667 16.8 12.7167 15.75 14 15.75C15.2833 15.75 16.3333 16.8 16.3333 18.0833C16.3333 19.3667 15.2833 20.4167 14 20.4167ZM10.5 9.91667V7.58333C10.5 5.64667 12.0633 4.08333 14 4.08333C15.9367 4.08333 17.5 5.64667 17.5 7.58333V9.91667H10.5Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$S; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-lock",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$R = "/*!@:host*/.sc-swirl-icon-lock-person-h{display:inline-flex}";

class SwirlIconLockPerson {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12 11.9998C12.2777 11.9998 12.5138 11.9026 12.7083 11.7082C12.9027 11.5137 13 11.2776 13 10.9998C13 10.7221 12.9027 10.4859 12.7083 10.2915C12.5138 10.0971 12.2777 9.99984 12 9.99984C11.7222 9.99984 11.4861 10.0971 11.2916 10.2915C11.0972 10.4859 11 10.7221 11 10.9998C11 11.2776 11.0972 11.5137 11.2916 11.7082C11.4861 11.9026 11.7222 11.9998 12 11.9998ZM12 13.9998C12.3333 13.9998 12.6444 13.9221 12.9333 13.7665C13.2222 13.6109 13.4611 13.3943 13.65 13.1165C13.3944 12.9609 13.1277 12.8471 12.85 12.7748C12.5722 12.7026 12.2888 12.6665 12 12.6665C11.7111 12.6665 11.4277 12.7026 11.15 12.7748C10.8722 12.8471 10.6055 12.9609 10.35 13.1165C10.5388 13.3943 10.7777 13.6109 11.0666 13.7665C11.3555 13.9221 11.6666 13.9998 12 13.9998ZM5.99996 5.33317H9.99996V3.99984C9.99996 3.44428 9.80552 2.97206 9.41663 2.58317C9.02774 2.19428 8.55552 1.99984 7.99996 1.99984C7.4444 1.99984 6.97218 2.19428 6.58329 2.58317C6.1944 2.97206 5.99996 3.44428 5.99996 3.99984V5.33317ZM8.16663 14.6665H3.99996C3.63329 14.6665 3.3194 14.5359 3.05829 14.2748C2.79718 14.0137 2.66663 13.6998 2.66663 13.3332V6.6665C2.66663 6.29984 2.79718 5.98595 3.05829 5.72484C3.3194 5.46373 3.63329 5.33317 3.99996 5.33317H4.66663V3.99984C4.66663 3.07762 4.99163 2.2915 5.64163 1.6415C6.29163 0.991504 7.07774 0.666504 7.99996 0.666504C8.92218 0.666504 9.70829 0.991504 10.3583 1.6415C11.0083 2.2915 11.3333 3.07762 11.3333 3.99984V5.33317H12C12.3666 5.33317 12.6805 5.46373 12.9416 5.72484C13.2027 5.98595 13.3333 6.29984 13.3333 6.6665V7.53317C13.1333 7.4665 12.925 7.4165 12.7083 7.38317C12.4916 7.34984 12.2555 7.33317 12 7.33317V6.6665H3.99996V13.3332H7.53329C7.62218 13.5998 7.71107 13.8304 7.79996 14.0248C7.88885 14.2193 8.01107 14.4332 8.16663 14.6665ZM12 15.3332C11.0777 15.3332 10.2916 15.0082 9.64163 14.3582C8.99163 13.7082 8.66663 12.9221 8.66663 11.9998C8.66663 11.0776 8.99163 10.2915 9.64163 9.6415C10.2916 8.9915 11.0777 8.6665 12 8.6665C12.9222 8.6665 13.7083 8.9915 14.3583 9.6415C15.0083 10.2915 15.3333 11.0776 15.3333 11.9998C15.3333 12.9221 15.0083 13.7082 14.3583 14.3582C13.7083 15.0082 12.9222 15.3332 12 15.3332Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M18 18C18.4167 18 18.7708 17.8542 19.0625 17.5625C19.3542 17.2708 19.5 16.9167 19.5 16.5C19.5 16.0833 19.3542 15.7292 19.0625 15.4375C18.7708 15.1458 18.4167 15 18 15C17.5833 15 17.2292 15.1458 16.9375 15.4375C16.6458 15.7292 16.5 16.0833 16.5 16.5C16.5 16.9167 16.6458 17.2708 16.9375 17.5625C17.2292 17.8542 17.5833 18 18 18ZM18 21C18.5 21 18.9667 20.8833 19.4 20.65C19.8333 20.4167 20.1917 20.0917 20.475 19.675C20.0917 19.4417 19.6917 19.2708 19.275 19.1625C18.8583 19.0542 18.4333 19 18 19C17.5667 19 17.1417 19.0542 16.725 19.1625C16.3083 19.2708 15.9083 19.4417 15.525 19.675C15.8083 20.0917 16.1667 20.4167 16.6 20.65C17.0333 20.8833 17.5 21 18 21ZM9 8H15V6C15 5.16667 14.7083 4.45833 14.125 3.875C13.5417 3.29167 12.8333 3 12 3C11.1667 3 10.4583 3.29167 9.875 3.875C9.29167 4.45833 9 5.16667 9 6V8ZM12.25 22H6C5.45 22 4.97917 21.8042 4.5875 21.4125C4.19583 21.0208 4 20.55 4 20V10C4 9.45 4.19583 8.97917 4.5875 8.5875C4.97917 8.19583 5.45 8 6 8H7V6C7 4.61667 7.4875 3.4375 8.4625 2.4625C9.4375 1.4875 10.6167 1 12 1C13.3833 1 14.5625 1.4875 15.5375 2.4625C16.5125 3.4375 17 4.61667 17 6V8H18C18.55 8 19.0208 8.19583 19.4125 8.5875C19.8042 8.97917 20 9.45 20 10V11.3C19.7 11.2 19.3875 11.125 19.0625 11.075C18.7375 11.025 18.3833 11 18 11V10H6V20H11.3C11.4333 20.4 11.5667 20.7458 11.7 21.0375C11.8333 21.3292 12.0167 21.65 12.25 22ZM18 23C16.6167 23 15.4375 22.5125 14.4625 21.5375C13.4875 20.5625 13 19.3833 13 18C13 16.6167 13.4875 15.4375 14.4625 14.4625C15.4375 13.4875 16.6167 13 18 13C19.3833 13 20.5625 13.4875 21.5375 14.4625C22.5125 15.4375 23 16.6167 23 18C23 19.3833 22.5125 20.5625 21.5375 21.5375C20.5625 22.5125 19.3833 23 18 23Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M21 20.9998C21.4861 20.9998 21.8993 20.8297 22.2395 20.4894C22.5798 20.1491 22.75 19.7359 22.75 19.2498C22.75 18.7637 22.5798 18.3505 22.2395 18.0103C21.8993 17.67 21.4861 17.4998 21 17.4998C20.5138 17.4998 20.1007 17.67 19.7604 18.0103C19.4201 18.3505 19.25 18.7637 19.25 19.2498C19.25 19.7359 19.4201 20.1491 19.7604 20.4894C20.1007 20.8297 20.5138 20.9998 21 20.9998ZM21 24.4998C21.5833 24.4998 22.1277 24.3637 22.6333 24.0915C23.1388 23.8193 23.5569 23.4401 23.8875 22.954C23.4402 22.6818 22.9736 22.4825 22.4875 22.3561C22.0013 22.2297 21.5055 22.1665 21 22.1665C20.4944 22.1665 19.9986 22.2297 19.5125 22.3561C19.0263 22.4825 18.5597 22.6818 18.1125 22.954C18.443 23.4401 18.8611 23.8193 19.3666 24.0915C19.8722 24.3637 20.4166 24.4998 21 24.4998ZM10.5 9.33317H17.5V6.99984C17.5 6.02761 17.1597 5.20123 16.4791 4.52067C15.7986 3.84011 14.9722 3.49984 14 3.49984C13.0277 3.49984 12.2013 3.84011 11.5208 4.52067C10.8402 5.20123 10.5 6.02761 10.5 6.99984V9.33317ZM14.2916 25.6665H6.99996C6.35829 25.6665 5.80899 25.438 5.35204 24.9811C4.8951 24.5241 4.66663 23.9748 4.66663 23.3332V11.6665C4.66663 11.0248 4.8951 10.4755 5.35204 10.0186C5.80899 9.56164 6.35829 9.33317 6.99996 9.33317H8.16663V6.99984C8.16663 5.38595 8.73538 4.01025 9.87288 2.87275C11.0104 1.73525 12.3861 1.1665 14 1.1665C15.6138 1.1665 16.9895 1.73525 18.127 2.87275C19.2645 4.01025 19.8333 5.38595 19.8333 6.99984V9.33317H21C21.6416 9.33317 22.1909 9.56164 22.6479 10.0186C23.1048 10.4755 23.3333 11.0248 23.3333 11.6665V13.1832C22.9833 13.0665 22.6187 12.979 22.2395 12.9207C21.8604 12.8623 21.4472 12.8332 21 12.8332V11.6665H6.99996V23.3332H13.1833C13.3388 23.7998 13.4944 24.2033 13.65 24.5436C13.8055 24.8839 14.0194 25.2582 14.2916 25.6665ZM21 26.8332C19.3861 26.8332 18.0104 26.2644 16.8729 25.1269C15.7354 23.9894 15.1666 22.6137 15.1666 20.9998C15.1666 19.3859 15.7354 18.0103 16.8729 16.8728C18.0104 15.7353 19.3861 15.1665 21 15.1665C22.6138 15.1665 23.9895 15.7353 25.127 16.8728C26.2645 18.0103 26.8333 19.3859 26.8333 20.9998C26.8333 22.6137 26.2645 23.9894 25.127 25.1269C23.9895 26.2644 22.6138 26.8332 21 26.8332Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$R; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-lock-person",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$Q = "/*!@:host*/.sc-swirl-icon-logout-h{display:inline-flex}";

class SwirlIconLogout {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M10.15 10.9833C10.0056 10.8167 9.93335 10.6304 9.93335 10.4247C9.93335 10.2193 10.0056 10.0444 10.15 9.9L11.3 8.76667H6.68335C6.47224 8.76667 6.29446 8.69156 6.15001 8.54134C6.00557 8.39156 5.93335 8.21111 5.93335 8C5.93335 7.78889 6.00557 7.60845 6.15001 7.45867C6.29446 7.30845 6.47224 7.23334 6.68335 7.23334H11.3L10.15 6.1C9.99446 5.94445 9.91935 5.76378 9.92468 5.558C9.93046 5.35267 10.0056 5.17222 10.15 5.01667C10.2945 4.87222 10.4696 4.8 10.6753 4.8C10.8807 4.8 11.0556 4.87222 11.2 5.01667L13.6667 7.46667C13.7333 7.54445 13.7833 7.62778 13.8167 7.71667C13.85 7.80556 13.8667 7.9 13.8667 8C13.8667 8.1 13.85 8.19445 13.8167 8.28333C13.7833 8.37222 13.7333 8.45556 13.6667 8.53333L11.2 11C11.0333 11.1556 10.8529 11.2249 10.6587 11.208C10.464 11.1916 10.2945 11.1167 10.15 10.9833V10.9833ZM3.33335 14.1333C2.91113 14.1333 2.5529 13.9862 2.25868 13.692C1.96401 13.3973 1.81668 13.0389 1.81668 12.6167V3.38334C1.81668 2.96111 1.96401 2.60267 2.25868 2.308C2.5529 2.01378 2.91113 1.86667 3.33335 1.86667H7.26668C7.4889 1.86667 7.67224 1.93889 7.81668 2.08334C7.96113 2.22778 8.03335 2.40556 8.03335 2.61667C8.03335 2.83889 7.96113 3.02222 7.81668 3.16667C7.67224 3.31111 7.4889 3.38334 7.26668 3.38334H3.33335V12.6167H7.26668C7.4889 12.6167 7.67224 12.6889 7.81668 12.8333C7.96113 12.9778 8.03335 13.1611 8.03335 13.3833C8.03335 13.5944 7.96113 13.7722 7.81668 13.9167C7.67224 14.0611 7.4889 14.1333 7.26668 14.1333H3.33335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M15.225 16.475C15.0083 16.225 14.9 15.9457 14.9 15.637C14.9 15.329 15.0083 15.0667 15.225 14.85L16.95 13.15H10.025C9.70834 13.15 9.44167 13.0373 9.22501 12.812C9.00834 12.5873 8.90001 12.3167 8.90001 12C8.90001 11.6833 9.00834 11.4127 9.22501 11.188C9.44167 10.9627 9.70834 10.85 10.025 10.85H16.95L15.225 9.14999C14.9917 8.91665 14.879 8.64565 14.887 8.33699C14.8957 8.02899 15.0083 7.75832 15.225 7.52499C15.4417 7.30832 15.7043 7.19999 16.013 7.19999C16.321 7.19999 16.5833 7.30832 16.8 7.52499L20.5 11.2C20.6 11.3167 20.675 11.4417 20.725 11.575C20.775 11.7083 20.8 11.85 20.8 12C20.8 12.15 20.775 12.2917 20.725 12.425C20.675 12.5583 20.6 12.6833 20.5 12.8L16.8 16.5C16.55 16.7333 16.2793 16.8373 15.988 16.812C15.696 16.7873 15.4417 16.675 15.225 16.475ZM5.00001 21.2C4.36667 21.2 3.82934 20.9793 3.38801 20.538C2.94601 20.096 2.72501 19.5583 2.72501 18.925V5.07499C2.72501 4.44165 2.94601 3.90399 3.38801 3.46199C3.82934 3.02065 4.36667 2.79999 5.00001 2.79999H10.9C11.2333 2.79999 11.5083 2.90832 11.725 3.12499C11.9417 3.34165 12.05 3.60832 12.05 3.92499C12.05 4.25832 11.9417 4.53332 11.725 4.74999C11.5083 4.96665 11.2333 5.07499 10.9 5.07499H5.00001V18.925H10.9C11.2333 18.925 11.5083 19.0333 11.725 19.25C11.9417 19.4667 12.05 19.7417 12.05 20.075C12.05 20.3917 11.9417 20.6583 11.725 20.875C11.5083 21.0917 11.2333 21.2 10.9 21.2H5.00001Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M17.7625 19.2208C17.5097 18.9292 17.3833 18.6033 17.3833 18.2432C17.3833 17.8838 17.5097 17.5778 17.7625 17.325L19.775 15.3417H11.6958C11.3264 15.3417 11.0153 15.2102 10.7625 14.9473C10.5097 14.6852 10.3833 14.3694 10.3833 14C10.3833 13.6306 10.5097 13.3148 10.7625 13.0527C11.0153 12.7898 11.3264 12.6583 11.6958 12.6583H19.775L17.7625 10.675C17.4903 10.4028 17.3588 10.0866 17.3682 9.7265C17.3783 9.36716 17.5097 9.05139 17.7625 8.77916C18.0153 8.52639 18.3217 8.4 18.6818 8.4C19.0412 8.4 19.3472 8.52639 19.6 8.77916L23.9167 13.0667C24.0333 13.2028 24.1208 13.3486 24.1792 13.5042C24.2375 13.6597 24.2667 13.825 24.2667 14C24.2667 14.175 24.2375 14.3403 24.1792 14.4958C24.1208 14.6514 24.0333 14.7972 23.9167 14.9333L19.6 19.25C19.3083 19.5222 18.9926 19.6436 18.6527 19.614C18.312 19.5852 18.0153 19.4542 17.7625 19.2208V19.2208ZM5.83334 24.7333C5.09445 24.7333 4.46756 24.4759 3.95267 23.961C3.437 23.4453 3.17917 22.8181 3.17917 22.0792V5.92083C3.17917 5.18194 3.437 4.55466 3.95267 4.039C4.46756 3.52411 5.09445 3.26666 5.83334 3.26666H12.7167C13.1056 3.26666 13.4264 3.39305 13.6792 3.64583C13.9319 3.89861 14.0583 4.20972 14.0583 4.57916C14.0583 4.96805 13.9319 5.28889 13.6792 5.54166C13.4264 5.79444 13.1056 5.92083 12.7167 5.92083H5.83334V22.0792H12.7167C13.1056 22.0792 13.4264 22.2056 13.6792 22.4583C13.9319 22.7111 14.0583 23.0319 14.0583 23.4208C14.0583 23.7903 13.9319 24.1014 13.6792 24.3542C13.4264 24.6069 13.1056 24.7333 12.7167 24.7333H5.83334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$Q; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-logout",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$P = "/*!@:host*/.sc-swirl-icon-long-text-h{display:inline-flex}";

class SwirlIconLongText {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.33335 12.6668C3.14446 12.6668 2.98613 12.6029 2.85835 12.4752C2.73058 12.3474 2.66669 12.1891 2.66669 12.0002C2.66669 11.8113 2.73058 11.6529 2.85835 11.5252C2.98613 11.3974 3.14446 11.3335 3.33335 11.3335H8.66669C8.85558 11.3335 9.01391 11.3974 9.14169 11.5252C9.26947 11.6529 9.33335 11.8113 9.33335 12.0002C9.33335 12.1891 9.26947 12.3474 9.14169 12.4752C9.01391 12.6029 8.85558 12.6668 8.66669 12.6668H3.33335ZM3.33335 7.3335C3.14446 7.3335 2.98613 7.26961 2.85835 7.14183C2.73058 7.01405 2.66669 6.85572 2.66669 6.66683C2.66669 6.47794 2.73058 6.31961 2.85835 6.19183C2.98613 6.06405 3.14446 6.00016 3.33335 6.00016H12.6667C12.8556 6.00016 13.0139 6.06405 13.1417 6.19183C13.2695 6.31961 13.3334 6.47794 13.3334 6.66683C13.3334 6.85572 13.2695 7.01405 13.1417 7.14183C13.0139 7.26961 12.8556 7.3335 12.6667 7.3335H3.33335ZM3.33335 10.0002C3.14446 10.0002 2.98613 9.93627 2.85835 9.8085C2.73058 9.68072 2.66669 9.52238 2.66669 9.3335C2.66669 9.14461 2.73058 8.98627 2.85835 8.8585C2.98613 8.73072 3.14446 8.66683 3.33335 8.66683H12.6667C12.8556 8.66683 13.0139 8.73072 13.1417 8.8585C13.2695 8.98627 13.3334 9.14461 13.3334 9.3335C13.3334 9.52238 13.2695 9.68072 13.1417 9.8085C13.0139 9.93627 12.8556 10.0002 12.6667 10.0002H3.33335ZM3.33335 4.66683C3.14446 4.66683 2.98613 4.60294 2.85835 4.47516C2.73058 4.34738 2.66669 4.18905 2.66669 4.00016C2.66669 3.81127 2.73058 3.65294 2.85835 3.52516C2.98613 3.39738 3.14446 3.3335 3.33335 3.3335H12.6667C12.8556 3.3335 13.0139 3.39738 13.1417 3.52516C13.2695 3.65294 13.3334 3.81127 13.3334 4.00016C13.3334 4.18905 13.2695 4.34738 13.1417 4.47516C13.0139 4.60294 12.8556 4.66683 12.6667 4.66683H3.33335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5 19C4.71667 19 4.47917 18.9042 4.2875 18.7125C4.09583 18.5208 4 18.2833 4 18C4 17.7167 4.09583 17.4792 4.2875 17.2875C4.47917 17.0958 4.71667 17 5 17H13C13.2833 17 13.5208 17.0958 13.7125 17.2875C13.9042 17.4792 14 17.7167 14 18C14 18.2833 13.9042 18.5208 13.7125 18.7125C13.5208 18.9042 13.2833 19 13 19H5ZM5 11C4.71667 11 4.47917 10.9042 4.2875 10.7125C4.09583 10.5208 4 10.2833 4 10C4 9.71667 4.09583 9.47917 4.2875 9.2875C4.47917 9.09583 4.71667 9 5 9H19C19.2833 9 19.5208 9.09583 19.7125 9.2875C19.9042 9.47917 20 9.71667 20 10C20 10.2833 19.9042 10.5208 19.7125 10.7125C19.5208 10.9042 19.2833 11 19 11H5ZM5 15C4.71667 15 4.47917 14.9042 4.2875 14.7125C4.09583 14.5208 4 14.2833 4 14C4 13.7167 4.09583 13.4792 4.2875 13.2875C4.47917 13.0958 4.71667 13 5 13H19C19.2833 13 19.5208 13.0958 19.7125 13.2875C19.9042 13.4792 20 13.7167 20 14C20 14.2833 19.9042 14.5208 19.7125 14.7125C19.5208 14.9042 19.2833 15 19 15H5ZM5 7C4.71667 7 4.47917 6.90417 4.2875 6.7125C4.09583 6.52083 4 6.28333 4 6C4 5.71667 4.09583 5.47917 4.2875 5.2875C4.47917 5.09583 4.71667 5 5 5H19C19.2833 5 19.5208 5.09583 19.7125 5.2875C19.9042 5.47917 20 5.71667 20 6C20 6.28333 19.9042 6.52083 19.7125 6.7125C19.5208 6.90417 19.2833 7 19 7H5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M5.83332 22.1668C5.50277 22.1668 5.22568 22.055 5.00207 21.8314C4.77846 21.6078 4.66666 21.3307 4.66666 21.0002C4.66666 20.6696 4.77846 20.3925 5.00207 20.1689C5.22568 19.9453 5.50277 19.8335 5.83332 19.8335H15.1667C15.4972 19.8335 15.7743 19.9453 15.9979 20.1689C16.2215 20.3925 16.3333 20.6696 16.3333 21.0002C16.3333 21.3307 16.2215 21.6078 15.9979 21.8314C15.7743 22.055 15.4972 22.1668 15.1667 22.1668H5.83332ZM5.83332 12.8335C5.50277 12.8335 5.22568 12.7217 5.00207 12.4981C4.77846 12.2745 4.66666 11.9974 4.66666 11.6668C4.66666 11.3363 4.77846 11.0592 5.00207 10.8356C5.22568 10.612 5.50277 10.5002 5.83332 10.5002H22.1667C22.4972 10.5002 22.7743 10.612 22.9979 10.8356C23.2215 11.0592 23.3333 11.3363 23.3333 11.6668C23.3333 11.9974 23.2215 12.2745 22.9979 12.4981C22.7743 12.7217 22.4972 12.8335 22.1667 12.8335H5.83332ZM5.83332 17.5002C5.50277 17.5002 5.22568 17.3884 5.00207 17.1647C4.77846 16.9411 4.66666 16.6641 4.66666 16.3335C4.66666 16.0029 4.77846 15.7259 5.00207 15.5022C5.22568 15.2786 5.50277 15.1668 5.83332 15.1668H22.1667C22.4972 15.1668 22.7743 15.2786 22.9979 15.5022C23.2215 15.7259 23.3333 16.0029 23.3333 16.3335C23.3333 16.6641 23.2215 16.9411 22.9979 17.1647C22.7743 17.3884 22.4972 17.5002 22.1667 17.5002H5.83332ZM5.83332 8.16683C5.50277 8.16683 5.22568 8.05502 5.00207 7.83141C4.77846 7.6078 4.66666 7.33072 4.66666 7.00016C4.66666 6.66961 4.77846 6.39252 5.00207 6.16891C5.22568 5.9453 5.50277 5.8335 5.83332 5.8335H22.1667C22.4972 5.8335 22.7743 5.9453 22.9979 6.16891C23.2215 6.39252 23.3333 6.66961 23.3333 7.00016C23.3333 7.33072 23.2215 7.6078 22.9979 7.83141C22.7743 8.05502 22.4972 8.16683 22.1667 8.16683H5.83332Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$P; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-long-text",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$O = "/*!@:host*/.sc-swirl-icon-mail-h{display:inline-flex}";

class SwirlIconMail {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M13.3333 2.66669H2.66668C1.93334 2.66669 1.33334 3.26669 1.33334 4.00002V12C1.33334 12.7334 1.93334 13.3334 2.66668 13.3334H13.3333C14.0667 13.3334 14.6667 12.7334 14.6667 12V4.00002C14.6667 3.26669 14.0667 2.66669 13.3333 2.66669ZM13.0667 5.50002L8.70668 8.22669C8.27334 8.50002 7.72668 8.50002 7.29334 8.22669L2.93334 5.50002C2.76668 5.39335 2.66668 5.21335 2.66668 5.02002C2.66668 4.57335 3.15334 4.30669 3.53334 4.54002L8.00001 7.33335L12.4667 4.54002C12.8467 4.30669 13.3333 4.57335 13.3333 5.02002C13.3333 5.21335 13.2333 5.39335 13.0667 5.50002Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM19.6 8.25L13.06 12.34C12.41 12.75 11.59 12.75 10.94 12.34L4.4 8.25C4.15 8.09 4 7.82 4 7.53C4 6.86 4.73 6.46 5.3 6.81L12 11L18.7 6.81C19.27 6.46 20 6.86 20 7.53C20 7.82 19.85 8.09 19.6 8.25Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M23.3333 4.66669H4.66668C3.38334 4.66669 2.33334 5.71669 2.33334 7.00002V21C2.33334 22.2834 3.38334 23.3334 4.66668 23.3334H23.3333C24.6167 23.3334 25.6667 22.2834 25.6667 21V7.00002C25.6667 5.71669 24.6167 4.66669 23.3333 4.66669ZM22.8667 9.62502L15.2367 14.3967C14.4783 14.875 13.5217 14.875 12.7633 14.3967L5.13334 9.62502C4.84168 9.43835 4.66668 9.12335 4.66668 8.78502C4.66668 8.00335 5.51834 7.53669 6.18334 7.94502L14 12.8334L21.8167 7.94502C22.4817 7.53669 23.3333 8.00335 23.3333 8.78502C23.3333 9.12335 23.1583 9.43835 22.8667 9.62502Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$O; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-mail",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$N = "/*!@:host*/.sc-swirl-icon-manage-accounts-h{display:inline-flex}";

class SwirlIconManageAccounts {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.21381 8.35C7.06714 8.34334 6.92047 8.33667 6.76714 8.33667C5.15381 8.33667 3.64714 8.78334 2.36047 9.55C1.77381 9.89667 1.43381 10.55 1.43381 11.2367V12.3367C1.43381 12.7033 1.73381 13.0033 2.10047 13.0033H7.60714C7.08047 12.25 6.76714 11.33 6.76714 10.3367C6.76714 9.62334 6.93381 8.95667 7.21381 8.35Z", fill: "currentColor" }), hAsync("path", { d: "M6.76714 7.67C8.2399 7.67 9.43381 6.4761 9.43381 5.00334C9.43381 3.53058 8.2399 2.33667 6.76714 2.33667C5.29438 2.33667 4.10047 3.53058 4.10047 5.00334C4.10047 6.4761 5.29438 7.67 6.76714 7.67Z", fill: "currentColor" }), hAsync("path", { d: "M13.9338 10.3367C13.9338 10.19 13.9138 10.0567 13.8938 9.91667L14.4538 9.43C14.5738 9.32334 14.6005 9.15 14.5205 9.01L14.1271 8.33C14.0471 8.19 13.8805 8.13 13.7338 8.18334L13.0271 8.42334C12.8138 8.24334 12.5738 8.10334 12.3071 8.00334L12.1605 7.27667C12.1271 7.12334 11.9938 7.01 11.8338 7.01H11.0471C10.8871 7.01 10.7538 7.12334 10.7205 7.27667L10.5738 8.00334C10.3071 8.10334 10.0671 8.24334 9.85381 8.42334L9.14714 8.18334C8.99381 8.13 8.83381 8.19667 8.75381 8.33L8.36047 9.01C8.28047 9.15 8.30714 9.32334 8.42714 9.43L8.98714 9.91667C8.96714 10.0567 8.94714 10.19 8.94714 10.3367C8.94714 10.4833 8.96714 10.6167 8.98714 10.7567L8.42714 11.2433C8.30714 11.35 8.28047 11.5233 8.36047 11.6633L8.75381 12.3433C8.83381 12.4833 9.00047 12.5433 9.14714 12.49L9.85381 12.25C10.0671 12.43 10.3071 12.57 10.5738 12.67L10.7205 13.3967C10.7538 13.55 10.8871 13.6633 11.0471 13.6633H11.8338C11.9938 13.6633 12.1271 13.55 12.1605 13.3967L12.3071 12.67C12.5738 12.57 12.8138 12.43 13.0271 12.25L13.7338 12.49C13.8871 12.5433 14.0471 12.4767 14.1271 12.3433L14.5205 11.6633C14.6005 11.5233 14.5738 11.35 14.4538 11.2433L13.8938 10.7567C13.9138 10.6167 13.9338 10.4833 13.9338 10.3367ZM11.4338 11.67C10.7005 11.67 10.1005 11.07 10.1005 10.3367C10.1005 9.60334 10.7005 9.00334 11.4338 9.00334C12.1671 9.00334 12.7671 9.60334 12.7671 10.3367C12.7671 11.07 12.1671 11.67 11.4338 11.67Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M10.8207 12.525C10.6007 12.515 10.3807 12.505 10.1507 12.505C7.7307 12.505 5.4707 13.175 3.5407 14.325C2.6607 14.845 2.1507 15.825 2.1507 16.855V18.505C2.1507 19.055 2.6007 19.505 3.1507 19.505H11.4107C10.6207 18.375 10.1507 16.995 10.1507 15.505C10.1507 14.435 10.4007 13.435 10.8207 12.525Z", fill: "currentColor" }), hAsync("path", { d: "M10.1507 11.505C12.3598 11.505 14.1507 9.71414 14.1507 7.505C14.1507 5.29587 12.3598 3.505 10.1507 3.505C7.94156 3.505 6.1507 5.29587 6.1507 7.505C6.1507 9.71414 7.94156 11.505 10.1507 11.505Z", fill: "currentColor" }), hAsync("path", { d: "M20.9007 15.505C20.9007 15.285 20.8707 15.085 20.8407 14.875L21.6807 14.145C21.8607 13.985 21.9007 13.725 21.7807 13.515L21.1907 12.495C21.0707 12.285 20.8207 12.195 20.6007 12.275L19.5407 12.635C19.2207 12.365 18.8607 12.155 18.4607 12.005L18.2407 10.915C18.1907 10.685 17.9907 10.515 17.7507 10.515H16.5707C16.3307 10.515 16.1307 10.685 16.0807 10.915L15.8607 12.005C15.4607 12.155 15.1007 12.365 14.7807 12.635L13.7207 12.275C13.4907 12.195 13.2507 12.295 13.1307 12.495L12.5407 13.515C12.4207 13.725 12.4607 13.985 12.6407 14.145L13.4807 14.875C13.4507 15.085 13.4207 15.285 13.4207 15.505C13.4207 15.725 13.4507 15.925 13.4807 16.135L12.6407 16.865C12.4607 17.025 12.4207 17.285 12.5407 17.495L13.1307 18.515C13.2507 18.725 13.5007 18.815 13.7207 18.735L14.7807 18.375C15.1007 18.645 15.4607 18.855 15.8607 19.005L16.0807 20.095C16.1307 20.325 16.3307 20.495 16.5707 20.495H17.7507C17.9907 20.495 18.1907 20.325 18.2407 20.095L18.4607 19.005C18.8607 18.855 19.2207 18.645 19.5407 18.375L20.6007 18.735C20.8307 18.815 21.0707 18.715 21.1907 18.515L21.7807 17.495C21.9007 17.285 21.8607 17.025 21.6807 16.865L20.8407 16.135C20.8707 15.925 20.9007 15.725 20.9007 15.505ZM17.1507 17.505C16.0507 17.505 15.1507 16.605 15.1507 15.505C15.1507 14.405 16.0507 13.505 17.1507 13.505C18.2507 13.505 19.1507 14.405 19.1507 15.505C19.1507 16.605 18.2507 17.505 17.1507 17.505Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M12.6242 14.6125C12.3675 14.6008 12.1108 14.5892 11.8425 14.5892C9.01915 14.5892 6.38249 15.3708 4.13082 16.7125C3.10416 17.3192 2.50916 18.4625 2.50916 19.6642V21.5892C2.50916 22.2308 3.03416 22.7558 3.67582 22.7558H13.3125C12.3908 21.4375 11.8425 19.8275 11.8425 18.0892C11.8425 16.8408 12.1342 15.6742 12.6242 14.6125Z", fill: "currentColor" }), hAsync("path", { d: "M11.8425 13.4225C14.4198 13.4225 16.5092 11.3332 16.5092 8.75584C16.5092 6.17851 14.4198 4.08917 11.8425 4.08917C9.26516 4.08917 7.17582 6.17851 7.17582 8.75584C7.17582 11.3332 9.26516 13.4225 11.8425 13.4225Z", fill: "currentColor" }), hAsync("path", { d: "M24.3842 18.0892C24.3842 17.8325 24.3492 17.5992 24.3142 17.3542L25.2942 16.5025C25.5042 16.3158 25.5508 16.0125 25.4108 15.7675L24.7225 14.5775C24.5825 14.3325 24.2908 14.2275 24.0342 14.3208L22.7975 14.7408C22.4242 14.4258 22.0042 14.1808 21.5375 14.0058L21.2808 12.7342C21.2225 12.4658 20.9892 12.2675 20.7092 12.2675H19.3325C19.0525 12.2675 18.8192 12.4658 18.7608 12.7342L18.5042 14.0058C18.0375 14.1808 17.6175 14.4258 17.2442 14.7408L16.0075 14.3208C15.7392 14.2275 15.4592 14.3442 15.3192 14.5775L14.6308 15.7675C14.4908 16.0125 14.5375 16.3158 14.7475 16.5025L15.7275 17.3542C15.6925 17.5992 15.6575 17.8325 15.6575 18.0892C15.6575 18.3458 15.6925 18.5792 15.7275 18.8242L14.7475 19.6758C14.5375 19.8625 14.4908 20.1658 14.6308 20.4108L15.3192 21.6008C15.4592 21.8458 15.7508 21.9508 16.0075 21.8575L17.2442 21.4375C17.6175 21.7525 18.0375 21.9975 18.5042 22.1725L18.7608 23.4442C18.8192 23.7125 19.0525 23.9108 19.3325 23.9108H20.7092C20.9892 23.9108 21.2225 23.7125 21.2808 23.4442L21.5375 22.1725C22.0042 21.9975 22.4242 21.7525 22.7975 21.4375L24.0342 21.8575C24.3025 21.9508 24.5825 21.8342 24.7225 21.6008L25.4108 20.4108C25.5508 20.1658 25.5042 19.8625 25.2942 19.6758L24.3142 18.8242C24.3492 18.5792 24.3842 18.3458 24.3842 18.0892ZM20.0092 20.4225C18.7258 20.4225 17.6758 19.3725 17.6758 18.0892C17.6758 16.8058 18.7258 15.7558 20.0092 15.7558C21.2925 15.7558 22.3425 16.8058 22.3425 18.0892C22.3425 19.3725 21.2925 20.4225 20.0092 20.4225Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$N; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-manage-accounts",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$M = "/*!@:host*/.sc-swirl-icon-mark-chat-read-h{display:inline-flex}";

class SwirlIconMarkChatRead {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M11.5667 11.45L13.9334 9.08331C14.0667 8.94998 14.2223 8.88609 14.4 8.89165C14.5778 8.8972 14.7334 8.96665 14.8667 9.09998C14.9889 9.23331 15.0528 9.38887 15.0584 9.56665C15.0639 9.74442 15 9.89998 14.8667 10.0333L12.0334 12.8666C11.9 13 11.7445 13.0639 11.5667 13.0583C11.3889 13.0528 11.2334 12.9833 11.1 12.85L9.68337 11.4333C9.56115 11.3111 9.49726 11.1583 9.49171 10.975C9.48615 10.7916 9.55004 10.6333 9.68337 10.5C9.8056 10.3778 9.96115 10.3166 10.15 10.3166C10.3389 10.3166 10.4945 10.3778 10.6167 10.5L11.5667 11.45ZM4.00004 12L2.46671 13.5333C2.2556 13.7444 2.01393 13.7916 1.74171 13.675C1.46949 13.5583 1.33337 13.35 1.33337 13.05V2.66665C1.33337 2.29998 1.46393 1.98609 1.72504 1.72498C1.98615 1.46387 2.30004 1.33331 2.66671 1.33331H13.3334C13.7 1.33331 14.0139 1.46387 14.275 1.72498C14.5362 1.98609 14.6667 2.29998 14.6667 2.66665V7.33331H9.33337C8.96671 7.33331 8.65282 7.46387 8.39171 7.72498C8.1306 7.98609 8.00004 8.29998 8.00004 8.66665V12H4.00004Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M17.35 17.175L20.9 13.625C21.1 13.425 21.3333 13.3292 21.6 13.3375C21.8667 13.3458 22.1 13.45 22.3 13.65C22.4833 13.85 22.5792 14.0833 22.5875 14.35C22.5958 14.6167 22.5 14.85 22.3 15.05L18.05 19.3C17.85 19.5 17.6167 19.5958 17.35 19.5875C17.0833 19.5792 16.85 19.475 16.65 19.275L14.525 17.15C14.3417 16.9667 14.2458 16.7375 14.2375 16.4625C14.2292 16.1875 14.325 15.95 14.525 15.75C14.7083 15.5667 14.9417 15.475 15.225 15.475C15.5083 15.475 15.7417 15.5667 15.925 15.75L17.35 17.175ZM6 18L3.7 20.3C3.38333 20.6167 3.02083 20.6875 2.6125 20.5125C2.20417 20.3375 2 20.025 2 19.575V4C2 3.45 2.19583 2.97917 2.5875 2.5875C2.97917 2.19583 3.45 2 4 2H20C20.55 2 21.0208 2.19583 21.4125 2.5875C21.8042 2.97917 22 3.45 22 4V11H14C13.45 11 12.9792 11.1958 12.5875 11.5875C12.1958 11.9792 12 12.45 12 13V18H6Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M20.2417 20.0375L24.3834 15.8958C24.6167 15.6625 24.8889 15.5507 25.2 15.5604C25.5112 15.5701 25.7834 15.6916 26.0167 15.925C26.2306 16.1583 26.3424 16.4305 26.3521 16.7416C26.3618 17.0528 26.25 17.325 26.0167 17.5583L21.0584 22.5166C20.825 22.75 20.5528 22.8618 20.2417 22.8521C19.9306 22.8423 19.6584 22.7208 19.425 22.4875L16.9459 20.0083C16.732 19.7944 16.6202 19.5271 16.6105 19.2062C16.6007 18.8854 16.7125 18.6083 16.9459 18.375C17.1598 18.1611 17.432 18.0541 17.7625 18.0541C18.0931 18.0541 18.3653 18.1611 18.5792 18.375L20.2417 20.0375ZM7.00004 21L4.31671 23.6833C3.94726 24.0528 3.52435 24.1354 3.04796 23.9312C2.57157 23.7271 2.33337 23.3625 2.33337 22.8375V4.66665C2.33337 4.02498 2.56185 3.47567 3.01879 3.01873C3.47574 2.56179 4.02504 2.33331 4.66671 2.33331H23.3334C23.975 2.33331 24.5243 2.56179 24.9813 3.01873C25.4382 3.47567 25.6667 4.02498 25.6667 4.66665V12.8333H16.3334C15.6917 12.8333 15.1424 13.0618 14.6855 13.5187C14.2285 13.9757 14 14.525 14 15.1666V21H7.00004Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$M; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-mark-chat-read",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$L = "/*!@:host*/.sc-swirl-icon-mark-chat-unread-h{display:inline-flex}";

class SwirlIconMarkChatUnread {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("g", { "clip-path": "url(#clip0_57_257)" }, hAsync("path", { d: "M12.6667 4C12.1112 4 11.6389 3.80556 11.25 3.41667C10.8612 3.02778 10.6667 2.55556 10.6667 2C10.6667 1.44444 10.8612 0.972222 11.25 0.583333C11.6389 0.194444 12.1112 0 12.6667 0C13.2223 0 13.6945 0.194444 14.0834 0.583333C14.4723 0.972222 14.6667 1.44444 14.6667 2C14.6667 2.55556 14.4723 3.02778 14.0834 3.41667C13.6945 3.80556 13.2223 4 12.6667 4ZM4.00004 12L2.46671 13.5333C2.2556 13.7444 2.01393 13.7917 1.74171 13.675C1.46949 13.5583 1.33337 13.35 1.33337 13.05V2.66667C1.33337 2.3 1.46393 1.98611 1.72504 1.725C1.98615 1.46389 2.30004 1.33333 2.66671 1.33333H9.40004C9.3556 1.55556 9.33337 1.77778 9.33337 2C9.33337 2.22222 9.3556 2.44444 9.40004 2.66667C9.5556 3.43333 9.93893 4.06944 10.55 4.575C11.1612 5.08056 11.8667 5.33333 12.6667 5.33333C13.0223 5.33333 13.3723 5.27778 13.7167 5.16667C14.0612 5.05556 14.3778 4.88889 14.6667 4.66667V10.6667C14.6667 11.0333 14.5362 11.3472 14.275 11.6083C14.0139 11.8694 13.7 12 13.3334 12H4.00004Z", fill: "currentColor" })), hAsync("defs", null, hAsync("clipPath", { id: "clip0_57_257" }, hAsync("rect", { width: "16", height: "16", fill: "currentColor" }))))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("g", { "clip-path": "url(#clip0_57_242)" }, hAsync("path", { d: "M19 6C18.1667 6 17.4583 5.70833 16.875 5.125C16.2917 4.54167 16 3.83333 16 3C16 2.16667 16.2917 1.45833 16.875 0.875C17.4583 0.291667 18.1667 0 19 0C19.8333 0 20.5417 0.291667 21.125 0.875C21.7083 1.45833 22 2.16667 22 3C22 3.83333 21.7083 4.54167 21.125 5.125C20.5417 5.70833 19.8333 6 19 6ZM6 18L3.7 20.3C3.38333 20.6167 3.02083 20.6875 2.6125 20.5125C2.20417 20.3375 2 20.025 2 19.575V4C2 3.45 2.19583 2.97917 2.5875 2.5875C2.97917 2.19583 3.45 2 4 2H14.1C14.0333 2.33333 14 2.66667 14 3C14 3.33333 14.0333 3.66667 14.1 4C14.3333 5.15 14.9083 6.10417 15.825 6.8625C16.7417 7.62083 17.8 8 19 8C19.5333 8 20.0583 7.91667 20.575 7.75C21.0917 7.58333 21.5667 7.33333 22 7V16C22 16.55 21.8042 17.0208 21.4125 17.4125C21.0208 17.8042 20.55 18 20 18H6Z", fill: "currentColor" })), hAsync("defs", null, hAsync("clipPath", { id: "clip0_57_242" }, hAsync("rect", { width: "24", height: "24", fill: "currentColor" }))))), this.size === 28 && (hAsync(Fragment, null, hAsync("g", { "clip-path": "url(#clip0_57_269)" }, hAsync("path", { d: "M22.1667 7C21.1945 7 20.3681 6.65972 19.6875 5.97917C19.007 5.29861 18.6667 4.47222 18.6667 3.5C18.6667 2.52778 19.007 1.70139 19.6875 1.02083C20.3681 0.340278 21.1945 0 22.1667 0C23.1389 0 23.9653 0.340278 24.6459 1.02083C25.3264 1.70139 25.6667 2.52778 25.6667 3.5C25.6667 4.47222 25.3264 5.29861 24.6459 5.97917C23.9653 6.65972 23.1389 7 22.1667 7ZM7.00004 21L4.31671 23.6833C3.94726 24.0528 3.52435 24.1354 3.04796 23.9312C2.57157 23.7271 2.33337 23.3625 2.33337 22.8375V4.66667C2.33337 4.025 2.56185 3.47569 3.01879 3.01875C3.47574 2.56181 4.02504 2.33333 4.66671 2.33333H16.45C16.3723 2.72222 16.3334 3.11111 16.3334 3.5C16.3334 3.88889 16.3723 4.27778 16.45 4.66667C16.7223 6.00833 17.3931 7.12153 18.4625 8.00625C19.532 8.89097 20.7667 9.33333 22.1667 9.33333C22.7889 9.33333 23.4014 9.23611 24.0042 9.04167C24.607 8.84722 25.1612 8.55556 25.6667 8.16667V18.6667C25.6667 19.3083 25.4382 19.8576 24.9813 20.3146C24.5243 20.7715 23.975 21 23.3334 21H7.00004Z", fill: "currentColor" })), hAsync("defs", null, hAsync("clipPath", { id: "clip0_57_269" }, hAsync("rect", { width: "28", height: "28", fill: "currentColor" })))))));
  }
  static get style() { return swirlIconCss$L; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-mark-chat-unread",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$K = "/*!@:host*/.sc-swirl-icon-mention-h{display:inline-flex}";

class SwirlIconMention {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.00001 14.7833C7.06668 14.7833 6.1889 14.6056 5.36668 14.25C4.54445 13.8945 3.8249 13.4085 3.20801 12.792C2.59156 12.1751 2.10556 11.4556 1.75001 10.6333C1.39445 9.81112 1.21667 8.93334 1.21667 8.00001C1.21667 7.06668 1.39445 6.1889 1.75001 5.36668C2.10556 4.54445 2.59156 3.8249 3.20801 3.20801C3.8249 2.59156 4.54445 2.10556 5.36668 1.75001C6.1889 1.39445 7.06668 1.21667 8.00001 1.21667C8.93334 1.21667 9.81112 1.39445 10.6333 1.75001C11.4556 2.10556 12.1751 2.59156 12.792 3.20801C13.4085 3.8249 13.8945 4.54445 14.25 5.36668C14.6056 6.1889 14.7833 7.06668 14.7833 8.00001V8.96668C14.7833 9.65556 14.5529 10.2333 14.092 10.7C13.6307 11.1667 13.0556 11.4 12.3667 11.4C11.9556 11.4 11.5749 11.3085 11.2247 11.1253C10.8749 10.9418 10.5889 10.7 10.3667 10.4C10.0778 10.7111 9.73068 10.9556 9.32534 11.1333C8.91956 11.3111 8.47779 11.4 8.00001 11.4C7.06668 11.4 6.26667 11.0696 5.60001 10.4087C4.93334 9.74734 4.60001 8.94445 4.60001 8.00001C4.60001 7.06668 4.93334 6.26667 5.60001 5.60001C6.26667 4.93334 7.06668 4.60001 8.00001 4.60001C8.94445 4.60001 9.74734 4.93045 10.4087 5.59134C11.0696 6.25268 11.4 7.05556 11.4 8.00001V8.93334C11.4 9.24445 11.4945 9.4889 11.6833 9.66668C11.8722 9.84445 12.1 9.93334 12.3667 9.93334C12.6222 9.93334 12.8471 9.84445 13.0413 9.66668C13.236 9.4889 13.3333 9.24445 13.3333 8.93334V8.00001C13.3333 6.54445 12.8082 5.29156 11.758 4.24134C10.7082 3.19156 9.45556 2.66667 8.00001 2.66667C6.54445 2.66667 5.29156 3.19156 4.24134 4.24134C3.19156 5.29156 2.66667 6.54445 2.66667 8.00001C2.66667 9.45556 3.19156 10.7082 4.24134 11.758C5.29156 12.8082 6.54445 13.3333 8.00001 13.3333H10.6C10.8111 13.3333 10.9862 13.4027 11.1253 13.5413C11.264 13.6805 11.3333 13.8556 11.3333 14.0667C11.3333 14.2667 11.264 14.4362 11.1253 14.5753C10.9862 14.714 10.8111 14.7833 10.6 14.7833H8.00001ZM8.00001 9.93334C8.53334 9.93334 8.9889 9.74445 9.36668 9.36668C9.74445 8.9889 9.93334 8.53334 9.93334 8.00001C9.93334 7.46668 9.74445 7.01112 9.36668 6.63334C8.9889 6.25556 8.53334 6.06668 8.00001 6.06668C7.46668 6.06668 7.01112 6.25556 6.63334 6.63334C6.25556 7.01112 6.06668 7.46668 6.06668 8.00001C6.06668 8.53334 6.25556 8.9889 6.63334 9.36668C7.01112 9.74445 7.46668 9.93334 8.00001 9.93334Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 22.175C10.6 22.175 9.28335 21.9083 8.05001 21.375C6.81668 20.8417 5.73735 20.1127 4.81201 19.188C3.88735 18.2627 3.15835 17.1833 2.62501 15.95C2.09168 14.7167 1.82501 13.4 1.82501 12C1.82501 10.6 2.09168 9.28335 2.62501 8.05001C3.15835 6.81668 3.88735 5.73735 4.81201 4.81201C5.73735 3.88735 6.81668 3.15835 8.05001 2.62501C9.28335 2.09168 10.6 1.82501 12 1.82501C13.4 1.82501 14.7167 2.09168 15.95 2.62501C17.1833 3.15835 18.2627 3.88735 19.188 4.81201C20.1127 5.73735 20.8417 6.81668 21.375 8.05001C21.9083 9.28335 22.175 10.6 22.175 12V13.45C22.175 14.4833 21.8293 15.35 21.138 16.05C20.446 16.75 19.5833 17.1 18.55 17.1C17.9333 17.1 17.3623 16.9627 16.837 16.688C16.3123 16.4127 15.8833 16.05 15.55 15.6C15.1167 16.0667 14.596 16.4333 13.988 16.7C13.3793 16.9667 12.7167 17.1 12 17.1C10.6 17.1 9.40001 16.6043 8.40001 15.613C7.40001 14.621 6.90001 13.4167 6.90001 12C6.90001 10.6 7.40001 9.40001 8.40001 8.40001C9.40001 7.40001 10.6 6.90001 12 6.90001C13.4167 6.90001 14.621 7.39568 15.613 8.38701C16.6043 9.37901 17.1 10.5833 17.1 12V13.4C17.1 13.8667 17.2417 14.2333 17.525 14.5C17.8083 14.7667 18.15 14.9 18.55 14.9C18.9333 14.9 19.2707 14.7667 19.562 14.5C19.854 14.2333 20 13.8667 20 13.4V12C20 9.81668 19.2123 7.93735 17.637 6.36201C16.0623 4.78735 14.1833 4.00001 12 4.00001C9.81668 4.00001 7.93735 4.78735 6.36201 6.36201C4.78735 7.93735 4.00001 9.81668 4.00001 12C4.00001 14.1833 4.78735 16.0623 6.36201 17.637C7.93735 19.2123 9.81668 20 12 20H15.9C16.2167 20 16.4793 20.104 16.688 20.312C16.896 20.5207 17 20.7833 17 21.1C17 21.4 16.896 21.6543 16.688 21.863C16.4793 22.071 16.2167 22.175 15.9 22.175H12ZM12 14.9C12.8 14.9 13.4833 14.6167 14.05 14.05C14.6167 13.4833 14.9 12.8 14.9 12C14.9 11.2 14.6167 10.5167 14.05 9.95001C13.4833 9.38335 12.8 9.10001 12 9.10001C11.2 9.10001 10.5167 9.38335 9.95001 9.95001C9.38335 10.5167 9.10001 11.2 9.10001 12C9.10001 12.8 9.38335 13.4833 9.95001 14.05C10.5167 14.6167 11.2 14.9 12 14.9Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 25.8708C12.3667 25.8708 10.8306 25.5597 9.39168 24.9375C7.95279 24.3153 6.69357 23.4648 5.61401 22.386C4.53524 21.3064 3.68474 20.0472 3.06251 18.6083C2.44029 17.1694 2.12918 15.6333 2.12918 14C2.12918 12.3667 2.44029 10.8305 3.06251 9.39165C3.68474 7.95276 4.53524 6.69354 5.61401 5.61398C6.69357 4.53521 7.95279 3.68471 9.39168 3.06248C10.8306 2.44026 12.3667 2.12915 14 2.12915C15.6333 2.12915 17.1695 2.44026 18.6083 3.06248C20.0472 3.68471 21.3065 4.53521 22.386 5.61398C23.4648 6.69354 24.3153 7.95276 24.9375 9.39165C25.5597 10.8305 25.8708 12.3667 25.8708 14V15.6916C25.8708 16.8972 25.4676 17.9083 24.661 18.725C23.8537 19.5416 22.8472 19.95 21.6417 19.95C20.9222 19.95 20.2561 19.7898 19.6432 19.4693C19.0311 19.1481 18.5306 18.725 18.1417 18.2C17.6361 18.7444 17.0287 19.1722 16.3193 19.4833C15.6092 19.7944 14.8361 19.95 14 19.95C12.3667 19.95 10.9667 19.3717 9.80001 18.2151C8.63335 17.0578 8.05001 15.6528 8.05001 14C8.05001 12.3667 8.63335 10.9666 9.80001 9.79998C10.9667 8.63332 12.3667 8.04998 14 8.04998C15.6528 8.04998 17.0578 8.62826 18.2152 9.78482C19.3717 10.9422 19.95 12.3472 19.95 14V15.6333C19.95 16.1778 20.1153 16.6055 20.4458 16.9167C20.7764 17.2278 21.175 17.3833 21.6417 17.3833C22.0889 17.3833 22.4825 17.2278 22.8223 16.9167C23.163 16.6055 23.3333 16.1778 23.3333 15.6333V14C23.3333 11.4528 22.4144 9.26021 20.5765 7.42232C18.7394 5.58521 16.5472 4.66665 14 4.66665C11.4528 4.66665 9.26024 5.58521 7.42235 7.42232C5.58524 9.26021 4.66668 11.4528 4.66668 14C4.66668 16.5472 5.58524 18.7394 7.42235 20.5765C9.26024 22.4144 11.4528 23.3333 14 23.3333H18.55C18.9195 23.3333 19.2259 23.4546 19.4693 23.6973C19.712 23.9408 19.8333 24.2472 19.8333 24.6166C19.8333 24.9666 19.712 25.2634 19.4693 25.5068C19.2259 25.7495 18.9195 25.8708 18.55 25.8708H14ZM14 17.3833C14.9333 17.3833 15.7306 17.0528 16.3917 16.3917C17.0528 15.7305 17.3833 14.9333 17.3833 14C17.3833 13.0667 17.0528 12.2694 16.3917 11.6083C15.7306 10.9472 14.9333 10.6167 14 10.6167C13.0667 10.6167 12.2695 10.9472 11.6083 11.6083C10.9472 12.2694 10.6167 13.0667 10.6167 14C10.6167 14.9333 10.9472 15.7305 11.6083 16.3917C12.2695 17.0528 13.0667 17.3833 14 17.3833Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$K; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-mention",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$J = "/*!@:host*/.sc-swirl-icon-menu-h{display:inline-flex}";

class SwirlIconMenu {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M2.66667 12C2.47778 12 2.31956 11.936 2.192 11.808C2.064 11.6804 2 11.5222 2 11.3333C2 11.1444 2.064 10.9862 2.192 10.8587C2.31956 10.7307 2.47778 10.6667 2.66667 10.6667H13.3333C13.5222 10.6667 13.6804 10.7307 13.808 10.8587C13.936 10.9862 14 11.1444 14 11.3333C14 11.5222 13.936 11.6804 13.808 11.808C13.6804 11.936 13.5222 12 13.3333 12H2.66667ZM2.66667 8.66667C2.47778 8.66667 2.31956 8.60267 2.192 8.47467C2.064 8.34711 2 8.18889 2 8C2 7.81111 2.064 7.65267 2.192 7.52467C2.31956 7.39711 2.47778 7.33333 2.66667 7.33333H13.3333C13.5222 7.33333 13.6804 7.39711 13.808 7.52467C13.936 7.65267 14 7.81111 14 8C14 8.18889 13.936 8.34711 13.808 8.47467C13.6804 8.60267 13.5222 8.66667 13.3333 8.66667H2.66667ZM2.66667 5.33333C2.47778 5.33333 2.31956 5.26956 2.192 5.142C2.064 5.014 2 4.85556 2 4.66667C2 4.47778 2.064 4.31933 2.192 4.19133C2.31956 4.06378 2.47778 4 2.66667 4H13.3333C13.5222 4 13.6804 4.06378 13.808 4.19133C13.936 4.31933 14 4.47778 14 4.66667C14 4.85556 13.936 5.014 13.808 5.142C13.6804 5.26956 13.5222 5.33333 13.3333 5.33333H2.66667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M4 18C3.71667 18 3.47933 17.904 3.288 17.712C3.096 17.5207 3 17.2833 3 17C3 16.7167 3.096 16.4793 3.288 16.288C3.47933 16.096 3.71667 16 4 16H20C20.2833 16 20.5207 16.096 20.712 16.288C20.904 16.4793 21 16.7167 21 17C21 17.2833 20.904 17.5207 20.712 17.712C20.5207 17.904 20.2833 18 20 18H4ZM4 13C3.71667 13 3.47933 12.904 3.288 12.712C3.096 12.5207 3 12.2833 3 12C3 11.7167 3.096 11.479 3.288 11.287C3.47933 11.0957 3.71667 11 4 11H20C20.2833 11 20.5207 11.0957 20.712 11.287C20.904 11.479 21 11.7167 21 12C21 12.2833 20.904 12.5207 20.712 12.712C20.5207 12.904 20.2833 13 20 13H4ZM4 8C3.71667 8 3.47933 7.90433 3.288 7.713C3.096 7.521 3 7.28333 3 7C3 6.71667 3.096 6.479 3.288 6.287C3.47933 6.09567 3.71667 6 4 6H20C20.2833 6 20.5207 6.09567 20.712 6.287C20.904 6.479 21 6.71667 21 7C21 7.28333 20.904 7.521 20.712 7.713C20.5207 7.90433 20.2833 8 20 8H4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66667 21C4.33611 21 4.05922 20.888 3.836 20.664C3.612 20.4408 3.5 20.1639 3.5 19.8333C3.5 19.5028 3.612 19.2259 3.836 19.0027C4.05922 18.7787 4.33611 18.6667 4.66667 18.6667H23.3333C23.6639 18.6667 23.9408 18.7787 24.164 19.0027C24.388 19.2259 24.5 19.5028 24.5 19.8333C24.5 20.1639 24.388 20.4408 24.164 20.664C23.9408 20.888 23.6639 21 23.3333 21H4.66667ZM4.66667 15.1667C4.33611 15.1667 4.05922 15.0547 3.836 14.8307C3.612 14.6074 3.5 14.3306 3.5 14C3.5 13.6694 3.612 13.3922 3.836 13.1682C4.05922 12.9449 4.33611 12.8333 4.66667 12.8333H23.3333C23.6639 12.8333 23.9408 12.9449 24.164 13.1682C24.388 13.3922 24.5 13.6694 24.5 14C24.5 14.3306 24.388 14.6074 24.164 14.8307C23.9408 15.0547 23.6639 15.1667 23.3333 15.1667H4.66667ZM4.66667 9.33333C4.33611 9.33333 4.05922 9.22172 3.836 8.9985C3.612 8.7745 3.5 8.49722 3.5 8.16667C3.5 7.83611 3.612 7.55883 3.836 7.33483C4.05922 7.11161 4.33611 7 4.66667 7H23.3333C23.6639 7 23.9408 7.11161 24.164 7.33483C24.388 7.55883 24.5 7.83611 24.5 8.16667C24.5 8.49722 24.388 8.7745 24.164 8.9985C23.9408 9.22172 23.6639 9.33333 23.3333 9.33333H4.66667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$J; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-menu",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$I = "/*!@:host*/.sc-swirl-icon-menu-book-h{display:inline-flex}";

class SwirlIconMenuBook {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M9.33333 5.85008C9.33333 5.75008 9.36945 5.6473 9.44167 5.54175C9.51389 5.43619 9.59445 5.36675 9.68333 5.33341C10.0056 5.2223 10.3278 5.13897 10.65 5.08341C10.9722 5.02786 11.3111 5.00008 11.6667 5.00008C11.8889 5.00008 12.1083 5.01397 12.325 5.04175C12.5417 5.06953 12.7556 5.10564 12.9667 5.15008C13.0667 5.1723 13.1528 5.22786 13.225 5.31675C13.2972 5.40564 13.3333 5.50564 13.3333 5.61675C13.3333 5.80564 13.2722 5.94453 13.15 6.03341C13.0278 6.1223 12.8722 6.14453 12.6833 6.10008C12.5278 6.06675 12.3639 6.04175 12.1917 6.02508C12.0194 6.00841 11.8444 6.00008 11.6667 6.00008C11.3778 6.00008 11.0944 6.02786 10.8167 6.08341C10.5389 6.13897 10.2722 6.21119 10.0167 6.30008C9.81667 6.37786 9.65278 6.3723 9.525 6.28341C9.39722 6.19453 9.33333 6.05008 9.33333 5.85008ZM9.33333 9.51675C9.33333 9.41675 9.36945 9.31397 9.44167 9.20841C9.51389 9.10286 9.59445 9.03341 9.68333 9.00008C10.0056 8.88897 10.3278 8.80564 10.65 8.75008C10.9722 8.69453 11.3111 8.66675 11.6667 8.66675C11.8889 8.66675 12.1083 8.68064 12.325 8.70841C12.5417 8.73619 12.7556 8.7723 12.9667 8.81675C13.0667 8.83897 13.1528 8.89453 13.225 8.98341C13.2972 9.0723 13.3333 9.1723 13.3333 9.28341C13.3333 9.4723 13.2722 9.61119 13.15 9.70008C13.0278 9.78897 12.8722 9.81119 12.6833 9.76675C12.5278 9.73341 12.3639 9.70841 12.1917 9.69175C12.0194 9.67508 11.8444 9.66675 11.6667 9.66675C11.3778 9.66675 11.0944 9.69175 10.8167 9.74175C10.5389 9.79175 10.2722 9.86119 10.0167 9.95008C9.81667 10.0279 9.65278 10.0251 9.525 9.94175C9.39722 9.85841 9.33333 9.71675 9.33333 9.51675ZM9.33333 7.68341C9.33333 7.58341 9.36945 7.48064 9.44167 7.37508C9.51389 7.26953 9.59445 7.20008 9.68333 7.16675C10.0056 7.05564 10.3278 6.9723 10.65 6.91675C10.9722 6.86119 11.3111 6.83341 11.6667 6.83341C11.8889 6.83341 12.1083 6.8473 12.325 6.87508C12.5417 6.90286 12.7556 6.93897 12.9667 6.98341C13.0667 7.00564 13.1528 7.06119 13.225 7.15008C13.2972 7.23897 13.3333 7.33897 13.3333 7.45008C13.3333 7.63897 13.2722 7.77786 13.15 7.86675C13.0278 7.95564 12.8722 7.97786 12.6833 7.93341C12.5278 7.90008 12.3639 7.87508 12.1917 7.85841C12.0194 7.84175 11.8444 7.83341 11.6667 7.83341C11.3778 7.83341 11.0944 7.86119 10.8167 7.91675C10.5389 7.9723 10.2722 8.04453 10.0167 8.13341C9.81667 8.21119 9.65278 8.20564 9.525 8.11675C9.39722 8.02786 9.33333 7.88341 9.33333 7.68341ZM4.33333 10.6667C4.85556 10.6667 5.36389 10.7251 5.85833 10.8417C6.35278 10.9584 6.84445 11.1334 7.33333 11.3667V4.80008C6.87778 4.53341 6.39445 4.33341 5.88333 4.20008C5.37222 4.06675 4.85556 4.00008 4.33333 4.00008C3.93333 4.00008 3.53611 4.03897 3.14167 4.11675C2.74722 4.19453 2.36667 4.31119 2 4.46675V11.0667C2.38889 10.9334 2.775 10.8334 3.15833 10.7667C3.54167 10.7001 3.93333 10.6667 4.33333 10.6667ZM8.66667 11.3667C9.15556 11.1334 9.64722 10.9584 10.1417 10.8417C10.6361 10.7251 11.1444 10.6667 11.6667 10.6667C12.0667 10.6667 12.4583 10.7001 12.8417 10.7667C13.225 10.8334 13.6111 10.9334 14 11.0667V4.46675C13.6333 4.31119 13.2528 4.19453 12.8583 4.11675C12.4639 4.03897 12.0667 4.00008 11.6667 4.00008C11.1444 4.00008 10.6278 4.06675 10.1167 4.20008C9.60556 4.33341 9.12222 4.53341 8.66667 4.80008V11.3667ZM8 12.9834C7.84445 12.9834 7.69722 12.964 7.55833 12.9251C7.41945 12.8862 7.28889 12.8334 7.16667 12.7667C6.73333 12.5112 6.27778 12.3195 5.8 12.1917C5.32222 12.064 4.83333 12.0001 4.33333 12.0001C3.86667 12.0001 3.40833 12.0612 2.95833 12.1834C2.50833 12.3056 2.07778 12.4779 1.66667 12.7001C1.43333 12.8223 1.20833 12.8167 0.991668 12.6834C0.775001 12.5501 0.666668 12.3556 0.666668 12.1001V4.06675C0.666668 3.94453 0.697223 3.82786 0.758335 3.71675C0.819446 3.60564 0.911112 3.5223 1.03333 3.46675C1.54445 3.20008 2.07778 3.00008 2.63333 2.86675C3.18889 2.73341 3.75556 2.66675 4.33333 2.66675C4.97778 2.66675 5.60833 2.75008 6.225 2.91675C6.84167 3.08341 7.43333 3.33341 8 3.66675C8.56667 3.33341 9.15833 3.08341 9.775 2.91675C10.3917 2.75008 11.0222 2.66675 11.6667 2.66675C12.2444 2.66675 12.8111 2.73341 13.3667 2.86675C13.9222 3.00008 14.4556 3.20008 14.9667 3.46675C15.0889 3.5223 15.1806 3.60564 15.2417 3.71675C15.3028 3.82786 15.3333 3.94453 15.3333 4.06675V12.1001C15.3333 12.3556 15.225 12.5501 15.0083 12.6834C14.7917 12.8167 14.5667 12.8223 14.3333 12.7001C13.9222 12.4779 13.4917 12.3056 13.0417 12.1834C12.5917 12.0612 12.1333 12.0001 11.6667 12.0001C11.1667 12.0001 10.6778 12.064 10.2 12.1917C9.72222 12.3195 9.26667 12.5112 8.83333 12.7667C8.71111 12.8334 8.58056 12.8862 8.44167 12.9251C8.30278 12.964 8.15556 12.9834 8 12.9834Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M14 8.775C14 8.625 14.0542 8.47083 14.1625 8.3125C14.2708 8.15417 14.3917 8.05 14.525 8C15.0083 7.83333 15.4917 7.70833 15.975 7.625C16.4583 7.54167 16.9667 7.5 17.5 7.5C17.8333 7.5 18.1625 7.52083 18.4875 7.5625C18.8125 7.60417 19.1333 7.65833 19.45 7.725C19.6 7.75833 19.7292 7.84167 19.8375 7.975C19.9458 8.10833 20 8.25833 20 8.425C20 8.70833 19.9083 8.91667 19.725 9.05C19.5417 9.18333 19.3083 9.21667 19.025 9.15C18.7917 9.1 18.5458 9.0625 18.2875 9.0375C18.0292 9.0125 17.7667 9 17.5 9C17.0667 9 16.6417 9.04167 16.225 9.125C15.8083 9.20833 15.4083 9.31667 15.025 9.45C14.725 9.56667 14.4792 9.55833 14.2875 9.425C14.0958 9.29167 14 9.075 14 8.775ZM14 14.275C14 14.125 14.0542 13.9708 14.1625 13.8125C14.2708 13.6542 14.3917 13.55 14.525 13.5C15.0083 13.3333 15.4917 13.2083 15.975 13.125C16.4583 13.0417 16.9667 13 17.5 13C17.8333 13 18.1625 13.0208 18.4875 13.0625C18.8125 13.1042 19.1333 13.1583 19.45 13.225C19.6 13.2583 19.7292 13.3417 19.8375 13.475C19.9458 13.6083 20 13.7583 20 13.925C20 14.2083 19.9083 14.4167 19.725 14.55C19.5417 14.6833 19.3083 14.7167 19.025 14.65C18.7917 14.6 18.5458 14.5625 18.2875 14.5375C18.0292 14.5125 17.7667 14.5 17.5 14.5C17.0667 14.5 16.6417 14.5375 16.225 14.6125C15.8083 14.6875 15.4083 14.7917 15.025 14.925C14.725 15.0417 14.4792 15.0375 14.2875 14.9125C14.0958 14.7875 14 14.575 14 14.275ZM14 11.525C14 11.375 14.0542 11.2208 14.1625 11.0625C14.2708 10.9042 14.3917 10.8 14.525 10.75C15.0083 10.5833 15.4917 10.4583 15.975 10.375C16.4583 10.2917 16.9667 10.25 17.5 10.25C17.8333 10.25 18.1625 10.2708 18.4875 10.3125C18.8125 10.3542 19.1333 10.4083 19.45 10.475C19.6 10.5083 19.7292 10.5917 19.8375 10.725C19.9458 10.8583 20 11.0083 20 11.175C20 11.4583 19.9083 11.6667 19.725 11.8C19.5417 11.9333 19.3083 11.9667 19.025 11.9C18.7917 11.85 18.5458 11.8125 18.2875 11.7875C18.0292 11.7625 17.7667 11.75 17.5 11.75C17.0667 11.75 16.6417 11.7917 16.225 11.875C15.8083 11.9583 15.4083 12.0667 15.025 12.2C14.725 12.3167 14.4792 12.3083 14.2875 12.175C14.0958 12.0417 14 11.825 14 11.525ZM6.5 16C7.28333 16 8.04583 16.0875 8.7875 16.2625C9.52917 16.4375 10.2667 16.7 11 17.05V7.2C10.3167 6.8 9.59167 6.5 8.825 6.3C8.05833 6.1 7.28333 6 6.5 6C5.9 6 5.30417 6.05833 4.7125 6.175C4.12083 6.29167 3.55 6.46667 3 6.7V16.6C3.58333 16.4 4.1625 16.25 4.7375 16.15C5.3125 16.05 5.9 16 6.5 16ZM13 17.05C13.7333 16.7 14.4708 16.4375 15.2125 16.2625C15.9542 16.0875 16.7167 16 17.5 16C18.1 16 18.6875 16.05 19.2625 16.15C19.8375 16.25 20.4167 16.4 21 16.6V6.7C20.45 6.46667 19.8792 6.29167 19.2875 6.175C18.6958 6.05833 18.1 6 17.5 6C16.7167 6 15.9417 6.1 15.175 6.3C14.4083 6.5 13.6833 6.8 13 7.2V17.05ZM12 19.475C11.7667 19.475 11.5458 19.4458 11.3375 19.3875C11.1292 19.3292 10.9333 19.25 10.75 19.15C10.1 18.7667 9.41667 18.4792 8.7 18.2875C7.98333 18.0958 7.25 18 6.5 18C5.8 18 5.1125 18.0917 4.4375 18.275C3.7625 18.4583 3.11667 18.7167 2.5 19.05C2.15 19.2333 1.8125 19.225 1.4875 19.025C1.1625 18.825 1 18.5333 1 18.15V6.1C1 5.91667 1.04583 5.74167 1.1375 5.575C1.22917 5.40833 1.36667 5.28333 1.55 5.2C2.31667 4.8 3.11667 4.5 3.95 4.3C4.78333 4.1 5.63333 4 6.5 4C7.46667 4 8.4125 4.125 9.3375 4.375C10.2625 4.625 11.15 5 12 5.5C12.85 5 13.7375 4.625 14.6625 4.375C15.5875 4.125 16.5333 4 17.5 4C18.3667 4 19.2167 4.1 20.05 4.3C20.8833 4.5 21.6833 4.8 22.45 5.2C22.6333 5.28333 22.7708 5.40833 22.8625 5.575C22.9542 5.74167 23 5.91667 23 6.1V18.15C23 18.5333 22.8375 18.825 22.5125 19.025C22.1875 19.225 21.85 19.2333 21.5 19.05C20.8833 18.7167 20.2375 18.4583 19.5625 18.275C18.8875 18.0917 18.2 18 17.5 18C16.75 18 16.0167 18.0958 15.3 18.2875C14.5833 18.4792 13.9 18.7667 13.25 19.15C13.0667 19.25 12.8708 19.3292 12.6625 19.3875C12.4542 19.4458 12.2333 19.475 12 19.475Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M16.3333 10.2376C16.3333 10.0626 16.3965 9.88272 16.5229 9.698C16.6493 9.51328 16.7903 9.39175 16.9458 9.33341C17.5097 9.13897 18.0736 8.99314 18.6375 8.89591C19.2014 8.79869 19.7944 8.75008 20.4167 8.75008C20.8056 8.75008 21.1896 8.77439 21.5687 8.823C21.9479 8.87161 22.3222 8.9348 22.6917 9.01258C22.8667 9.05147 23.0174 9.14869 23.1437 9.30425C23.2701 9.4598 23.3333 9.6348 23.3333 9.82925C23.3333 10.1598 23.2264 10.4029 23.0125 10.5584C22.7986 10.714 22.5264 10.7529 22.1958 10.6751C21.9236 10.6167 21.6368 10.573 21.3354 10.5438C21.034 10.5147 20.7278 10.5001 20.4167 10.5001C19.9111 10.5001 19.4153 10.5487 18.9292 10.6459C18.4431 10.7431 17.9764 10.8695 17.5292 11.0251C17.1792 11.1612 16.8924 11.1515 16.6687 10.9959C16.4451 10.8404 16.3333 10.5876 16.3333 10.2376ZM16.3333 16.6542C16.3333 16.4792 16.3965 16.2994 16.5229 16.1147C16.6493 15.9299 16.7903 15.8084 16.9458 15.7501C17.5097 15.5556 18.0736 15.4098 18.6375 15.3126C19.2014 15.2154 19.7944 15.1667 20.4167 15.1667C20.8056 15.1667 21.1896 15.1911 21.5687 15.2397C21.9479 15.2883 22.3222 15.3515 22.6917 15.4292C22.8667 15.4681 23.0174 15.5654 23.1437 15.7209C23.2701 15.8765 23.3333 16.0515 23.3333 16.2459C23.3333 16.5765 23.2264 16.8195 23.0125 16.9751C22.7986 17.1306 22.5264 17.1695 22.1958 17.0917C21.9236 17.0334 21.6368 16.9897 21.3354 16.9605C21.034 16.9313 20.7278 16.9167 20.4167 16.9167C19.9111 16.9167 19.4153 16.9605 18.9292 17.048C18.4431 17.1355 17.9764 17.257 17.5292 17.4126C17.1792 17.5487 16.8924 17.5438 16.6687 17.398C16.4451 17.2522 16.3333 17.0042 16.3333 16.6542ZM16.3333 13.4459C16.3333 13.2709 16.3965 13.0911 16.5229 12.9063C16.6493 12.7216 16.7903 12.6001 16.9458 12.5417C17.5097 12.3473 18.0736 12.2015 18.6375 12.1042C19.2014 12.007 19.7944 11.9584 20.4167 11.9584C20.8056 11.9584 21.1896 11.9827 21.5687 12.0313C21.9479 12.0799 22.3222 12.1431 22.6917 12.2209C22.8667 12.2598 23.0174 12.357 23.1437 12.5126C23.2701 12.6681 23.3333 12.8431 23.3333 13.0376C23.3333 13.3681 23.2264 13.6112 23.0125 13.7667C22.7986 13.9223 22.5264 13.9612 22.1958 13.8834C21.9236 13.8251 21.6368 13.7813 21.3354 13.7522C21.034 13.723 20.7278 13.7084 20.4167 13.7084C19.9111 13.7084 19.4153 13.757 18.9292 13.8542C18.4431 13.9515 17.9764 14.0779 17.5292 14.2334C17.1792 14.3695 16.8924 14.3598 16.6687 14.2042C16.4451 14.0487 16.3333 13.7959 16.3333 13.4459ZM7.58333 18.6667C8.49722 18.6667 9.3868 18.7688 10.2521 18.973C11.1174 19.1772 11.9778 19.4834 12.8333 19.8917V8.40008C12.0361 7.93341 11.1903 7.58341 10.2958 7.35008C9.40139 7.11675 8.49722 7.00008 7.58333 7.00008C6.88333 7.00008 6.18819 7.06814 5.49791 7.20425C4.80764 7.34036 4.14166 7.54453 3.5 7.81675V19.3667C4.18055 19.1334 4.85625 18.9584 5.52708 18.8417C6.19791 18.7251 6.88333 18.6667 7.58333 18.6667ZM15.1667 19.8917C16.0222 19.4834 16.8826 19.1772 17.7479 18.973C18.6132 18.7688 19.5028 18.6667 20.4167 18.6667C21.1167 18.6667 21.8021 18.7251 22.4729 18.8417C23.1437 18.9584 23.8194 19.1334 24.5 19.3667V7.81675C23.8583 7.54453 23.1924 7.34036 22.5021 7.20425C21.8118 7.06814 21.1167 7.00008 20.4167 7.00008C19.5028 7.00008 18.5986 7.11675 17.7042 7.35008C16.8097 7.58341 15.9639 7.93341 15.1667 8.40008V19.8917ZM14 22.7209C13.7278 22.7209 13.4701 22.6869 13.2271 22.6188C12.984 22.5508 12.7556 22.4584 12.5417 22.3417C11.7833 21.8945 10.9861 21.5591 10.15 21.3355C9.31389 21.1119 8.45833 21.0001 7.58333 21.0001C6.76666 21.0001 5.96458 21.107 5.17708 21.3209C4.38958 21.5348 3.63611 21.8362 2.91666 22.2251C2.50833 22.439 2.11458 22.4292 1.73541 22.1959C1.35625 21.9626 1.16666 21.6223 1.16666 21.1751V7.11675C1.16666 6.90286 1.22014 6.69869 1.32708 6.50425C1.43403 6.3098 1.59444 6.16397 1.80833 6.06675C2.70278 5.60008 3.63611 5.25008 4.60833 5.01675C5.58055 4.78341 6.57222 4.66675 7.58333 4.66675C8.71111 4.66675 9.81458 4.81258 10.8937 5.10425C11.9729 5.39591 13.0083 5.83341 14 6.41675C14.9917 5.83341 16.0271 5.39591 17.1062 5.10425C18.1854 4.81258 19.2889 4.66675 20.4167 4.66675C21.4278 4.66675 22.4194 4.78341 23.3917 5.01675C24.3639 5.25008 25.2972 5.60008 26.1917 6.06675C26.4056 6.16397 26.566 6.3098 26.6729 6.50425C26.7799 6.69869 26.8333 6.90286 26.8333 7.11675V21.1751C26.8333 21.6223 26.6437 21.9626 26.2646 22.1959C25.8854 22.4292 25.4917 22.439 25.0833 22.2251C24.3639 21.8362 23.6104 21.5348 22.8229 21.3209C22.0354 21.107 21.2333 21.0001 20.4167 21.0001C19.5417 21.0001 18.6861 21.1119 17.85 21.3355C17.0139 21.5591 16.2167 21.8945 15.4583 22.3417C15.2444 22.4584 15.016 22.5508 14.7729 22.6188C14.5299 22.6869 14.2722 22.7209 14 22.7209Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$I; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-menu-book",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$H = "/*!@:host*/.sc-swirl-icon-menu-filled-h{display:inline-flex}";

class SwirlIconMenuFilled {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7 3.8335V5.5C7 5.89782 6.84196 6.27935 6.56066 6.56066C6.27935 6.84196 5.89782 7 5.5 7H3.8335C3.43567 7 3.05414 6.84196 2.77284 6.56066C2.49153 6.27935 2.3335 5.89782 2.3335 5.5V3.8335C2.3335 3.43567 2.49153 3.05414 2.77284 2.77284C3.05414 2.49153 3.43567 2.3335 3.8335 2.3335H5.5C5.89782 2.3335 6.27935 2.49153 6.56066 2.77284C6.84196 3.05414 7 3.43567 7 3.8335Z", fill: "currentColor" }), hAsync("path", { d: "M12.1665 7H10.5C10.1022 7 9.72064 6.84196 9.43934 6.56066C9.15803 6.27935 9 5.89782 9 5.5V3.8335C9 3.43567 9.15803 3.05414 9.43934 2.77284C9.72064 2.49153 10.1022 2.3335 10.5 2.3335H12.1665C12.5643 2.3335 12.9459 2.49153 13.2272 2.77284C13.5085 3.05414 13.6665 3.43567 13.6665 3.8335V5.5C13.6665 5.89782 13.5085 6.27935 13.2272 6.56066C12.9459 6.84196 12.5643 7 12.1665 7Z", fill: "currentColor" }), hAsync("path", { d: "M5.5 13.6665H3.8335C3.43567 13.6665 3.05414 13.5085 2.77284 13.2272C2.49153 12.9459 2.3335 12.5643 2.3335 12.1665V10.5C2.3335 10.1022 2.49153 9.72064 2.77284 9.43934C3.05414 9.15803 3.43567 9 3.8335 9H5.5C5.89782 9 6.27935 9.15803 6.56066 9.43934C6.84196 9.72064 7 10.1022 7 10.5V12.1665C7 12.5643 6.84196 12.9459 6.56066 13.2272C6.27935 13.5085 5.89782 13.6665 5.5 13.6665Z", fill: "currentColor" }), hAsync("path", { d: "M12.0835 13.5835H10.5C10.1022 13.5835 9.72064 13.4255 9.43934 13.1442C9.15803 12.8629 9 12.4813 9 12.0835V10.5C9 10.1022 9.15803 9.72064 9.43934 9.43934C9.72064 9.15803 10.1022 9 10.5 9H12.0835C12.4813 9 12.8629 9.15803 13.1442 9.43934C13.4255 9.72064 13.5835 10.1022 13.5835 10.5V12.0835C13.5835 12.4813 13.4255 12.8629 13.1442 13.1442C12.8629 13.4255 12.4813 13.5835 12.0835 13.5835Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M10.5 5.75024V8.24999C10.5 8.84673 10.2629 9.41903 9.84098 9.84098C9.41903 10.2629 8.84673 10.5 8.24999 10.5H5.75024C5.15351 10.5 4.58121 10.2629 4.15925 9.84098C3.7373 9.41903 3.50024 8.84673 3.50024 8.24999V5.75024C3.50024 5.15351 3.7373 4.58121 4.15925 4.15925C4.58121 3.7373 5.15351 3.50024 5.75024 3.50024H8.24999C8.84673 3.50024 9.41903 3.7373 9.84098 4.15925C10.2629 4.58121 10.5 5.15351 10.5 5.75024Z", fill: "currentColor" }), hAsync("path", { d: "M18.2497 10.5H15.75C15.1533 10.5 14.581 10.2629 14.159 9.84098C13.737 9.41903 13.5 8.84673 13.5 8.24999V5.75024C13.5 5.15351 13.737 4.58121 14.159 4.15925C14.581 3.7373 15.1533 3.50024 15.75 3.50024H18.2497C18.8465 3.50024 19.4188 3.7373 19.8407 4.15925C20.2627 4.58121 20.4997 5.15351 20.4997 5.75024V8.24999C20.4997 8.84673 20.2627 9.41903 19.8407 9.84098C19.4188 10.2629 18.8465 10.5 18.2497 10.5Z", fill: "currentColor" }), hAsync("path", { d: "M8.24999 20.4997H5.75024C5.15351 20.4997 4.58121 20.2627 4.15925 19.8407C3.7373 19.4188 3.50024 18.8465 3.50024 18.2497V15.75C3.50024 15.1533 3.7373 14.581 4.15925 14.159C4.58121 13.737 5.15351 13.5 5.75024 13.5H8.24999C8.84673 13.5 9.41903 13.737 9.84098 14.159C10.2629 14.581 10.5 15.1533 10.5 15.75V18.2497C10.5 18.8465 10.2629 19.4188 9.84098 19.8407C9.41903 20.2627 8.84673 20.4997 8.24999 20.4997Z", fill: "currentColor" }), hAsync("path", { d: "M18.1252 20.3752H15.75C15.1533 20.3752 14.581 20.1382 14.159 19.7162C13.737 19.2943 13.5 18.722 13.5 18.1252V15.75C13.5 15.1533 13.737 14.581 14.159 14.159C14.581 13.737 15.1533 13.5 15.75 13.5H18.1252C18.722 13.5 19.2943 13.737 19.7162 14.159C20.1382 14.581 20.3752 15.1533 20.3752 15.75V18.1252C20.3752 18.722 20.1382 19.2943 19.7162 19.7162C19.2943 20.1382 18.722 20.3752 18.1252 20.3752Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M12.25 6.70874V9.62512C12.25 10.3213 11.9734 10.989 11.4811 11.4813C10.9889 11.9736 10.3212 12.2501 9.62499 12.2501H6.70862C6.01242 12.2501 5.34475 11.9736 4.85246 11.4813C4.36018 10.989 4.08362 10.3213 4.08362 9.62512V6.70874C4.08362 6.01255 4.36018 5.34487 4.85246 4.85259C5.34475 4.3603 6.01242 4.08374 6.70862 4.08374H9.62499C10.3212 4.08374 10.9889 4.3603 11.4811 4.85259C11.9734 5.34487 12.25 6.01255 12.25 6.70874Z", fill: "currentColor" }), hAsync("path", { d: "M21.2914 12.2501H18.375C17.6788 12.2501 17.0111 11.9736 16.5188 11.4813C16.0266 10.989 15.75 10.3213 15.75 9.62512V6.70874C15.75 6.01255 16.0266 5.34487 16.5188 4.85259C17.0111 4.3603 17.6788 4.08374 18.375 4.08374H21.2914C21.9876 4.08374 22.6552 4.3603 23.1475 4.85259C23.6398 5.34487 23.9164 6.01255 23.9164 6.70874V9.62512C23.9164 10.3213 23.6398 10.989 23.1475 11.4813C22.6552 11.9736 21.9876 12.2501 21.2914 12.2501Z", fill: "currentColor" }), hAsync("path", { d: "M9.62499 23.9165H6.70862C6.01242 23.9165 5.34475 23.6399 4.85246 23.1476C4.36018 22.6554 4.08362 21.9877 4.08362 21.2915V18.3751C4.08362 17.6789 4.36018 17.0112 4.85246 16.519C5.34475 16.0267 6.01242 15.7501 6.70862 15.7501H9.62499C10.3212 15.7501 10.9889 16.0267 11.4811 16.519C11.9734 17.0112 12.25 17.6789 12.25 18.3751V21.2915C12.25 21.9877 11.9734 22.6554 11.4811 23.1476C10.9889 23.6399 10.3212 23.9165 9.62499 23.9165Z", fill: "currentColor" }), hAsync("path", { d: "M21.1461 23.7712H18.375C17.6788 23.7712 17.0111 23.4947 16.5188 23.0024C16.0266 22.5101 15.75 21.8424 15.75 21.1462V18.3751C15.75 17.6789 16.0266 17.0112 16.5188 16.519C17.0111 16.0267 17.6788 15.7501 18.375 15.7501H21.1461C21.8423 15.7501 22.51 16.0267 23.0023 16.519C23.4946 17.0112 23.7711 17.6789 23.7711 18.3751V21.1462C23.7711 21.8424 23.4946 22.5101 23.0023 23.0024C22.51 23.4947 21.8423 23.7712 21.1461 23.7712Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$H; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-menu-filled",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$G = "/*!@:host*/.sc-swirl-icon-menu-outlined-h{display:inline-flex}";

class SwirlIconMenuOutlined {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M5.8335 3.3335C5.9661 3.3335 6.09328 3.38617 6.18705 3.47994C6.28082 3.57371 6.3335 3.70089 6.3335 3.8335V5.8335C6.3335 5.9661 6.28082 6.09328 6.18705 6.18705C6.09328 6.28082 5.9661 6.3335 5.8335 6.3335H3.8335C3.70089 6.3335 3.57371 6.28082 3.47994 6.18705C3.38617 6.09328 3.3335 5.9661 3.3335 5.8335V3.8335C3.3335 3.70089 3.38617 3.57371 3.47994 3.47994C3.57371 3.38617 3.70089 3.3335 3.8335 3.3335H5.8335ZM5.8335 2.3335H3.8335C3.43567 2.3335 3.05414 2.49153 2.77284 2.77284C2.49153 3.05414 2.3335 3.43567 2.3335 3.8335V5.8335C2.3335 6.23132 2.49153 6.61285 2.77284 6.89416C3.05414 7.17546 3.43567 7.3335 3.8335 7.3335H5.8335C6.23132 7.3335 6.61285 7.17546 6.89416 6.89416C7.17546 6.61285 7.3335 6.23132 7.3335 5.8335V3.8335C7.3335 3.43567 7.17546 3.05414 6.89416 2.77284C6.61285 2.49153 6.23132 2.3335 5.8335 2.3335Z", fill: "currentColor" }), hAsync("path", { d: "M12.1665 3.3335C12.2991 3.3335 12.4263 3.38617 12.5201 3.47994C12.6138 3.57371 12.6665 3.70089 12.6665 3.8335V5.8335C12.6665 5.9661 12.6138 6.09328 12.5201 6.18705C12.4263 6.28082 12.2991 6.3335 12.1665 6.3335H10.1665C10.0339 6.3335 9.90671 6.28082 9.81294 6.18705C9.71917 6.09328 9.6665 5.9661 9.6665 5.8335V3.8335C9.6665 3.70089 9.71917 3.57371 9.81294 3.47994C9.90671 3.38617 10.0339 3.3335 10.1665 3.3335H12.1665ZM12.1665 2.3335H10.1665C9.76867 2.3335 9.38714 2.49153 9.10584 2.77284C8.82453 3.05414 8.6665 3.43567 8.6665 3.8335V5.8335C8.6665 6.23132 8.82453 6.61285 9.10584 6.89416C9.38714 7.17546 9.76867 7.3335 10.1665 7.3335H12.1665C12.5643 7.3335 12.9459 7.17546 13.2272 6.89416C13.5085 6.61285 13.6665 6.23132 13.6665 5.8335V3.8335C13.6665 3.43567 13.5085 3.05414 13.2272 2.77284C12.9459 2.49153 12.5643 2.3335 12.1665 2.3335Z", fill: "currentColor" }), hAsync("path", { d: "M5.8335 9.6665C5.9661 9.6665 6.09328 9.71917 6.18705 9.81294C6.28082 9.90671 6.3335 10.0339 6.3335 10.1665V12.1665C6.3335 12.2991 6.28082 12.4263 6.18705 12.5201C6.09328 12.6138 5.9661 12.6665 5.8335 12.6665H3.8335C3.70089 12.6665 3.57371 12.6138 3.47994 12.5201C3.38617 12.4263 3.3335 12.2991 3.3335 12.1665V10.1665C3.3335 10.0339 3.38617 9.90671 3.47994 9.81294C3.57371 9.71917 3.70089 9.6665 3.8335 9.6665H5.8335ZM5.8335 8.6665H3.8335C3.43567 8.6665 3.05414 8.82453 2.77284 9.10584C2.49153 9.38714 2.3335 9.76867 2.3335 10.1665V12.1665C2.3335 12.5643 2.49153 12.9459 2.77284 13.2272C3.05414 13.5085 3.43567 13.6665 3.8335 13.6665H5.8335C6.23132 13.6665 6.61285 13.5085 6.89416 13.2272C7.17546 12.9459 7.3335 12.5643 7.3335 12.1665V10.1665C7.3335 9.76867 7.17546 9.38714 6.89416 9.10584C6.61285 8.82453 6.23132 8.6665 5.8335 8.6665Z", fill: "currentColor" }), hAsync("path", { d: "M12.0835 9.6665C12.2161 9.6665 12.3433 9.71917 12.437 9.81294C12.5308 9.90671 12.5835 10.0339 12.5835 10.1665V12.083C12.5835 12.2156 12.5308 12.3428 12.437 12.4365C12.3433 12.5303 12.2161 12.583 12.0835 12.583H10.167C10.0344 12.583 9.90721 12.5303 9.81344 12.4365C9.71967 12.3428 9.667 12.2156 9.667 12.083V10.1665C9.667 10.0339 9.71967 9.90671 9.81344 9.81294C9.90721 9.71917 10.0344 9.6665 10.167 9.6665H12.0835ZM12.0835 8.6665H10.167C9.76917 8.6665 9.38764 8.82453 9.10634 9.10584C8.82503 9.38714 8.667 9.76867 8.667 10.1665V12.083C8.667 12.4808 8.82503 12.8624 9.10634 13.1437C9.38764 13.425 9.76917 13.583 10.167 13.583H12.0835C12.4813 13.583 12.8629 13.425 13.1442 13.1437C13.4255 12.8624 13.5835 12.4808 13.5835 12.083V10.1665C13.5835 9.76867 13.4255 9.38714 13.1442 9.10584C12.8629 8.82453 12.4813 8.6665 12.0835 8.6665Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M8.75024 5.00024C8.94916 5.00024 9.13992 5.07926 9.28057 5.21991C9.42123 5.36057 9.50024 5.55133 9.50024 5.75024V8.75024C9.50024 8.94916 9.42123 9.13992 9.28057 9.28057C9.13992 9.42123 8.94916 9.50024 8.75024 9.50024H5.75024C5.55133 9.50024 5.36057 9.42123 5.21991 9.28057C5.07926 9.13992 5.00024 8.94916 5.00024 8.75024V5.75024C5.00024 5.55133 5.07926 5.36057 5.21991 5.21991C5.36057 5.07926 5.55133 5.00024 5.75024 5.00024H8.75024ZM8.75024 3.50024H5.75024C5.15351 3.50024 4.58121 3.7373 4.15925 4.15925C3.7373 4.58121 3.50024 5.15351 3.50024 5.75024V8.75024C3.50024 9.34698 3.7373 9.91928 4.15925 10.3412C4.58121 10.7632 5.15351 11.0002 5.75024 11.0002H8.75024C9.34698 11.0002 9.91928 10.7632 10.3412 10.3412C10.7632 9.91928 11.0002 9.34698 11.0002 8.75024V5.75024C11.0002 5.15351 10.7632 4.58121 10.3412 4.15925C9.91928 3.7373 9.34698 3.50024 8.75024 3.50024Z", fill: "currentColor" }), hAsync("path", { d: "M18.2497 5.00024C18.4487 5.00024 18.6394 5.07926 18.7801 5.21991C18.9207 5.36057 18.9997 5.55133 18.9997 5.75024V8.75024C18.9997 8.94916 18.9207 9.13992 18.7801 9.28057C18.6394 9.42123 18.4487 9.50024 18.2497 9.50024H15.2497C15.0508 9.50024 14.8601 9.42123 14.7194 9.28057C14.5788 9.13992 14.4997 8.94916 14.4997 8.75024V5.75024C14.4997 5.55133 14.5788 5.36057 14.7194 5.21991C14.8601 5.07926 15.0508 5.00024 15.2497 5.00024H18.2497ZM18.2497 3.50024H15.2497C14.653 3.50024 14.0807 3.7373 13.6588 4.15925C13.2368 4.58121 12.9997 5.15351 12.9997 5.75024V8.75024C12.9997 9.34698 13.2368 9.91928 13.6588 10.3412C14.0807 10.7632 14.653 11.0002 15.2497 11.0002H18.2497C18.8465 11.0002 19.4188 10.7632 19.8407 10.3412C20.2627 9.91928 20.4997 9.34698 20.4997 8.75024V5.75024C20.4997 5.15351 20.2627 4.58121 19.8407 4.15925C19.4188 3.7373 18.8465 3.50024 18.2497 3.50024Z", fill: "currentColor" }), hAsync("path", { d: "M8.75024 14.4997C8.94916 14.4997 9.13992 14.5788 9.28057 14.7194C9.42123 14.8601 9.50024 15.0508 9.50024 15.2497V18.2497C9.50024 18.4487 9.42123 18.6394 9.28057 18.7801C9.13992 18.9207 8.94916 18.9997 8.75024 18.9997H5.75024C5.55133 18.9997 5.36057 18.9207 5.21991 18.7801C5.07926 18.6394 5.00024 18.4487 5.00024 18.2497V15.2497C5.00024 15.0508 5.07926 14.8601 5.21991 14.7194C5.36057 14.5788 5.55133 14.4997 5.75024 14.4997H8.75024ZM8.75024 12.9997H5.75024C5.15351 12.9997 4.58121 13.2368 4.15925 13.6588C3.7373 14.0807 3.50024 14.653 3.50024 15.2497V18.2497C3.50024 18.8465 3.7373 19.4188 4.15925 19.8407C4.58121 20.2627 5.15351 20.4997 5.75024 20.4997H8.75024C9.34698 20.4997 9.91928 20.2627 10.3412 19.8407C10.7632 19.4188 11.0002 18.8465 11.0002 18.2497V15.2497C11.0002 14.653 10.7632 14.0807 10.3412 13.6588C9.91928 13.2368 9.34698 12.9997 8.75024 12.9997Z", fill: "currentColor" }), hAsync("path", { d: "M18.1252 14.4997C18.3242 14.4997 18.5149 14.5788 18.6556 14.7194C18.7962 14.8601 18.8752 15.0508 18.8752 15.2497V18.1245C18.8752 18.3234 18.7962 18.5142 18.6556 18.6548C18.5149 18.7955 18.3242 18.8745 18.1252 18.8745H15.2505C15.0516 18.8745 14.8608 18.7955 14.7202 18.6548C14.5795 18.5142 14.5005 18.3234 14.5005 18.1245V15.2497C14.5005 15.0508 14.5795 14.8601 14.7202 14.7194C14.8608 14.5788 15.0516 14.4997 15.2505 14.4997H18.1252ZM18.1252 12.9997H15.2505C14.6538 12.9997 14.0815 13.2368 13.6595 13.6588C13.2375 14.0807 13.0005 14.653 13.0005 15.2497V18.1245C13.0005 18.7212 13.2375 19.2935 13.6595 19.7155C14.0815 20.1374 14.6538 20.3745 15.2505 20.3745H18.1252C18.722 20.3745 19.2943 20.1374 19.7162 19.7155C20.1382 19.2935 20.3752 18.7212 20.3752 18.1245V15.2497C20.3752 14.653 20.1382 14.0807 19.7162 13.6588C19.2943 13.2368 18.722 12.9997 18.1252 12.9997Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M10.2086 5.83374C10.4407 5.83374 10.6632 5.92593 10.8273 6.09002C10.9914 6.25412 11.0836 6.47668 11.0836 6.70874V10.2087C11.0836 10.4408 10.9914 10.6634 10.8273 10.8275C10.6632 10.9916 10.4407 11.0837 10.2086 11.0837H6.70862C6.47655 11.0837 6.25399 10.9916 6.0899 10.8275C5.92581 10.6634 5.83362 10.4408 5.83362 10.2087V6.70874C5.83362 6.47668 5.92581 6.25412 6.0899 6.09002C6.25399 5.92593 6.47655 5.83374 6.70862 5.83374H10.2086ZM10.2086 4.08374H6.70862C6.01242 4.08374 5.34475 4.3603 4.85246 4.85259C4.36018 5.34487 4.08362 6.01255 4.08362 6.70874V10.2087C4.08362 10.9049 4.36018 11.5726 4.85246 12.0649C5.34475 12.5572 6.01242 12.8337 6.70862 12.8337H10.2086C10.9048 12.8337 11.5725 12.5572 12.0648 12.0649C12.5571 11.5726 12.8336 10.9049 12.8336 10.2087V6.70874C12.8336 6.01255 12.5571 5.34487 12.0648 4.85259C11.5725 4.3603 10.9048 4.08374 10.2086 4.08374Z", fill: "currentColor" }), hAsync("path", { d: "M21.2914 5.83374C21.5234 5.83374 21.746 5.92593 21.9101 6.09002C22.0742 6.25412 22.1664 6.47668 22.1664 6.70874V10.2087C22.1664 10.4408 22.0742 10.6634 21.9101 10.8275C21.746 10.9916 21.5234 11.0837 21.2914 11.0837H17.7914C17.5593 11.0837 17.3367 10.9916 17.1726 10.8275C17.0086 10.6634 16.9164 10.4408 16.9164 10.2087V6.70874C16.9164 6.47668 17.0086 6.25412 17.1726 6.09002C17.3367 5.92593 17.5593 5.83374 17.7914 5.83374H21.2914ZM21.2914 4.08374H17.7914C17.0952 4.08374 16.4275 4.3603 15.9352 4.85259C15.4429 5.34487 15.1664 6.01255 15.1664 6.70874V10.2087C15.1664 10.9049 15.4429 11.5726 15.9352 12.0649C16.4275 12.5572 17.0952 12.8337 17.7914 12.8337H21.2914C21.9876 12.8337 22.6552 12.5572 23.1475 12.0649C23.6398 11.5726 23.9164 10.9049 23.9164 10.2087V6.70874C23.9164 6.01255 23.6398 5.34487 23.1475 4.85259C22.6552 4.3603 21.9876 4.08374 21.2914 4.08374Z", fill: "currentColor" }), hAsync("path", { d: "M10.2086 16.9165C10.4407 16.9165 10.6632 17.0087 10.8273 17.1728C10.9914 17.3369 11.0836 17.5594 11.0836 17.7915V21.2915C11.0836 21.5236 10.9914 21.7461 10.8273 21.9102C10.6632 22.0743 10.4407 22.1665 10.2086 22.1665H6.70862C6.47655 22.1665 6.25399 22.0743 6.0899 21.9102C5.92581 21.7461 5.83362 21.5236 5.83362 21.2915V17.7915C5.83362 17.5594 5.92581 17.3369 6.0899 17.1728C6.25399 17.0087 6.47655 16.9165 6.70862 16.9165H10.2086ZM10.2086 15.1665H6.70862C6.01242 15.1665 5.34475 15.4431 4.85246 15.9353C4.36018 16.4276 4.08362 17.0953 4.08362 17.7915V21.2915C4.08362 21.9877 4.36018 22.6554 4.85246 23.1476C5.34475 23.6399 6.01242 23.9165 6.70862 23.9165H10.2086C10.9048 23.9165 11.5725 23.6399 12.0648 23.1476C12.5571 22.6554 12.8336 21.9877 12.8336 21.2915V17.7915C12.8336 17.0953 12.5571 16.4276 12.0648 15.9353C11.5725 15.4431 10.9048 15.1665 10.2086 15.1665Z", fill: "currentColor" }), hAsync("path", { d: "M21.1461 16.9165C21.3782 16.9165 21.6007 17.0087 21.7648 17.1728C21.9289 17.3369 22.0211 17.5594 22.0211 17.7915V21.1454C22.0211 21.3774 21.9289 21.6 21.7648 21.7641C21.6007 21.9282 21.3782 22.0204 21.1461 22.0204H17.7922C17.5602 22.0204 17.3376 21.9282 17.1735 21.7641C17.0094 21.6 16.9172 21.3774 16.9172 21.1454V17.7915C16.9172 17.5594 17.0094 17.3369 17.1735 17.1728C17.3376 17.0087 17.5602 16.9165 17.7922 16.9165H21.1461ZM21.1461 15.1665H17.7922C17.096 15.1665 16.4284 15.4431 15.9361 15.9353C15.4438 16.4276 15.1672 17.0953 15.1672 17.7915V21.1454C15.1672 21.8416 15.4438 22.5092 15.9361 23.0015C16.4284 23.4938 17.096 23.7704 17.7922 23.7704H21.1461C21.8423 23.7704 22.51 23.4938 23.0023 23.0015C23.4946 22.5092 23.7711 21.8416 23.7711 21.1454V17.7915C23.7711 17.0953 23.4946 16.4276 23.0023 15.9353C22.51 15.4431 21.8423 15.1665 21.1461 15.1665Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$G; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-menu-outlined",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$F = "/*!@:host*/.sc-swirl-icon-message-h{display:inline-flex}";

class SwirlIconMessage {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66668 9.33334H8.68334C8.87223 9.33334 9.02779 9.26934 9.15001 9.14134C9.27223 9.01378 9.33334 8.85556 9.33334 8.66667C9.33334 8.47778 9.26957 8.31934 9.14201 8.19134C9.01401 8.06378 8.85557 8 8.66668 8H4.65001C4.46112 8 4.30557 8.06378 4.18334 8.19134C4.06112 8.31934 4.00001 8.47778 4.00001 8.66667C4.00001 8.85556 4.06379 9.01378 4.19134 9.14134C4.31934 9.26934 4.47779 9.33334 4.66668 9.33334ZM4.66668 7.33334H11.35C11.5389 7.33334 11.6945 7.26934 11.8167 7.14134C11.9389 7.01378 12 6.85556 12 6.66667C12 6.47778 11.936 6.31934 11.808 6.19134C11.6805 6.06378 11.5222 6 11.3333 6H4.65001C4.46112 6 4.30557 6.06378 4.18334 6.19134C4.06112 6.31934 4.00001 6.47778 4.00001 6.66667C4.00001 6.85556 4.06379 7.01378 4.19134 7.14134C4.31934 7.26934 4.47779 7.33334 4.66668 7.33334ZM4.66668 5.33334H11.35C11.5389 5.33334 11.6945 5.26956 11.8167 5.142C11.9389 5.014 12 4.85556 12 4.66667C12 4.47778 11.936 4.31934 11.808 4.19134C11.6805 4.06378 11.5222 4 11.3333 4H4.65001C4.46112 4 4.30557 4.06378 4.18334 4.19134C4.06112 4.31934 4.00001 4.47778 4.00001 4.66667C4.00001 4.85556 4.06379 5.014 4.19134 5.142C4.31934 5.26956 4.47779 5.33334 4.66668 5.33334ZM1.33334 13.05V2.66667C1.33334 2.3 1.46401 1.986 1.72534 1.72467C1.98623 1.46378 2.30001 1.33334 2.66668 1.33334H13.3333C13.7 1.33334 14.014 1.46378 14.2753 1.72467C14.5362 1.986 14.6667 2.3 14.6667 2.66667V10.6667C14.6667 11.0333 14.5362 11.3473 14.2753 11.6087C14.014 11.8696 13.7 12 13.3333 12H4.00001L2.46668 13.5333C2.25557 13.7444 2.01379 13.7916 1.74134 13.6747C1.46934 13.5582 1.33334 13.35 1.33334 13.05Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M7 14H13.025C13.3083 14 13.5417 13.904 13.725 13.712C13.9083 13.5207 14 13.2833 14 13C14 12.7167 13.9043 12.479 13.713 12.287C13.521 12.0957 13.2833 12 13 12H6.975C6.69167 12 6.45833 12.0957 6.275 12.287C6.09167 12.479 6 12.7167 6 13C6 13.2833 6.09567 13.5207 6.287 13.712C6.479 13.904 6.71667 14 7 14ZM7 11H17.025C17.3083 11 17.5417 10.904 17.725 10.712C17.9083 10.5207 18 10.2833 18 10C18 9.71667 17.904 9.479 17.712 9.287C17.5207 9.09567 17.2833 9 17 9H6.975C6.69167 9 6.45833 9.09567 6.275 9.287C6.09167 9.479 6 9.71667 6 10C6 10.2833 6.09567 10.5207 6.287 10.712C6.479 10.904 6.71667 11 7 11ZM7 8H17.025C17.3083 8 17.5417 7.90433 17.725 7.713C17.9083 7.521 18 7.28333 18 7C18 6.71667 17.904 6.479 17.712 6.287C17.5207 6.09567 17.2833 6 17 6H6.975C6.69167 6 6.45833 6.09567 6.275 6.287C6.09167 6.479 6 6.71667 6 7C6 7.28333 6.09567 7.521 6.287 7.713C6.479 7.90433 6.71667 8 7 8ZM2 19.575V4C2 3.45 2.196 2.979 2.588 2.587C2.97933 2.19567 3.45 2 4 2H20C20.55 2 21.021 2.19567 21.413 2.587C21.8043 2.979 22 3.45 22 4V16C22 16.55 21.8043 17.021 21.413 17.413C21.021 17.8043 20.55 18 20 18H6L3.7 20.3C3.38333 20.6167 3.02067 20.6873 2.612 20.512C2.204 20.3373 2 20.025 2 19.575Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M8.16668 16.3333H15.1958C15.5264 16.3333 15.7986 16.2213 16.0125 15.9973C16.2264 15.7741 16.3333 15.4972 16.3333 15.1667C16.3333 14.8361 16.2217 14.5588 15.9985 14.3348C15.7745 14.1116 15.4972 14 15.1667 14H8.13751C7.80695 14 7.53473 14.1116 7.32084 14.3348C7.10696 14.5588 7.00001 14.8361 7.00001 15.1667C7.00001 15.4972 7.11162 15.7741 7.33484 15.9973C7.55884 16.2213 7.83612 16.3333 8.16668 16.3333ZM8.16668 12.8333H19.8625C20.1931 12.8333 20.4653 12.7213 20.6792 12.4973C20.8931 12.2741 21 11.9972 21 11.6667C21 11.3361 20.888 11.0588 20.664 10.8348C20.4408 10.6116 20.1639 10.5 19.8333 10.5H8.13751C7.80695 10.5 7.53473 10.6116 7.32084 10.8348C7.10696 11.0588 7.00001 11.3361 7.00001 11.6667C7.00001 11.9972 7.11162 12.2741 7.33484 12.4973C7.55884 12.7213 7.83612 12.8333 8.16668 12.8333ZM8.16668 9.33334H19.8625C20.1931 9.33334 20.4653 9.22172 20.6792 8.9985C20.8931 8.7745 21 8.49722 21 8.16667C21 7.83611 20.888 7.55884 20.664 7.33484C20.4408 7.11161 20.1639 7 19.8333 7H8.13751C7.80695 7 7.53473 7.11161 7.32084 7.33484C7.10696 7.55884 7.00001 7.83611 7.00001 8.16667C7.00001 8.49722 7.11162 8.7745 7.33484 8.9985C7.55884 9.22172 7.83612 9.33334 8.16668 9.33334ZM2.33334 22.8375V4.66667C2.33334 4.025 2.56201 3.4755 3.01934 3.01817C3.4759 2.56161 4.02501 2.33334 4.66668 2.33334H23.3333C23.975 2.33334 24.5245 2.56161 24.9818 3.01817C25.4384 3.4755 25.6667 4.025 25.6667 4.66667V18.6667C25.6667 19.3083 25.4384 19.8578 24.9818 20.3152C24.5245 20.7717 23.975 21 23.3333 21H7.00001L4.31668 23.6833C3.94723 24.0528 3.52412 24.1352 3.04734 23.9307C2.57134 23.7269 2.33334 23.3625 2.33334 22.8375Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$F; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-message",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$E = "/*!@:host*/.sc-swirl-icon-more-horizontal-h{display:inline-flex}";

class SwirlIconMoreHorizontal {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.88334 9.39998C3.49445 9.39998 3.164 9.26109 2.892 8.98331C2.61956 8.70553 2.48334 8.37775 2.48334 7.99998C2.48334 7.61109 2.61956 7.28042 2.892 7.00798C3.164 6.73598 3.49445 6.59998 3.88334 6.59998C4.26112 6.59998 4.58623 6.73598 4.85867 7.00798C5.13067 7.28042 5.26667 7.61109 5.26667 7.99998C5.26667 8.37775 5.13067 8.70553 4.85867 8.98331C4.58623 9.26109 4.26112 9.39998 3.88334 9.39998ZM8 9.39998C7.62223 9.39998 7.29445 9.26109 7.01667 8.98331C6.73889 8.70553 6.6 8.37775 6.6 7.99998C6.6 7.61109 6.73889 7.28042 7.01667 7.00798C7.29445 6.73598 7.62223 6.59998 8 6.59998C8.38889 6.59998 8.71956 6.73598 8.992 7.00798C9.264 7.28042 9.4 7.61109 9.4 7.99998C9.4 8.37775 9.264 8.70553 8.992 8.98331C8.71956 9.26109 8.38889 9.39998 8 9.39998ZM12.1167 9.39998C11.7389 9.39998 11.4138 9.26109 11.1413 8.98331C10.8693 8.70553 10.7333 8.37775 10.7333 7.99998C10.7333 7.61109 10.8693 7.28042 11.1413 7.00798C11.4138 6.73598 11.7389 6.59998 12.1167 6.59998C12.5056 6.59998 12.8362 6.73598 13.1087 7.00798C13.3807 7.28042 13.5167 7.61109 13.5167 7.99998C13.5167 8.37775 13.3807 8.70553 13.1087 8.98331C12.8362 9.26109 12.5056 9.39998 12.1167 9.39998Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5.82501 14.1C5.24167 14.1 4.74601 13.8917 4.33801 13.475C3.92934 13.0584 3.72501 12.5667 3.72501 12C3.72501 11.4167 3.92934 10.9207 4.33801 10.512C4.74601 10.104 5.24167 9.90002 5.82501 9.90002C6.39167 9.90002 6.87934 10.104 7.28801 10.512C7.69601 10.9207 7.90001 11.4167 7.90001 12C7.90001 12.5667 7.69601 13.0584 7.28801 13.475C6.87934 13.8917 6.39167 14.1 5.82501 14.1ZM12 14.1C11.4333 14.1 10.9417 13.8917 10.525 13.475C10.1083 13.0584 9.90001 12.5667 9.90001 12C9.90001 11.4167 10.1083 10.9207 10.525 10.512C10.9417 10.104 11.4333 9.90002 12 9.90002C12.5833 9.90002 13.0793 10.104 13.488 10.512C13.896 10.9207 14.1 11.4167 14.1 12C14.1 12.5667 13.896 13.0584 13.488 13.475C13.0793 13.8917 12.5833 14.1 12 14.1ZM18.175 14.1C17.6083 14.1 17.1207 13.8917 16.712 13.475C16.304 13.0584 16.1 12.5667 16.1 12C16.1 11.4167 16.304 10.9207 16.712 10.512C17.1207 10.104 17.6083 9.90002 18.175 9.90002C18.7583 9.90002 19.2543 10.104 19.663 10.512C20.071 10.9207 20.275 11.4167 20.275 12C20.275 12.5667 20.071 13.0584 19.663 13.475C19.2543 13.8917 18.7583 14.1 18.175 14.1Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M6.79583 16.45C6.11527 16.45 5.53699 16.2069 5.06099 15.7208C4.58421 15.2347 4.34583 14.6611 4.34583 14C4.34583 13.3194 4.58421 12.7408 5.06099 12.264C5.53699 11.788 6.11527 11.55 6.79583 11.55C7.45694 11.55 8.02588 11.788 8.50266 12.264C8.97866 12.7408 9.21666 13.3194 9.21666 14C9.21666 14.6611 8.97866 15.2347 8.50266 15.7208C8.02588 16.2069 7.45694 16.45 6.79583 16.45ZM14 16.45C13.3389 16.45 12.7653 16.2069 12.2792 15.7208C11.793 15.2347 11.55 14.6611 11.55 14C11.55 13.3194 11.793 12.7408 12.2792 12.264C12.7653 11.788 13.3389 11.55 14 11.55C14.6805 11.55 15.2592 11.788 15.736 12.264C16.212 12.7408 16.45 13.3194 16.45 14C16.45 14.6611 16.212 15.2347 15.736 15.7208C15.2592 16.2069 14.6805 16.45 14 16.45ZM21.2042 16.45C20.543 16.45 19.9741 16.2069 19.4973 15.7208C19.0213 15.2347 18.7833 14.6611 18.7833 14C18.7833 13.3194 19.0213 12.7408 19.4973 12.264C19.9741 11.788 20.543 11.55 21.2042 11.55C21.8847 11.55 22.4634 11.788 22.9402 12.264C23.4162 12.7408 23.6542 13.3194 23.6542 14C23.6542 14.6611 23.4162 15.2347 22.9402 15.7208C22.4634 16.2069 21.8847 16.45 21.2042 16.45Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$E; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-more-horizontal",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$D = "/*!@:host*/.sc-swirl-icon-more-vertikal-h{display:inline-flex}";

class SwirlIconMoreVertikal {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.00001 13.5167C7.62223 13.5167 7.29445 13.3807 7.01667 13.1087C6.73889 12.8362 6.60001 12.5056 6.60001 12.1167C6.60001 11.7389 6.73889 11.4138 7.01667 11.1413C7.29445 10.8693 7.62223 10.7333 8.00001 10.7333C8.3889 10.7333 8.71956 10.8693 8.99201 11.1413C9.26401 11.4138 9.40001 11.7389 9.40001 12.1167C9.40001 12.5056 9.26401 12.8362 8.99201 13.1087C8.71956 13.3807 8.3889 13.5167 8.00001 13.5167ZM8.00001 9.4C7.62223 9.4 7.29445 9.26112 7.01667 8.98334C6.73889 8.70556 6.60001 8.37778 6.60001 8C6.60001 7.61112 6.73889 7.28045 7.01667 7.008C7.29445 6.736 7.62223 6.6 8.00001 6.6C8.3889 6.6 8.71956 6.736 8.99201 7.008C9.26401 7.28045 9.40001 7.61112 9.40001 8C9.40001 8.37778 9.26401 8.70556 8.99201 8.98334C8.71956 9.26112 8.3889 9.4 8.00001 9.4V9.4ZM8.00001 5.26667C7.62223 5.26667 7.29445 5.13045 7.01667 4.858C6.73889 4.586 6.60001 4.26112 6.60001 3.88334C6.60001 3.49445 6.73889 3.16378 7.01667 2.89134C7.29445 2.61934 7.62223 2.48334 8.00001 2.48334C8.3889 2.48334 8.71956 2.61934 8.99201 2.89134C9.26401 3.16378 9.40001 3.49445 9.40001 3.88334C9.40001 4.26112 9.26401 4.586 8.99201 4.858C8.71956 5.13045 8.3889 5.26667 8.00001 5.26667V5.26667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 20.275C11.4333 20.275 10.9417 20.071 10.525 19.663C10.1083 19.2543 9.89999 18.7583 9.89999 18.175C9.89999 17.6083 10.1083 17.1206 10.525 16.712C10.9417 16.304 11.4333 16.1 12 16.1C12.5833 16.1 13.0793 16.304 13.488 16.712C13.896 17.1206 14.1 17.6083 14.1 18.175C14.1 18.7583 13.896 19.2543 13.488 19.663C13.0793 20.071 12.5833 20.275 12 20.275ZM12 14.1C11.4333 14.1 10.9417 13.8916 10.525 13.475C10.1083 13.0583 9.89999 12.5666 9.89999 12C9.89999 11.4166 10.1083 10.9206 10.525 10.512C10.9417 10.104 11.4333 9.89998 12 9.89998C12.5833 9.89998 13.0793 10.104 13.488 10.512C13.896 10.9206 14.1 11.4166 14.1 12C14.1 12.5666 13.896 13.0583 13.488 13.475C13.0793 13.8916 12.5833 14.1 12 14.1ZM12 7.89998C11.4333 7.89998 10.9417 7.69564 10.525 7.28698C10.1083 6.87898 9.89999 6.39164 9.89999 5.82498C9.89999 5.24164 10.1083 4.74564 10.525 4.33698C10.9417 3.92898 11.4333 3.72498 12 3.72498C12.5833 3.72498 13.0793 3.92898 13.488 4.33698C13.896 4.74564 14.1 5.24164 14.1 5.82498C14.1 6.39164 13.896 6.87898 13.488 7.28698C13.0793 7.69564 12.5833 7.89998 12 7.89998Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 23.6542C13.3389 23.6542 12.7653 23.4162 12.2792 22.9402C11.793 22.4634 11.55 21.8847 11.55 21.2042C11.55 20.543 11.793 19.9741 12.2792 19.4973C12.7653 19.0213 13.3389 18.7833 14 18.7833C14.6805 18.7833 15.2592 19.0213 15.736 19.4973C16.212 19.9741 16.45 20.543 16.45 21.2042C16.45 21.8847 16.212 22.4634 15.736 22.9402C15.2592 23.4162 14.6805 23.6542 14 23.6542ZM14 16.45C13.3389 16.45 12.7653 16.2069 12.2792 15.7208C11.793 15.2347 11.55 14.6611 11.55 14C11.55 13.3194 11.793 12.7408 12.2792 12.264C12.7653 11.788 13.3389 11.55 14 11.55C14.6805 11.55 15.2592 11.788 15.736 12.264C16.212 12.7408 16.45 13.3194 16.45 14C16.45 14.6611 16.212 15.2347 15.736 15.7208C15.2592 16.2069 14.6805 16.45 14 16.45V16.45ZM14 9.21666C13.3389 9.21666 12.7653 8.97827 12.2792 8.50149C11.793 8.02549 11.55 7.45694 11.55 6.79583C11.55 6.11527 11.793 5.5366 12.2792 5.05983C12.7653 4.58383 13.3389 4.34583 14 4.34583C14.6805 4.34583 15.2592 4.58383 15.736 5.05983C16.212 5.5366 16.45 6.11527 16.45 6.79583C16.45 7.45694 16.212 8.02549 15.736 8.50149C15.2592 8.97827 14.6805 9.21666 14 9.21666V9.21666Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$D; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-more-vertikal",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$C = "/*!@:host*/.sc-swirl-icon-news-filled-h{display:inline-flex}";

class SwirlIconNewsFilled {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M11.5 2H4.5C3.83696 2 3.20107 2.26339 2.73223 2.73223C2.26339 3.20107 2 3.83696 2 4.5V11.5C2 12.163 2.26339 12.7989 2.73223 13.2678C3.20107 13.7366 3.83696 14 4.5 14H11.5C12.163 14 12.7989 13.7366 13.2678 13.2678C13.7366 12.7989 14 12.163 14 11.5V4.5C14 3.83696 13.7366 3.20107 13.2678 2.73223C12.7989 2.26339 12.163 2 11.5 2V2ZM4.835 3.835C5.0652 3.83599 5.28995 3.90515 5.48087 4.03376C5.6718 4.16237 5.82034 4.34467 5.90775 4.55763C5.99516 4.77059 6.01752 5.00467 5.972 5.23033C5.92649 5.45599 5.81514 5.6631 5.65201 5.82553C5.48889 5.98796 5.2813 6.09842 5.05545 6.14297C4.8296 6.18752 4.59561 6.16415 4.38303 6.07583C4.17044 5.98751 3.98879 5.83819 3.861 5.64672C3.7332 5.45524 3.665 5.2302 3.665 5C3.665 4.84659 3.6953 4.69469 3.75416 4.55302C3.81302 4.41134 3.89928 4.28269 4.00799 4.17445C4.1167 4.0662 4.24572 3.98049 4.38764 3.92224C4.52956 3.86399 4.68159 3.83434 4.835 3.835ZM12.335 11.365C12.335 11.4924 12.3099 11.6185 12.2612 11.7362C12.2124 11.8539 12.141 11.9608 12.0509 12.0509C11.9608 12.141 11.8539 12.2124 11.7362 12.2612C11.6185 12.3099 11.4924 12.335 11.365 12.335H4.635C4.50762 12.335 4.38148 12.3099 4.2638 12.2612C4.14611 12.2124 4.03918 12.141 3.94911 12.0509C3.85903 11.9608 3.78758 11.8539 3.73884 11.7362C3.69009 11.6185 3.665 11.4924 3.665 11.365V8.3C3.665 8.04274 3.7672 7.79602 3.94911 7.61411C4.13102 7.4322 4.37774 7.33 4.635 7.33H11.365C11.4924 7.33 11.6185 7.35509 11.7362 7.40384C11.8539 7.45258 11.9608 7.52403 12.0509 7.61411C12.141 7.70418 12.2124 7.81111 12.2612 7.9288C12.3099 8.04648 12.335 8.17262 12.335 8.3V11.365ZM11.75 5.585H7.915C7.75985 5.585 7.61105 5.52337 7.50134 5.41366C7.39163 5.30395 7.33 5.15515 7.33 5C7.33 4.84485 7.39163 4.69605 7.50134 4.58634C7.61105 4.47663 7.75985 4.415 7.915 4.415H11.75C11.9052 4.415 12.0539 4.47663 12.1637 4.58634C12.2734 4.69605 12.335 4.84485 12.335 5C12.335 5.15515 12.2734 5.30395 12.1637 5.41366C12.0539 5.52337 11.9052 5.585 11.75 5.585V5.585Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M17.25 3H6.75C5.75544 3 4.80161 3.39509 4.09835 4.09835C3.39509 4.80161 3 5.75544 3 6.75V17.25C3 18.2446 3.39509 19.1984 4.09835 19.9017C4.80161 20.6049 5.75544 21 6.75 21H17.25C18.2446 21 19.1984 20.6049 19.9017 19.9017C20.6049 19.1984 21 18.2446 21 17.25V6.75C21 5.75544 20.6049 4.80161 19.9017 4.09835C19.1984 3.39509 18.2446 3 17.25 3V3ZM7.2525 5.7525C7.5978 5.75398 7.93492 5.85773 8.22131 6.05065C8.50769 6.24356 8.73051 6.517 8.86162 6.83644C8.99274 7.15588 9.02628 7.50701 8.958 7.84549C8.88973 8.18398 8.72271 8.49465 8.47802 8.7383C8.23333 8.98194 7.92195 9.14763 7.58317 9.21445C7.2444 9.28127 6.89342 9.24623 6.57454 9.11375C6.25566 8.98127 5.98318 8.75729 5.79149 8.47007C5.59981 8.18286 5.4975 7.8453 5.4975 7.5C5.4975 7.26988 5.54295 7.04203 5.63123 6.82952C5.71952 6.61702 5.84891 6.42404 6.01198 6.26167C6.17505 6.0993 6.36857 5.97074 6.58146 5.88336C6.79434 5.79598 7.02238 5.75151 7.2525 5.7525ZM18.5025 17.0475C18.5025 17.2386 18.4649 17.4278 18.3917 17.6043C18.3186 17.7808 18.2114 17.9412 18.0763 18.0763C17.9412 18.2114 17.7808 18.3186 17.6043 18.3917C17.4278 18.4649 17.2386 18.5025 17.0475 18.5025H6.9525C6.76143 18.5025 6.57222 18.4649 6.3957 18.3917C6.21917 18.3186 6.05877 18.2114 5.92366 18.0763C5.78855 17.9412 5.68138 17.7808 5.60826 17.6043C5.53513 17.4278 5.4975 17.2386 5.4975 17.0475V12.45C5.4975 12.0641 5.65079 11.694 5.92366 11.4212C6.19653 11.1483 6.56661 10.995 6.9525 10.995H17.0475C17.2386 10.995 17.4278 11.0326 17.6043 11.1058C17.7808 11.1789 17.9412 11.2861 18.0763 11.4212C18.2114 11.5563 18.3186 11.7167 18.3917 11.8932C18.4649 12.0697 18.5025 12.2589 18.5025 12.45V17.0475ZM17.625 8.3775H11.8725C11.6398 8.3775 11.4166 8.28505 11.252 8.12049C11.0875 7.95592 10.995 7.73273 10.995 7.5C10.995 7.26727 11.0875 7.04408 11.252 6.87951C11.4166 6.71495 11.6398 6.6225 11.8725 6.6225H17.625C17.8577 6.6225 18.0809 6.71495 18.2455 6.87951C18.41 7.04408 18.5025 7.26727 18.5025 7.5C18.5025 7.73273 18.41 7.95592 18.2455 8.12049C18.0809 8.28505 17.8577 8.3775 17.625 8.3775V8.3775Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M20.125 3.5H7.875C6.71468 3.5 5.60188 3.96094 4.78141 4.78141C3.96094 5.60188 3.5 6.71468 3.5 7.875V20.125C3.5 21.2853 3.96094 22.3981 4.78141 23.2186C5.60188 24.0391 6.71468 24.5 7.875 24.5H20.125C21.2853 24.5 22.3981 24.0391 23.2186 23.2186C24.0391 22.3981 24.5 21.2853 24.5 20.125V7.875C24.5 6.71468 24.0391 5.60188 23.2186 4.78141C22.3981 3.96094 21.2853 3.5 20.125 3.5V3.5ZM8.46125 6.71125C8.8641 6.71298 9.25741 6.83402 9.59152 7.05909C9.92564 7.28416 10.1856 7.60317 10.3386 7.97585C10.4915 8.34853 10.5307 8.75818 10.451 9.15308C10.3714 9.54798 10.1765 9.91043 9.89102 10.1947C9.60555 10.4789 9.24227 10.6722 8.84703 10.7502C8.4518 10.8282 8.04232 10.7873 7.6703 10.6327C7.29827 10.4781 6.98038 10.2168 6.75674 9.88175C6.53311 9.54668 6.41375 9.15285 6.41375 8.75C6.41375 8.48153 6.46677 8.2157 6.56977 7.96778C6.67278 7.71985 6.82373 7.49471 7.01398 7.30528C7.20422 7.11585 7.43 6.96586 7.67837 6.86392C7.92673 6.76198 8.19278 6.7101 8.46125 6.71125ZM21.5863 19.8887C21.5863 20.1117 21.5423 20.3324 21.457 20.5384C21.3717 20.7443 21.2467 20.9314 21.0891 21.0891C20.9314 21.2467 20.7443 21.3717 20.5384 21.457C20.3324 21.5423 20.1117 21.5863 19.8887 21.5863H8.11125C7.88833 21.5863 7.6676 21.5423 7.46165 21.457C7.2557 21.3717 7.06856 21.2467 6.91094 21.0891C6.75331 20.9314 6.62827 20.7443 6.54296 20.5384C6.45766 20.3324 6.41375 20.1117 6.41375 19.8887V14.525C6.41375 14.0748 6.59259 13.643 6.91094 13.3247C7.22928 13.0063 7.66105 12.8275 8.11125 12.8275H19.8887C20.1117 12.8275 20.3324 12.8714 20.5384 12.9567C20.7443 13.042 20.9314 13.1671 21.0891 13.3247C21.2467 13.4823 21.3717 13.6694 21.457 13.8754C21.5423 14.0813 21.5863 14.3021 21.5863 14.525V19.8887ZM20.5625 9.77375H13.8512C13.5797 9.77375 13.3193 9.66589 13.1273 9.4739C12.9354 9.28191 12.8275 9.02152 12.8275 8.75C12.8275 8.47848 12.9354 8.21809 13.1273 8.0261C13.3193 7.83411 13.5797 7.72625 13.8512 7.72625H20.5625C20.834 7.72625 21.0944 7.83411 21.2864 8.0261C21.4784 8.21809 21.5863 8.47848 21.5863 8.75C21.5863 9.02152 21.4784 9.28191 21.2864 9.4739C21.0944 9.66589 20.834 9.77375 20.5625 9.77375V9.77375Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$C; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-news-filled",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$B = "/*!@:host*/.sc-swirl-icon-news-outlined-h{display:inline-flex}";

class SwirlIconNewsOutlined {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M11.5 2H4.5C3.83696 2 3.20107 2.26339 2.73223 2.73223C2.26339 3.20107 2 3.83696 2 4.5V11.5C2 12.163 2.26339 12.7989 2.73223 13.2678C3.20107 13.7366 3.83696 14 4.5 14H11.5C12.163 14 12.7989 13.7366 13.2678 13.2678C13.7366 12.7989 14 12.163 14 11.5V4.5C14 3.83696 13.7366 3.20107 13.2678 2.73223C12.7989 2.26339 12.163 2 11.5 2ZM4.5 3H11.5C11.8978 3 12.2794 3.15804 12.5607 3.43934C12.842 3.72064 13 4.10218 13 4.5V7.34H3V4.5C3 4.10218 3.15804 3.72064 3.43934 3.43934C3.72064 3.15804 4.10218 3 4.5 3ZM11.5 13H4.5C4.10218 13 3.72064 12.842 3.43934 12.5607C3.15804 12.2794 3 11.8978 3 11.5V8.34H13V11.5C13 11.8978 12.842 12.2794 12.5607 12.5607C12.2794 12.842 11.8978 13 11.5 13Z", fill: "currentColor" }), hAsync("path", { d: "M5.17 4H5.165C4.52159 4 4 4.52159 4 5.165V5.17C4 5.81341 4.52159 6.335 5.165 6.335H5.17C5.81341 6.335 6.335 5.81341 6.335 5.17V5.165C6.335 4.52159 5.81341 4 5.17 4Z", fill: "currentColor" }), hAsync("path", { d: "M11.325 4.49H8.01C7.63721 4.49 7.335 4.79221 7.335 5.165V5.17C7.335 5.54279 7.63721 5.845 8.01 5.845H11.325C11.6978 5.845 12 5.54279 12 5.17V5.165C12 4.79221 11.6978 4.49 11.325 4.49Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M17.25 3H6.75C5.75544 3 4.80161 3.39509 4.09835 4.09835C3.39509 4.80161 3 5.75544 3 6.75V17.25C3 18.2446 3.39509 19.1984 4.09835 19.9017C4.80161 20.6049 5.75544 21 6.75 21H17.25C18.2446 21 19.1984 20.6049 19.9017 19.9017C20.6049 19.1984 21 18.2446 21 17.25V6.75C21 5.75544 20.6049 4.80161 19.9017 4.09835C19.1984 3.39509 18.2446 3 17.25 3ZM6.75 4.5H17.25C17.8467 4.5 18.419 4.73705 18.841 5.15901C19.2629 5.58097 19.5 6.15326 19.5 6.75V11.01H4.5V6.75C4.5 6.15326 4.73705 5.58097 5.15901 5.15901C5.58097 4.73705 6.15326 4.5 6.75 4.5ZM17.25 19.5H6.75C6.15326 19.5 5.58097 19.2629 5.15901 18.841C4.73705 18.419 4.5 17.8467 4.5 17.25V12.51H19.5V17.25C19.5 17.8467 19.2629 18.419 18.841 18.841C18.419 19.2629 17.8467 19.5 17.25 19.5Z", fill: "currentColor" }), hAsync("path", { d: "M7.755 6H7.7475C6.78238 6 6 6.78238 6 7.7475V7.755C6 8.72012 6.78238 9.5025 7.7475 9.5025H7.755C8.72012 9.5025 9.5025 8.72012 9.5025 7.755V7.7475C9.5025 6.78238 8.72012 6 7.755 6Z", fill: "currentColor" }), hAsync("path", { d: "M16.9875 6.735H12.015C11.4558 6.735 11.0025 7.18831 11.0025 7.7475V7.755C11.0025 8.31419 11.4558 8.7675 12.015 8.7675H16.9875C17.5467 8.7675 18 8.31419 18 7.755V7.7475C18 7.18831 17.5467 6.735 16.9875 6.735Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M20.125 3.5H7.875C6.71468 3.5 5.60188 3.96094 4.78141 4.78141C3.96094 5.60188 3.5 6.71468 3.5 7.875V20.125C3.5 21.2853 3.96094 22.3981 4.78141 23.2186C5.60188 24.0391 6.71468 24.5 7.875 24.5H20.125C21.2853 24.5 22.3981 24.0391 23.2186 23.2186C24.0391 22.3981 24.5 21.2853 24.5 20.125V7.875C24.5 6.71468 24.0391 5.60188 23.2186 4.78141C22.3981 3.96094 21.2853 3.5 20.125 3.5ZM7.875 5.25H20.125C20.8212 5.25 21.4889 5.52656 21.9812 6.01884C22.4734 6.51113 22.75 7.17881 22.75 7.875V12.845H5.25V7.875C5.25 7.17881 5.52656 6.51113 6.01884 6.01884C6.51113 5.52656 7.17881 5.25 7.875 5.25ZM20.125 22.75H7.875C7.17881 22.75 6.51113 22.4734 6.01884 21.9812C5.52656 21.4889 5.25 20.8212 5.25 20.125V14.595H22.75V20.125C22.75 20.8212 22.4734 21.4889 21.9812 21.9812C21.4889 22.4734 20.8212 22.75 20.125 22.75Z", fill: "currentColor" }), hAsync("path", { d: "M9.0475 7H9.03875C7.91278 7 7 7.91278 7 9.03875V9.0475C7 10.1735 7.91278 11.0863 9.03875 11.0863H9.0475C10.1735 11.0863 11.0863 10.1735 11.0863 9.0475V9.03875C11.0863 7.91278 10.1735 7 9.0475 7Z", fill: "currentColor" }), hAsync("path", { d: "M19.8187 7.8575H14.0175C13.3651 7.8575 12.8363 8.38636 12.8363 9.03875V9.0475C12.8363 9.69989 13.3651 10.2287 14.0175 10.2287H19.8187C20.4711 10.2287 21 9.69989 21 9.0475V9.03875C21 8.38636 20.4711 7.8575 19.8187 7.8575Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$B; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-news-outlined",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$A = "/*!@:host*/.sc-swirl-icon-notifications-h{display:inline-flex}";

class SwirlIconNotifications {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8.00083 14.5C8.73416 14.5 9.33416 13.9 9.33416 13.1667H6.66749C6.66749 13.9 7.26083 14.5 8.00083 14.5ZM12.0008 10.5V7.16667C12.0008 5.12 10.9075 3.40667 9.00083 2.95333V2.5C9.00083 1.94667 8.55416 1.5 8.00083 1.5C7.44749 1.5 7.00083 1.94667 7.00083 2.5V2.95333C5.08749 3.40667 4.00083 5.11333 4.00083 7.16667V10.5L3.14083 11.36C2.72083 11.78 3.01416 12.5 3.60749 12.5H12.3875C12.9808 12.5 13.2808 11.78 12.8608 11.36L12.0008 10.5Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12.0012 21.75C13.1012 21.75 14.0012 20.85 14.0012 19.75H10.0012C10.0012 20.85 10.8912 21.75 12.0012 21.75ZM18.0012 15.75V10.75C18.0012 7.68 16.3612 5.11 13.5012 4.43V3.75C13.5012 2.92 12.8312 2.25 12.0012 2.25C11.1712 2.25 10.5012 2.92 10.5012 3.75V4.43C7.63124 5.11 6.00124 7.67 6.00124 10.75V15.75L4.71124 17.04C4.08124 17.67 4.52124 18.75 5.41124 18.75H18.5812C19.4712 18.75 19.9212 17.67 19.2912 17.04L18.0012 15.75Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14.0014 25.375C15.2848 25.375 16.3348 24.325 16.3348 23.0417H11.6681C11.6681 24.325 12.7064 25.375 14.0014 25.375ZM21.0014 18.375V12.5417C21.0014 8.96 19.0881 5.96167 15.7514 5.16833V4.375C15.7514 3.40667 14.9698 2.625 14.0014 2.625C13.0331 2.625 12.2514 3.40667 12.2514 4.375V5.16833C8.9031 5.96167 7.00143 8.94833 7.00143 12.5417V18.375L5.49643 19.88C4.76143 20.615 5.27477 21.875 6.3131 21.875H21.6781C22.7164 21.875 23.2414 20.615 22.5064 19.88L21.0014 18.375Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$A; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-notifications",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$z = "/*!@:host*/.sc-swirl-icon-notifications-active-h{display:inline-flex}";

class SwirlIconNotificationsActive {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.0026 10.5V7.16667C12.0026 5.12 10.9093 3.40667 9.00262 2.95333V2.5C9.00262 1.94667 8.54929 1.5 7.99595 1.5C7.44262 1.5 7.00262 1.94667 7.00262 2.5V2.95333C5.08929 3.40667 4.00262 5.11333 4.00262 7.16667V10.5L3.13595 11.36C2.71595 11.78 3.00929 12.5 3.60262 12.5H12.3826C12.976 12.5 13.276 11.78 12.856 11.36L12.0026 10.5ZM7.99595 14.5C8.72929 14.5 9.32929 13.9 9.32929 13.1667H6.66262C6.66262 13.9 7.25595 14.5 7.99595 14.5ZM4.51595 2.98667C4.79595 2.73333 4.80262 2.3 4.53595 2.03333C4.28262 1.78 3.86929 1.77333 3.60929 2.02C2.46929 3.06 1.68262 4.47333 1.42929 6.06C1.36929 6.46667 1.68262 6.83333 2.09595 6.83333C2.41595 6.83333 2.69595 6.6 2.74929 6.28C2.94929 4.98667 3.58929 3.83333 4.51595 2.98667ZM12.4026 2.02C12.136 1.77333 11.7226 1.78 11.4693 2.03333C11.2026 2.3 11.216 2.72667 11.4893 2.98C12.4093 3.82667 13.056 4.98 13.256 6.27333C13.3026 6.59333 13.5826 6.82667 13.9093 6.82667C14.316 6.82667 14.636 6.46 14.5693 6.05333C14.316 4.47333 13.536 3.06667 12.4026 2.02Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M18.0039 15.75V10.75C18.0039 7.68 16.3639 5.11 13.5039 4.43V3.75C13.5039 2.92 12.8239 2.25 11.9939 2.25C11.1639 2.25 10.5039 2.92 10.5039 3.75V4.43C7.63391 5.11 6.00391 7.67 6.00391 10.75V15.75L4.70391 17.04C4.07391 17.67 4.51391 18.75 5.40391 18.75H18.5739C19.4639 18.75 19.9139 17.67 19.2839 17.04L18.0039 15.75ZM11.9939 21.75C13.0939 21.75 13.9939 20.85 13.9939 19.75H9.99391C9.99391 20.85 10.8839 21.75 11.9939 21.75ZM6.77391 4.48C7.19391 4.1 7.20391 3.45 6.80391 3.05C6.42391 2.67 5.80391 2.66 5.41391 3.03C3.70391 4.59 2.52391 6.71 2.14391 9.09C2.05391 9.7 2.52391 10.25 3.14391 10.25C3.62391 10.25 4.04391 9.9 4.12391 9.42C4.42391 7.48 5.38391 5.75 6.77391 4.48ZM18.6039 3.03C18.2039 2.66 17.5839 2.67 17.2039 3.05C16.8039 3.45 16.8239 4.09 17.2339 4.47C18.6139 5.74 19.5839 7.47 19.8839 9.41C19.9539 9.89 20.3739 10.24 20.8639 10.24C21.4739 10.24 21.9539 9.69 21.8539 9.08C21.4739 6.71 20.3039 4.6 18.6039 3.03Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M21.0046 18.375V12.5417C21.0046 8.96 19.0912 5.96167 15.7546 5.16833V4.375C15.7546 3.40667 14.9612 2.625 13.9929 2.625C13.0246 2.625 12.2546 3.40667 12.2546 4.375V5.16833C8.90623 5.96167 7.00456 8.94833 7.00456 12.5417V18.375L5.48789 19.88C4.75289 20.615 5.26623 21.875 6.30456 21.875H21.6696C22.7079 21.875 23.2329 20.615 22.4979 19.88L21.0046 18.375ZM13.9929 25.375C15.2762 25.375 16.3262 24.325 16.3262 23.0417H11.6596C11.6596 24.325 12.6979 25.375 13.9929 25.375ZM7.90289 5.22667C8.39289 4.78333 8.40456 4.025 7.93789 3.55833C7.49456 3.115 6.77123 3.10333 6.31623 3.535C4.32123 5.355 2.94456 7.82833 2.50123 10.605C2.39623 11.3167 2.94456 11.9583 3.66789 11.9583C4.22789 11.9583 4.71789 11.55 4.81123 10.99C5.16123 8.72667 6.28123 6.70833 7.90289 5.22667ZM21.7046 3.535C21.2379 3.10333 20.5146 3.115 20.0712 3.55833C19.6046 4.025 19.6279 4.77167 20.1062 5.215C21.7162 6.69667 22.8479 8.715 23.1979 10.9783C23.2796 11.5383 23.7696 11.9467 24.3412 11.9467C25.0529 11.9467 25.6129 11.305 25.4962 10.5933C25.0529 7.82833 23.6879 5.36667 21.7046 3.535Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$z; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-notifications-active",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$y = "/*!@:host*/.sc-swirl-icon-notifications-off-h{display:inline-flex}";

class SwirlIconNotificationsOff {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.53667 14.5C8.27001 14.5 8.87001 13.9 8.87001 13.1667H6.20334C6.20334 13.9 6.79667 14.5 7.53667 14.5ZM11.5367 7.16667C11.5367 5.12 10.4433 3.40667 8.53667 2.95333V2.5C8.53667 1.94667 8.09001 1.5 7.53667 1.5C6.98334 1.5 6.53667 1.94667 6.53667 2.5V2.95333C6.37667 2.99333 6.22334 3.05333 6.07667 3.10667L11.5367 8.56667V7.16667ZM3.14334 2.06667L2.20334 3.00667L4.07667 4.88C3.73001 5.54667 3.53667 6.32 3.53667 7.16667V10.5L2.67667 11.36C2.25667 11.78 2.55001 12.5 3.14334 12.5H11.6967L12.8567 13.66L13.7967 12.72L3.14334 2.06667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M11.305 21.75C12.405 21.75 13.305 20.85 13.305 19.75H9.30499C9.30499 20.85 10.195 21.75 11.305 21.75ZM17.305 10.75C17.305 7.68 15.665 5.11 12.805 4.43V3.75C12.805 2.92 12.135 2.25 11.305 2.25C10.475 2.25 9.80499 2.92 9.80499 3.75V4.43C9.56499 4.49 9.33499 4.58 9.11499 4.66L17.305 12.85V10.75ZM4.71499 3.1L3.30499 4.51L6.11499 7.32C5.59499 8.32 5.30499 9.48 5.30499 10.75V15.75L4.01499 17.04C3.38499 17.67 3.82499 18.75 4.71499 18.75H17.545L19.285 20.49L20.695 19.08L4.71499 3.1Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M13.1892 25.375C14.4725 25.375 15.5225 24.325 15.5225 23.0417H10.8558C10.8558 24.325 11.8942 25.375 13.1892 25.375ZM20.1892 12.5417C20.1892 8.96 18.2758 5.96167 14.9392 5.16833V4.375C14.9392 3.40667 14.1575 2.625 13.1892 2.625C12.2208 2.625 11.4392 3.40667 11.4392 4.375V5.16833C11.1592 5.23833 10.8908 5.34333 10.6342 5.43667L20.1892 14.9917V12.5417ZM5.50083 3.61667L3.85583 5.26167L7.13417 8.54C6.5275 9.70667 6.18917 11.06 6.18917 12.5417V18.375L4.68417 19.88C3.94917 20.615 4.4625 21.875 5.50083 21.875H20.4692L22.4992 23.905L24.1442 22.26L5.50083 3.61667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$y; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-notifications-off",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$x = "/*!@:host*/.sc-swirl-icon-open-in-new-h{display:inline-flex}";

class SwirlIconOpenInNew {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.38334 14.1334C2.96111 14.1334 2.60289 13.9863 2.30867 13.692C2.014 13.3974 1.86667 13.0389 1.86667 12.6167V3.38337C1.86667 2.96114 2.014 2.6027 2.30867 2.30803C2.60289 2.01381 2.96111 1.8667 3.38334 1.8667H7.23334C7.45556 1.8667 7.63889 1.93892 7.78334 2.08337C7.92778 2.22781 8 2.40559 8 2.6167C8 2.83892 7.92778 3.02225 7.78334 3.1667C7.63889 3.31114 7.45556 3.38337 7.23334 3.38337H3.38334V12.6167H12.6167V8.7667C12.6167 8.54448 12.6889 8.36114 12.8333 8.2167C12.9778 8.07225 13.1611 8.00003 13.3833 8.00003C13.5944 8.00003 13.7722 8.07225 13.9167 8.2167C14.0611 8.36114 14.1333 8.54448 14.1333 8.7667V12.6167C14.1333 13.0389 13.9862 13.3974 13.692 13.692C13.3973 13.9863 13.0389 14.1334 12.6167 14.1334H3.38334ZM6.06667 9.93337C5.92222 9.80003 5.85 9.62781 5.85 9.4167C5.85 9.20559 5.92222 9.02781 6.06667 8.88337L11.5667 3.38337H10.1C9.87778 3.38337 9.69445 3.31114 9.55 3.1667C9.40556 3.02225 9.33333 2.83892 9.33333 2.6167C9.33333 2.40559 9.40556 2.22781 9.55 2.08337C9.69445 1.93892 9.87778 1.8667 10.1 1.8667H13.3833C13.5944 1.8667 13.7722 1.93892 13.9167 2.08337C14.0611 2.22781 14.1333 2.40559 14.1333 2.6167V5.90003C14.1333 6.12225 14.0611 6.30559 13.9167 6.45003C13.7722 6.59448 13.5944 6.6667 13.3833 6.6667C13.1611 6.6667 12.9778 6.59448 12.8333 6.45003C12.6889 6.30559 12.6167 6.12225 12.6167 5.90003V4.43337L7.1 9.95003C6.96667 10.0945 6.79733 10.1667 6.592 10.1667C6.38622 10.1667 6.21111 10.0889 6.06667 9.93337Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5.075 21.2001C4.44167 21.2001 3.90433 20.9794 3.463 20.538C3.021 20.096 2.8 19.5584 2.8 18.925V5.07505C2.8 4.44172 3.021 3.90405 3.463 3.46205C3.90433 3.02072 4.44167 2.80005 5.075 2.80005H10.85C11.1833 2.80005 11.4583 2.90838 11.675 3.12505C11.8917 3.34172 12 3.60838 12 3.92505C12 4.25838 11.8917 4.53338 11.675 4.75005C11.4583 4.96672 11.1833 5.07505 10.85 5.07505H5.075V18.925H18.925V13.15C18.925 12.8167 19.0333 12.5417 19.25 12.325C19.4667 12.1084 19.7417 12 20.075 12C20.3917 12 20.6583 12.1084 20.875 12.325C21.0917 12.5417 21.2 12.8167 21.2 13.15V18.925C21.2 19.5584 20.9793 20.096 20.538 20.538C20.096 20.9794 19.5583 21.2001 18.925 21.2001H5.075ZM9.1 14.9C8.88333 14.7 8.775 14.4417 8.775 14.125C8.775 13.8084 8.88333 13.5417 9.1 13.325L17.35 5.07505H15.15C14.8167 5.07505 14.5417 4.96672 14.325 4.75005C14.1083 4.53338 14 4.25838 14 3.92505C14 3.60838 14.1083 3.34172 14.325 3.12505C14.5417 2.90838 14.8167 2.80005 15.15 2.80005H20.075C20.3917 2.80005 20.6583 2.90838 20.875 3.12505C21.0917 3.34172 21.2 3.60838 21.2 3.92505V8.85005C21.2 9.18338 21.0917 9.45838 20.875 9.67505C20.6583 9.89172 20.3917 10 20.075 10C19.7417 10 19.4667 9.89172 19.25 9.67505C19.0333 9.45838 18.925 9.18338 18.925 8.85005V6.65005L10.65 14.925C10.45 15.1417 10.196 15.25 9.888 15.25C9.57933 15.25 9.31667 15.1334 9.1 14.9Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M5.92084 24.7334C5.18195 24.7334 4.55506 24.4759 4.04017 23.9611C3.5245 23.4454 3.26667 22.8181 3.26667 22.0792V5.92089C3.26667 5.182 3.5245 4.55472 4.04017 4.03906C4.55506 3.52417 5.18195 3.26672 5.92084 3.26672H12.6583C13.0472 3.26672 13.3681 3.39311 13.6208 3.64589C13.8736 3.89867 14 4.20978 14 4.57922C14 4.96811 13.8736 5.28895 13.6208 5.54172C13.3681 5.7945 13.0472 5.92089 12.6583 5.92089H5.92084V22.0792H22.0792V15.3417C22.0792 14.9528 22.2056 14.632 22.4583 14.3792C22.7111 14.1264 23.032 14.0001 23.4208 14.0001C23.7903 14.0001 24.1014 14.1264 24.3542 14.3792C24.607 14.632 24.7333 14.9528 24.7333 15.3417V22.0792C24.7333 22.8181 24.4759 23.4454 23.961 23.9611C23.4453 24.4759 22.8181 24.7334 22.0792 24.7334H5.92084ZM10.6167 17.3834C10.3639 17.1501 10.2375 16.8487 10.2375 16.4792C10.2375 16.1098 10.3639 15.7987 10.6167 15.5459L20.2417 5.92089H17.675C17.2861 5.92089 16.9653 5.7945 16.7125 5.54172C16.4597 5.28895 16.3333 4.96811 16.3333 4.57922C16.3333 4.20978 16.4597 3.89867 16.7125 3.64589C16.9653 3.39311 17.2861 3.26672 17.675 3.26672H23.4208C23.7903 3.26672 24.1014 3.39311 24.3542 3.64589C24.607 3.89867 24.7333 4.20978 24.7333 4.57922V10.3251C24.7333 10.7139 24.607 11.0348 24.3542 11.2876C24.1014 11.5403 23.7903 11.6667 23.4208 11.6667C23.032 11.6667 22.7111 11.5403 22.4583 11.2876C22.2056 11.0348 22.0792 10.7139 22.0792 10.3251V7.75839L12.425 17.4126C12.1917 17.6653 11.8953 17.7917 11.536 17.7917C11.1759 17.7917 10.8694 17.6556 10.6167 17.3834Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$x; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-open-in-new",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$w = "/*!@:host*/.sc-swirl-icon-people-alt-h{display:inline-flex}";

class SwirlIconPeopleAlt {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M11.1133 8.75329C12.0267 9.37329 12.6667 10.2133 12.6667 11.3333V13.3333H14.6667C15.0333 13.3333 15.3333 13.0333 15.3333 12.6666V11.3333C15.3333 9.87996 12.9533 9.01996 11.1133 8.75329Z", fill: "currentColor" }), hAsync("path", { d: "M5.99999 7.99996C7.47275 7.99996 8.66666 6.80605 8.66666 5.33329C8.66666 3.86053 7.47275 2.66663 5.99999 2.66663C4.52723 2.66663 3.33332 3.86053 3.33332 5.33329C3.33332 6.80605 4.52723 7.99996 5.99999 7.99996Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M9.99999 7.99996C11.4733 7.99996 12.6667 6.80663 12.6667 5.33329C12.6667 3.85996 11.4733 2.66663 9.99999 2.66663C9.68666 2.66663 9.39332 2.73329 9.11332 2.82663C9.66666 3.51329 9.99999 4.38663 9.99999 5.33329C9.99999 6.27996 9.66666 7.15329 9.11332 7.83996C9.39332 7.93329 9.68666 7.99996 9.99999 7.99996Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M5.99999 8.66663C4.21999 8.66663 0.666656 9.55996 0.666656 11.3333V12.6666C0.666656 13.0333 0.966656 13.3333 1.33332 13.3333H10.6667C11.0333 13.3333 11.3333 13.0333 11.3333 12.6666V11.3333C11.3333 9.55996 7.77999 8.66663 5.99999 8.66663Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M16.67 13.13C18.04 14.06 19 15.32 19 17V20H22C22.55 20 23 19.55 23 19V17C23 14.82 19.43 13.53 16.67 13.13Z", fill: "currentColor" }), hAsync("path", { d: "M9 12C11.2091 12 13 10.2091 13 8C13 5.79086 11.2091 4 9 4C6.79086 4 5 5.79086 5 8C5 10.2091 6.79086 12 9 12Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M15 12C17.21 12 19 10.21 19 8C19 5.79 17.21 4 15 4C14.53 4 14.09 4.1 13.67 4.24C14.5 5.27 15 6.58 15 8C15 9.42 14.5 10.73 13.67 11.76C14.09 11.9 14.53 12 15 12Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M9 13C6.33 13 1 14.34 1 17V19C1 19.55 1.45 20 2 20H16C16.55 20 17 19.55 17 19V17C17 14.34 11.67 13 9 13Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M19.4483 15.3183C21.0467 16.4033 22.1667 17.8733 22.1667 19.8333V23.3333H25.6667C26.3083 23.3333 26.8333 22.8083 26.8333 22.1666V19.8333C26.8333 17.29 22.6683 15.785 19.4483 15.3183Z", fill: "currentColor" }), hAsync("path", { d: "M10.5 14C13.0773 14 15.1667 11.9106 15.1667 9.33329C15.1667 6.75596 13.0773 4.66663 10.5 4.66663C7.92266 4.66663 5.83332 6.75596 5.83332 9.33329C5.83332 11.9106 7.92266 14 10.5 14Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M17.5 14C20.0783 14 22.1667 11.9116 22.1667 9.33329C22.1667 6.75496 20.0783 4.66663 17.5 4.66663C16.9517 4.66663 16.4383 4.78329 15.9483 4.94663C16.9167 6.14829 17.5 7.67663 17.5 9.33329C17.5 10.99 16.9167 12.5183 15.9483 13.72C16.4383 13.8833 16.9517 14 17.5 14Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M10.5 15.1666C7.38499 15.1666 1.16666 16.73 1.16666 19.8333V22.1666C1.16666 22.8083 1.69166 23.3333 2.33332 23.3333H18.6667C19.3083 23.3333 19.8333 22.8083 19.8333 22.1666V19.8333C19.8333 16.73 13.615 15.1666 10.5 15.1666Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$w; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-people-alt",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$v = "/*!@:host*/.sc-swirl-icon-person-h{display:inline-flex}";

class SwirlIconPerson {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.99999 8.00002C9.47332 8.00002 10.6667 6.80669 10.6667 5.33335C10.6667 3.86002 9.47332 2.66669 7.99999 2.66669C6.52666 2.66669 5.33332 3.86002 5.33332 5.33335C5.33332 6.80669 6.52666 8.00002 7.99999 8.00002ZM7.99999 9.33335C6.21999 9.33335 2.66666 10.2267 2.66666 12V12.6667C2.66666 13.0334 2.96666 13.3334 3.33332 13.3334H12.6667C13.0333 13.3334 13.3333 13.0334 13.3333 12.6667V12C13.3333 10.2267 9.77999 9.33335 7.99999 9.33335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V19C4 19.55 4.45 20 5 20H19C19.55 20 20 19.55 20 19V18C20 15.34 14.67 14 12 14Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 14C16.5783 14 18.6667 11.9117 18.6667 9.33335C18.6667 6.75502 16.5783 4.66669 14 4.66669C11.4217 4.66669 9.33332 6.75502 9.33332 9.33335C9.33332 11.9117 11.4217 14 14 14ZM14 16.3334C10.885 16.3334 4.66666 17.8967 4.66666 21V22.1667C4.66666 22.8084 5.19166 23.3334 5.83332 23.3334H22.1667C22.8083 23.3334 23.3333 22.8084 23.3333 22.1667V21C23.3333 17.8967 17.115 16.3334 14 16.3334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$v; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-person",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$u = "/*!@:host*/.sc-swirl-icon-person-off-h{display:inline-flex}";

class SwirlIconPersonOff {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6.23708 3.41005C6.71041 2.67672 7.53708 2.19672 8.47042 2.19672C9.94375 2.19672 11.1371 3.39005 11.1371 4.86338C11.1371 5.79672 10.6571 6.62338 9.92375 7.09672L6.23708 3.41005ZM13.8037 10.9767C13.7904 10.2434 13.3837 9.57005 12.7304 9.23005C12.3704 9.04338 11.9771 8.87005 11.5504 8.72338L13.8037 10.9767ZM14.1304 13.19L2.81042 1.87005C2.55042 1.61005 2.13042 1.61005 1.87042 1.87005C1.61042 2.13005 1.61042 2.55005 1.87042 2.81005L7.32375 8.26338C6.11042 8.41672 5.05042 8.79672 4.19042 9.23672C3.53708 9.58338 3.13708 10.27 3.13708 11.01V12.8634H11.9171L13.1837 14.13C13.4437 14.39 13.8637 14.39 14.1237 14.13C14.3904 13.87 14.3904 13.45 14.1304 13.19Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9.35562 5.11495C10.0656 4.01495 11.3056 3.29495 12.7056 3.29495C14.9156 3.29495 16.7056 5.08495 16.7056 7.29495C16.7056 8.69495 15.9856 9.93495 14.8856 10.645L9.35562 5.11495ZM20.7056 16.465C20.6856 15.365 20.0756 14.355 19.0956 13.845C18.5556 13.565 17.9656 13.305 17.3256 13.085L20.7056 16.465ZM21.1956 19.785L4.21562 2.80495C3.82562 2.41495 3.19562 2.41495 2.80562 2.80495C2.41562 3.19495 2.41562 3.82495 2.80562 4.21495L10.9856 12.395C9.16562 12.625 7.57562 13.195 6.28562 13.855C5.30562 14.375 4.70562 15.405 4.70562 16.515V19.295H17.8756L19.7756 21.195C20.1656 21.5849 20.7956 21.5849 21.1856 21.195C21.5856 20.805 21.5856 20.1749 21.1956 19.785Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M10.9149 5.96752C11.7432 4.68419 13.1899 3.84419 14.8232 3.84419C17.4016 3.84419 19.4899 5.93252 19.4899 8.51086C19.4899 10.1442 18.6499 11.5909 17.3666 12.4192L10.9149 5.96752ZM24.1566 19.2092C24.1332 17.9259 23.4216 16.7475 22.2782 16.1525C21.6482 15.8259 20.9599 15.5225 20.2132 15.2659L24.1566 19.2092ZM24.7282 23.0825L4.91823 3.27252C4.46323 2.81752 3.72823 2.81752 3.27323 3.27252C2.81823 3.72752 2.81823 4.46252 3.27323 4.91752L12.8166 14.4609C10.6932 14.7292 8.83823 15.3942 7.33323 16.1642C6.18989 16.7709 5.48989 17.9725 5.48989 19.2675V22.5109H20.8549L23.0716 24.7275C23.5266 25.1825 24.2616 25.1825 24.7166 24.7275C25.1832 24.2725 25.1832 23.5375 24.7282 23.0825Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$u; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-person-off",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$t = "/*!@:host*/.sc-swirl-icon-phone-h{display:inline-flex}";

class SwirlIconPhone {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.8145 10.1788L11.1212 9.98545C10.7145 9.93878 10.3145 10.0788 10.0279 10.3654L8.8012 11.5921C6.91453 10.6321 5.36787 9.09211 4.40787 7.19878L5.6412 5.96545C5.92787 5.67878 6.06787 5.27878 6.0212 4.87212L5.82787 3.19212C5.74787 2.51878 5.1812 2.01212 4.5012 2.01212H3.34787C2.59453 2.01212 1.96787 2.63878 2.01453 3.39212C2.36787 9.08545 6.9212 13.6321 12.6079 13.9854C13.3612 14.0321 13.9879 13.4054 13.9879 12.6521V11.4988C13.9945 10.8254 13.4879 10.2588 12.8145 10.1788Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M19.2218 15.2682L16.6818 14.9782C16.0718 14.9082 15.4718 15.1182 15.0418 15.5482L13.2018 17.3882C10.3718 15.9482 8.0518 13.6382 6.6118 10.7982L8.4618 8.94816C8.8918 8.51816 9.1018 7.91816 9.0318 7.30816L8.7418 4.78816C8.6218 3.77816 7.7718 3.01816 6.7518 3.01816H5.0218C3.8918 3.01816 2.9518 3.95816 3.0218 5.08816C3.5518 13.6282 10.3818 20.4482 18.9118 20.9782C20.0418 21.0482 20.9818 20.1082 20.9818 18.9782V17.2482C20.9918 16.2382 20.2318 15.3882 19.2218 15.2682Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M22.4254 17.8129L19.4621 17.4745C18.7504 17.3929 18.0504 17.6379 17.5488 18.1395L15.4021 20.2862C12.1004 18.6062 9.39377 15.9112 7.71377 12.5979L9.8721 10.4395C10.3738 9.93786 10.6188 9.23786 10.5371 8.52619L10.1988 5.58619C10.0588 4.40786 9.0671 3.52119 7.8771 3.52119H5.85877C4.54043 3.52119 3.44377 4.61786 3.52543 5.93619C4.14377 15.8995 12.1121 23.8562 22.0638 24.4745C23.3821 24.5562 24.4788 23.4595 24.4788 22.1412V20.1229C24.4904 18.9445 23.6038 17.9529 22.4254 17.8129Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$t; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-phone",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$s = "/*!@:host*/.sc-swirl-icon-play-arrow-h{display:inline-flex}";

class SwirlIconPlayArrow {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6.35004 12.0167C6.12782 12.1611 5.90282 12.1695 5.67504 12.0417C5.44726 11.9139 5.33337 11.7167 5.33337 11.45V4.55001C5.33337 4.28334 5.44726 4.08612 5.67504 3.95834C5.90282 3.83057 6.12782 3.8389 6.35004 3.98334L11.7834 7.43334C11.9834 7.56668 12.0834 7.75557 12.0834 8.00001C12.0834 8.24445 11.9834 8.43334 11.7834 8.56668L6.35004 12.0167Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9.525 18.025C9.19167 18.2417 8.85417 18.2542 8.5125 18.0625C8.17083 17.8708 8 17.575 8 17.175V6.825C8 6.425 8.17083 6.12917 8.5125 5.9375C8.85417 5.74583 9.19167 5.75833 9.525 5.975L17.675 11.15C17.975 11.35 18.125 11.6333 18.125 12C18.125 12.3667 17.975 12.65 17.675 12.85L9.525 18.025Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M11.1125 21.0292C10.7237 21.282 10.3299 21.2965 9.93129 21.0729C9.53268 20.8493 9.33337 20.5042 9.33337 20.0375V7.96251C9.33337 7.49584 9.53268 7.1507 9.93129 6.92709C10.3299 6.70348 10.7237 6.71807 11.1125 6.97084L20.6209 13.0083C20.9709 13.2417 21.1459 13.5722 21.1459 14C21.1459 14.4278 20.9709 14.7583 20.6209 14.9917L11.1125 21.0292Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$s; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-play-arrow",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$r = "/*!@:host*/.sc-swirl-icon-poll-h{display:inline-flex}";

class SwirlIconPoll {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M10 8.66667H3.33333C2.98004 8.66772 2.64151 8.80854 2.39169 9.05836C2.14187 9.30818 2.00106 9.6467 2 10V12.6667C2.00106 13.02 2.14187 13.3585 2.39169 13.6083C2.64151 13.8581 2.98004 13.9989 3.33333 14H10C10.3533 13.9989 10.6918 13.8581 10.9416 13.6083C11.1915 13.3585 11.3323 13.02 11.3333 12.6667V10C11.3323 9.6467 11.1915 9.30818 10.9416 9.05836C10.6918 8.80854 10.3533 8.66772 10 8.66667ZM4.66667 12.6667C4.40296 12.6667 4.14517 12.5885 3.92591 12.442C3.70664 12.2955 3.53574 12.0872 3.43483 11.8436C3.33391 11.5999 3.30751 11.3319 3.35895 11.0732C3.4104 10.8146 3.53739 10.577 3.72386 10.3905C3.91033 10.2041 4.1479 10.0771 4.40655 10.0256C4.66519 9.97417 4.93328 10.0006 5.17691 10.1015C5.42055 10.2024 5.62878 10.3733 5.77529 10.5926C5.9218 10.8118 6 11.0696 6 11.3333C5.99894 11.6866 5.85813 12.0252 5.60831 12.275C5.35849 12.5248 5.01996 12.6656 4.66667 12.6667V12.6667ZM12.6667 2H3.33333C2.98004 2.00106 2.64151 2.14187 2.39169 2.39169C2.14187 2.64151 2.00106 2.98004 2 3.33333V6C2.00106 6.3533 2.14187 6.69182 2.39169 6.94164C2.64151 7.19146 2.98004 7.33228 3.33333 7.33333H12.6667C13.02 7.33228 13.3585 7.19146 13.6083 6.94164C13.8581 6.69182 13.9989 6.3533 14 6V3.33333C13.9989 2.98004 13.8581 2.64151 13.6083 2.39169C13.3585 2.14187 13.02 2.00106 12.6667 2V2ZM4.66667 6C4.40296 6 4.14517 5.9218 3.92591 5.77529C3.70664 5.62878 3.53574 5.42055 3.43483 5.17691C3.33391 4.93328 3.30751 4.66519 3.35895 4.40655C3.4104 4.1479 3.53739 3.91033 3.72386 3.72386C3.91033 3.53739 4.1479 3.4104 4.40655 3.35895C4.66519 3.30751 4.93328 3.33391 5.17691 3.43483C5.42055 3.53574 5.62878 3.70664 5.77529 3.92591C5.9218 4.14517 6 4.40296 6 4.66667C5.99894 5.01996 5.85813 5.35849 5.60831 5.60831C5.35849 5.85813 5.01996 5.99894 4.66667 6V6Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M15 13H5C4.47005 13.0016 3.96227 13.2128 3.58753 13.5875C3.2128 13.9623 3.00158 14.4701 3 15V19C3.00158 19.5299 3.2128 20.0377 3.58753 20.4125C3.96227 20.7872 4.47005 20.9984 5 21H15C15.5299 20.9984 16.0377 20.7872 16.4125 20.4125C16.7872 20.0377 16.9984 19.5299 17 19V15C16.9984 14.4701 16.7872 13.9623 16.4125 13.5875C16.0377 13.2128 15.5299 13.0016 15 13ZM7 19C6.60444 19 6.21776 18.8827 5.88886 18.6629C5.55996 18.4432 5.30362 18.1308 5.15224 17.7654C5.00087 17.3999 4.96126 16.9978 5.03843 16.6098C5.1156 16.2219 5.30608 15.8655 5.58579 15.5858C5.86549 15.3061 6.22186 15.1156 6.60982 15.0384C6.99778 14.9613 7.39991 15.0009 7.76537 15.1522C8.13082 15.3036 8.44318 15.56 8.66294 15.8889C8.8827 16.2178 9 16.6044 9 17C8.99842 17.5299 8.7872 18.0377 8.41247 18.4125C8.03773 18.7872 7.52995 18.9984 7 19ZM19 3H5C4.47005 3.00158 3.96227 3.2128 3.58753 3.58753C3.2128 3.96227 3.00158 4.47005 3 5V9C3.00158 9.52995 3.2128 10.0377 3.58753 10.4125C3.96227 10.7872 4.47005 10.9984 5 11H19C19.5299 10.9984 20.0377 10.7872 20.4125 10.4125C20.7872 10.0377 20.9984 9.52995 21 9V5C20.9984 4.47005 20.7872 3.96227 20.4125 3.58753C20.0377 3.2128 19.5299 3.00158 19 3ZM7 9C6.60444 9 6.21776 8.8827 5.88886 8.66294C5.55996 8.44318 5.30362 8.13082 5.15224 7.76537C5.00087 7.39991 4.96126 6.99778 5.03843 6.60982C5.1156 6.22186 5.30608 5.86549 5.58579 5.58579C5.86549 5.30608 6.22186 5.1156 6.60982 5.03843C6.99778 4.96126 7.39991 5.00087 7.76537 5.15224C8.13082 5.30362 8.44318 5.55996 8.66294 5.88886C8.8827 6.21776 9 6.60444 9 7C8.99842 7.52995 8.7872 8.03773 8.41247 8.41247C8.03773 8.7872 7.52995 8.99842 7 9Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M17.5 15.1667H5.83333C5.21506 15.1685 4.62264 15.4149 4.18546 15.8521C3.74827 16.2893 3.50185 16.8817 3.5 17.5V22.1667C3.50185 22.7849 3.74827 23.3774 4.18546 23.8145C4.62264 24.2517 5.21506 24.4982 5.83333 24.5H17.5C18.1183 24.4982 18.7107 24.2517 19.1479 23.8145C19.5851 23.3774 19.8315 22.7849 19.8333 22.1667V17.5C19.8315 16.8817 19.5851 16.2893 19.1479 15.8521C18.7107 15.4149 18.1183 15.1685 17.5 15.1667ZM8.16667 22.1667C7.70518 22.1667 7.25405 22.0298 6.87034 21.7734C6.48662 21.517 6.18755 21.1526 6.01095 20.7263C5.83434 20.2999 5.78814 19.8307 5.87817 19.3781C5.9682 18.9255 6.19043 18.5097 6.51675 18.1834C6.84307 17.8571 7.25883 17.6349 7.71146 17.5448C8.16408 17.4548 8.63323 17.501 9.05959 17.6776C9.48596 17.8542 9.85037 18.1533 10.1068 18.537C10.3632 18.9207 10.5 19.3718 10.5 19.8333C10.4982 20.4516 10.2517 21.044 9.81454 21.4812C9.37736 21.9184 8.78494 22.1648 8.16667 22.1667V22.1667ZM22.1667 3.5H5.83333C5.21506 3.50185 4.62264 3.74827 4.18546 4.18546C3.74827 4.62264 3.50185 5.21506 3.5 5.83333V10.5C3.50185 11.1183 3.74827 11.7107 4.18546 12.1479C4.62264 12.5851 5.21506 12.8315 5.83333 12.8333H22.1667C22.7849 12.8315 23.3774 12.5851 23.8145 12.1479C24.2517 11.7107 24.4982 11.1183 24.5 10.5V5.83333C24.4982 5.21506 24.2517 4.62264 23.8145 4.18546C23.3774 3.74827 22.7849 3.50185 22.1667 3.5V3.5ZM8.16667 10.5C7.70518 10.5 7.25405 10.3632 6.87034 10.1068C6.48662 9.85037 6.18755 9.48596 6.01095 9.05959C5.83434 8.63323 5.78814 8.16408 5.87817 7.71146C5.9682 7.25883 6.19043 6.84307 6.51675 6.51675C6.84307 6.19043 7.25883 5.9682 7.71146 5.87817C8.16408 5.78814 8.63323 5.83434 9.05959 6.01095C9.48596 6.18755 9.85037 6.48662 10.1068 6.87034C10.3632 7.25405 10.5 7.70518 10.5 8.16667C10.4982 8.78494 10.2517 9.37736 9.81454 9.81454C9.37736 10.2517 8.78494 10.4982 8.16667 10.5V10.5Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$r; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-poll",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$q = "/*!@:host*/.sc-swirl-icon-print-h{display:inline-flex}";

class SwirlIconPrint {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M10.6167 5.20003V3.38337H5.38333V5.20003H3.86666V2.6167C3.86666 2.40559 3.93889 2.22781 4.08333 2.08337C4.22777 1.93892 4.40555 1.8667 4.61666 1.8667H11.3833C11.5944 1.8667 11.7722 1.93892 11.9167 2.08337C12.0611 2.22781 12.1333 2.40559 12.1333 2.6167V5.20003H10.6167ZM2.71666 6.7167H13.2833H3.86666H2.71666ZM11.9167 8.50003C12.1167 8.50003 12.286 8.4307 12.4247 8.29203C12.5638 8.15292 12.6333 7.98337 12.6333 7.78337C12.6333 7.57225 12.5638 7.39714 12.4247 7.25803C12.286 7.11937 12.1167 7.05003 11.9167 7.05003C11.7056 7.05003 11.5307 7.11937 11.392 7.25803C11.2529 7.39714 11.1833 7.57225 11.1833 7.78337C11.1833 7.98337 11.2529 8.15292 11.392 8.29203C11.5307 8.4307 11.7056 8.50003 11.9167 8.50003ZM5.38333 12.7167H10.6167V10.35H5.38333V12.7167ZM5.38333 14.2C4.96111 14.2 4.60289 14.0529 4.30866 13.7587C4.014 13.464 3.86666 13.1056 3.86666 12.6834V11.45H1.95C1.73889 11.45 1.56111 11.3749 1.41666 11.2247C1.27222 11.0749 1.2 10.8945 1.2 10.6834V7.33337C1.2 6.73337 1.40555 6.22781 1.81666 5.8167C2.22777 5.40559 2.72777 5.20003 3.31666 5.20003H12.6833C13.2833 5.20003 13.7862 5.40559 14.192 5.8167C14.5973 6.22781 14.8 6.73337 14.8 7.33337V10.6834C14.8 10.8945 14.7278 11.0749 14.5833 11.2247C14.4389 11.3749 14.2611 11.45 14.05 11.45H12.1333V12.6834C12.1333 13.1056 11.9862 13.464 11.692 13.7587C11.3973 14.0529 11.0389 14.2 10.6167 14.2H5.38333ZM13.2833 9.93337V7.33337C13.2833 7.15559 13.2278 7.00825 13.1167 6.89137C13.0056 6.77492 12.8611 6.7167 12.6833 6.7167H3.31666C3.15 6.7167 3.00844 6.77492 2.892 6.89137C2.77511 7.00825 2.71666 7.15559 2.71666 7.33337V9.93337H3.86666V8.83337H12.1333V9.93337H13.2833Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M15.925 7.80005V5.07505H8.075V7.80005H5.8V3.92505C5.8 3.60838 5.90833 3.34172 6.125 3.12505C6.34167 2.90838 6.60833 2.80005 6.925 2.80005H17.075C17.3917 2.80005 17.6583 2.90838 17.875 3.12505C18.0917 3.34172 18.2 3.60838 18.2 3.92505V7.80005H15.925ZM4.075 10.075H19.925H5.8H4.075ZM17.875 12.75C18.175 12.75 18.429 12.646 18.637 12.438C18.8457 12.2294 18.95 11.975 18.95 11.675C18.95 11.3584 18.8457 11.0957 18.637 10.887C18.429 10.679 18.175 10.575 17.875 10.575C17.5583 10.575 17.296 10.679 17.088 10.887C16.8793 11.0957 16.775 11.3584 16.775 11.675C16.775 11.975 16.8793 12.2294 17.088 12.438C17.296 12.646 17.5583 12.75 17.875 12.75ZM8.075 19.0751H15.925V15.525H8.075V19.0751ZM8.075 21.3C7.44167 21.3 6.90433 21.0794 6.463 20.6381C6.021 20.1961 5.8 19.6584 5.8 19.025V17.175H2.925C2.60833 17.175 2.34167 17.0624 2.125 16.837C1.90833 16.6124 1.8 16.3417 1.8 16.025V11C1.8 10.1 2.10833 9.34172 2.725 8.72505C3.34167 8.10838 4.09167 7.80005 4.975 7.80005H19.025C19.925 7.80005 20.6793 8.10838 21.288 8.72505C21.896 9.34172 22.2 10.1 22.2 11V16.025C22.2 16.3417 22.0917 16.6124 21.875 16.837C21.6583 17.0624 21.3917 17.175 21.075 17.175H18.2V19.025C18.2 19.6584 17.9793 20.1961 17.538 20.6381C17.096 21.0794 16.5583 21.3 15.925 21.3H8.075ZM19.925 14.9V11C19.925 10.7334 19.8417 10.5124 19.675 10.337C19.5083 10.1624 19.2917 10.075 19.025 10.075H4.975C4.725 10.075 4.51267 10.1624 4.338 10.337C4.16267 10.5124 4.075 10.7334 4.075 11V14.9H5.8V13.25H18.2V14.9H19.925Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M18.5792 9.10006V5.92089H9.42083V9.10006H6.76666V4.57922C6.76666 4.20978 6.89305 3.89867 7.14583 3.64589C7.39861 3.39311 7.70972 3.26672 8.07916 3.26672H19.9208C20.2903 3.26672 20.6014 3.39311 20.8542 3.64589C21.1069 3.89867 21.2333 4.20978 21.2333 4.57922V9.10006H18.5792ZM4.75416 11.7542H23.2458H6.76666H4.75416ZM20.8542 14.8751C21.2042 14.8751 21.5005 14.7537 21.7432 14.5111C21.9866 14.2676 22.1083 13.9709 22.1083 13.6209C22.1083 13.2514 21.9866 12.945 21.7432 12.7016C21.5005 12.4589 21.2042 12.3376 20.8542 12.3376C20.4847 12.3376 20.1787 12.4589 19.936 12.7016C19.6926 12.945 19.5708 13.2514 19.5708 13.6209C19.5708 13.9709 19.6926 14.2676 19.936 14.5111C20.1787 14.7537 20.4847 14.8751 20.8542 14.8751ZM9.42083 22.2542H18.5792V18.1126H9.42083V22.2542ZM9.42083 24.8501C8.68194 24.8501 8.05505 24.5926 7.54017 24.0777C7.0245 23.5621 6.76666 22.9348 6.76666 22.1959V20.0376H3.4125C3.04305 20.0376 2.73194 19.9061 2.47917 19.6432C2.22639 19.3811 2.1 19.0653 2.1 18.6959V12.8334C2.1 11.7834 2.45972 10.8987 3.17917 10.1792C3.89861 9.45978 4.77361 9.10006 5.80416 9.10006H22.1958C23.2458 9.10006 24.1259 9.45978 24.836 10.1792C25.5453 10.8987 25.9 11.7834 25.9 12.8334V18.6959C25.9 19.0653 25.7736 19.3811 25.5208 19.6432C25.2681 19.9061 24.9569 20.0376 24.5875 20.0376H21.2333V22.1959C21.2333 22.9348 20.9759 23.5621 20.461 24.0777C19.9453 24.5926 19.3181 24.8501 18.5792 24.8501H9.42083ZM23.2458 17.3834V12.8334C23.2458 12.5223 23.1486 12.2644 22.9542 12.0599C22.7597 11.8561 22.5069 11.7542 22.1958 11.7542H5.80416C5.5125 11.7542 5.26478 11.8561 5.061 12.0599C4.85644 12.2644 4.75416 12.5223 4.75416 12.8334V17.3834H6.76666V15.4584H21.2333V17.3834H23.2458Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$q; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-print",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$p = "/*!@:host*/.sc-swirl-icon-recieved-h{display:inline-flex}";

class SwirlIconRecieved {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M1.16667 9.16662L3.2929 11.2928C3.68342 11.6834 4.31659 11.6834 4.70711 11.2928L10.5 5.49995C10.7761 5.22381 10.7761 4.7761 10.5 4.49995C10.2239 4.22381 9.77615 4.22381 9.5 4.49995L4 9.99995L2.16667 8.16662C1.89053 7.89048 1.44281 7.89048 1.16667 8.16662C0.890529 8.44276 0.890529 8.89048 1.16667 9.16662Z", fill: "currentColor" }), hAsync("path", { d: "M8 9.33329L7 10.3333L7.95957 11.2928C8.35009 11.6834 8.98325 11.6834 9.37378 11.2928L15.1667 5.49995C15.4428 5.22381 15.4428 4.7761 15.1667 4.49995C14.8905 4.22381 14.4428 4.22381 14.1667 4.49995L8.66667 9.99995L8 9.33329Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M1.74999 13.75L4.93933 16.9393C5.52512 17.5251 6.47486 17.5251 7.06065 16.9393L15.75 8.24999C16.1642 7.83578 16.1642 7.1642 15.75 6.74999C15.3358 6.33578 14.6642 6.33578 14.25 6.74999L5.99999 15L3.24999 12.25C2.83578 11.8358 2.1642 11.8358 1.74999 12.25C1.33578 12.6642 1.33578 13.3358 1.74999 13.75Z", fill: "currentColor" }), hAsync("path", { d: "M12 14L10.5 15.5L11.9393 16.9393C12.5251 17.5251 13.4749 17.5251 14.0607 16.9393L22.75 8.24999C23.1642 7.83578 23.1642 7.1642 22.75 6.74999C22.3358 6.33578 21.6642 6.33578 21.25 6.74999L13 15L12 14Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M2.04167 16.0417L5.76256 19.7626C6.44598 20.446 7.55402 20.446 8.23744 19.7626L18.375 9.62501C18.8583 9.14176 18.8583 8.35826 18.375 7.87501C17.8918 7.39176 17.1082 7.39176 16.625 7.87501L7 17.5L3.79167 14.2917C3.30842 13.8084 2.52492 13.8084 2.04167 14.2917C1.55842 14.7749 1.55842 15.5584 2.04167 16.0417Z", fill: "currentColor" }), hAsync("path", { d: "M14 16.3333L12.25 18.0833L13.9292 19.7626C14.6126 20.446 15.7207 20.446 16.4041 19.7626L26.5417 9.62501C27.0249 9.14176 27.0249 8.35826 26.5417 7.87501C26.0584 7.39176 25.2749 7.39176 24.7917 7.87501L15.1667 17.5L14 16.3333Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$p; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-recieved",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$o = "/*!@:host*/.sc-swirl-icon-remove-h{display:inline-flex}";

class SwirlIconRemove {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M4 8.76661C3.78889 8.76661 3.60844 8.6915 3.45866 8.54128C3.30844 8.3915 3.23333 8.21105 3.23333 7.99994C3.23333 7.78883 3.30844 7.60839 3.45866 7.45861C3.60844 7.30839 3.78889 7.23328 4 7.23328H12C12.2111 7.23328 12.3916 7.30839 12.5413 7.45861C12.6916 7.60839 12.7667 7.78883 12.7667 7.99994C12.7667 8.21105 12.6916 8.3915 12.5413 8.54128C12.3916 8.6915 12.2111 8.76661 12 8.76661H4Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M6 13.15C5.68333 13.15 5.41267 13.0373 5.188 12.812C4.96267 12.5873 4.85 12.3166 4.85 12C4.85 11.6833 4.96267 11.4126 5.188 11.188C5.41267 10.9626 5.68333 10.85 6 10.85H18C18.3167 10.85 18.5873 10.9626 18.812 11.188C19.0373 11.4126 19.15 11.6833 19.15 12C19.15 12.3166 19.0373 12.5873 18.812 12.812C18.5873 13.0373 18.3167 13.15 18 13.15H6Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M7 15.3417C6.63056 15.3417 6.31478 15.2102 6.05267 14.9473C5.78978 14.6852 5.65833 14.3694 5.65833 14C5.65833 13.6305 5.78978 13.3148 6.05267 13.0527C6.31478 12.7898 6.63056 12.6583 7 12.6583H21C21.3694 12.6583 21.6852 12.7898 21.9473 13.0527C22.2102 13.3148 22.3417 13.6305 22.3417 14C22.3417 14.3694 22.2102 14.6852 21.9473 14.9473C21.6852 15.2102 21.3694 15.3417 21 15.3417H7Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$o; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-remove",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$n = "/*!@:host*/.sc-swirl-icon-reply-h{display:inline-flex}";

class SwirlIconReply {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6.66661 6V4.94C6.66661 4.34667 5.94661 4.04667 5.52661 4.46667L2.46661 7.52667C2.20661 7.78667 2.20661 8.20667 2.46661 8.46667L5.52661 11.5267C5.94661 11.9467 6.66661 11.6533 6.66661 11.06V9.93333C9.99994 9.93333 12.3333 11 13.9999 13.3333C13.3333 10 11.3333 6.66667 6.66661 6Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9.99997 9V7.41C9.99997 6.52 8.91997 6.07 8.28997 6.7L3.69997 11.29C3.30997 11.68 3.30997 12.31 3.69997 12.7L8.28997 17.29C8.91997 17.92 9.99997 17.48 9.99997 16.59V14.9C15 14.9 18.5 16.5 21 20C20 15 17 10 9.99997 9Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M11.6667 10.5V8.645C11.6667 7.60667 10.4067 7.08167 9.67171 7.81667L4.31671 13.1717C3.86171 13.6267 3.86171 14.3617 4.31671 14.8167L9.67171 20.1717C10.4067 20.9067 11.6667 20.3933 11.6667 19.355V17.3833C17.5 17.3833 21.5834 19.25 24.5 23.3333C23.3334 17.5 19.8334 11.6667 11.6667 10.5Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$n; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-reply",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$m = "/*!@:host*/.sc-swirl-icon-roadmap-h{display:inline-flex}";

class SwirlIconRoadmap {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M2.66663 3.66667C2.66663 3.11439 3.11434 2.66667 3.66663 2.66667H6.99996C7.55224 2.66667 7.99996 3.11439 7.99996 3.66667C7.99996 4.21896 7.55224 4.66667 6.99996 4.66667H3.66663C3.11434 4.66667 2.66663 4.21896 2.66663 3.66667Z", fill: "currentColor" }), hAsync("path", { d: "M2.66663 12.3333C2.66663 11.7811 3.11434 11.3333 3.66663 11.3333H5.66663C6.21891 11.3333 6.66663 11.7811 6.66663 12.3333C6.66663 12.8856 6.21891 13.3333 5.66663 13.3333H3.66663C3.11434 13.3333 2.66663 12.8856 2.66663 12.3333Z", fill: "currentColor" }), hAsync("path", { d: "M5.33329 8.00001C5.33329 7.44772 5.78101 7.00001 6.33329 7.00001H12.3333C12.8856 7.00001 13.3333 7.44772 13.3333 8.00001C13.3333 8.55229 12.8856 9.00001 12.3333 9.00001H6.33329C5.78101 9.00001 5.33329 8.55229 5.33329 8.00001Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M4 5.5C4 4.67157 4.67157 4 5.5 4H10.5C11.3284 4 12 4.67157 12 5.5C12 6.32843 11.3284 7 10.5 7H5.5C4.67157 7 4 6.32843 4 5.5Z", fill: "currentColor" }), hAsync("path", { d: "M4 18.5C4 17.6716 4.67157 17 5.5 17H8.5C9.32843 17 10 17.6716 10 18.5C10 19.3284 9.32843 20 8.5 20H5.5C4.67157 20 4 19.3284 4 18.5Z", fill: "currentColor" }), hAsync("path", { d: "M8 12C8 11.1716 8.67157 10.5 9.5 10.5H18.5C19.3284 10.5 20 11.1716 20 12C20 12.8284 19.3284 13.5 18.5 13.5H9.5C8.67157 13.5 8 12.8284 8 12Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66663 6.41667C4.66663 5.45017 5.45013 4.66667 6.41663 4.66667H12.25C13.2165 4.66667 14 5.45017 14 6.41667C14 7.38317 13.2165 8.16667 12.25 8.16667H6.41663C5.45013 8.16667 4.66663 7.38317 4.66663 6.41667Z", fill: "currentColor" }), hAsync("path", { d: "M4.66663 21.5833C4.66663 20.6168 5.45013 19.8333 6.41663 19.8333H9.91663C10.8831 19.8333 11.6666 20.6168 11.6666 21.5833C11.6666 22.5498 10.8831 23.3333 9.91663 23.3333H6.41663C5.45013 23.3333 4.66663 22.5498 4.66663 21.5833Z", fill: "currentColor" }), hAsync("path", { d: "M9.33329 14C9.33329 13.0335 10.1168 12.25 11.0833 12.25H21.5833C22.5498 12.25 23.3333 13.0335 23.3333 14C23.3333 14.9665 22.5498 15.75 21.5833 15.75H11.0833C10.1168 15.75 9.33329 14.9665 9.33329 14Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$m; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-roadmap",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$l = "/*!@:host*/.sc-swirl-icon-search-h{display:inline-flex}";

class SwirlIconSearch {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.5333 13.6167L8.83333 9.91669C8.5 10.1722 8.11666 10.3778 7.68333 10.5334C7.25 10.6889 6.78889 10.7667 6.3 10.7667C5.06666 10.7667 4.02222 10.336 3.16666 9.47469C2.31111 8.6138 1.88333 7.56669 1.88333 6.33336C1.88333 5.10002 2.31111 4.05269 3.16666 3.19136C4.02222 2.33047 5.06666 1.90002 6.3 1.90002C7.53333 1.90002 8.58066 2.33047 9.442 3.19136C10.3029 4.05269 10.7333 5.10002 10.7333 6.33336C10.7333 6.82225 10.6584 7.28336 10.5087 7.71669C10.3584 8.15002 10.1556 8.5278 9.9 8.85002L13.6167 12.5834C13.75 12.7167 13.8167 12.8862 13.8167 13.092C13.8167 13.2974 13.7444 13.4722 13.6 13.6167C13.4556 13.7611 13.2751 13.8334 13.0587 13.8334C12.8418 13.8334 12.6667 13.7611 12.5333 13.6167ZM6.3 9.23336C7.11111 9.23336 7.8 8.95269 8.36667 8.39136C8.93333 7.83047 9.21666 7.14447 9.21666 6.33336C9.21666 5.52225 8.93333 4.83602 8.36667 4.27469C7.8 3.7138 7.11111 3.43336 6.3 3.43336C5.48889 3.43336 4.80289 3.7138 4.242 4.27469C3.68066 4.83602 3.4 5.52225 3.4 6.33336C3.4 7.14447 3.68066 7.83047 4.242 8.39136C4.80289 8.95269 5.48889 9.23336 6.3 9.23336Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M18.8 20.425L13.25 14.875C12.75 15.2583 12.175 15.5666 11.525 15.8C10.875 16.0333 10.1833 16.15 9.45001 16.15C7.60001 16.15 6.03335 15.504 4.75001 14.212C3.46668 12.9206 2.82501 11.35 2.82501 9.49998C2.82501 7.64998 3.46668 6.07898 4.75001 4.78698C6.03335 3.49564 7.60001 2.84998 9.45001 2.84998C11.3 2.84998 12.871 3.49564 14.163 4.78698C15.4543 6.07898 16.1 7.64998 16.1 9.49998C16.1 10.2333 15.9877 10.925 15.763 11.575C15.5377 12.225 15.2333 12.7916 14.85 13.275L20.425 18.875C20.625 19.075 20.725 19.3293 20.725 19.638C20.725 19.946 20.6167 20.2083 20.4 20.425C20.1833 20.6416 19.9127 20.75 19.588 20.75C19.2627 20.75 19 20.6416 18.8 20.425ZM9.45001 13.85C10.6667 13.85 11.7 13.429 12.55 12.587C13.4 11.7456 13.825 10.7166 13.825 9.49998C13.825 8.28331 13.4 7.25398 12.55 6.41198C11.7 5.57064 10.6667 5.14998 9.45001 5.14998C8.23335 5.14998 7.20435 5.57064 6.36301 6.41198C5.52101 7.25398 5.10001 8.28331 5.10001 9.49998C5.10001 10.7166 5.52101 11.7456 6.36301 12.587C7.20435 13.429 8.23335 13.85 9.45001 13.85Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M21.9333 23.8292L15.4583 17.3542C14.875 17.8014 14.2042 18.1611 13.4458 18.4333C12.6875 18.7056 11.8806 18.8417 11.025 18.8417C8.86667 18.8417 7.03889 18.088 5.54167 16.5807C4.04445 15.0741 3.29584 13.2417 3.29584 11.0833C3.29584 8.92501 4.04445 7.09218 5.54167 5.58485C7.03889 4.07829 8.86667 3.32501 11.025 3.32501C13.1833 3.32501 15.0162 4.07829 16.5235 5.58485C18.0301 7.09218 18.7833 8.92501 18.7833 11.0833C18.7833 11.9389 18.6523 12.7458 18.3902 13.5042C18.1273 14.2625 17.7722 14.9236 17.325 15.4875L23.8292 22.0208C24.0625 22.2542 24.1792 22.5509 24.1792 22.911C24.1792 23.2703 24.0528 23.5764 23.8 23.8292C23.5472 24.082 23.2314 24.2083 22.8527 24.2083C22.4731 24.2083 22.1667 24.082 21.9333 23.8292ZM11.025 16.1583C12.4444 16.1583 13.65 15.6672 14.6417 14.6848C15.6333 13.7033 16.1292 12.5028 16.1292 11.0833C16.1292 9.6639 15.6333 8.46301 14.6417 7.48068C13.65 6.49912 12.4444 6.00835 11.025 6.00835C9.60556 6.00835 8.40506 6.49912 7.4235 7.48068C6.44117 8.46301 5.95 9.6639 5.95 11.0833C5.95 12.5028 6.44117 13.7033 7.4235 14.6848C8.40506 15.6672 9.60556 16.1583 11.025 16.1583Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$l; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-search",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$k = "/*!@:host*/.sc-swirl-icon-search-strong-h{display:inline-flex}";

class SwirlIconSearchStrong {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.3 13.9L8.71667 10.3166C8.39445 10.5389 8.01956 10.7166 7.592 10.85C7.164 10.9833 6.7 11.05 6.2 11.05C4.88889 11.05 3.77512 10.5915 2.85867 9.67464C1.94178 8.75819 1.48334 7.64442 1.48334 6.3333C1.48334 5.02219 1.94178 3.90819 2.85867 2.9913C3.77512 2.07486 4.88889 1.61664 6.2 1.61664C7.51112 1.61664 8.62489 2.07486 9.54134 2.9913C10.4582 3.90819 10.9167 5.02219 10.9167 6.3333C10.9167 6.84442 10.85 7.30819 10.7167 7.72464C10.5833 8.14153 10.4056 8.50553 10.1833 8.81664L13.8 12.45C14 12.65 14.0973 12.8915 14.092 13.1746C14.0862 13.4582 13.9833 13.7 13.7833 13.9C13.5833 14.1 13.336 14.2 13.0413 14.2C12.7471 14.2 12.5 14.1 12.3 13.9V13.9ZM6.2 8.94997C6.93334 8.94997 7.55289 8.69708 8.05867 8.1913C8.564 7.68597 8.81667 7.06664 8.81667 6.3333C8.81667 5.59997 8.564 4.98042 8.05867 4.47464C7.55289 3.9693 6.93334 3.71664 6.2 3.71664C5.46667 3.71664 4.84734 3.9693 4.342 4.47464C3.83623 4.98042 3.58334 5.59997 3.58334 6.3333C3.58334 7.06664 3.83623 7.68597 4.342 8.1913C4.84734 8.69708 5.46667 8.94997 6.2 8.94997Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M18.45 20.85L13.075 15.475C12.5917 15.8083 12.0293 16.075 11.388 16.275C10.746 16.475 10.05 16.575 9.30001 16.575C7.33334 16.575 5.66267 15.8873 4.28801 14.512C2.91267 13.1373 2.22501 11.4667 2.22501 9.49999C2.22501 7.53332 2.91267 5.86232 4.28801 4.48699C5.66267 3.11232 7.33334 2.42499 9.30001 2.42499C11.2667 2.42499 12.9373 3.11232 14.312 4.48699C15.6873 5.86232 16.375 7.53332 16.375 9.49999C16.375 10.2667 16.275 10.9623 16.075 11.587C15.875 12.2123 15.6083 12.7583 15.275 13.225L20.7 18.675C21 18.975 21.146 19.3373 21.138 19.762C21.1293 20.1873 20.975 20.55 20.675 20.85C20.375 21.15 20.004 21.3 19.562 21.3C19.1207 21.3 18.75 21.15 18.45 20.85ZM9.30001 13.425C10.4 13.425 11.3293 13.0457 12.088 12.287C12.846 11.529 13.225 10.6 13.225 9.49999C13.225 8.39999 12.846 7.47065 12.088 6.71199C11.3293 5.95399 10.4 5.57499 9.30001 5.57499C8.20001 5.57499 7.27101 5.95399 6.51301 6.71199C5.75434 7.47065 5.37501 8.39999 5.37501 9.49999C5.37501 10.6 5.75434 11.529 6.51301 12.287C7.27101 13.0457 8.20001 13.425 9.30001 13.425Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M21.525 24.325L15.2542 18.0542C14.6903 18.4431 14.0342 18.7542 13.286 18.9875C12.537 19.2208 11.725 19.3375 10.85 19.3375C8.55555 19.3375 6.60644 18.5352 5.00266 16.9307C3.3981 15.3269 2.59583 13.3778 2.59583 11.0833C2.59583 8.78888 3.3981 6.83939 5.00266 5.23483C6.60644 3.63105 8.55555 2.82916 10.85 2.82916C13.1444 2.82916 15.0935 3.63105 16.6973 5.23483C18.3019 6.83939 19.1042 8.78888 19.1042 11.0833C19.1042 11.9778 18.9875 12.7894 18.7542 13.5182C18.5208 14.2477 18.2097 14.8847 17.8208 15.4292L24.15 21.7875C24.5 22.1375 24.6703 22.5602 24.661 23.0557C24.6509 23.5519 24.4708 23.975 24.1208 24.325C23.7708 24.675 23.338 24.85 22.8223 24.85C22.3074 24.85 21.875 24.675 21.525 24.325V24.325ZM10.85 15.6625C12.1333 15.6625 13.2175 15.2199 14.1027 14.3348C14.987 13.4505 15.4292 12.3667 15.4292 11.0833C15.4292 9.8 14.987 8.71577 14.1027 7.83066C13.2175 6.94633 12.1333 6.50416 10.85 6.50416C9.56666 6.50416 8.48283 6.94633 7.59849 7.83066C6.71338 8.71577 6.27083 9.8 6.27083 11.0833C6.27083 12.3667 6.71338 13.4505 7.59849 14.3348C8.48283 15.2199 9.56666 15.6625 10.85 15.6625Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$k; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-search-strong",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$j = "/*!@:host*/.sc-swirl-icon-send-h{display:inline-flex}";

class SwirlIconSend {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M2.93333 12.95C2.71111 13.0389 2.5 13.0193 2.3 12.8913C2.1 12.7638 2 12.5778 2 12.3333V9.85C2 9.69444 2.04444 9.55555 2.13333 9.43333C2.22222 9.31111 2.34444 9.23333 2.5 9.2L7.33333 8L2.5 6.8C2.34444 6.76666 2.22222 6.68889 2.13333 6.56666C2.04444 6.44444 2 6.30555 2 6.15V3.66666C2 3.42222 2.1 3.236 2.3 3.108C2.5 2.98044 2.71111 2.96111 2.93333 3.05L13.2 7.38333C13.4778 7.50555 13.6167 7.71111 13.6167 8C13.6167 8.28889 13.4778 8.49444 13.2 8.61666L2.93333 12.95Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M4.4 19.425C4.06667 19.5583 3.75 19.529 3.45 19.337C3.15 19.1457 3 18.8667 3 18.5V14.775C3 14.5417 3.06667 14.3333 3.2 14.15C3.33333 13.9667 3.51667 13.85 3.75 13.8L11 12L3.75 10.2C3.51667 10.15 3.33333 10.0333 3.2 9.84999C3.06667 9.66666 3 9.45833 3 9.22499V5.49999C3 5.13333 3.15 4.85399 3.45 4.66199C3.75 4.47066 4.06667 4.44166 4.4 4.57499L19.8 11.075C20.2167 11.2583 20.425 11.5667 20.425 12C20.425 12.4333 20.2167 12.7417 19.8 12.925L4.4 19.425Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M5.13333 22.6625C4.74444 22.818 4.375 22.7838 4.025 22.5598C3.675 22.3366 3.5 22.0111 3.5 21.5833V17.2375C3.5 16.9653 3.57778 16.7222 3.73333 16.5083C3.88889 16.2944 4.10278 16.1583 4.375 16.1L12.8333 14L4.375 11.9C4.10278 11.8417 3.88889 11.7055 3.73333 11.4917C3.57778 11.2778 3.5 11.0347 3.5 10.7625V6.41666C3.5 5.98888 3.675 5.66299 4.025 5.43899C4.375 5.21577 4.74444 5.18194 5.13333 5.33749L23.1 12.9208C23.5861 13.1347 23.8292 13.4944 23.8292 14C23.8292 14.5055 23.5861 14.8653 23.1 15.0792L5.13333 22.6625Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$j; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-send",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$i = "/*!@:host*/.sc-swirl-icon-settings-h{display:inline-flex}";

class SwirlIconSettings {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M13 8.00004C13 7.84671 12.9933 7.70004 12.98 7.54671L14.22 6.60671C14.4867 6.40671 14.56 6.03337 14.3933 5.74004L13.1467 3.58671C12.98 3.29337 12.62 3.17337 12.3133 3.30671L10.88 3.91337C10.6333 3.74004 10.3733 3.58671 10.1 3.46004L9.90666 1.92004C9.86666 1.58671 9.57999 1.33337 9.24666 1.33337H6.75999C6.41999 1.33337 6.13332 1.58671 6.09332 1.92004L5.89999 3.46004C5.62666 3.58671 5.36666 3.74004 5.11999 3.91337L3.68666 3.30671C3.37999 3.17337 3.01999 3.29337 2.85332 3.58671L1.60666 5.74671C1.43999 6.04004 1.51332 6.40671 1.77999 6.61337L3.01999 7.55337C3.00666 7.70004 2.99999 7.84671 2.99999 8.00004C2.99999 8.15337 3.00666 8.30004 3.01999 8.45337L1.77999 9.39337C1.51332 9.59337 1.43999 9.96671 1.60666 10.26L2.85332 12.4134C3.01999 12.7067 3.37999 12.8267 3.68666 12.6934L5.11999 12.0867C5.36666 12.26 5.62666 12.4134 5.89999 12.54L6.09332 14.08C6.13332 14.4134 6.41999 14.6667 6.75332 14.6667H9.23999C9.57332 14.6667 9.85999 14.4134 9.89999 14.08L10.0933 12.54C10.3667 12.4134 10.6267 12.26 10.8733 12.0867L12.3067 12.6934C12.6133 12.8267 12.9733 12.7067 13.14 12.4134L14.3867 10.26C14.5533 9.96671 14.48 9.60004 14.2133 9.39337L12.9733 8.45337C12.9933 8.30004 13 8.15337 13 8.00004ZM8.02666 10.3334C6.73999 10.3334 5.69332 9.28671 5.69332 8.00004C5.69332 6.71337 6.73999 5.66671 8.02666 5.66671C9.31332 5.66671 10.36 6.71337 10.36 8.00004C10.36 9.28671 9.31332 10.3334 8.02666 10.3334Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M19.5 12C19.5 11.77 19.49 11.55 19.47 11.32L21.33 9.91C21.73 9.61 21.84 9.05 21.59 8.61L19.72 5.38C19.47 4.94 18.93 4.76 18.47 4.96L16.32 5.87C15.95 5.61 15.56 5.38 15.15 5.19L14.86 2.88C14.8 2.38 14.37 2 13.87 2H10.14C9.63 2 9.2 2.38 9.14 2.88L8.85 5.19C8.44 5.38 8.05 5.61 7.68 5.87L5.53 4.96C5.07 4.76 4.53 4.94 4.28 5.38L2.41 8.62C2.16 9.06 2.27 9.61 2.67 9.92L4.53 11.33C4.51 11.55 4.5 11.77 4.5 12C4.5 12.23 4.51 12.45 4.53 12.68L2.67 14.09C2.27 14.39 2.16 14.95 2.41 15.39L4.28 18.62C4.53 19.06 5.07 19.24 5.53 19.04L7.68 18.13C8.05 18.39 8.44 18.62 8.85 18.81L9.14 21.12C9.2 21.62 9.63 22 10.13 22H13.86C14.36 22 14.79 21.62 14.85 21.12L15.14 18.81C15.55 18.62 15.94 18.39 16.31 18.13L18.46 19.04C18.92 19.24 19.46 19.06 19.71 18.62L21.58 15.39C21.83 14.95 21.72 14.4 21.32 14.09L19.46 12.68C19.49 12.45 19.5 12.23 19.5 12ZM12.04 15.5C10.11 15.5 8.54 13.93 8.54 12C8.54 10.07 10.11 8.5 12.04 8.5C13.97 8.5 15.54 10.07 15.54 12C15.54 13.93 13.97 15.5 12.04 15.5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M22.75 14C22.75 13.7317 22.7383 13.475 22.715 13.2067L24.885 11.5617C25.3517 11.2117 25.48 10.5584 25.1883 10.045L23.0067 6.27671C22.715 5.76337 22.085 5.55337 21.5483 5.78671L19.04 6.84837C18.6083 6.54504 18.1533 6.27671 17.675 6.05504L17.3367 3.36004C17.2667 2.77671 16.765 2.33337 16.1817 2.33337H11.83C11.235 2.33337 10.7333 2.77671 10.6633 3.36004L10.325 6.05504C9.84667 6.27671 9.39167 6.54504 8.96001 6.84837L6.45167 5.78671C5.91501 5.55337 5.28501 5.76337 4.99334 6.27671L2.81167 10.0567C2.52001 10.57 2.64834 11.2117 3.11501 11.5734L5.28501 13.2184C5.26167 13.475 5.25001 13.7317 5.25001 14C5.25001 14.2684 5.26167 14.525 5.28501 14.7934L3.11501 16.4384C2.64834 16.7884 2.52001 17.4417 2.81167 17.955L4.99334 21.7234C5.28501 22.2367 5.91501 22.4467 6.45167 22.2134L8.96001 21.1517C9.39167 21.455 9.84667 21.7234 10.325 21.945L10.6633 24.64C10.7333 25.2234 11.235 25.6667 11.8183 25.6667H16.17C16.7533 25.6667 17.255 25.2234 17.325 24.64L17.6633 21.945C18.1417 21.7234 18.5967 21.455 19.0283 21.1517L21.5367 22.2134C22.0733 22.4467 22.7033 22.2367 22.995 21.7234L25.1767 17.955C25.4683 17.4417 25.34 16.8 24.8733 16.4384L22.7033 14.7934C22.7383 14.525 22.75 14.2684 22.75 14ZM14.0467 18.0834C11.795 18.0834 9.96334 16.2517 9.96334 14C9.96334 11.7484 11.795 9.91671 14.0467 9.91671C16.2983 9.91671 18.13 11.7484 18.13 14C18.13 16.2517 16.2983 18.0834 14.0467 18.0834Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$i; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-settings",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$h = "/*!@:host*/.sc-swirl-icon-short-text-h{display:inline-flex}";

class SwirlIconShortText {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.33335 7.33333C3.14446 7.33333 2.98613 7.26944 2.85835 7.14167C2.73058 7.01389 2.66669 6.85556 2.66669 6.66667C2.66669 6.47778 2.73058 6.31944 2.85835 6.19167C2.98613 6.06389 3.14446 6 3.33335 6H12.6667C12.8556 6 13.0139 6.06389 13.1417 6.19167C13.2695 6.31944 13.3334 6.47778 13.3334 6.66667C13.3334 6.85556 13.2695 7.01389 13.1417 7.14167C13.0139 7.26944 12.8556 7.33333 12.6667 7.33333H3.33335ZM3.33335 10C3.14446 10 2.98613 9.93611 2.85835 9.80833C2.73058 9.68056 2.66669 9.52222 2.66669 9.33333C2.66669 9.14444 2.73058 8.98611 2.85835 8.85833C2.98613 8.73056 3.14446 8.66667 3.33335 8.66667H8.66669C8.85558 8.66667 9.01391 8.73056 9.14169 8.85833C9.26947 8.98611 9.33335 9.14444 9.33335 9.33333C9.33335 9.52222 9.26947 9.68056 9.14169 9.80833C9.01391 9.93611 8.85558 10 8.66669 10H3.33335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5 11C4.71667 11 4.47917 10.9042 4.2875 10.7125C4.09583 10.5208 4 10.2833 4 10C4 9.71667 4.09583 9.47917 4.2875 9.2875C4.47917 9.09583 4.71667 9 5 9H19C19.2833 9 19.5208 9.09583 19.7125 9.2875C19.9042 9.47917 20 9.71667 20 10C20 10.2833 19.9042 10.5208 19.7125 10.7125C19.5208 10.9042 19.2833 11 19 11H5ZM5 15C4.71667 15 4.47917 14.9042 4.2875 14.7125C4.09583 14.5208 4 14.2833 4 14C4 13.7167 4.09583 13.4792 4.2875 13.2875C4.47917 13.0958 4.71667 13 5 13H13C13.2833 13 13.5208 13.0958 13.7125 13.2875C13.9042 13.4792 14 13.7167 14 14C14 14.2833 13.9042 14.5208 13.7125 14.7125C13.5208 14.9042 13.2833 15 13 15H5Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M5.83332 12.8333C5.50277 12.8333 5.22568 12.7215 5.00207 12.4979C4.77846 12.2743 4.66666 11.9972 4.66666 11.6667C4.66666 11.3361 4.77846 11.059 5.00207 10.8354C5.22568 10.6118 5.50277 10.5 5.83332 10.5H22.1667C22.4972 10.5 22.7743 10.6118 22.9979 10.8354C23.2215 11.059 23.3333 11.3361 23.3333 11.6667C23.3333 11.9972 23.2215 12.2743 22.9979 12.4979C22.7743 12.7215 22.4972 12.8333 22.1667 12.8333H5.83332ZM5.83332 17.5C5.50277 17.5 5.22568 17.3882 5.00207 17.1646C4.77846 16.941 4.66666 16.6639 4.66666 16.3333C4.66666 16.0028 4.77846 15.7257 5.00207 15.5021C5.22568 15.2785 5.50277 15.1667 5.83332 15.1667H15.1667C15.4972 15.1667 15.7743 15.2785 15.9979 15.5021C16.2215 15.7257 16.3333 16.0028 16.3333 16.3333C16.3333 16.6639 16.2215 16.941 15.9979 17.1646C15.7743 17.3882 15.4972 17.5 15.1667 17.5H5.83332Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$h; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-short-text",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$g = "/*!@:host*/.sc-swirl-icon-simplify-h{display:inline-flex}";

class SwirlIconSimplify {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M9.30002 13.5998L13.2667 12.3665C13.2111 12.2665 13.1306 12.1804 13.025 12.1082C12.9195 12.0359 12.8 11.9998 12.6667 11.9998H9.30002C9.00002 11.9998 8.76113 11.9887 8.58335 11.9665C8.40558 11.9443 8.22224 11.8998 8.03335 11.8332L7.08335 11.5165C6.90558 11.4609 6.7778 11.3498 6.70002 11.1832C6.62224 11.0165 6.61113 10.8443 6.66669 10.6665C6.72224 10.4887 6.83058 10.3582 6.99169 10.2748C7.1528 10.1915 7.32224 10.1776 7.50002 10.2332L8.20002 10.4665C8.38891 10.5221 8.6028 10.5665 8.84169 10.5998C9.08058 10.6332 9.40558 10.6554 9.81669 10.6665H10C10 10.5443 9.96391 10.4276 9.89169 10.3165C9.81946 10.2054 9.73335 10.1332 9.63335 10.0998L5.73335 8.6665H4.66669V12.3332L9.30002 13.5998ZM8.95002 14.8998L4.66669 13.6998C4.5778 13.9887 4.4028 14.2221 4.14169 14.3998C3.88058 14.5776 3.61113 14.6665 3.33335 14.6665H2.00002C1.63335 14.6665 1.31946 14.5359 1.05835 14.2748C0.797243 14.0137 0.666687 13.6998 0.666687 13.3332V8.6665C0.666687 8.29984 0.797243 7.98595 1.05835 7.72484C1.31946 7.46373 1.63335 7.33317 2.00002 7.33317H5.73335C5.81113 7.33317 5.88891 7.3415 5.96669 7.35817C6.04446 7.37484 6.11669 7.39428 6.18335 7.4165L10.1 8.8665C10.4667 8.99984 10.7639 9.23317 10.9917 9.5665C11.2195 9.89984 11.3334 10.2665 11.3334 10.6665H12.6667C13.2222 10.6665 13.6945 10.8498 14.0834 11.2165C14.4722 11.5832 14.6667 12.0665 14.6667 12.6665C14.6667 12.9109 14.6028 13.1026 14.475 13.2415C14.3472 13.3804 14.15 13.4943 13.8834 13.5832L9.71669 14.8832C9.59446 14.9276 9.46669 14.9498 9.33335 14.9498C9.20002 14.9498 9.07224 14.9332 8.95002 14.8998ZM2.00002 13.3332H3.33335V8.6665H2.00002V13.3332Z", fill: "currentColor" }), hAsync("path", { d: "M10.5209 5.479L11.6667 7.99984L12.8125 5.479L15.3334 4.33317L12.8125 3.18734L11.6667 0.666504L10.5209 3.18734L8.00002 4.33317L10.5209 5.479Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M13.95 20.4L19.9 18.55C19.8167 18.4 19.6958 18.2708 19.5375 18.1625C19.3792 18.0542 19.2 18 19 18H13.95C13.5 18 13.1417 17.9833 12.875 17.95C12.6083 17.9167 12.3333 17.85 12.05 17.75L10.625 17.275C10.3583 17.1917 10.1667 17.025 10.05 16.775C9.93333 16.525 9.91667 16.2667 10 16C10.0833 15.7333 10.2458 15.5375 10.4875 15.4125C10.7292 15.2875 10.9833 15.2667 11.25 15.35L12.3 15.7C12.5833 15.7833 12.9042 15.85 13.2625 15.9C13.6208 15.95 14.1083 15.9833 14.725 16H15C15 15.8167 14.9458 15.6417 14.8375 15.475C14.7292 15.3083 14.6 15.2 14.45 15.15L8.6 13H7V18.5L13.95 20.4ZM13.425 22.35L7 20.55C6.86667 20.9833 6.60417 21.3333 6.2125 21.6C5.82083 21.8667 5.41667 22 5 22H3C2.45 22 1.97917 21.8042 1.5875 21.4125C1.19583 21.0208 1 20.55 1 20V13C1 12.45 1.19583 11.9792 1.5875 11.5875C1.97917 11.1958 2.45 11 3 11H8.6C8.71667 11 8.83333 11.0125 8.95 11.0375C9.06667 11.0625 9.175 11.0917 9.275 11.125L15.15 13.3C15.7 13.5 16.1458 13.85 16.4875 14.35C16.8292 14.85 17 15.4 17 16H19C19.8333 16 20.5417 16.275 21.125 16.825C21.7083 17.375 22 18.1 22 19C22 19.3667 21.9042 19.6542 21.7125 19.8625C21.5208 20.0708 21.225 20.2417 20.825 20.375L14.575 22.325C14.3917 22.3917 14.2 22.425 14 22.425C13.8 22.425 13.6083 22.4 13.425 22.35ZM3 20H5V13H3V20Z", fill: "currentColor" }), hAsync("path", { d: "M15.7812 8.21875L17.5 12L19.2188 8.21875L23 6.5L19.2188 4.78125L17.5 1L15.7812 4.78125L12 6.5L15.7812 8.21875Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M16.275 23.7998L23.2167 21.6415C23.1194 21.4665 22.9785 21.3158 22.7937 21.1894C22.609 21.063 22.4 20.9998 22.1667 20.9998H16.275C15.75 20.9998 15.3319 20.9804 15.0208 20.9415C14.7097 20.9026 14.3889 20.8248 14.0583 20.7082L12.3958 20.154C12.0847 20.0568 11.8611 19.8623 11.725 19.5707C11.5889 19.279 11.5694 18.9776 11.6667 18.6665C11.7639 18.3554 11.9535 18.1269 12.2354 17.9811C12.5174 17.8353 12.8139 17.811 13.125 17.9082L14.35 18.3165C14.6805 18.4137 15.0549 18.4915 15.4729 18.5498C15.891 18.6082 16.4597 18.6471 17.1792 18.6665H17.5C17.5 18.4526 17.4368 18.2485 17.3104 18.054C17.184 17.8596 17.0333 17.7332 16.8583 17.6748L10.0333 15.1665H8.16666V21.5832L16.275 23.7998ZM15.6625 26.0748L8.16666 23.9748C8.0111 24.4804 7.70485 24.8887 7.24791 25.1998C6.79096 25.511 6.31943 25.6665 5.83332 25.6665H3.49999C2.85832 25.6665 2.30902 25.438 1.85207 24.9811C1.39513 24.5241 1.16666 23.9748 1.16666 23.3332V15.1665C1.16666 14.5248 1.39513 13.9755 1.85207 13.5186C2.30902 13.0616 2.85832 12.8332 3.49999 12.8332H10.0333C10.1694 12.8332 10.3055 12.8478 10.4417 12.8769C10.5778 12.9061 10.7042 12.9401 10.8208 12.979L17.675 15.5165C18.3167 15.7498 18.8368 16.1582 19.2354 16.7415C19.634 17.3248 19.8333 17.9665 19.8333 18.6665H22.1667C23.1389 18.6665 23.9653 18.9873 24.6458 19.629C25.3264 20.2707 25.6667 21.1165 25.6667 22.1665C25.6667 22.5943 25.5549 22.9297 25.3312 23.1728C25.1076 23.4158 24.7625 23.6151 24.2958 23.7707L17.0042 26.0457C16.7903 26.1235 16.5667 26.1623 16.3333 26.1623C16.1 26.1623 15.8764 26.1332 15.6625 26.0748ZM3.49999 23.3332H5.83332V15.1665H3.49999V23.3332Z", fill: "currentColor" }), hAsync("path", { d: "M18.4114 9.58838L20.4167 13.9998L22.4219 9.58838L26.8333 7.58317L22.4219 5.57796L20.4167 1.1665L18.4114 5.57796L14 7.58317L18.4114 9.58838Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$g; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-simplify",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$f = "/*!@:host*/.sc-swirl-icon-spellcheck-h{display:inline-flex}";

class SwirlIconSpellcheck {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M9.40002 14.4667C9.33335 14.4667 9.27224 14.4556 9.21669 14.4333C9.16113 14.4111 9.10558 14.3722 9.05002 14.3167L7.03335 12.3C6.91113 12.1778 6.85002 12.0222 6.85002 11.8333C6.85002 11.6444 6.91113 11.4889 7.03335 11.3667C7.15558 11.2444 7.31113 11.1833 7.50002 11.1833C7.68891 11.1833 7.84446 11.2444 7.96669 11.3667L9.40002 12.8L12.7 9.5C12.8222 9.37778 12.9778 9.31667 13.1667 9.31667C13.3556 9.31667 13.5111 9.37778 13.6334 9.5C13.7556 9.62222 13.8167 9.77778 13.8167 9.96667C13.8167 10.1556 13.7556 10.3111 13.6334 10.4333L9.75002 14.3167C9.69447 14.3722 9.63891 14.4111 9.58335 14.4333C9.5278 14.4556 9.46669 14.4667 9.40002 14.4667ZM2.93335 10.6667C2.6778 10.6667 2.49169 10.5833 2.37502 10.4167C2.25835 10.25 2.24446 10.0444 2.33335 9.8L4.96669 2.73333C5.04446 2.53333 5.18335 2.36111 5.38335 2.21667C5.58335 2.07222 5.79446 2 6.01669 2C6.23891 2 6.45002 2.07222 6.65002 2.21667C6.85002 2.36111 6.98891 2.53333 7.06669 2.73333L9.70002 9.75C9.78891 10.0056 9.77224 10.2222 9.65002 10.4C9.5278 10.5778 9.3278 10.6667 9.05002 10.6667C8.89446 10.6667 8.74724 10.6167 8.60835 10.5167C8.46947 10.4167 8.37224 10.2944 8.31669 10.15L7.73335 8.46667H4.23335L3.63335 10.1833C3.5778 10.3167 3.48613 10.4306 3.35835 10.525C3.23058 10.6194 3.08891 10.6667 2.93335 10.6667ZM4.70002 7.2H7.30002L6.03335 3.6H5.96669L4.70002 7.2Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M14.1 21.7C14 21.7 13.9083 21.6833 13.825 21.65C13.7417 21.6167 13.6583 21.5583 13.575 21.475L10.55 18.45C10.3667 18.2667 10.275 18.0333 10.275 17.75C10.275 17.4667 10.3667 17.2333 10.55 17.05C10.7333 16.8667 10.9667 16.775 11.25 16.775C11.5333 16.775 11.7667 16.8667 11.95 17.05L14.1 19.2L19.05 14.25C19.2333 14.0667 19.4667 13.975 19.75 13.975C20.0333 13.975 20.2667 14.0667 20.45 14.25C20.6333 14.4333 20.725 14.6667 20.725 14.95C20.725 15.2333 20.6333 15.4667 20.45 15.65L14.625 21.475C14.5417 21.5583 14.4583 21.6167 14.375 21.65C14.2917 21.6833 14.2 21.7 14.1 21.7ZM4.4 16C4.01667 16 3.7375 15.875 3.5625 15.625C3.3875 15.375 3.36667 15.0667 3.5 14.7L7.45 4.1C7.56667 3.8 7.775 3.54167 8.075 3.325C8.375 3.10833 8.69167 3 9.025 3C9.35833 3 9.675 3.10833 9.975 3.325C10.275 3.54167 10.4833 3.8 10.6 4.1L14.55 14.625C14.6833 15.0083 14.6583 15.3333 14.475 15.6C14.2917 15.8667 13.9917 16 13.575 16C13.3417 16 13.1208 15.925 12.9125 15.775C12.7042 15.625 12.5583 15.4417 12.475 15.225L11.6 12.7H6.35L5.45 15.275C5.36667 15.475 5.22917 15.6458 5.0375 15.7875C4.84583 15.9292 4.63333 16 4.4 16ZM7.05 10.8H10.95L9.05 5.4H8.95L7.05 10.8Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M16.45 25.3167C16.3333 25.3167 16.2264 25.2972 16.1292 25.2583C16.0319 25.2194 15.9347 25.1514 15.8375 25.0542L12.3083 21.525C12.0944 21.3111 11.9875 21.0389 11.9875 20.7083C11.9875 20.3778 12.0944 20.1056 12.3083 19.8917C12.5222 19.6778 12.7944 19.5708 13.125 19.5708C13.4555 19.5708 13.7278 19.6778 13.9417 19.8917L16.45 22.4L22.225 16.625C22.4389 16.4111 22.7111 16.3042 23.0417 16.3042C23.3722 16.3042 23.6444 16.4111 23.8583 16.625C24.0722 16.8389 24.1792 17.1111 24.1792 17.4417C24.1792 17.7722 24.0722 18.0444 23.8583 18.2583L17.0625 25.0542C16.9653 25.1514 16.868 25.2194 16.7708 25.2583C16.6736 25.2972 16.5667 25.3167 16.45 25.3167ZM5.13332 18.6667C4.6861 18.6667 4.36041 18.5208 4.15624 18.2292C3.95207 17.9375 3.92777 17.5778 4.08332 17.15L8.69166 4.78333C8.82777 4.43333 9.07082 4.13194 9.42082 3.87917C9.77082 3.62639 10.1403 3.5 10.5292 3.5C10.918 3.5 11.2875 3.62639 11.6375 3.87917C11.9875 4.13194 12.2305 4.43333 12.3667 4.78333L16.975 17.0625C17.1305 17.5097 17.1014 17.8889 16.8875 18.2C16.6736 18.5111 16.3236 18.6667 15.8375 18.6667C15.5653 18.6667 15.3076 18.5792 15.0646 18.4042C14.8215 18.2292 14.6514 18.0153 14.5542 17.7625L13.5333 14.8167H7.40832L6.35832 17.8208C6.2611 18.0542 6.10068 18.2535 5.87707 18.4187C5.65346 18.584 5.40555 18.6667 5.13332 18.6667ZM8.22499 12.6H12.775L10.5583 6.3H10.4417L8.22499 12.6Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$f; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-spellcheck",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$e = "/*!@:host*/.sc-swirl-icon-sync-h{display:inline-flex}";

class SwirlIconSync {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.82754 10.5882C7.94754 10.4682 8.09014 10.4082 8.25534 10.4082C8.42014 10.4082 8.55753 10.4632 8.66753 10.5732L9.80752 11.7132V3.20818C9.80752 3.03818 9.86512 2.89578 9.98032 2.78098C10.0951 2.66578 10.2375 2.60818 10.4075 2.60818C10.5775 2.60818 10.7201 2.66578 10.8353 2.78098C10.9501 2.89578 11.0075 3.03818 11.0075 3.20818V11.7132L12.1475 10.5732C12.2575 10.4632 12.3951 10.4082 12.5603 10.4082C12.7251 10.4082 12.8675 10.4682 12.9875 10.5882C13.0975 10.6982 13.1525 10.8382 13.1525 11.0082C13.1525 11.1782 13.0975 11.3182 12.9875 11.4282L10.8275 13.5882C10.7675 13.6482 10.7025 13.6908 10.6325 13.716C10.5625 13.7408 10.4875 13.7532 10.4075 13.7532C10.3275 13.7532 10.2525 13.7408 10.1825 13.716C10.1125 13.6908 10.0475 13.6482 9.98752 13.5882L7.82754 11.4282C7.70754 11.3082 7.65015 11.1658 7.65534 11.001C7.66014 10.8358 7.71754 10.6982 7.82754 10.5882ZM3.0276 4.58819L5.18757 2.42818C5.24757 2.36818 5.31257 2.32578 5.38257 2.30098C5.45257 2.27578 5.52757 2.26318 5.60757 2.26318C5.68757 2.26318 5.76257 2.27578 5.83257 2.30098C5.90257 2.32578 5.96756 2.36818 6.02756 2.42818L8.18754 4.58819C8.29754 4.69819 8.35514 4.83579 8.36034 5.00099C8.36514 5.16579 8.30754 5.30819 8.18754 5.42819C8.07754 5.54819 7.94014 5.61059 7.77534 5.61539C7.61015 5.62059 7.46755 5.56319 7.34755 5.44319L6.20756 4.30319V12.8082C6.20756 12.9782 6.15016 13.1206 6.03536 13.2354C5.92017 13.3506 5.77757 13.4082 5.60757 13.4082C5.43757 13.4082 5.29517 13.3506 5.18037 13.2354C5.06518 13.1206 5.00758 12.9782 5.00758 12.8082V4.30319L3.86759 5.44319C3.75759 5.55319 3.61759 5.61059 3.44759 5.61539C3.27759 5.62059 3.1376 5.56319 3.0276 5.44319C2.9076 5.33319 2.8476 5.19319 2.8476 5.02319C2.8476 4.85319 2.9076 4.70819 3.0276 4.58819Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M11.7413 15.882C11.9213 15.702 12.1352 15.612 12.383 15.612C12.6302 15.612 12.8363 15.6945 13.0013 15.8595L14.7113 17.5695V4.81203C14.7113 4.55703 14.7977 4.34343 14.9705 4.17123C15.1427 3.99843 15.3563 3.91203 15.6113 3.91203C15.8663 3.91203 16.0802 3.99843 16.253 4.17123C16.4252 4.34343 16.5113 4.55703 16.5113 4.81203V17.5695L18.2212 15.8595C18.3862 15.6945 18.5926 15.612 18.8404 15.612C19.0876 15.612 19.3012 15.702 19.4812 15.882C19.6462 16.047 19.7287 16.257 19.7287 16.512C19.7287 16.767 19.6462 16.977 19.4812 17.142L16.2413 20.3821C16.1513 20.4721 16.0538 20.536 15.9488 20.5738C15.8438 20.611 15.7313 20.6296 15.6113 20.6296C15.4913 20.6296 15.3788 20.611 15.2738 20.5738C15.1688 20.536 15.0713 20.4721 14.9813 20.3821L11.7413 17.142C11.5613 16.962 11.4752 16.7484 11.483 16.5012C11.4902 16.2534 11.5763 16.047 11.7413 15.882ZM4.5414 6.88204L7.78136 3.64203C7.87136 3.55203 7.96886 3.48843 8.07386 3.45123C8.17885 3.41343 8.29135 3.39453 8.41135 3.39453C8.53135 3.39453 8.64385 3.41343 8.74885 3.45123C8.85385 3.48843 8.95135 3.55203 9.04134 3.64203L12.2813 6.88204C12.4463 7.04704 12.5327 7.25344 12.5405 7.50124C12.5477 7.74844 12.4613 7.96204 12.2813 8.14204C12.1163 8.32204 11.9102 8.41564 11.663 8.42284C11.4152 8.43064 11.2013 8.34454 11.0213 8.16454L9.31134 6.45453V19.2121C9.31134 19.4671 9.22524 19.6807 9.05305 19.8529C8.88025 20.0257 8.66635 20.1121 8.41135 20.1121C8.15636 20.1121 7.94276 20.0257 7.77056 19.8529C7.59776 19.6807 7.51136 19.4671 7.51136 19.2121V6.45453L5.80138 8.16454C5.63638 8.32954 5.42639 8.41564 5.17139 8.42284C4.91639 8.43064 4.7064 8.34454 4.5414 8.16454C4.3614 7.99954 4.2714 7.78954 4.2714 7.53454C4.2714 7.27954 4.3614 7.06204 4.5414 6.88204Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M13.6982 18.5292C13.9082 18.3192 14.1577 18.2142 14.4468 18.2142C14.7352 18.2142 14.9757 18.3105 15.1682 18.503L17.1632 20.498V5.6142C17.1632 5.3167 17.264 5.0675 17.4656 4.8666C17.6665 4.665 17.9157 4.5642 18.2132 4.5642C18.5106 4.5642 18.7602 4.665 18.9618 4.8666C19.1627 5.0675 19.2631 5.3167 19.2631 5.6142V20.498L21.2581 18.503C21.4506 18.3105 21.6914 18.2142 21.9805 18.2142C22.2689 18.2142 22.5181 18.3192 22.7281 18.5292C22.9206 18.7217 23.0168 18.9667 23.0168 19.2642C23.0168 19.5617 22.9206 19.8067 22.7281 19.9992L18.9481 23.7792C18.8431 23.8842 18.7294 23.9588 18.6069 24.0029C18.4844 24.0463 18.3531 24.068 18.2132 24.068C18.0732 24.068 17.9419 24.0463 17.8194 24.0029C17.6969 23.9588 17.5832 23.8842 17.4782 23.7792L13.6982 19.9992C13.4882 19.7892 13.3878 19.54 13.3969 19.2516C13.4053 18.9625 13.5057 18.7217 13.6982 18.5292ZM5.2983 8.0292L9.07826 4.2492C9.18325 4.1442 9.297 4.07 9.4195 4.0266C9.542 3.9825 9.67325 3.96045 9.81325 3.96045C9.95325 3.96045 10.0845 3.9825 10.207 4.0266C10.3295 4.07 10.4432 4.1442 10.5482 4.2492L14.3282 8.0292C14.5207 8.2217 14.6215 8.4625 14.6306 8.7516C14.639 9.04001 14.5382 9.28921 14.3282 9.49921C14.1357 9.70921 13.8953 9.81841 13.6069 9.82681C13.3178 9.83591 13.0682 9.73546 12.8582 9.52546L10.8632 7.53045V22.4142C10.8632 22.7117 10.7628 22.9609 10.5619 23.1618C10.3603 23.3634 10.1107 23.4642 9.81325 23.4642C9.51575 23.4642 9.26655 23.3634 9.06566 23.1618C8.86406 22.9609 8.76326 22.7117 8.76326 22.4142V7.53045L6.76828 9.52546C6.57578 9.71796 6.33079 9.81841 6.03329 9.82681C5.73579 9.83591 5.4908 9.73546 5.2983 9.52546C5.0883 9.33296 4.9833 9.08796 4.9833 8.79046C4.9833 8.49296 5.0883 8.2392 5.2983 8.0292Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$e; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-sync",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$d = "/*!@:host*/.sc-swirl-icon-tasks-filled-h{display:inline-flex}";

class SwirlIconTasksFilled {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M8 14C11.3137 14 14 11.3137 14 8C14 4.68629 11.3137 2 8 2C4.68629 2 2 4.68629 2 8C2 11.3137 4.68629 14 8 14ZM10.5303 7.03033C10.8232 6.73744 10.8232 6.26256 10.5303 5.96967C10.2374 5.67678 9.76257 5.67678 9.46967 5.96967L7 8.43934L6.53033 7.96967C6.23744 7.67678 5.76256 7.67678 5.46967 7.96967C5.17678 8.26256 5.17678 8.73744 5.46967 9.03033L6.46967 10.0303C6.76257 10.3232 7.23744 10.3232 7.53033 10.0303L10.5303 7.03033Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21ZM15.7955 10.5455C16.2348 10.1062 16.2348 9.39384 15.7955 8.9545C15.3562 8.51516 14.6438 8.51516 14.2045 8.9545L10.5 12.659L9.79549 11.9545C9.35615 11.5152 8.64384 11.5152 8.2045 11.9545C7.76516 12.3938 7.76517 13.1062 8.20451 13.5455L9.70451 15.0455C10.1438 15.4848 10.8562 15.4848 11.2955 15.0455L15.7955 10.5455Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M14 24.5C19.799 24.5 24.5 19.799 24.5 14C24.5 8.20101 19.799 3.5 14 3.5C8.20101 3.5 3.5 8.20101 3.5 14C3.5 19.799 8.20101 24.5 14 24.5ZM18.4281 12.3031C18.9406 11.7905 18.9406 10.9595 18.4281 10.4469C17.9155 9.93436 17.0845 9.93436 16.5719 10.4469L12.25 14.7688L11.4281 13.9469C10.9155 13.4344 10.0845 13.4344 9.57192 13.9469C9.05936 14.4595 9.05936 15.2905 9.57192 15.8031L11.3219 17.5531C11.8345 18.0656 12.6655 18.0656 13.1781 17.5531L18.4281 12.3031Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$d; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-tasks-filled",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$c = "/*!@:host*/.sc-swirl-icon-tasks-outlined-h{display:inline-flex}";

class SwirlIconTasksOutlined {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M10.3536 6.85355C10.5488 6.65829 10.5488 6.34171 10.3536 6.14645C10.1583 5.95118 9.84171 5.95118 9.64645 6.14645L7 8.79289L6.35355 8.14645C6.15829 7.95118 5.84171 7.95118 5.64645 8.14645C5.45118 8.34171 5.45118 8.65829 5.64645 8.85355L6.64645 9.85355C6.84171 10.0488 7.15829 10.0488 7.35356 9.85355L10.3536 6.85355Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M14 8C14 11.3137 11.3137 14 8 14C4.68629 14 2 11.3137 2 8C2 4.68629 4.68629 2 8 2C11.3137 2 14 4.68629 14 8ZM13 8C13 10.7614 10.7614 13 8 13C5.23858 13 3 10.7614 3 8C3 5.23858 5.23858 3 8 3C10.7614 3 13 5.23858 13 8Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M15.5303 10.2803C15.8232 9.98744 15.8232 9.51256 15.5303 9.21967C15.2374 8.92678 14.7626 8.92678 14.4697 9.21967L10.5 13.1893L9.53033 12.2197C9.23744 11.9268 8.76256 11.9268 8.46967 12.2197C8.17678 12.5126 8.17678 12.9874 8.46967 13.2803L9.96967 14.7803C10.2626 15.0732 10.7374 15.0732 11.0303 14.7803L15.5303 10.2803Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12ZM19.5 12C19.5 16.1421 16.1421 19.5 12 19.5C7.85786 19.5 4.5 16.1421 4.5 12C4.5 7.85786 7.85786 4.5 12 4.5C16.1421 4.5 19.5 7.85786 19.5 12Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M18.1187 11.9937C18.4604 11.652 18.4604 11.098 18.1187 10.7563C17.777 10.4146 17.223 10.4146 16.8813 10.7563L12.25 15.3876L11.1187 14.2563C10.777 13.9146 10.223 13.9146 9.88128 14.2563C9.53957 14.598 9.53957 15.152 9.88128 15.4937L11.6313 17.2437C11.973 17.5854 12.527 17.5854 12.8687 17.2437L18.1187 11.9937Z", fill: "currentColor" }), hAsync("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M24.5 14C24.5 19.799 19.799 24.5 14 24.5C8.20101 24.5 3.5 19.799 3.5 14C3.5 8.20101 8.20101 3.5 14 3.5C19.799 3.5 24.5 8.20101 24.5 14ZM22.75 14C22.75 18.8325 18.8325 22.75 14 22.75C9.16751 22.75 5.25 18.8325 5.25 14C5.25 9.16751 9.16751 5.25 14 5.25C18.8325 5.25 22.75 9.16751 22.75 14Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$c; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-tasks-outlined",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$b = "/*!@:host*/.sc-swirl-icon-time-filled-h{display:inline-flex}";

class SwirlIconTimeFilled {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M9.75001 10.6834C9.87223 10.8056 10.0222 10.8667 10.2 10.8667C10.3778 10.8667 10.5333 10.8 10.6667 10.6667C10.7889 10.5445 10.85 10.3889 10.85 10.2C10.85 10.0112 10.7889 9.8556 10.6667 9.73337L8.66668 7.73337V5.31671C8.66668 5.12782 8.6029 4.97226 8.47534 4.85004C8.34734 4.72782 8.1889 4.66671 8.00001 4.66671C7.81112 4.66671 7.6529 4.73049 7.52534 4.85804C7.39734 4.98604 7.33334 5.14448 7.33334 5.33337V7.98337C7.33334 8.07226 7.35001 8.15826 7.38334 8.24137C7.41668 8.32493 7.46668 8.40004 7.53334 8.46671L9.75001 10.6834ZM8.00001 14.6667C7.07779 14.6667 6.21112 14.4916 5.40001 14.1414C4.5889 13.7916 3.88334 13.3167 3.28334 12.7167C2.68334 12.1167 2.20845 11.4112 1.85868 10.6C1.50845 9.78893 1.33334 8.92226 1.33334 8.00004C1.33334 7.07782 1.50845 6.21115 1.85868 5.40004C2.20845 4.58893 2.68334 3.88337 3.28334 3.28337C3.88334 2.68337 4.5889 2.20826 5.40001 1.85804C6.21112 1.50826 7.07779 1.33337 8.00001 1.33337C8.92223 1.33337 9.7889 1.50826 10.6 1.85804C11.4111 2.20826 12.1167 2.68337 12.7167 3.28337C13.3167 3.88337 13.7916 4.58893 14.1413 5.40004C14.4916 6.21115 14.6667 7.07782 14.6667 8.00004C14.6667 8.92226 14.4916 9.78893 14.1413 10.6C13.7916 11.4112 13.3167 12.1167 12.7167 12.7167C12.1167 13.3167 11.4111 13.7916 10.6 14.1414C9.7889 14.4916 8.92223 14.6667 8.00001 14.6667Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M14.625 16.025C14.8083 16.2083 15.0333 16.3 15.3 16.3C15.5667 16.3 15.8 16.2 16 16C16.1833 15.8167 16.275 15.5833 16.275 15.3C16.275 15.0167 16.1833 14.7833 16 14.6L13 11.6V7.975C13 7.69167 12.9043 7.45833 12.713 7.275C12.521 7.09167 12.2833 7 12 7C11.7167 7 11.4793 7.09567 11.288 7.287C11.096 7.479 11 7.71667 11 8V11.975C11 12.1083 11.025 12.2373 11.075 12.362C11.125 12.4873 11.2 12.6 11.3 12.7L14.625 16.025ZM12 22C10.6167 22 9.31667 21.7373 8.1 21.212C6.88333 20.6873 5.825 19.975 4.925 19.075C4.025 18.175 3.31267 17.1167 2.788 15.9C2.26267 14.6833 2 13.3833 2 12C2 10.6167 2.26267 9.31667 2.788 8.1C3.31267 6.88333 4.025 5.825 4.925 4.925C5.825 4.025 6.88333 3.31233 8.1 2.787C9.31667 2.26233 10.6167 2 12 2C13.3833 2 14.6833 2.26233 15.9 2.787C17.1167 3.31233 18.175 4.025 19.075 4.925C19.975 5.825 20.6873 6.88333 21.212 8.1C21.7373 9.31667 22 10.6167 22 12C22 13.3833 21.7373 14.6833 21.212 15.9C20.6873 17.1167 19.975 18.175 19.075 19.075C18.175 19.975 17.1167 20.6873 15.9 21.212C14.6833 21.7373 13.3833 22 12 22Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M17.0625 18.6959C17.2764 18.9098 17.5389 19.0167 17.85 19.0167C18.1611 19.0167 18.4333 18.9 18.6667 18.6667C18.8806 18.4528 18.9875 18.1806 18.9875 17.85C18.9875 17.5195 18.8806 17.2473 18.6667 17.0334L15.1667 13.5334V9.30421C15.1667 8.97365 15.0551 8.70143 14.8318 8.48754C14.6078 8.27365 14.3306 8.16671 14 8.16671C13.6695 8.16671 13.3926 8.27832 13.1693 8.50154C12.9453 8.72554 12.8333 9.00282 12.8333 9.33337V13.9709C12.8333 14.1264 12.8625 14.2769 12.9208 14.4224C12.9792 14.5686 13.0667 14.7 13.1833 14.8167L17.0625 18.6959ZM14 25.6667C12.3861 25.6667 10.8695 25.3603 9.45001 24.7474C8.03057 24.1353 6.79584 23.3042 5.74584 22.2542C4.69584 21.2042 3.86479 19.9695 3.25268 18.55C2.63979 17.1306 2.33334 15.6139 2.33334 14C2.33334 12.3862 2.63979 10.8695 3.25268 9.45004C3.86479 8.0306 4.69584 6.79587 5.74584 5.74587C6.79584 4.69587 8.03057 3.86443 9.45001 3.25154C10.8695 2.63943 12.3861 2.33337 14 2.33337C15.6139 2.33337 17.1306 2.63943 18.55 3.25154C19.9695 3.86443 21.2042 4.69587 22.2542 5.74587C23.3042 6.79587 24.1352 8.0306 24.7473 9.45004C25.3602 10.8695 25.6667 12.3862 25.6667 14C25.6667 15.6139 25.3602 17.1306 24.7473 18.55C24.1352 19.9695 23.3042 21.2042 22.2542 22.2542C21.2042 23.3042 19.9695 24.1353 18.55 24.7474C17.1306 25.3603 15.6139 25.6667 14 25.6667Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$b; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-time-filled",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$a = "/*!@:host*/.sc-swirl-icon-time-outlined-h{display:inline-flex}";

class SwirlIconTimeOutlined {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M9.65001 10.6667C9.78335 10.8 9.94735 10.8667 10.142 10.8667C10.3362 10.8667 10.5056 10.7945 10.65 10.65C10.7833 10.5167 10.85 10.3471 10.85 10.1413C10.85 9.93601 10.7833 9.76668 10.65 9.63335L8.73335 7.70001V5.40001C8.73335 5.1889 8.66401 5.01668 8.52535 4.88335C8.38623 4.75001 8.21112 4.68335 8.00001 4.68335C7.7889 4.68335 7.61401 4.75268 7.47535 4.89135C7.33623 5.03046 7.26668 5.20557 7.26668 5.41668V7.96668C7.26668 8.06668 7.28623 8.16379 7.32535 8.25801C7.36401 8.35268 7.42223 8.4389 7.50001 8.51668L9.65001 10.6667ZM8.00001 14.8C7.05557 14.8 6.16935 14.6222 5.34135 14.2667C4.51379 13.9111 3.79446 13.4278 3.18335 12.8167C2.57223 12.2056 2.0889 11.4862 1.73335 10.6587C1.37779 9.83068 1.20001 8.94446 1.20001 8.00001C1.20001 7.05557 1.37779 6.16935 1.73335 5.34135C2.0889 4.51379 2.57223 3.79446 3.18335 3.18335C3.79446 2.57223 4.51379 2.0889 5.34135 1.73335C6.16935 1.37779 7.05557 1.20001 8.00001 1.20001C8.94446 1.20001 9.83068 1.37779 10.6587 1.73335C11.4862 2.0889 12.2056 2.57223 12.8167 3.18335C13.4278 3.79446 13.9111 4.51379 14.2667 5.34135C14.6222 6.16935 14.8 7.05557 14.8 8.00001C14.8 8.94446 14.6222 9.83068 14.2667 10.6587C13.9111 11.4862 13.4278 12.2056 12.8167 12.8167C12.2056 13.4278 11.4862 13.9111 10.6587 14.2667C9.83068 14.6222 8.94446 14.8 8.00001 14.8ZM8.00001 13.2833C9.46668 13.2833 10.714 12.7696 11.742 11.742C12.7696 10.714 13.2833 9.46668 13.2833 8.00001C13.2833 6.53335 12.7696 5.28601 11.742 4.25801C10.714 3.23046 9.46668 2.71668 8.00001 2.71668C6.53335 2.71668 5.28623 3.23046 4.25868 4.25801C3.23068 5.28601 2.71668 6.53335 2.71668 8.00001C2.71668 9.46668 3.23068 10.714 4.25868 11.742C5.28623 12.7696 6.53335 13.2833 8.00001 13.2833Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M14.475 16C14.675 16.2 14.921 16.3 15.213 16.3C15.5043 16.3 15.7583 16.1917 15.975 15.975C16.175 15.775 16.275 15.5207 16.275 15.212C16.275 14.904 16.175 14.65 15.975 14.45L13.1 11.55V8.09999C13.1 7.78332 12.996 7.52499 12.788 7.32499C12.5793 7.12499 12.3167 7.02499 12 7.02499C11.6833 7.02499 11.421 7.12899 11.213 7.33699C11.0043 7.54565 10.9 7.80832 10.9 8.12499V11.95C10.9 12.1 10.9293 12.2457 10.988 12.387C11.046 12.529 11.1333 12.6583 11.25 12.775L14.475 16ZM12 22.2C10.5833 22.2 9.25399 21.9333 8.01199 21.4C6.77065 20.8667 5.69165 20.1417 4.77499 19.225C3.85832 18.3083 3.13332 17.2293 2.59999 15.988C2.06665 14.746 1.79999 13.4167 1.79999 12C1.79999 10.5833 2.06665 9.25399 2.59999 8.01199C3.13332 6.77065 3.85832 5.69165 4.77499 4.77499C5.69165 3.85832 6.77065 3.13332 8.01199 2.59999C9.25399 2.06665 10.5833 1.79999 12 1.79999C13.4167 1.79999 14.746 2.06665 15.988 2.59999C17.2293 3.13332 18.3083 3.85832 19.225 4.77499C20.1417 5.69165 20.8667 6.77065 21.4 8.01199C21.9333 9.25399 22.2 10.5833 22.2 12C22.2 13.4167 21.9333 14.746 21.4 15.988C20.8667 17.2293 20.1417 18.3083 19.225 19.225C18.3083 20.1417 17.2293 20.8667 15.988 21.4C14.746 21.9333 13.4167 22.2 12 22.2ZM12 19.925C14.2 19.925 16.071 19.1543 17.613 17.613C19.1543 16.071 19.925 14.2 19.925 12C19.925 9.79999 19.1543 7.92899 17.613 6.38699C16.071 4.84565 14.2 4.07499 12 4.07499C9.79999 4.07499 7.92932 4.84565 6.38799 6.38699C4.84599 7.92899 4.07499 9.79999 4.07499 12C4.07499 14.2 4.84599 16.071 6.38799 17.613C7.92932 19.1543 9.79999 19.925 12 19.925Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M16.8875 18.6667C17.1208 18.9 17.4078 19.0167 17.7485 19.0167C18.0884 19.0167 18.3847 18.8903 18.6375 18.6375C18.8708 18.4042 18.9875 18.1074 18.9875 17.7473C18.9875 17.388 18.8708 17.0917 18.6375 16.8583L15.2833 13.475V9.45001C15.2833 9.08056 15.162 8.77917 14.9193 8.54584C14.6759 8.31251 14.3694 8.19584 14 8.19584C13.6306 8.19584 13.3245 8.31717 13.0818 8.55984C12.8384 8.80328 12.7167 9.10973 12.7167 9.47917V13.9417C12.7167 14.1167 12.7509 14.2866 12.8193 14.4515C12.887 14.6172 12.9889 14.7681 13.125 14.9042L16.8875 18.6667ZM14 25.9C12.3472 25.9 10.7963 25.5889 9.34734 24.9667C7.89912 24.3445 6.64028 23.4986 5.57084 22.4292C4.5014 21.3597 3.65556 20.1009 3.03334 18.6527C2.41112 17.2037 2.10001 15.6528 2.10001 14C2.10001 12.3472 2.41112 10.7963 3.03334 9.34734C3.65556 7.89912 4.5014 6.64028 5.57084 5.57084C6.64028 4.5014 7.89912 3.65556 9.34734 3.03334C10.7963 2.41112 12.3472 2.10001 14 2.10001C15.6528 2.10001 17.2037 2.41112 18.6527 3.03334C20.1009 3.65556 21.3597 4.5014 22.4292 5.57084C23.4986 6.64028 24.3445 7.89912 24.9667 9.34734C25.5889 10.7963 25.9 12.3472 25.9 14C25.9 15.6528 25.5889 17.2037 24.9667 18.6527C24.3445 20.1009 23.4986 21.3597 22.4292 22.4292C21.3597 23.4986 20.1009 24.3445 18.6527 24.9667C17.2037 25.5889 15.6528 25.9 14 25.9ZM14 23.2458C16.5667 23.2458 18.7495 22.3467 20.5485 20.5485C22.3467 18.7495 23.2458 16.5667 23.2458 14C23.2458 11.4333 22.3467 9.25051 20.5485 7.45151C18.7495 5.65328 16.5667 4.75417 14 4.75417C11.4333 4.75417 9.2509 5.65328 7.45267 7.45151C5.65367 9.25051 4.75417 11.4333 4.75417 14C4.75417 16.5667 5.65367 18.7495 7.45267 20.5485C9.2509 22.3467 11.4333 23.2458 14 23.2458Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$a; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-time-outlined",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$9 = "/*!@:host*/.sc-swirl-icon-today-h{display:inline-flex}";

class SwirlIconToday {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M6 11C5.53333 11 5.13889 10.8389 4.81667 10.5167C4.49444 10.1945 4.33333 9.80004 4.33333 9.33337C4.33333 8.86671 4.49444 8.47226 4.81667 8.15004C5.13889 7.82782 5.53333 7.66671 6 7.66671C6.46667 7.66671 6.86111 7.82782 7.18333 8.15004C7.50556 8.47226 7.66667 8.86671 7.66667 9.33337C7.66667 9.80004 7.50556 10.1945 7.18333 10.5167C6.86111 10.8389 6.46667 11 6 11ZM3.33333 14.6667C2.96667 14.6667 2.65267 14.5363 2.39133 14.2754C2.13044 14.014 2 13.7 2 13.3334V4.00004C2 3.63337 2.13044 3.3196 2.39133 3.05871C2.65267 2.79737 2.96667 2.66671 3.33333 2.66671H4V2.00004C4 1.81115 4.06378 1.65271 4.19133 1.52471C4.31933 1.39715 4.47778 1.33337 4.66667 1.33337C4.85556 1.33337 5.014 1.39715 5.142 1.52471C5.26956 1.65271 5.33333 1.81115 5.33333 2.00004V2.66671H10.6667V2.00004C10.6667 1.81115 10.7307 1.65271 10.8587 1.52471C10.9862 1.39715 11.1444 1.33337 11.3333 1.33337C11.5222 1.33337 11.6804 1.39715 11.808 1.52471C11.936 1.65271 12 1.81115 12 2.00004V2.66671H12.6667C13.0333 2.66671 13.3473 2.79737 13.6087 3.05871C13.8696 3.3196 14 3.63337 14 4.00004V13.3334C14 13.7 13.8696 14.014 13.6087 14.2754C13.3473 14.5363 13.0333 14.6667 12.6667 14.6667H3.33333ZM3.33333 13.3334H12.6667V6.66671H3.33333V13.3334Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M9 16.5C8.3 16.5 7.70833 16.2583 7.225 15.775C6.74167 15.2917 6.5 14.7 6.5 14C6.5 13.3 6.74167 12.7083 7.225 12.225C7.70833 11.7417 8.3 11.5 9 11.5C9.7 11.5 10.2917 11.7417 10.775 12.225C11.2583 12.7083 11.5 13.3 11.5 14C11.5 14.7 11.2583 15.2917 10.775 15.775C10.2917 16.2583 9.7 16.5 9 16.5ZM5 22C4.45 22 3.979 21.8043 3.587 21.413C3.19567 21.021 3 20.55 3 20V6C3 5.45 3.19567 4.97933 3.587 4.588C3.979 4.196 4.45 4 5 4H6V3C6 2.71667 6.09567 2.479 6.287 2.287C6.479 2.09567 6.71667 2 7 2C7.28333 2 7.521 2.09567 7.713 2.287C7.90433 2.479 8 2.71667 8 3V4H16V3C16 2.71667 16.096 2.479 16.288 2.287C16.4793 2.09567 16.7167 2 17 2C17.2833 2 17.5207 2.09567 17.712 2.287C17.904 2.479 18 2.71667 18 3V4H19C19.55 4 20.021 4.196 20.413 4.588C20.8043 4.97933 21 5.45 21 6V20C21 20.55 20.8043 21.021 20.413 21.413C20.021 21.8043 19.55 22 19 22H5ZM5 20H19V10H5V20Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M10.5 19.25C9.68333 19.25 8.99306 18.9681 8.42917 18.4042C7.86528 17.8403 7.58333 17.15 7.58333 16.3334C7.58333 15.5167 7.86528 14.8264 8.42917 14.2625C8.99306 13.6987 9.68333 13.4167 10.5 13.4167C11.3167 13.4167 12.0069 13.6987 12.5708 14.2625C13.1347 14.8264 13.4167 15.5167 13.4167 16.3334C13.4167 17.15 13.1347 17.8403 12.5708 18.4042C12.0069 18.9681 11.3167 19.25 10.5 19.25ZM5.83333 25.6667C5.19167 25.6667 4.64217 25.4384 4.18483 24.9819C3.72828 24.5245 3.5 23.975 3.5 23.3334V7.00004C3.5 6.35837 3.72828 5.80926 4.18483 5.35271C4.64217 4.89537 5.19167 4.66671 5.83333 4.66671H7V3.50004C7 3.16949 7.11161 2.89221 7.33483 2.66821C7.55883 2.44499 7.83611 2.33337 8.16667 2.33337C8.49722 2.33337 8.7745 2.44499 8.9985 2.66821C9.22172 2.89221 9.33333 3.16949 9.33333 3.50004V4.66671H18.6667V3.50004C18.6667 3.16949 18.7787 2.89221 19.0027 2.66821C19.2259 2.44499 19.5028 2.33337 19.8333 2.33337C20.1639 2.33337 20.4408 2.44499 20.664 2.66821C20.888 2.89221 21 3.16949 21 3.50004V4.66671H22.1667C22.8083 4.66671 23.3578 4.89537 23.8152 5.35271C24.2717 5.80926 24.5 6.35837 24.5 7.00004V23.3334C24.5 23.975 24.2717 24.5245 23.8152 24.9819C23.3578 25.4384 22.8083 25.6667 22.1667 25.6667H5.83333ZM5.83333 23.3334H22.1667V11.6667H5.83333V23.3334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$9; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-today",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$8 = "/*!@:host*/.sc-swirl-icon-undo-h{display:inline-flex}";

class SwirlIconUndo {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M5.33335 12.6664C5.14446 12.6664 4.98612 12.6025 4.85835 12.4747C4.73057 12.3469 4.66668 12.1886 4.66668 11.9997C4.66668 11.8108 4.73057 11.6525 4.85835 11.5247C4.98612 11.3969 5.14446 11.333 5.33335 11.333H9.40001C10.1 11.333 10.7083 11.1108 11.225 10.6664C11.7417 10.2219 12 9.66637 12 8.99971C12 8.33304 11.7417 7.77748 11.225 7.33304C10.7083 6.8886 10.1 6.66637 9.40001 6.66637H5.20001L6.46668 7.93304C6.5889 8.05526 6.65001 8.21082 6.65001 8.39971C6.65001 8.5886 6.5889 8.74415 6.46668 8.86637C6.34446 8.9886 6.1889 9.04971 6.00001 9.04971C5.81112 9.04971 5.65557 8.9886 5.53335 8.86637L3.13335 6.46637C3.06668 6.39971 3.01946 6.32748 2.99168 6.24971C2.9639 6.17193 2.95001 6.0886 2.95001 5.99971C2.95001 5.91082 2.9639 5.82748 2.99168 5.74971C3.01946 5.67193 3.06668 5.59971 3.13335 5.53304L5.53335 3.13304C5.65557 3.01082 5.81112 2.94971 6.00001 2.94971C6.1889 2.94971 6.34446 3.01082 6.46668 3.13304C6.5889 3.25526 6.65001 3.41082 6.65001 3.59971C6.65001 3.7886 6.5889 3.94415 6.46668 4.06637L5.20001 5.33304H9.40001C10.4778 5.33304 11.4028 5.68304 12.175 6.38304C12.9472 7.08304 13.3333 7.95526 13.3333 8.99971C13.3333 10.0442 12.9472 10.9164 12.175 11.6164C11.4028 12.3164 10.4778 12.6664 9.40001 12.6664H5.33335Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M7.99999 18.9998C7.71665 18.9998 7.47915 18.904 7.28749 18.7123C7.09582 18.5206 6.99999 18.2831 6.99999 17.9998C6.99999 17.7165 7.09582 17.479 7.28749 17.2873C7.47915 17.0956 7.71665 16.9998 7.99999 16.9998H14.1C15.15 16.9998 16.0625 16.6665 16.8375 15.9998C17.6125 15.3331 18 14.4998 18 13.4998C18 12.4998 17.6125 11.6665 16.8375 10.9998C16.0625 10.3331 15.15 9.9998 14.1 9.9998H7.79999L9.69999 11.8998C9.88332 12.0831 9.97499 12.3165 9.97499 12.5998C9.97499 12.8831 9.88332 13.1165 9.69999 13.2998C9.51665 13.4831 9.28332 13.5748 8.99999 13.5748C8.71665 13.5748 8.48332 13.4831 8.29999 13.2998L4.69999 9.6998C4.59999 9.5998 4.52915 9.49147 4.48749 9.3748C4.44582 9.25814 4.42499 9.13314 4.42499 8.9998C4.42499 8.86647 4.44582 8.74147 4.48749 8.6248C4.52915 8.50814 4.59999 8.3998 4.69999 8.2998L8.29999 4.6998C8.48332 4.51647 8.71665 4.4248 8.99999 4.4248C9.28332 4.4248 9.51665 4.51647 9.69999 4.6998C9.88332 4.88314 9.97499 5.11647 9.97499 5.3998C9.97499 5.68314 9.88332 5.91647 9.69999 6.0998L7.79999 7.9998H14.1C15.7167 7.9998 17.1042 8.5248 18.2625 9.5748C19.4208 10.6248 20 11.9331 20 13.4998C20 15.0665 19.4208 16.3748 18.2625 17.4248C17.1042 18.4748 15.7167 18.9998 14.1 18.9998H7.99999Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M9.33334 22.1663C9.00278 22.1663 8.7257 22.0545 8.50209 21.8309C8.27848 21.6072 8.16667 21.3302 8.16667 20.9996C8.16667 20.6691 8.27848 20.392 8.50209 20.1684C8.7257 19.9447 9.00278 19.8329 9.33334 19.8329H16.45C17.675 19.8329 18.7396 19.4441 19.6438 18.6663C20.5479 17.8885 21 16.9163 21 15.7496C21 14.5829 20.5479 13.6107 19.6438 12.8329C18.7396 12.0552 17.675 11.6663 16.45 11.6663H9.10001L11.3167 13.8829C11.5306 14.0968 11.6375 14.3691 11.6375 14.6996C11.6375 15.0302 11.5306 15.3024 11.3167 15.5163C11.1028 15.7302 10.8306 15.8371 10.5 15.8371C10.1695 15.8371 9.89723 15.7302 9.68334 15.5163L5.48334 11.3163C5.36667 11.1996 5.28403 11.0732 5.23542 10.9371C5.18681 10.801 5.16251 10.6552 5.16251 10.4996C5.16251 10.3441 5.18681 10.1982 5.23542 10.0621C5.28403 9.926 5.36667 9.79961 5.48334 9.68294L9.68334 5.48294C9.89723 5.26905 10.1695 5.16211 10.5 5.16211C10.8306 5.16211 11.1028 5.26905 11.3167 5.48294C11.5306 5.69683 11.6375 5.96905 11.6375 6.29961C11.6375 6.63017 11.5306 6.90239 11.3167 7.11628L9.10001 9.33294H16.45C18.3361 9.33294 19.9549 9.94544 21.3063 11.1704C22.6576 12.3954 23.3333 13.9218 23.3333 15.7496C23.3333 17.5774 22.6576 19.1038 21.3063 20.3288C19.9549 21.5538 18.3361 22.1663 16.45 22.1663H9.33334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$8; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-undo",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$7 = "/*!@:host*/.sc-swirl-icon-unlock-person-h{display:inline-flex}";

class SwirlIconUnlockPerson {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M3.99733 13.3339V6.66724H11.9973V7.3339C12.464 7.3339 12.9107 7.40057 13.3307 7.52724V6.66724C13.3307 5.9339 12.7307 5.3339 11.9973 5.3339H3.99733C3.264 5.3339 2.664 5.9339 2.664 6.66724V13.3339C2.664 14.0672 3.264 14.6672 3.99733 14.6672H8.17067C7.89067 14.2672 7.67067 13.8139 7.524 13.3339H3.99733ZM9.99733 5.3339H5.99733Z", fill: "currentColor" }), hAsync("path", { d: "M11.9973 8.66724C10.1573 8.66724 8.664 10.1606 8.664 12.0006C8.664 13.8406 10.1573 15.3339 11.9973 15.3339C13.8373 15.3339 15.3307 13.8406 15.3307 12.0006C15.3307 10.1606 13.8373 8.66724 11.9973 8.66724ZM11.9973 10.0006C12.5507 10.0006 12.9973 10.4472 12.9973 11.0006C12.9973 11.5539 12.5507 12.0006 11.9973 12.0006C11.444 12.0006 10.9973 11.5539 10.9973 11.0006C10.9973 10.4472 11.444 10.0006 11.9973 10.0006ZM11.9973 14.0006C11.3107 14.0006 10.704 13.6539 10.344 13.1206C10.8307 12.8406 11.3907 12.6672 11.9973 12.6672C12.604 12.6672 13.164 12.8406 13.6507 13.1206C13.2907 13.6539 12.684 14.0006 11.9973 14.0006Z", fill: "currentColor" }), hAsync("path", { d: "M11.3307 5.3339V4.00057C11.3307 2.16057 9.83734 0.667236 7.99734 0.667236C6.15734 0.667236 4.664 2.16057 4.664 4.00057H5.99734C5.99734 2.8939 6.89067 2.00057 7.99734 2.00057C9.104 2.00057 9.99734 2.8939 9.99734 4.00057L9.99733 5.3339L11.3307 5.3339Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M5.99597 20.0007V10.0007H17.996V11.0007C18.696 11.0007 19.366 11.1007 19.996 11.2907V10.0007C19.996 8.90073 19.096 8.00073 17.996 8.00073H5.99597C4.89597 8.00073 3.99597 8.90073 3.99597 10.0007V20.0007C3.99597 21.1007 4.89597 22.0007 5.99597 22.0007H12.256C11.836 21.4007 11.506 20.7207 11.286 20.0007H5.99597ZM14.996 8.00073H8.99597Z", fill: "currentColor" }), hAsync("path", { d: "M17.996 13.0007C15.236 13.0007 12.996 15.2407 12.996 18.0007C12.996 20.7607 15.236 23.0007 17.996 23.0007C20.756 23.0007 22.996 20.7607 22.996 18.0007C22.996 15.2407 20.756 13.0007 17.996 13.0007ZM17.996 15.0007C18.826 15.0007 19.496 15.6707 19.496 16.5007C19.496 17.3307 18.826 18.0007 17.996 18.0007C17.166 18.0007 16.496 17.3307 16.496 16.5007C16.496 15.6707 17.166 15.0007 17.996 15.0007ZM17.996 21.0007C16.966 21.0007 16.056 20.4807 15.516 19.6807C16.246 19.2607 17.086 19.0007 17.996 19.0007C18.906 19.0007 19.746 19.2607 20.476 19.6807C19.936 20.4807 19.026 21.0007 17.996 21.0007Z", fill: "currentColor" }), hAsync("path", { d: "M16.996 8.00073V6.00073C16.996 3.24073 14.756 1.00073 11.996 1.00073C9.23597 1.00073 6.99597 3.24073 6.99597 6.00073H8.99597C8.99597 4.34073 10.336 3.00073 11.996 3.00073C13.656 3.00073 14.996 4.34073 14.996 6.00073L14.996 8.00073L16.996 8.00073Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M6.99532 23.3341V11.6675H20.9953V12.8341C21.812 12.8341 22.5937 12.9508 23.3287 13.1725V11.6675C23.3287 10.3841 22.2787 9.33415 20.9953 9.33415H6.99532C5.71199 9.33415 4.66199 10.3841 4.66199 11.6675V23.3341C4.66199 24.6175 5.71199 25.6675 6.99532 25.6675H14.2987C13.8087 24.9675 13.4237 24.1741 13.167 23.3341H6.99532ZM17.4953 9.33415H10.4953Z", fill: "currentColor" }), hAsync("path", { d: "M20.9953 15.1675C17.7753 15.1675 15.162 17.7808 15.162 21.0008C15.162 24.2208 17.7753 26.8341 20.9953 26.8341C24.2153 26.8341 26.8287 24.2208 26.8287 21.0008C26.8287 17.7808 24.2153 15.1675 20.9953 15.1675ZM20.9953 17.5008C21.9637 17.5008 22.7453 18.2825 22.7453 19.2508C22.7453 20.2191 21.9637 21.0008 20.9953 21.0008C20.027 21.0008 19.2453 20.2191 19.2453 19.2508C19.2453 18.2825 20.027 17.5008 20.9953 17.5008ZM20.9953 24.5008C19.7937 24.5008 18.732 23.8941 18.102 22.9608C18.9537 22.4708 19.9337 22.1675 20.9953 22.1675C22.057 22.1675 23.037 22.4708 23.8887 22.9608C23.2587 23.8941 22.197 24.5008 20.9953 24.5008Z", fill: "currentColor" }), hAsync("path", { d: "M19.8287 9.33415V7.00081C19.8287 3.78081 17.2153 1.16748 13.9953 1.16748C10.7753 1.16748 8.16199 3.78081 8.16199 7.00081H10.4953C10.4953 5.06415 12.0587 3.50081 13.9953 3.50081C15.932 3.50081 17.4953 5.06415 17.4953 7.00081L17.4953 9.33415L19.8287 9.33415Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$7; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-unlock-person",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$6 = "/*!@:host*/.sc-swirl-icon-user-assign-h{display:inline-flex}";

class SwirlIconUserAssign {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M5.33332 13.3334C5.15651 13.3334 4.98699 13.2631 4.86197 13.1381C4.73694 13.0131 4.66666 12.8436 4.66666 12.6667V12.0001C4.66666 10.2274 8.22066 9.33341 9.99999 9.33341C11.7793 9.33341 15.3333 10.2267 15.3333 12.0001V12.6667C15.3333 12.8436 15.263 13.0131 15.138 13.1381C15.013 13.2631 14.8435 13.3334 14.6667 13.3334H5.33332ZM3.33332 8.71134V8.00008H1.33332C1.15651 8.00008 0.986993 7.92979 0.861969 7.80477C0.736945 7.67974 0.666656 7.51023 0.666656 7.33341C0.666656 7.1566 0.736945 6.98708 0.861969 6.86206C0.986993 6.73704 1.15651 6.66675 1.33332 6.66675H3.33332V5.95483C3.33324 5.84937 3.36433 5.74603 3.42284 5.65828C3.48136 5.57054 3.5647 5.50213 3.6621 5.46167C3.7595 5.42121 3.86658 5.41061 3.97004 5.43107C4.0735 5.45153 4.16881 5.50242 4.24348 5.5769L5.62206 6.95679C5.722 7.0568 5.77798 7.19235 5.77798 7.33374C5.77798 7.47513 5.722 7.61068 5.62206 7.71069L4.24348 9.08927C4.19485 9.13903 4.13669 9.17879 4.07258 9.20581C4.00847 9.23283 3.93967 9.24677 3.87011 9.24683C3.79968 9.24727 3.72988 9.2338 3.6647 9.20711C3.59952 9.18042 3.54012 9.14094 3.49022 9.09123C3.44033 9.04152 3.40095 8.98248 3.37401 8.9174C3.34708 8.85232 3.33315 8.78243 3.33332 8.712V8.71134ZM7.33332 5.33341C7.33332 4.62617 7.61415 3.94777 8.11425 3.44767C8.61434 2.94758 9.29275 2.66675 9.99999 2.66675C10.7072 2.66675 11.3856 2.94758 11.8857 3.44767C12.3858 3.94777 12.6667 4.62617 12.6667 5.33341C12.6667 6.04066 12.3858 6.71906 11.8857 7.21916C11.3856 7.71925 10.7072 8.00008 9.99999 8.00008C9.29275 8.00008 8.61434 7.71925 8.11425 7.21916C7.61415 6.71906 7.33332 6.04066 7.33332 5.33341Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M8 20C7.73478 20 7.4805 19.8946 7.29297 19.707C7.10543 19.5195 7 19.2652 7 19V18C7 15.341 12.331 14 15 14C17.669 14 23 15.34 23 18V19C23 19.2652 22.8946 19.5195 22.707 19.707C22.5195 19.8946 22.2652 20 22 20H8ZM5 13.0669V12H2C1.73478 12 1.48051 11.8946 1.29297 11.707C1.10543 11.5195 1 11.2652 1 11C1 10.7348 1.10543 10.4805 1.29297 10.293C1.48051 10.1054 1.73478 10 2 10H5V8.93213C4.99988 8.77393 5.04651 8.61892 5.13428 8.4873C5.22205 8.35569 5.34707 8.25307 5.49316 8.19238C5.63926 8.1317 5.79989 8.11579 5.95508 8.14648C6.11027 8.17718 6.25324 8.25351 6.36523 8.36523L8.43311 10.4351C8.58302 10.5851 8.66699 10.7884 8.66699 11.0005C8.66699 11.2126 8.58302 11.4159 8.43311 11.5659L6.36523 13.6338C6.29229 13.7084 6.20505 13.7681 6.10889 13.8086C6.01273 13.8491 5.90953 13.87 5.80518 13.8701C5.69953 13.8708 5.59484 13.8506 5.49707 13.8105C5.3993 13.7705 5.3102 13.7113 5.23535 13.6367C5.16051 13.5622 5.10143 13.4736 5.06104 13.376C5.02064 13.2784 4.99973 13.1735 5 13.0679V13.0669ZM11 8C11 6.93913 11.4212 5.92153 12.1714 5.17139C12.9215 4.42124 13.9391 4 15 4C16.0609 4 17.0785 4.42124 17.8286 5.17139C18.5788 5.92153 19 6.93913 19 8C19 9.06087 18.5788 10.0785 17.8286 10.8286C17.0785 11.5788 16.0609 12 15 12C13.9391 12 12.9215 11.5788 12.1714 10.8286C11.4212 10.0785 11 9.06087 11 8Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M9.33332 23.3334C9.0239 23.3334 8.72725 23.2104 8.50845 22.9916C8.28966 22.7728 8.16666 22.4762 8.16666 22.1667V21.0001C8.16666 17.8979 14.3862 16.3334 17.5 16.3334C20.6138 16.3334 26.8333 17.8967 26.8333 21.0001V22.1667C26.8333 22.4762 26.7103 22.7728 26.4915 22.9916C26.2727 23.2104 25.9761 23.3334 25.6667 23.3334H9.33332ZM5.83332 15.2448V14.0001H2.33332C2.0239 14.0001 1.72725 13.8771 1.50845 13.6583C1.28966 13.4395 1.16666 13.1428 1.16666 12.8334C1.16666 12.524 1.28966 12.2273 1.50845 12.0085C1.72725 11.7898 2.0239 11.6667 2.33332 11.6667H5.83332V10.4209C5.83318 10.2363 5.88758 10.0555 5.98998 9.90194C6.09238 9.74839 6.23824 9.62866 6.40868 9.55786C6.57912 9.48706 6.76653 9.46851 6.94758 9.50431C7.12864 9.54012 7.29543 9.62917 7.4261 9.75952L9.83861 12.1743C10.0135 12.3493 10.1115 12.5866 10.1115 12.834C10.1115 13.0814 10.0135 13.3186 9.83861 13.4937L7.4261 15.9062C7.341 15.9932 7.23921 16.0628 7.12702 16.1101C7.01484 16.1574 6.89444 16.1818 6.77269 16.1819C6.64944 16.1827 6.5273 16.1591 6.41324 16.1124C6.29917 16.0657 6.19522 15.9966 6.1079 15.9096C6.02058 15.8226 5.95166 15.7193 5.90453 15.6054C5.8574 15.4915 5.83301 15.3692 5.83332 15.2459V15.2448ZM12.8333 9.33341C12.8333 8.09574 13.3248 6.90854 14.1999 6.03337C15.0751 5.1582 16.2623 4.66675 17.5 4.66675C18.7377 4.66675 19.9249 5.1582 20.8 6.03337C21.6752 6.90854 22.1667 8.09574 22.1667 9.33341C22.1667 10.5711 21.6752 11.7583 20.8 12.6335C19.9249 13.5086 18.7377 14.0001 17.5 14.0001C16.2623 14.0001 15.0751 13.5086 14.1999 12.6335C13.3248 11.7583 12.8333 10.5711 12.8333 9.33341Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$6; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-user-assign",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$5 = "/*!@:host*/.sc-swirl-icon-video-camera-h{display:inline-flex}";

class SwirlIconVideoCamera {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M2.66668 13.3334C2.30001 13.3334 1.98623 13.2029 1.72534 12.942C1.46401 12.6807 1.33334 12.3667 1.33334 12V4.00002C1.33334 3.63335 1.46401 3.31958 1.72534 3.05869C1.98623 2.79735 2.30001 2.66669 2.66668 2.66669H10.6667C11.0333 2.66669 11.3473 2.79735 11.6087 3.05869C11.8696 3.31958 12 3.63335 12 4.00002V7.00002L14.1 4.90002C14.2 4.80002 14.3196 4.77491 14.4587 4.82469C14.5973 4.87491 14.6667 4.9778 14.6667 5.13335V10.8667C14.6667 11.0222 14.5973 11.1249 14.4587 11.1747C14.3196 11.2249 14.2 11.2 14.1 11.1L12 9.00002V12C12 12.3667 11.8696 12.6807 11.6087 12.942C11.3473 13.2029 11.0333 13.3334 10.6667 13.3334H2.66668Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M4 20C3.45 20 2.97933 19.8043 2.588 19.413C2.196 19.021 2 18.55 2 18V6C2 5.45 2.196 4.97933 2.588 4.588C2.97933 4.196 3.45 4 4 4H16C16.55 4 17.021 4.196 17.413 4.588C17.8043 4.97933 18 5.45 18 6V10.5L21.15 7.35C21.3 7.2 21.4793 7.16233 21.688 7.237C21.896 7.31233 22 7.46667 22 7.7V16.3C22 16.5333 21.896 16.6873 21.688 16.762C21.4793 16.8373 21.3 16.8 21.15 16.65L18 13.5V18C18 18.55 17.8043 19.021 17.413 19.413C17.021 19.8043 16.55 20 16 20H4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M4.66668 23.3334C4.02501 23.3334 3.4759 23.1051 3.01934 22.6485C2.56201 22.1912 2.33334 21.6417 2.33334 21V7.00002C2.33334 6.35835 2.56201 5.80924 3.01934 5.35269C3.4759 4.89535 4.02501 4.66669 4.66668 4.66669H18.6667C19.3083 4.66669 19.8578 4.89535 20.3152 5.35269C20.7717 5.80924 21 6.35835 21 7.00002V12.25L24.675 8.57502C24.85 8.40002 25.0592 8.35608 25.3027 8.44319C25.5453 8.53108 25.6667 8.71113 25.6667 8.98335V19.0167C25.6667 19.2889 25.5453 19.4686 25.3027 19.5557C25.0592 19.6436 24.85 19.6 24.675 19.425L21 15.75V21C21 21.6417 20.7717 22.1912 20.3152 22.6485C19.8578 23.1051 19.3083 23.3334 18.6667 23.3334H4.66668Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$5; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-video-camera",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$4 = "/*!@:host*/.sc-swirl-icon-video-library-h{display:inline-flex}";

class SwirlIconVideoLibrary {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M11.6834 7.08334C11.8389 6.98334 11.9167 6.84445 11.9167 6.66668C11.9167 6.4889 11.8389 6.35001 11.6834 6.25001L8.43337 4.16668C8.26671 4.05557 8.09726 4.04723 7.92504 4.14168C7.75282 4.23612 7.66671 4.38334 7.66671 4.58334V8.75001C7.66671 8.95001 7.75282 9.09723 7.92504 9.19168C8.09726 9.28612 8.26671 9.27779 8.43337 9.16668L11.6834 7.08334ZM5.33337 12C4.96671 12 4.65282 11.8695 4.39171 11.6083C4.1306 11.3472 4.00004 11.0333 4.00004 10.6667V2.66668C4.00004 2.30001 4.1306 1.98612 4.39171 1.72501C4.65282 1.4639 4.96671 1.33334 5.33337 1.33334H13.3334C13.7 1.33334 14.0139 1.4639 14.275 1.72501C14.5362 1.98612 14.6667 2.30001 14.6667 2.66668V10.6667C14.6667 11.0333 14.5362 11.3472 14.275 11.6083C14.0139 11.8695 13.7 12 13.3334 12H5.33337ZM2.66671 14.6667C2.30004 14.6667 1.98615 14.5361 1.72504 14.275C1.46393 14.0139 1.33337 13.7 1.33337 13.3333V4.66668C1.33337 4.47779 1.39726 4.31945 1.52504 4.19168C1.65282 4.0639 1.81115 4.00001 2.00004 4.00001C2.18893 4.00001 2.34726 4.0639 2.47504 4.19168C2.60282 4.31945 2.66671 4.47779 2.66671 4.66668V13.3333H11.3334C11.5223 13.3333 11.6806 13.3972 11.8084 13.525C11.9362 13.6528 12 13.8111 12 14C12 14.1889 11.9362 14.3472 11.8084 14.475C11.6806 14.6028 11.5223 14.6667 11.3334 14.6667H2.66671Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M17.525 10.625C17.7583 10.475 17.875 10.2667 17.875 10C17.875 9.73333 17.7583 9.525 17.525 9.375L12.65 6.25C12.4 6.08333 12.1458 6.07083 11.8875 6.2125C11.6292 6.35417 11.5 6.575 11.5 6.875V13.125C11.5 13.425 11.6292 13.6458 11.8875 13.7875C12.1458 13.9292 12.4 13.9167 12.65 13.75L17.525 10.625ZM8 18C7.45 18 6.97917 17.8042 6.5875 17.4125C6.19583 17.0208 6 16.55 6 16V4C6 3.45 6.19583 2.97917 6.5875 2.5875C6.97917 2.19583 7.45 2 8 2H20C20.55 2 21.0208 2.19583 21.4125 2.5875C21.8042 2.97917 22 3.45 22 4V16C22 16.55 21.8042 17.0208 21.4125 17.4125C21.0208 17.8042 20.55 18 20 18H8ZM4 22C3.45 22 2.97917 21.8042 2.5875 21.4125C2.19583 21.0208 2 20.55 2 20V7C2 6.71667 2.09583 6.47917 2.2875 6.2875C2.47917 6.09583 2.71667 6 3 6C3.28333 6 3.52083 6.09583 3.7125 6.2875C3.90417 6.47917 4 6.71667 4 7V20H17C17.2833 20 17.5208 20.0958 17.7125 20.2875C17.9042 20.4792 18 20.7167 18 21C18 21.2833 17.9042 21.5208 17.7125 21.7125C17.5208 21.9042 17.2833 22 17 22H4Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M20.4459 12.3958C20.7181 12.2208 20.8542 11.9778 20.8542 11.6667C20.8542 11.3556 20.7181 11.1125 20.4459 10.9375L14.7584 7.29168C14.4667 7.09723 14.1702 7.08265 13.8688 7.24793C13.5674 7.41321 13.4167 7.67084 13.4167 8.02084V15.3125C13.4167 15.6625 13.5674 15.9202 13.8688 16.0854C14.1702 16.2507 14.4667 16.2361 14.7584 16.0417L20.4459 12.3958ZM9.33337 21C8.69171 21 8.1424 20.7715 7.68546 20.3146C7.22851 19.8577 7.00004 19.3083 7.00004 18.6667V4.66668C7.00004 4.02501 7.22851 3.4757 7.68546 3.01876C8.1424 2.56182 8.69171 2.33334 9.33337 2.33334H23.3334C23.975 2.33334 24.5243 2.56182 24.9813 3.01876C25.4382 3.4757 25.6667 4.02501 25.6667 4.66668V18.6667C25.6667 19.3083 25.4382 19.8577 24.9813 20.3146C24.5243 20.7715 23.975 21 23.3334 21H9.33337ZM4.66671 25.6667C4.02504 25.6667 3.47574 25.4382 3.01879 24.9813C2.56185 24.5243 2.33337 23.975 2.33337 23.3333V8.16668C2.33337 7.83612 2.44518 7.55904 2.66879 7.33543C2.8924 7.11182 3.16949 7.00001 3.50004 7.00001C3.8306 7.00001 4.10768 7.11182 4.33129 7.33543C4.5549 7.55904 4.66671 7.83612 4.66671 8.16668V23.3333H19.8334C20.1639 23.3333 20.441 23.4452 20.6646 23.6688C20.8882 23.8924 21 24.1695 21 24.5C21 24.8306 20.8882 25.1077 20.6646 25.3313C20.441 25.5549 20.1639 25.6667 19.8334 25.6667H4.66671Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$4; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-video-library",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$3 = "/*!@:host*/.sc-swirl-icon-visibility-h{display:inline-flex}";

class SwirlIconVisibility {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M8 3C4.66666 3 1.82 5.07333 0.666664 8C1.82 10.9267 4.66666 13 8 13C11.3333 13 14.18 10.9267 15.3333 8C14.18 5.07333 11.3333 3 8 3ZM8 11.3333C6.16 11.3333 4.66666 9.84 4.66666 8C4.66666 6.16 6.16 4.66667 8 4.66667C9.84 4.66667 11.3333 6.16 11.3333 8C11.3333 9.84 9.84 11.3333 8 11.3333ZM8 6C6.89333 6 6 6.89333 6 8C6 9.10667 6.89333 10 8 10C9.10666 10 10 9.10667 10 8C10 6.89333 9.10666 6 8 6Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 4.5C7 4.5 2.73 7.61 1 12C2.73 16.39 7 19.5 12 19.5C17 19.5 21.27 16.39 23 12C21.27 7.61 17 4.5 12 4.5ZM12 17C9.24 17 7 14.76 7 12C7 9.24 9.24 7 12 7C14.76 7 17 9.24 17 12C17 14.76 14.76 17 12 17ZM12 9C10.34 9 9 10.34 9 12C9 13.66 10.34 15 12 15C13.66 15 15 13.66 15 12C15 10.34 13.66 9 12 9Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 5.25C8.16666 5.25 3.185 8.87833 1.16666 14C3.185 19.1217 8.16666 22.75 14 22.75C19.8333 22.75 24.815 19.1217 26.8333 14C24.815 8.87833 19.8333 5.25 14 5.25ZM14 19.8333C10.78 19.8333 8.16666 17.22 8.16666 14C8.16666 10.78 10.78 8.16667 14 8.16667C17.22 8.16667 19.8333 10.78 19.8333 14C19.8333 17.22 17.22 19.8333 14 19.8333ZM14 10.5C12.0633 10.5 10.5 12.0633 10.5 14C10.5 15.9367 12.0633 17.5 14 17.5C15.9367 17.5 17.5 15.9367 17.5 14C17.5 12.0633 15.9367 10.5 14 10.5Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$3; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-visibility",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$2 = "/*!@:host*/.sc-swirl-icon-visibility-off-h{display:inline-flex}";

class SwirlIconVisibilityOff {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M7.99999 4.31339C9.83999 4.31339 11.3333 5.80672 11.3333 7.64672C11.3333 7.98672 11.2667 8.31339 11.1733 8.62006L13.2133 10.6601C14.14 9.84006 14.8733 8.81339 15.3333 7.64006C14.18 4.72006 11.3333 2.64672 7.99999 2.64672C7.15332 2.64672 6.33999 2.78006 5.57332 3.02672L7.01999 4.47339C7.33332 4.38006 7.65999 4.31339 7.99999 4.31339ZM1.80666 2.08672C1.54666 2.34672 1.54666 2.76672 1.80666 3.02672L3.11999 4.34006C2.03999 5.20006 1.17999 6.33339 0.666656 7.64672C1.81999 10.5734 4.66666 12.6467 7.99999 12.6467C9.01332 12.6467 9.97999 12.4467 10.8733 12.1001L12.6867 13.9134C12.9467 14.1734 13.3667 14.1734 13.6267 13.9134C13.8867 13.6534 13.8867 13.2334 13.6267 12.9734L2.75332 2.08672C2.49332 1.82672 2.06666 1.82672 1.80666 2.08672ZM7.99999 10.9801C6.15999 10.9801 4.66666 9.48672 4.66666 7.64672C4.66666 7.13339 4.78666 6.64672 4.99332 6.22006L6.03999 7.26672C6.01999 7.38672 5.99999 7.51339 5.99999 7.64672C5.99999 8.75339 6.89332 9.64672 7.99999 9.64672C8.13332 9.64672 8.25332 9.62672 8.37999 9.60006L9.42666 10.6467C8.99332 10.8601 8.51332 10.9801 7.99999 10.9801ZM9.97999 7.42672C9.87999 6.49339 9.14666 5.76672 8.21999 5.66672L9.97999 7.42672Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M12 6.47002C14.76 6.47002 17 8.71002 17 11.47C17 11.98 16.9 12.47 16.76 12.93L19.82 15.99C21.21 14.76 22.31 13.22 23 11.46C21.27 7.08002 17 3.97002 12 3.97002C10.73 3.97002 9.51 4.17002 8.36 4.54002L10.53 6.71002C11 6.57002 11.49 6.47002 12 6.47002ZM2.71 3.13002C2.32 3.52002 2.32 4.15002 2.71 4.54002L4.68 6.51002C3.06 7.80002 1.77 9.50002 1 11.47C2.73 15.86 7 18.97 12 18.97C13.52 18.97 14.97 18.67 16.31 18.15L19.03 20.87C19.42 21.26 20.05 21.26 20.44 20.87C20.83 20.48 20.83 19.85 20.44 19.46L4.13 3.13002C3.74 2.74002 3.1 2.74002 2.71 3.13002ZM12 16.47C9.24 16.47 7 14.23 7 11.47C7 10.7 7.18 9.97002 7.49 9.33002L9.06 10.9C9.03 11.08 9 11.27 9 11.47C9 13.13 10.34 14.47 12 14.47C12.2 14.47 12.38 14.44 12.57 14.4L14.14 15.97C13.49 16.29 12.77 16.47 12 16.47ZM14.97 11.14C14.82 9.74002 13.72 8.65002 12.33 8.50002L14.97 11.14Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M14 7.54834C17.22 7.54834 19.8333 10.1617 19.8333 13.3817C19.8333 13.9767 19.7167 14.5483 19.5533 15.085L23.1233 18.655C24.745 17.22 26.0283 15.4233 26.8333 13.37C24.815 8.26001 19.8333 4.63167 14 4.63167C12.5183 4.63167 11.095 4.86501 9.75332 5.29667L12.285 7.82834C12.8333 7.66501 13.405 7.54834 14 7.54834ZM3.16166 3.65167C2.70666 4.10667 2.70666 4.84167 3.16166 5.29667L5.45999 7.59501C3.56999 9.10001 2.06499 11.0833 1.16666 13.3817C3.18499 18.5033 8.16666 22.1317 14 22.1317C15.7733 22.1317 17.465 21.7817 19.0283 21.175L22.2017 24.3483C22.6567 24.8033 23.3917 24.8033 23.8467 24.3483C24.3017 23.8933 24.3017 23.1583 23.8467 22.7033L4.81832 3.65167C4.36332 3.19667 3.61666 3.19667 3.16166 3.65167ZM14 19.215C10.78 19.215 8.16666 16.6017 8.16666 13.3817C8.16666 12.4833 8.37666 11.6317 8.73832 10.885L10.57 12.7167C10.535 12.9267 10.5 13.1483 10.5 13.3817C10.5 15.3183 12.0633 16.8817 14 16.8817C14.2333 16.8817 14.4433 16.8467 14.665 16.8L16.4967 18.6317C15.7383 19.005 14.8983 19.215 14 19.215ZM17.465 12.9967C17.29 11.3633 16.0067 10.0917 14.385 9.91667L17.465 12.9967Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$2; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-visibility-off",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss$1 = "/*!@:host*/.sc-swirl-icon-voice-h{display:inline-flex}";

class SwirlIconVoice {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M12.75 10.0833C12.6278 9.96106 12.5639 9.80551 12.5584 9.61662C12.5528 9.42773 12.6111 9.25551 12.7334 9.09995C13.0778 8.67773 13.3472 8.20273 13.5417 7.67495C13.7361 7.14717 13.8334 6.58884 13.8334 5.99995C13.8334 5.42217 13.7361 4.87217 13.5417 4.34995C13.3472 3.82773 13.0778 3.35551 12.7334 2.93328C12.6111 2.77773 12.55 2.60551 12.55 2.41662C12.55 2.22773 12.6167 2.06662 12.75 1.93328C12.9056 1.77773 13.0917 1.69995 13.3084 1.69995C13.525 1.69995 13.7 1.77773 13.8334 1.93328C14.3 2.49995 14.6667 3.12773 14.9334 3.81662C15.2 4.50551 15.3334 5.23328 15.3334 5.99995C15.3334 6.76662 15.2 7.4944 14.9334 8.18328C14.6667 8.87217 14.3 9.49995 13.8334 10.0666C13.7 10.2222 13.525 10.3027 13.3084 10.3083C13.0917 10.3138 12.9056 10.2388 12.75 10.0833ZM10.6 7.93328C10.4778 7.81106 10.4084 7.65273 10.3917 7.45828C10.375 7.26384 10.4222 7.07217 10.5334 6.88328C10.6111 6.74995 10.6695 6.60828 10.7084 6.45828C10.7472 6.30828 10.7667 6.15551 10.7667 5.99995C10.7667 5.8444 10.7472 5.69162 10.7084 5.54162C10.6695 5.39162 10.6111 5.24995 10.5334 5.11662C10.4222 4.92773 10.375 4.73606 10.3917 4.54162C10.4084 4.34717 10.4778 4.18884 10.6 4.06662C10.7556 3.91106 10.9445 3.83606 11.1667 3.84162C11.3889 3.84717 11.5611 3.93328 11.6834 4.09995C11.8722 4.37773 12.0222 4.67495 12.1334 4.99162C12.2445 5.30828 12.3 5.6444 12.3 5.99995C12.3 6.35551 12.2445 6.69162 12.1334 7.00828C12.0222 7.32495 11.8722 7.62217 11.6834 7.89995C11.5611 8.06662 11.3889 8.15273 11.1667 8.15828C10.9445 8.16384 10.7556 8.08884 10.6 7.93328ZM6.00002 8.66662C5.26669 8.66662 4.63891 8.40551 4.11669 7.88328C3.59446 7.36106 3.33335 6.73328 3.33335 5.99995C3.33335 5.26662 3.59446 4.63884 4.11669 4.11662C4.63891 3.5944 5.26669 3.33328 6.00002 3.33328C6.73335 3.33328 7.36113 3.5944 7.88335 4.11662C8.40558 4.63884 8.66669 5.26662 8.66669 5.99995C8.66669 6.73328 8.40558 7.36106 7.88335 7.88328C7.36113 8.40551 6.73335 8.66662 6.00002 8.66662ZM1.33335 14C1.14446 14 0.986131 13.9361 0.858354 13.8083C0.730576 13.6805 0.666687 13.5222 0.666687 13.3333V12.1333C0.666687 11.7666 0.761131 11.4222 0.95002 11.1C1.13891 10.7777 1.40002 10.5333 1.73335 10.3666C2.30002 10.0777 2.93891 9.83328 3.65002 9.63328C4.36113 9.43328 5.14446 9.33328 6.00002 9.33328C6.85558 9.33328 7.63891 9.43328 8.35002 9.63328C9.06113 9.83328 9.70002 10.0777 10.2667 10.3666C10.6 10.5333 10.8611 10.7777 11.05 11.1C11.2389 11.4222 11.3334 11.7666 11.3334 12.1333V13.3333C11.3334 13.5222 11.2695 13.6805 11.1417 13.8083C11.0139 13.9361 10.8556 14 10.6667 14H1.33335ZM2.00002 12.6666H10V12.1333C10 12.0111 9.96947 11.9 9.90835 11.8C9.84724 11.7 9.76669 11.6222 9.66669 11.5666C9.26669 11.3666 8.7528 11.1666 8.12502 10.9666C7.49724 10.7666 6.78891 10.6666 6.00002 10.6666C5.21113 10.6666 4.5028 10.7666 3.87502 10.9666C3.24724 11.1666 2.73335 11.3666 2.33335 11.5666C2.23335 11.6222 2.1528 11.7 2.09169 11.8C2.03058 11.9 2.00002 12.0111 2.00002 12.1333V12.6666ZM6.00002 7.33328C6.36669 7.33328 6.68058 7.20273 6.94169 6.94162C7.2028 6.68051 7.33335 6.36662 7.33335 5.99995C7.33335 5.63328 7.2028 5.3194 6.94169 5.05828C6.68058 4.79717 6.36669 4.66662 6.00002 4.66662C5.63335 4.66662 5.31947 4.79717 5.05835 5.05828C4.79724 5.3194 4.66669 5.63328 4.66669 5.99995C4.66669 6.36662 4.79724 6.68051 5.05835 6.94162C5.31947 7.20273 5.63335 7.33328 6.00002 7.33328Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M19.125 15.125C18.9417 14.9417 18.8458 14.7084 18.8375 14.425C18.8292 14.1417 18.9167 13.8834 19.1 13.65C19.6167 13.0167 20.0208 12.3042 20.3125 11.5125C20.6042 10.7209 20.75 9.88338 20.75 9.00005C20.75 8.13338 20.6042 7.30838 20.3125 6.52505C20.0208 5.74172 19.6167 5.03338 19.1 4.40005C18.9167 4.16672 18.825 3.90838 18.825 3.62505C18.825 3.34172 18.925 3.10005 19.125 2.90005C19.3583 2.66672 19.6375 2.55005 19.9625 2.55005C20.2875 2.55005 20.55 2.66672 20.75 2.90005C21.45 3.75005 22 4.69172 22.4 5.72505C22.8 6.75838 23 7.85005 23 9.00005C23 10.15 22.8 11.2417 22.4 12.275C22 13.3084 21.45 14.25 20.75 15.1C20.55 15.3334 20.2875 15.4542 19.9625 15.4625C19.6375 15.4709 19.3583 15.3584 19.125 15.125ZM15.9 11.9C15.7167 11.7167 15.6125 11.4792 15.5875 11.1875C15.5625 10.8959 15.6333 10.6084 15.8 10.325C15.9167 10.125 16.0042 9.91255 16.0625 9.68755C16.1208 9.46255 16.15 9.23338 16.15 9.00005C16.15 8.76672 16.1208 8.53755 16.0625 8.31255C16.0042 8.08755 15.9167 7.87505 15.8 7.67505C15.6333 7.39172 15.5625 7.10422 15.5875 6.81255C15.6125 6.52088 15.7167 6.28338 15.9 6.10005C16.1333 5.86672 16.4167 5.75422 16.75 5.76255C17.0833 5.77088 17.3417 5.90005 17.525 6.15005C17.8083 6.56672 18.0333 7.01255 18.2 7.48755C18.3667 7.96255 18.45 8.46672 18.45 9.00005C18.45 9.53338 18.3667 10.0375 18.2 10.5125C18.0333 10.9875 17.8083 11.4334 17.525 11.85C17.3417 12.1 17.0833 12.2292 16.75 12.2375C16.4167 12.2459 16.1333 12.1334 15.9 11.9ZM9 13C7.9 13 6.95833 12.6084 6.175 11.825C5.39167 11.0417 5 10.1 5 9.00005C5 7.90005 5.39167 6.95838 6.175 6.17505C6.95833 5.39172 7.9 5.00005 9 5.00005C10.1 5.00005 11.0417 5.39172 11.825 6.17505C12.6083 6.95838 13 7.90005 13 9.00005C13 10.1 12.6083 11.0417 11.825 11.825C11.0417 12.6084 10.1 13 9 13ZM2 21C1.71667 21 1.47917 20.9042 1.2875 20.7125C1.09583 20.5209 1 20.2834 1 20V18.2C1 17.65 1.14167 17.1334 1.425 16.65C1.70833 16.1667 2.1 15.8 2.6 15.55C3.45 15.1167 4.40833 14.75 5.475 14.45C6.54167 14.15 7.71667 14 9 14C10.2833 14 11.4583 14.15 12.525 14.45C13.5917 14.75 14.55 15.1167 15.4 15.55C15.9 15.8 16.2917 16.1667 16.575 16.65C16.8583 17.1334 17 17.65 17 18.2V20C17 20.2834 16.9042 20.5209 16.7125 20.7125C16.5208 20.9042 16.2833 21 16 21H2ZM3 19H15V18.2C15 18.0167 14.9542 17.85 14.8625 17.7C14.7708 17.55 14.65 17.4334 14.5 17.35C13.9 17.05 13.1292 16.75 12.1875 16.45C11.2458 16.15 10.1833 16 9 16C7.81667 16 6.75417 16.15 5.8125 16.45C4.87083 16.75 4.1 17.05 3.5 17.35C3.35 17.4334 3.22917 17.55 3.1375 17.7C3.04583 17.85 3 18.0167 3 18.2V19ZM9 11C9.55 11 10.0208 10.8042 10.4125 10.4125C10.8042 10.0209 11 9.55005 11 9.00005C11 8.45005 10.8042 7.97922 10.4125 7.58755C10.0208 7.19588 9.55 7.00005 9 7.00005C8.45 7.00005 7.97917 7.19588 7.5875 7.58755C7.19583 7.97922 7 8.45005 7 9.00005C7 9.55005 7.19583 10.0209 7.5875 10.4125C7.97917 10.8042 8.45 11 9 11Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M22.3125 17.6459C22.0986 17.432 21.9868 17.1598 21.9771 16.8293C21.9673 16.4987 22.0694 16.1973 22.2833 15.9251C22.8861 15.1862 23.3576 14.355 23.6979 13.4313C24.0382 12.5077 24.2083 11.5307 24.2083 10.5001C24.2083 9.48899 24.0382 8.52649 23.6979 7.6126C23.3576 6.69871 22.8861 5.87232 22.2833 5.13343C22.0694 4.86121 21.9625 4.55982 21.9625 4.22926C21.9625 3.89871 22.0792 3.61676 22.3125 3.38343C22.5847 3.11121 22.9104 2.9751 23.2896 2.9751C23.6687 2.9751 23.975 3.11121 24.2083 3.38343C25.025 4.3751 25.6667 5.47371 26.1333 6.67926C26.6 7.88482 26.8333 9.15843 26.8333 10.5001C26.8333 11.8418 26.6 13.1154 26.1333 14.3209C25.6667 15.5265 25.025 16.6251 24.2083 17.6168C23.975 17.889 23.6687 18.03 23.2896 18.0397C22.9104 18.0494 22.5847 17.9182 22.3125 17.6459ZM18.55 13.8834C18.3361 13.6695 18.2146 13.3925 18.1854 13.0522C18.1562 12.7119 18.2389 12.3765 18.4333 12.0459C18.5694 11.8126 18.6715 11.5647 18.7396 11.3022C18.8076 11.0397 18.8417 10.7723 18.8417 10.5001C18.8417 10.2279 18.8076 9.96052 18.7396 9.69802C18.6715 9.43552 18.5694 9.1876 18.4333 8.95426C18.2389 8.62371 18.1562 8.28829 18.1854 7.94801C18.2146 7.60774 18.3361 7.33065 18.55 7.11676C18.8222 6.84454 19.1528 6.71329 19.5417 6.72301C19.9305 6.73274 20.2319 6.88343 20.4458 7.1751C20.7764 7.66121 21.0389 8.18135 21.2333 8.73551C21.4278 9.28968 21.525 9.87788 21.525 10.5001C21.525 11.1223 21.4278 11.7105 21.2333 12.2647C21.0389 12.8188 20.7764 13.339 20.4458 13.8251C20.2319 14.1168 19.9305 14.2675 19.5417 14.2772C19.1528 14.2869 18.8222 14.1557 18.55 13.8834ZM10.5 15.1668C9.21666 15.1668 8.11805 14.7098 7.20416 13.7959C6.29027 12.882 5.83332 11.7834 5.83332 10.5001C5.83332 9.21677 6.29027 8.11815 7.20416 7.20426C8.11805 6.29038 9.21666 5.83343 10.5 5.83343C11.7833 5.83343 12.8819 6.29038 13.7958 7.20426C14.7097 8.11815 15.1667 9.21677 15.1667 10.5001C15.1667 11.7834 14.7097 12.882 13.7958 13.7959C12.8819 14.7098 11.7833 15.1668 10.5 15.1668ZM2.33332 24.5001C2.00277 24.5001 1.72568 24.3883 1.50207 24.1647C1.27846 23.9411 1.16666 23.664 1.16666 23.3334V21.2334C1.16666 20.5918 1.33193 19.989 1.66249 19.4251C1.99305 18.8612 2.44999 18.4334 3.03332 18.1418C4.02499 17.6362 5.14305 17.2084 6.38749 16.8584C7.63193 16.5084 9.00277 16.3334 10.5 16.3334C11.9972 16.3334 13.368 16.5084 14.6125 16.8584C15.8569 17.2084 16.975 17.6362 17.9667 18.1418C18.55 18.4334 19.0069 18.8612 19.3375 19.4251C19.668 19.989 19.8333 20.5918 19.8333 21.2334V23.3334C19.8333 23.664 19.7215 23.9411 19.4979 24.1647C19.2743 24.3883 18.9972 24.5001 18.6667 24.5001H2.33332ZM3.49999 22.1668H17.5V21.2334C17.5 21.0195 17.4465 20.8251 17.3396 20.6501C17.2326 20.4751 17.0917 20.339 16.9167 20.2418C16.2167 19.8918 15.3174 19.5418 14.2187 19.1918C13.1201 18.8418 11.8805 18.6668 10.5 18.6668C9.11943 18.6668 7.87985 18.8418 6.78124 19.1918C5.68263 19.5418 4.78332 19.8918 4.08332 20.2418C3.90832 20.339 3.76735 20.4751 3.66041 20.6501C3.55346 20.8251 3.49999 21.0195 3.49999 21.2334V22.1668ZM10.5 12.8334C11.1417 12.8334 11.691 12.605 12.1479 12.148C12.6049 11.6911 12.8333 11.1418 12.8333 10.5001C12.8333 9.85843 12.6049 9.30913 12.1479 8.85218C11.691 8.39524 11.1417 8.16677 10.5 8.16677C9.85832 8.16677 9.30902 8.39524 8.85207 8.85218C8.39513 9.30913 8.16666 9.85843 8.16666 10.5001C8.16666 11.1418 8.39513 11.6911 8.85207 12.148C9.30902 12.605 9.85832 12.8334 10.5 12.8334Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss$1; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-voice",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlIconCss = "/*!@:host*/.sc-swirl-icon-warning-h{display:inline-flex}";

class SwirlIconWarning {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 24;
  }
  render() {
    const viewBoxSize = this.size === 20 ? 24 : this.size;
    const className = classnames("swirl-icon", `swirl-icon--size-${this.size}`);
    return (hAsync("svg", { class: className, fill: "none", height: this.size, part: "icon", viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`, width: this.size, xmlns: "http://www.w3.org/2000/svg" }, this.size === 16 && (hAsync(Fragment, null, hAsync("path", { d: "M1.81666 14C1.5611 14 1.37221 13.8889 1.24999 13.6667C1.12777 13.4444 1.12777 13.2222 1.24999 13L7.41666 2.33333C7.53888 2.11111 7.73333 2 7.99999 2C8.26666 2 8.4611 2.11111 8.58333 2.33333L14.75 13C14.8722 13.2222 14.8722 13.4444 14.75 13.6667C14.6278 13.8889 14.4389 14 14.1833 14H1.81666ZM7.99999 6.66667C7.8111 6.66667 7.65288 6.73044 7.52533 6.858C7.39733 6.986 7.33333 7.14444 7.33333 7.33333V9.33333C7.33333 9.52222 7.39733 9.68044 7.52533 9.808C7.65288 9.936 7.8111 10 7.99999 10C8.18888 10 8.34733 9.936 8.47533 9.808C8.60288 9.68044 8.66666 9.52222 8.66666 9.33333V7.33333C8.66666 7.14444 8.60288 6.986 8.47533 6.858C8.34733 6.73044 8.18888 6.66667 7.99999 6.66667ZM7.99999 12C8.18888 12 8.34733 11.936 8.47533 11.808C8.60288 11.6804 8.66666 11.5222 8.66666 11.3333C8.66666 11.1444 8.60288 10.9862 8.47533 10.8587C8.34733 10.7307 8.18888 10.6667 7.99999 10.6667C7.8111 10.6667 7.65288 10.7307 7.52533 10.8587C7.39733 10.9862 7.33333 11.1444 7.33333 11.3333C7.33333 11.5222 7.39733 11.6804 7.52533 11.808C7.65288 11.936 7.8111 12 7.99999 12Z", fill: "currentColor" }))), (this.size === 20 || this.size === 24) && (hAsync(Fragment, null, hAsync("path", { d: "M2.72499 21C2.34165 21 2.05832 20.8333 1.87499 20.5C1.69165 20.1667 1.69165 19.8333 1.87499 19.5L11.125 3.5C11.3083 3.16667 11.6 3 12 3C12.4 3 12.6917 3.16667 12.875 3.5L22.125 19.5C22.3083 19.8333 22.3083 20.1667 22.125 20.5C21.9417 20.8333 21.6583 21 21.275 21H2.72499ZM12 10C11.7167 10 11.4793 10.0957 11.288 10.287C11.096 10.479 11 10.7167 11 11V14C11 14.2833 11.096 14.5207 11.288 14.712C11.4793 14.904 11.7167 15 12 15C12.2833 15 12.521 14.904 12.713 14.712C12.9043 14.5207 13 14.2833 13 14V11C13 10.7167 12.9043 10.479 12.713 10.287C12.521 10.0957 12.2833 10 12 10ZM12 18C12.2833 18 12.521 17.904 12.713 17.712C12.9043 17.5207 13 17.2833 13 17C13 16.7167 12.9043 16.4793 12.713 16.288C12.521 16.096 12.2833 16 12 16C11.7167 16 11.4793 16.096 11.288 16.288C11.096 16.4793 11 16.7167 11 17C11 17.2833 11.096 17.5207 11.288 17.712C11.4793 17.904 11.7167 18 12 18Z", fill: "currentColor" }))), this.size === 28 && (hAsync(Fragment, null, hAsync("path", { d: "M3.17915 24.5C2.73193 24.5 2.40137 24.3056 2.18749 23.9167C1.9736 23.5278 1.9736 23.1389 2.18749 22.75L12.9792 4.08333C13.193 3.69444 13.5333 3.5 14 3.5C14.4667 3.5 14.8069 3.69444 15.0208 4.08333L25.8125 22.75C26.0264 23.1389 26.0264 23.5278 25.8125 23.9167C25.5986 24.3056 25.268 24.5 24.8208 24.5H3.17915ZM14 11.6667C13.6694 11.6667 13.3925 11.7783 13.1693 12.0015C12.9453 12.2255 12.8333 12.5028 12.8333 12.8333V16.3333C12.8333 16.6639 12.9453 16.9408 13.1693 17.164C13.3925 17.388 13.6694 17.5 14 17.5C14.3305 17.5 14.6078 17.388 14.8318 17.164C15.055 16.9408 15.1667 16.6639 15.1667 16.3333V12.8333C15.1667 12.5028 15.055 12.2255 14.8318 12.0015C14.6078 11.7783 14.3305 11.6667 14 11.6667ZM14 21C14.3305 21 14.6078 20.888 14.8318 20.664C15.055 20.4408 15.1667 20.1639 15.1667 19.8333C15.1667 19.5028 15.055 19.2259 14.8318 19.0027C14.6078 18.7787 14.3305 18.6667 14 18.6667C13.6694 18.6667 13.3925 18.7787 13.1693 19.0027C12.9453 19.2259 12.8333 19.5028 12.8333 19.8333C12.8333 20.1639 12.9453 20.4408 13.1693 20.664C13.3925 20.888 13.6694 21 14 21Z", fill: "currentColor" })))));
  }
  static get style() { return swirlIconCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-icon-warning",
    "$members$": {
      "size": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlInlineErrorCss = "/*!@:host*/.sc-swirl-inline-error-h{display:inline-flex}/*!@:host **/.sc-swirl-inline-error-h *.sc-swirl-inline-error{box-sizing:border-box}/*!@.inline-error*/.inline-error.sc-swirl-inline-error{display:inline-flex;color:var(--s-text-critical);line-height:var(--s-line-height-base)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.inline-error*/.inline-error.sc-swirl-inline-error{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.inline-error--size-s*/.inline-error--size-s.sc-swirl-inline-error{font-size:var(--s-font-size-sm)}/*!@.inline-error--size-s .inline-error__icon*/.inline-error--size-s.sc-swirl-inline-error .inline-error__icon.sc-swirl-inline-error{padding-top:0.125rem}/*!@.inline-error--size-s .inline-error__message*/.inline-error--size-s.sc-swirl-inline-error .inline-error__message.sc-swirl-inline-error{padding-top:0}/*!@.inline-error__icon*/.inline-error__icon.sc-swirl-inline-error{display:inline-flex;color:var(--s-icon-critical);align-self:flex-start}/*!@.inline-error__message*/.inline-error__message.sc-swirl-inline-error{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;margin-left:var(--s-space-4);padding-top:0.0625rem}";

class SwirlInlineError {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.message = undefined;
    this.size = "m";
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    if (!Boolean(this.iconEl)) {
      return;
    }
    const icon = this.iconEl.children[0];
    let iconSize = "24";
    if (this.size === "s") {
      iconSize = "16";
    }
    else if (smallIcon) {
      iconSize = "20";
    }
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", iconSize);
  }
  render() {
    const className = classnames("inline-error", `inline-error--size-${this.size}`);
    return (hAsync(Host, null, hAsync("span", { class: className, part: "inline-error" }, hAsync("span", { class: "inline-error__icon", ref: (el) => (this.iconEl = el) }, hAsync("swirl-icon-error", null)), hAsync("span", { class: "inline-error__message" }, this.message))));
  }
  static get style() { return swirlInlineErrorCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-inline-error",
    "$members$": {
      "message": [1],
      "size": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlInlineNotificationCss = "/*!@:host*/.sc-swirl-inline-notification-h{display:block}/*!@:host **/.sc-swirl-inline-notification-h *.sc-swirl-inline-notification{box-sizing:border-box}/*!@.inline-notification*/.inline-notification.sc-swirl-inline-notification{display:flex;max-width:100%;padding:var(--s-space-12);border-radius:var(--s-border-radius-sm);gap:var(--s-space-8)}@media (min-width: 768px){/*!@.inline-notification*/.inline-notification.sc-swirl-inline-notification{padding:var(--s-space-16)}}/*!@.inline-notification--intent-info*/.inline-notification--intent-info.sc-swirl-inline-notification{background-color:var(--s-surface-info-subdued)}/*!@.inline-notification--intent-info .inline-notification__icon*/.inline-notification--intent-info.sc-swirl-inline-notification .inline-notification__icon.sc-swirl-inline-notification{color:var(--s-icon-info)}/*!@.inline-notification--intent-critical*/.inline-notification--intent-critical.sc-swirl-inline-notification{background-color:var(--s-surface-critical-subdued)}/*!@.inline-notification--intent-critical .inline-notification__icon*/.inline-notification--intent-critical.sc-swirl-inline-notification .inline-notification__icon.sc-swirl-inline-notification{color:var(--s-icon-critical)}/*!@.inline-notification--intent-warning*/.inline-notification--intent-warning.sc-swirl-inline-notification{background-color:var(--s-surface-warning-subdued)}/*!@.inline-notification--intent-warning .inline-notification__icon*/.inline-notification--intent-warning.sc-swirl-inline-notification .inline-notification__icon.sc-swirl-inline-notification{color:var(--s-icon-warning)}/*!@.inline-notification--intent-success*/.inline-notification--intent-success.sc-swirl-inline-notification{background-color:var(--s-surface-success-subdued)}/*!@.inline-notification--intent-success .inline-notification__icon*/.inline-notification--intent-success.sc-swirl-inline-notification .inline-notification__icon.sc-swirl-inline-notification{color:var(--s-icon-success)}/*!@.inline-notification__icon*/.inline-notification__icon.sc-swirl-inline-notification{display:inline-flex}/*!@.inline-notification__content*/.inline-notification__content.sc-swirl-inline-notification{position:relative;top:0.0625rem;font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}";

class SwirlInlineNotification {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.heading = undefined;
    this.importance = "status";
    this.intent = "info";
  }
  render() {
    const className = classnames("inline-notification", `inline-notification--intent-${this.intent}`);
    return (hAsync(Host, null, hAsync("div", { "aria-describedby": "content", class: className, role: this.importance, tabIndex: 0 }, hAsync("span", { "aria-hidden": "true", class: "inline-notification__icon" }, this.intent === "critical" && (hAsync("swirl-icon-error", { size: 20 })), this.intent === "success" && (hAsync("swirl-icon-check-circle", { size: 20 })), this.intent === "warning" && (hAsync("swirl-icon-warning", { size: 20 })), this.intent === "info" && (hAsync("swirl-icon-info", { size: 20 }))), hAsync("span", { class: "inline-notification__content", id: "content" }, hAsync("swirl-text", { class: "inline-notification__heading", size: "sm", weight: "semibold" }, this.heading), hAsync("slot", null)))));
  }
  static get style() { return swirlInlineNotificationCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-inline-notification",
    "$members$": {
      "heading": [1],
      "importance": [1],
      "intent": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlInlineStatusCss = "/*!@:host*/.sc-swirl-inline-status-h{display:inline-flex}/*!@:host **/.sc-swirl-inline-status-h *.sc-swirl-inline-status{box-sizing:border-box}/*!@.inline-status*/.inline-status.sc-swirl-inline-status{display:inline-flex;color:var(--s-text-default);line-height:var(--s-line-height-base)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.inline-status*/.inline-status.sc-swirl-inline-status{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.inline-status--size-s*/.inline-status--size-s.sc-swirl-inline-status{font-size:var(--s-font-size-sm)}/*!@.inline-status--size-s .inline-status__icon*/.inline-status--size-s.sc-swirl-inline-status .inline-status__icon.sc-swirl-inline-status{padding-top:0.125rem}/*!@.inline-status--size-s .inline-status__message*/.inline-status--size-s.sc-swirl-inline-status .inline-status__message.sc-swirl-inline-status{padding-top:0}/*!@.inline-status--intent-critical*/.inline-status--intent-critical.sc-swirl-inline-status{color:var(--s-text-critical)}/*!@.inline-status--intent-critical .inline-status__icon*/.inline-status--intent-critical.sc-swirl-inline-status .inline-status__icon.sc-swirl-inline-status{color:var(--s-icon-critical)}/*!@.inline-status--intent-info*/.inline-status--intent-info.sc-swirl-inline-status{color:var(--s-text-info)}/*!@.inline-status--intent-info .inline-status__icon*/.inline-status--intent-info.sc-swirl-inline-status .inline-status__icon.sc-swirl-inline-status{color:var(--s-icon-info)}/*!@.inline-status--intent-success*/.inline-status--intent-success.sc-swirl-inline-status{color:var(--s-text-success)}/*!@.inline-status--intent-success .inline-status__icon*/.inline-status--intent-success.sc-swirl-inline-status .inline-status__icon.sc-swirl-inline-status{color:var(--s-icon-success)}/*!@.inline-status--intent-warning*/.inline-status--intent-warning.sc-swirl-inline-status{color:var(--s-text-warning)}/*!@.inline-status--intent-warning .inline-status__icon*/.inline-status--intent-warning.sc-swirl-inline-status .inline-status__icon.sc-swirl-inline-status{color:var(--s-icon-warning)}/*!@.inline-status__icon*/.inline-status__icon.sc-swirl-inline-status{display:inline-flex;margin-right:var(--s-space-4);color:var(--s-icon-default);align-self:flex-start}/*!@.inline-status__message*/.inline-status__message.sc-swirl-inline-status{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;padding-top:0.0625rem}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.inline-status__message*/.inline-status__message.sc-swirl-inline-status{padding-top:0}}";

class SwirlInlineStatus {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.icon = undefined;
    this.intent = undefined;
    this.message = undefined;
    this.size = "m";
    this.iconSize = 20;
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    if (!Boolean(this.iconEl)) {
      return;
    }
    const icon = this.iconEl.children[0];
    if (!Boolean(icon)) {
      return;
    }
    let iconSize = "24";
    if (this.size === "s") {
      iconSize = "16";
    }
    else if (smallIcon) {
      iconSize = "20";
    }
    icon.setAttribute("size", iconSize);
  }
  render() {
    const className = classnames("inline-status", `inline-status--intent-${this.intent}`, `inline-status--size-${this.size}`);
    return (hAsync(Host, null, hAsync("span", { class: className, part: "inline-status" }, this.icon && (hAsync("span", { class: "inline-status__icon", innerHTML: this.icon, ref: (el) => (this.iconEl = el) })), hAsync("span", { class: "inline-status__message" }, this.message))));
  }
  static get style() { return swirlInlineStatusCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-inline-status",
    "$members$": {
      "icon": [1],
      "intent": [1],
      "message": [1],
      "size": [1],
      "iconSize": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Older browsers don't support event options, feature detect it.

// Adopted and modified solution from Bohdan Didukh (2017)
// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi

var hasPassiveEvents = false;
if (typeof window !== 'undefined') {
  var passiveTestOptions = {
    get passive() {
      hasPassiveEvents = true;
      return undefined;
    }
  };
  window.addEventListener('testPassive', null, passiveTestOptions);
  window.removeEventListener('testPassive', null, passiveTestOptions);
}

var isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);


var locks = [];
var documentListenerAdded = false;
var initialClientY = -1;
var previousBodyOverflowSetting = void 0;
var previousBodyPosition = void 0;
var previousBodyPaddingRight = void 0;

// returns true if `el` should be allowed to receive touchmove events.
var allowTouchMove = function allowTouchMove(el) {
  return locks.some(function (lock) {
    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
      return true;
    }

    return false;
  });
};

var preventDefault = function preventDefault(rawEvent) {
  var e = rawEvent || window.event;

  // For the case whereby consumers adds a touchmove event listener to document.
  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })
  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then
  // the touchmove event on document will break.
  if (allowTouchMove(e.target)) {
    return true;
  }

  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).
  if (e.touches.length > 1) return true;

  if (e.preventDefault) e.preventDefault();

  return false;
};

var setOverflowHidden = function setOverflowHidden(options) {
  // If previousBodyPaddingRight is already set, don't set it again.
  if (previousBodyPaddingRight === undefined) {
    var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
    var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;

    if (_reserveScrollBarGap && scrollBarGap > 0) {
      var computedBodyPaddingRight = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'), 10);
      previousBodyPaddingRight = document.body.style.paddingRight;
      document.body.style.paddingRight = computedBodyPaddingRight + scrollBarGap + 'px';
    }
  }

  // If previousBodyOverflowSetting is already set, don't set it again.
  if (previousBodyOverflowSetting === undefined) {
    previousBodyOverflowSetting = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
  }
};

var restoreOverflowSetting = function restoreOverflowSetting() {
  if (previousBodyPaddingRight !== undefined) {
    document.body.style.paddingRight = previousBodyPaddingRight;

    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
    // can be set again.
    previousBodyPaddingRight = undefined;
  }

  if (previousBodyOverflowSetting !== undefined) {
    document.body.style.overflow = previousBodyOverflowSetting;

    // Restore previousBodyOverflowSetting to undefined
    // so setOverflowHidden knows it can be set again.
    previousBodyOverflowSetting = undefined;
  }
};

var setPositionFixed = function setPositionFixed() {
  return window.requestAnimationFrame(function () {
    // If previousBodyPosition is already set, don't set it again.
    if (previousBodyPosition === undefined) {
      previousBodyPosition = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left
      };

      // Update the dom inside an animation frame 
      var _window = window,
          scrollY = _window.scrollY,
          scrollX = _window.scrollX,
          innerHeight = _window.innerHeight;

      document.body.style.position = 'fixed';
      document.body.style.top = -scrollY;
      document.body.style.left = -scrollX;

      setTimeout(function () {
        return window.requestAnimationFrame(function () {
          // Attempt to check if the bottom bar appeared due to the position change
          var bottomBarHeight = innerHeight - window.innerHeight;
          if (bottomBarHeight && scrollY >= innerHeight) {
            // Move the content further up so that the bottom bar doesn't hide it
            document.body.style.top = -(scrollY + bottomBarHeight);
          }
        });
      }, 300);
    }
  });
};

var restorePositionSetting = function restorePositionSetting() {
  if (previousBodyPosition !== undefined) {
    // Convert the position from "px" to Int
    var y = -parseInt(document.body.style.top, 10);
    var x = -parseInt(document.body.style.left, 10);

    // Restore styles
    document.body.style.position = previousBodyPosition.position;
    document.body.style.top = previousBodyPosition.top;
    document.body.style.left = previousBodyPosition.left;

    // Restore scroll
    window.scrollTo(x, y);

    previousBodyPosition = undefined;
  }
};

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions
var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {
  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
};

var handleScroll = function handleScroll(event, targetElement) {
  var clientY = event.targetTouches[0].clientY - initialClientY;

  if (allowTouchMove(event.target)) {
    return false;
  }

  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
    // element is at the top of its scroll.
    return preventDefault(event);
  }

  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
    // element is at the bottom of its scroll.
    return preventDefault(event);
  }

  event.stopPropagation();
  return true;
};

var disableBodyScroll = function disableBodyScroll(targetElement, options) {
  // targetElement must be provided
  if (!targetElement) {
    // eslint-disable-next-line no-console
    console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');
    return;
  }

  // disableBodyScroll must not have been called on this targetElement before
  if (locks.some(function (lock) {
    return lock.targetElement === targetElement;
  })) {
    return;
  }

  var lock = {
    targetElement: targetElement,
    options: options || {}
  };

  locks = [].concat(_toConsumableArray(locks), [lock]);

  if (isIosDevice) {
    setPositionFixed();
  } else {
    setOverflowHidden(options);
  }

  if (isIosDevice) {
    targetElement.ontouchstart = function (event) {
      if (event.targetTouches.length === 1) {
        // detect single touch.
        initialClientY = event.targetTouches[0].clientY;
      }
    };
    targetElement.ontouchmove = function (event) {
      if (event.targetTouches.length === 1) {
        // detect single touch.
        handleScroll(event, targetElement);
      }
    };

    if (!documentListenerAdded) {
      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);
      documentListenerAdded = true;
    }
  }
};

var enableBodyScroll = function enableBodyScroll(targetElement) {
  if (!targetElement) {
    // eslint-disable-next-line no-console
    console.error('enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.');
    return;
  }

  locks = locks.filter(function (lock) {
    return lock.targetElement !== targetElement;
  });

  if (isIosDevice) {
    targetElement.ontouchstart = null;
    targetElement.ontouchmove = null;

    if (documentListenerAdded && locks.length === 0) {
      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);
      documentListenerAdded = false;
    }
  }

  if (isIosDevice) {
    restorePositionSetting();
  } else {
    restoreOverflowSetting();
  }
};

const swirlLightboxCss = "/*!@:host*/.sc-swirl-lightbox-h{display:block}/*!@:host **/.sc-swirl-lightbox-h *.sc-swirl-lightbox{box-sizing:border-box}/*!@.lightbox*/.lightbox.sc-swirl-lightbox{position:fixed;z-index:var(--s-z-40);background-color:rgba(0, 0, 0, 1);inset:0}/*!@.lightbox[aria-hidden=\"true\"]*/.lightbox[aria-hidden=\"true\"].sc-swirl-lightbox{display:none}@media (min-width: 768px){/*!@.lightbox*/.lightbox.sc-swirl-lightbox{background-color:rgba(0, 0, 0, 0.6)}}/*!@.lightbox:not(.lightbox--closing) .lightbox__body*/.lightbox.sc-swirl-lightbox:not(.lightbox--closing) .lightbox__body.sc-swirl-lightbox{animation:0.15s lightbox-fade-in}@media (prefers-reduced-motion){/*!@.lightbox:not(.lightbox--closing) .lightbox__body*/.lightbox.sc-swirl-lightbox:not(.lightbox--closing) .lightbox__body.sc-swirl-lightbox{animation:none}}/*!@.lightbox--closing*/.lightbox--closing.sc-swirl-lightbox{animation:0.15s lightbox-fade-out;animation-fill-mode:forwards}@media (prefers-reduced-motion){/*!@.lightbox--closing*/.lightbox--closing.sc-swirl-lightbox{animation:none}}/*!@.lightbox__body*/.lightbox__body.sc-swirl-lightbox{position:relative;width:100%;height:100%}/*!@.lightbox__header*/.lightbox__header.sc-swirl-lightbox{position:absolute;z-index:1;top:0;right:0;left:0;display:flex;padding:var(--s-space-12) var(--s-space-16);justify-content:space-between;align-items:flex-start;pointer-events:none}/*!@.lightbox__controls*/.lightbox__controls.sc-swirl-lightbox{position:absolute;z-index:1;top:50%;right:0;left:0;display:none;padding-right:var(--s-space-16);padding-left:var(--s-space-16);justify-content:space-between;align-items:flex-start;pointer-events:none}@media (min-width: 768px){/*!@.lightbox__controls*/.lightbox__controls.sc-swirl-lightbox{display:flex}}/*!@.lightbox__close-button,\n.lightbox__menu-button,\n.lightbox__previous-slide-button,\n.lightbox__next-slide-button*/.lightbox__close-button.sc-swirl-lightbox,.lightbox__menu-button.sc-swirl-lightbox,.lightbox__previous-slide-button.sc-swirl-lightbox,.lightbox__next-slide-button.sc-swirl-lightbox{display:inline-flex;width:2.5rem;height:2.5rem;justify-content:center;align-items:center;border:none;border-radius:50%;color:var(--s-icon-on-image);background-color:rgba(0, 0, 0, 0.6);cursor:pointer;transition:opacity 0.15s;pointer-events:auto}/*!@.lightbox__close-button:disabled, .lightbox__menu-button:disabled, .lightbox__previous-slide-button:disabled, .lightbox__next-slide-button:disabled*/.lightbox__close-button.sc-swirl-lightbox:disabled,.lightbox__menu-button.sc-swirl-lightbox:disabled,.lightbox__previous-slide-button.sc-swirl-lightbox:disabled,.lightbox__next-slide-button.sc-swirl-lightbox:disabled{pointer-events:none;opacity:0}/*!@.lightbox__content*/.lightbox__content.sc-swirl-lightbox{overflow:hidden;width:100%;height:100%;-webkit-user-select:none;-moz-user-select:none;user-select:none}/*!@.lightbox__slides*/.lightbox__slides.sc-swirl-lightbox{display:flex;width:100%;height:100%}/*!@.lightbox__slides ::slotted(*)*/.lightbox__slides .sc-swirl-lightbox-s>*{flex-basis:100%;flex-shrink:0;transition:transform 0.3s}@media (min-width: 768px){/*!@.lightbox__slides ::slotted(*)*/.lightbox__slides .sc-swirl-lightbox-s>*{padding:4rem 5rem}}@media (prefers-reduced-motion){/*!@.lightbox__slides ::slotted(*)*/.lightbox__slides .sc-swirl-lightbox-s>*{transition:none}}/*!@.lightbox__pagination*/.lightbox__pagination.sc-swirl-lightbox{position:absolute;bottom:var(--s-space-32);left:50%;padding:var(--s-space-4) var(--s-space-12);border-radius:var(--s-border-radius-base);color:var(--s-text-on-image);background-color:rgba(0, 0, 0, 0.6);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base);transform:translateX(-50%);pointer-events:none}@media (min-width: 768px){/*!@.lightbox__pagination*/.lightbox__pagination.sc-swirl-lightbox{display:none}}/*!@.lightbox__meta*/.lightbox__meta.sc-swirl-lightbox{display:flex;padding-top:var(--s-space-4);padding-right:var(--s-space-16);padding-bottom:var(--s-space-4);padding-left:var(--s-space-16);align-items:center;gap:var(--s-space-12)}@media (min-width: 768px){/*!@.lightbox__meta*/.lightbox__meta.sc-swirl-lightbox{max-width:18rem}}/*!@.lightbox__thumbnail*/.lightbox__thumbnail.sc-swirl-lightbox{display:inline-flex;flex-shrink:0}/*!@.lightbox__file-info*/.lightbox__file-info.sc-swirl-lightbox{display:flex;min-width:0;flex-grow:1;flex-direction:column}@keyframes lightbox-fade-in{from{opacity:0}to{opacity:1}}@keyframes lightbox-fade-out{from{opacity:1}to{opacity:0}}";

class SwirlLightbox {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dragging = false;
    this.mediaPlayers = [];
    this.onCloseButtonClick = () => {
      this.close();
    };
    this.onDownloadButtonClick = () => {
      var _a;
      (_a = this.slides[this.activeSlideIndex]) === null || _a === void 0 ? void 0 : _a.download();
      this.menu.close();
    };
    this.onKeyDown = (event) => {
      if (event.code === "Escape") {
        this.close();
      }
      else if (event.code === "ArrowLeft") {
        this.onPreviousSlideClick();
      }
      else if (event.code === "ArrowRight") {
        this.onNextSlideClick();
      }
    };
    this.onNextSlideClick = () => {
      this.activateSlide(Math.min(this.slides.length - 1, this.activeSlideIndex + 1));
    };
    this.onPreviousSlideClick = () => {
      this.activateSlide(Math.max(0, this.activeSlideIndex - 1));
    };
    this.registerSlides = () => {
      this.slides = Array.from(this.el.children).filter((el) => el.tagName === "SWIRL-FILE-VIEWER");
      this.setSlideAttributes();
      this.updateMediaPlayers();
    };
    this.onPointerDown = (event) => {
      this.dragging = true;
      this.dragStartPosition =
        event instanceof MouseEvent ? event.clientX : event.touches[0].clientX;
      this.slides.forEach((slide) => {
        slide.style.transition = "none";
      });
    };
    this.onPointerMove = async (event) => {
      var _a, _b;
      const isMultiTouch = !(event instanceof MouseEvent) && event.touches.length > 1;
      const imageViewer = (_b = (_a = this.slides[this.activeSlideIndex]) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector("swirl-file-viewer-image");
      const showsZoomedImage = Boolean(imageViewer)
        ? (await imageViewer.getZoom()) > 1
        : false;
      if (isMultiTouch || showsZoomedImage) {
        return;
      }
      if (this.dragging) {
        event.preventDefault();
        const deltaX = event instanceof MouseEvent
          ? event.clientX - this.dragStartPosition
          : event.touches[0].clientX - this.dragStartPosition;
        this.slides.forEach((slide) => {
          const pixelOffset = this.activeSlideIndex * slide.getBoundingClientRect().width;
          this.dragDelta = deltaX;
          slide.style.transform = `translate3d(${(-pixelOffset + this.dragDelta) / 16}rem, 0, 0)`;
        });
      }
    };
    this.onPointerUp = () => {
      this.dragging = false;
      this.dragStartPosition = undefined;
      const dragRatio = this.dragDelta /
        this.slides[this.activeSlideIndex].getBoundingClientRect().width;
      this.dragDelta = 0;
      const shouldMoveToPreviousSlide = dragRatio > 0.2;
      const shouldMoveToNextSlide = dragRatio < -0.2;
      this.slides.forEach((slide) => {
        slide.style.transition = "";
      });
      if (shouldMoveToPreviousSlide) {
        this.onPreviousSlideClick();
      }
      else if (shouldMoveToNextSlide) {
        this.onNextSlideClick();
      }
      else {
        this.resetSlidePositions();
      }
    };
    this.closeButtonLabel = "Close modal";
    this.downloadButtonLabel = "Download";
    this.label = undefined;
    this.menuLabel = "Slide options";
    this.menuTriggerLabel = "Open slide menu";
    this.nextSlideButtonLabel = "Next slide";
    this.previousSlideButtonLabel = "Previous slide";
    this.activeSlideIndex = 0;
    this.closing = false;
    this.slides = undefined;
  }
  componentWillLoad() {
    this.registerSlides();
  }
  componentDidLoad() {
    this.modal = new A11yDialog(this.modalEl);
    this.activateSlide(0);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.modal) === null || _a === void 0 ? void 0 : _a.destroy();
    this.unlockBodyScroll();
  }
  /**
   * Open the lightbox.
   */
  async open() {
    this.modal.show();
    this.lockBodyScroll();
  }
  /**
   * Close the lightbox.
   */
  async close() {
    if (this.closing) {
      return;
    }
    this.closing = true;
    this.unlockBodyScroll();
    setTimeout(() => {
      this.modal.hide();
      this.resetImageZoom();
      this.closing = false;
    }, 150);
  }
  /**
   * Activate a slide.
   * @param newActiveSlideIndex
   */
  async activateSlide(newActiveSlideIndex) {
    var _a, _b;
    (_b = (_a = this.menu) === null || _a === void 0 ? void 0 : _a.close) === null || _b === void 0 ? void 0 : _b.call(_a);
    this.dragging = false;
    this.activeSlideIndex = newActiveSlideIndex;
    this.slides.forEach((slide, index) => {
      if (index === this.activeSlideIndex) {
        slide.removeAttribute("aria-hidden");
        slide.setAttribute("active", "true");
      }
      else if (index === this.activeSlideIndex - 1 ||
        index === this.activeSlideIndex + 1) {
        slide.setAttribute("aria-hidden", "true");
        slide.setAttribute("active", "true");
      }
      else {
        slide.setAttribute("aria-hidden", "true");
      }
      slide.style.transform = `translate3d(-${100 * this.activeSlideIndex}%, 0, 0)`;
    });
    // wait for slide animation before deactivating the slide
    setTimeout(() => {
      this.slides.forEach((slide, index) => {
        if (index !== this.activeSlideIndex &&
          index !== this.activeSlideIndex - 1 &&
          index !== this.activeSlideIndex + 1) {
          slide.setAttribute("active", "false");
        }
      });
    }, 300);
    this.stopAllMediaPlayers();
    this.updateMediaPlayers();
    this.resetImageZoom();
  }
  setSlideAttributes() {
    this.slides.forEach((slide) => {
      slide.setAttribute("active", "false");
      slide.setAttribute("aria-label", slide.file);
      slide.setAttribute("aria-roledescription", "slide");
      slide.setAttribute("role", "group");
    });
  }
  resetSlidePositions() {
    this.slides.forEach((slide) => {
      slide.style.transform = `translate3d(-${100 * this.activeSlideIndex}%, 0, 0)`;
    });
  }
  getCurrentFileName() {
    var _a, _b;
    return (_b = (_a = this.slides[this.activeSlideIndex]) === null || _a === void 0 ? void 0 : _a.file) === null || _b === void 0 ? void 0 : _b.split("/").pop();
  }
  getCurrentFileType() {
    var _a;
    return (_a = this.slides[this.activeSlideIndex]) === null || _a === void 0 ? void 0 : _a.type;
  }
  getCurrentThumbnailUrl() {
    var _a;
    return (_a = this.slides[this.activeSlideIndex]) === null || _a === void 0 ? void 0 : _a.thumbnailUrl;
  }
  lockBodyScroll() {
    disableBodyScroll(this.el);
  }
  unlockBodyScroll() {
    enableBodyScroll(this.el);
  }
  updateMediaPlayers() {
    const mediaPlayers = querySelectorAllDeep(this.el, "video");
    this.mediaPlayers = mediaPlayers;
  }
  stopAllMediaPlayers() {
    this.mediaPlayers.forEach((mediaPlayer) => mediaPlayer.pause());
  }
  resetImageZoom() {
    this.slides.forEach((slide) => {
      var _a;
      const imageViewer = (_a = slide === null || slide === void 0 ? void 0 : slide.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector("swirl-file-viewer-image");
      if (Boolean(imageViewer)) {
        imageViewer.resetZoom();
      }
    });
  }
  render() {
    const showPagination = this.slides.length > 1;
    const currentFileName = this.getCurrentFileName();
    const currentFileType = this.getCurrentFileType();
    const currentThumbnailUrl = this.getCurrentThumbnailUrl();
    const className = classnames("lightbox", {
      "lightbox--closing": this.closing,
    });
    return (hAsync(Host, null, hAsync("section", { "aria-hidden": "true", "aria-label": this.label, class: className, id: "lightbox", onMouseDown: this.onPointerDown, onMouseMove: this.onPointerMove, onMouseOut: this.onPointerUp, onMouseUp: this.onPointerUp, onKeyDown: this.onKeyDown, onTouchEnd: this.onPointerUp, onTouchMove: this.onPointerMove, onTouchStart: this.onPointerDown, ref: (el) => (this.modalEl = el) }, hAsync("div", { class: "lightbox__body", role: "document" }, hAsync("header", { class: "lightbox__header" }, hAsync("button", { "aria-label": this.closeButtonLabel, class: "lightbox__close-button", onClick: this.onCloseButtonClick }, hAsync("swirl-icon-close", null)), hAsync("button", { "aria-label": this.menuTriggerLabel, class: "lightbox__menu-button", id: "slide-menu-trigger" }, hAsync("swirl-icon-more-vertikal", null))), hAsync("div", { "aria-roledescription": "carousel", class: "lightbox__content", role: "group" }, hAsync("div", { "aria-atomic": "false", "aria-live": "polite", class: "lightbox__slides" }, hAsync("slot", { onSlotchange: this.registerSlides }))), hAsync("div", { class: "lightbox__controls" }, hAsync("button", { "aria-label": this.previousSlideButtonLabel, class: "lightbox__previous-slide-button", disabled: this.activeSlideIndex === 0, onClick: this.onPreviousSlideClick }, hAsync("swirl-icon-arrow-left", null)), hAsync("button", { "aria-label": this.nextSlideButtonLabel, class: "lightbox__next-slide-button", disabled: this.activeSlideIndex === this.slides.length - 1, onClick: this.onNextSlideClick }, hAsync("swirl-icon-arrow-right", null))), showPagination && (hAsync("span", { class: "lightbox__pagination" }, hAsync("span", { "aria-current": "page" }, this.activeSlideIndex + 1), " /", " ", this.slides.length))), hAsync("swirl-popover", { animation: "scale-in-y", disableScrollLock: true, label: this.menuLabel, placement: "bottom-end", popoverId: "slide-menu", ref: (el) => (this.menu = el), trigger: "slide-menu-trigger" }, hAsync("swirl-stack", null, hAsync("div", { class: "lightbox__meta" }, currentThumbnailUrl && (hAsync("div", { class: "lightbox__thumbnail" }, hAsync("swirl-thumbnail", { alt: "", src: currentThumbnailUrl }))), hAsync("div", { class: "lightbox__file-info" }, hAsync("swirl-text", { truncate: true, weight: "semibold" }, currentFileName), hAsync("swirl-text", { color: "subdued", size: "sm", truncate: true }, currentFileType))), hAsync("swirl-separator", null), hAsync("swirl-action-list", null, hAsync("swirl-action-list-item", { icon: "<swirl-icon-download></swirl-icon-download>", label: this.downloadButtonLabel, onClick: this.onDownloadButtonClick }), hAsync("slot", { name: "menu-items" })))))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlLightboxCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-lightbox",
    "$members$": {
      "closeButtonLabel": [1, "close-button-label"],
      "downloadButtonLabel": [1, "download-button-label"],
      "label": [1],
      "menuLabel": [1, "menu-label"],
      "menuTriggerLabel": [1, "menu-trigger-label"],
      "nextSlideButtonLabel": [1, "next-slide-button-label"],
      "previousSlideButtonLabel": [1, "previous-slide-button-label"],
      "activeSlideIndex": [32],
      "closing": [32],
      "slides": [32],
      "open": [64],
      "close": [64],
      "activateSlide": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlLinkCss = "/*!@:host*/.sc-swirl-link-h{display:inline-flex}/*!@:host **/.sc-swirl-link-h *.sc-swirl-link{box-sizing:border-box}/*!@.link*/.link.sc-swirl-link{color:var(--s-interactive-primary-default);line-height:var(--s-line-height-base);text-underline-offset:var(--s-space-4)}/*!@.link:hover*/.link.sc-swirl-link:hover{color:var(--s-interactive-primary-hovered)}/*!@.link:active*/.link.sc-swirl-link:active{color:var(--s-interactive-primary-pressed)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.link*/.link.sc-swirl-link{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.link--color-subdued*/.link--color-subdued.sc-swirl-link{color:var(--s-interactive-neutral-default);font-weight:var(--s-font-weight-medium);text-decoration:none}/*!@.link--color-subdued:hover*/.link--color-subdued.sc-swirl-link:hover{color:var(--s-interactive-neutral-hovered)}/*!@.link--color-subdued:active*/.link--color-subdued.sc-swirl-link:active{color:var(--s-interactive-neutral-pressed)}";

class SwirlLink {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.color = "default";
    this.href = undefined;
    this.label = undefined;
    this.target = undefined;
  }
  render() {
    const className = classnames("link", `link--color-${this.color}`);
    return (hAsync(Host, null, hAsync("a", { class: className, href: this.href, part: "link", target: this.target }, this.label)));
  }
  static get style() { return swirlLinkCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-link",
    "$members$": {
      "color": [1],
      "href": [1],
      "label": [1],
      "target": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlListCss = ":host{display:block}:host *{box-sizing:border-box}.swirl-list{line-height:var(--s-line-height-base)}.swirl-list ul,.swirl-list ol{margin:0;padding:0;list-style-position:outside;list-style-type:none}.swirl-list ul li{padding-left:1.5rem}.swirl-list ul li:before{display:inline-block;width:1.5rem;margin-left:-1.5rem;text-align:center;content:\"•\"}.swirl-list ol{counter-reset:item}.swirl-list ol ol{counter-reset:letter}.swirl-list ol ol li:before{content:counter(letter, lower-alpha) \".\";counter-increment:letter}.swirl-list ol li{padding-left:1.5rem}.swirl-list ol li:before{display:inline-block;min-width:1.5rem;margin-left:-1.5rem;padding-right:var(--s-space-8);text-align:right;content:counter(item) \".\";counter-increment:item;font-variant-numeric:tabular-nums}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.swirl-list{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}";

class SwirlList {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  componentDidRender() {
    const children = Array.from(this.containerEl.children);
    if (children.some((child) => !["UL", "OL"].includes(child.tagName))) {
      console.warn("[SwirlList] Only ul and ol elements are allowed as direct children of <swirl-list />.");
    }
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { class: "swirl-list", ref: (el) => (this.containerEl = el) }, hAsync("slot", null))));
  }
  static get style() { return swirlListCss; }
  static get cmpMeta() { return {
    "$flags$": 4,
    "$tagName$": "swirl-list",
    "$members$": undefined,
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

/*!
* tabbable 6.0.1
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches$1 = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
  return element.getRootNode();
} : function (element) {
  return element.ownerDocument;
};

/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */
var getCandidates = function getCandidates(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches$1.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};

/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */

/**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */

/**
 * @typedef {Object} CandidateScope
 * @property {Element} scopeParent contains inner candidates
 * @property {Element[]} candidates list of candidates found in the scope parent
 */

/**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */

/**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidateScope>}
 */
var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === 'SLOT') {
      // add shadow dom slot scope (slot itself cannot be focusable)
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      // check candidate element
      var validCandidate = matches$1.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }

      // iterate over shadow content if possible
      var shadowRoot = element.shadowRoot ||
      // check for an undisclosed shadow
      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
        //  shadow exists, so look at light dom children as fallback BUT create a scope for any
        //  child candidates found because they're likely slotted elements (elements that are
        //  children of the web component element (which has the shadow), in the light dom, but
        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
        //  _after_ we return from this recursive call
        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        // there's not shadow so just dig into the element's (light dom) children
        //  __without__ giving the element special scope treatment
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex(node, isScope) {
  if (node.tabIndex < 0) {
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    // yet they are still part of the regular tab order; in FF, they get a default
    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    // order, consider their tab index to be 0.
    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    //
    // isScope is positive for custom element with shadow root or slot that by default
    // have tabIndex -1, but need to be sorted by document order in order for their
    // content to be inserted in the correct position
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
  return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
    return child.tagName === 'SUMMARY';
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio(node) {
  return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
};

// determines if a node is ultimately attached to the window's document
var isNodeAttached = function isNodeAttached(node) {
  var _nodeRootHost;
  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
  //  (but NOT _the_ document; see second 'If' comment below for more).
  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
  //  is attached, and the one we need to check if it's in the document or not (because the
  //  shadow, and all nodes it contains, is never considered in the document since shadows
  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
  //  visibility, including all the nodes it contains). The host could be any normal node,
  //  or a custom element (i.e. web component). Either way, that's the one that is considered
  //  part of the document, not the shadow root, nor any of its children (i.e. the node being
  //  tested).
  // To further complicate things, we have to look all the way up until we find a shadow HOST
  //  that is attached (or find none) because the node might be in nested shadows...
  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
  //  document (per the docs) and while it's a Document-type object, that document does not
  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
  //  node is actually detached.
  var nodeRootHost = getRootNode(node).host;
  var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));
  while (!attached && nodeRootHost) {
    var _nodeRootHost2;
    // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
    //  which means we need to get the host's host and check if that parent host is contained
    //  in (i.e. attached to) the document
    nodeRootHost = getRootNode(nodeRootHost).host;
    attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
  }
  return attached;
};
var isZeroArea = function isZeroArea(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
    width = _node$getBoundingClie.width,
    height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
  var displayCheck = _ref.displayCheck,
    getShadowRoot = _ref.getShadowRoot;
  // NOTE: visibility will be `undefined` if node is detached from the document
  //  (see notes about this further down), which means we will consider it visible
  //  (this is legacy behavior from a very long way back)
  // NOTE: we check this regardless of `displayCheck="none"` because this is a
  //  _visibility_ check, not a _display_ check
  if (getComputedStyle(node).visibility === 'hidden') {
    return true;
  }
  var isDirectSummary = matches$1.call(node, 'details>summary:first-of-type');
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches$1.call(nodeUnderDetails, 'details:not([open]) *')) {
    return true;
  }
  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
    if (typeof getShadowRoot === 'function') {
      // figure out if we should consider the node to be in an undisclosed shadow and use the
      //  'non-zero-area' fallback
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
        ) {
          // node has an undisclosed shadow which means we can only treat it as a black box, so we
          //  fall back to a non-zero-area test
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          // iterate up slot
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          // cross shadow boundary
          node = rootNode.host;
        } else {
          // iterate up normal dom
          node = parentElement;
        }
      }
      node = originalNode;
    }
    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
    //  it might be a falsy value, which means shadow DOM support is disabled

    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
    //  now we can just test to see if it would normally be visible or not, provided it's
    //  attached to the main document.
    // NOTE: We must consider case where node is inside a shadow DOM and given directly to
    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

    if (isNodeAttached(node)) {
      // this works wherever the node is: if there's at least one client rect, it's
      //  somehow displayed; it also covers the CSS 'display: contents' case where the
      //  node itself is hidden in place of its contents; and there's no need to search
      //  up the hierarchy either
      return !node.getClientRects().length;
    }

    // Else, the node isn't attached to the document, which means the `getClientRects()`
    //  API will __always__ return zero rects (this can happen, for example, if React
    //  is used to render nodes onto a detached tree, as confirmed in this thread:
    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
    //
    // It also means that even window.getComputedStyle(node).display will return `undefined`
    //  because styles are only computed for nodes that are in the document.
    //
    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
    //  considering __everything__ to be visible because of the innability to determine styles.
    //
    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
    //  nodes as visible with the 'none' fallback.__
    if (displayCheck !== 'legacy-full') {
      return true; // hidden
    }
    // else, fallback to 'none' mode and consider the node visible
  } else if (displayCheck === 'non-zero-area') {
    // NOTE: Even though this tests that the node's client rect is non-zero to determine
    //  whether it's displayed, and that a detached node will __always__ have a zero-area
    //  client rect, we don't special-case for whether the node is attached or not. In
    //  this mode, we do want to consider nodes that have a zero area to be hidden at all
    //  times, and that includes attached or not.
    return isZeroArea(node);
  }

  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
  //  it's visible
  return false;
};

// form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    // check if `node` is contained in a disabled <fieldset>
    while (parentNode) {
      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
        // look for the first <legend> among the children of the disabled <fieldset>
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          // when the first <legend> (in document order) is found
          if (child.tagName === 'LEGEND') {
            // if its parent <fieldset> is not nested in another disabled <fieldset>,
            // return whether `node` is a descendant of its first <legend>
            return matches$1.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
          }
        }
        // the disabled <fieldset> containing `node` has no <legend>
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }

  // else, node's tabbable/focusable state should not be affected by a fieldset's
  //  enabled/disabled state
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||
  // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  // If a custom element has an explicit negative tabindex,
  // browsers will not allow tab targeting said element's children.
  return false;
};

/**
 * @param {Array.<Element|CandidateScope>} candidates
 * @returns Element[]
 */
var sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function (item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item: item,
        isScope: isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches$1.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches$1.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

/*!
* focus-trap 7.1.0
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var rooTrapStack = [];
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      // move this existing trap to the front of the queue
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput(node) {
  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
};
var isEscapeEvent = function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
};
var isTabEvent = function isTabEvent(e) {
  return e.key === 'Tab' || e.keyCode === 9;
};
var delay = function delay(fn) {
  return setTimeout(fn, 0);
};

// Array.find/findIndex() are not supported on IE; this replicates enough
//  of Array.findIndex() for our needs
var findIndex = function findIndex(arr, fn) {
  var idx = -1;
  arr.every(function (value, i) {
    if (fn(value)) {
      idx = i;
      return false; // break
    }

    return true; // next
  });

  return idx;
};

/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */
var valueOrHandler = function valueOrHandler(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === 'function' ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget(event) {
  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the
  //  shadow host. However, event.target.composedPath() will be an array of
  //  nodes "clicked" from inner-most (the actual element inside the shadow) to
  //  outer-most (the host HTML document). If we have access to composedPath(),
  //  then use its first element; otherwise, fall back to event.target (and
  //  this only works for an _open_ shadow DOM; otherwise,
  //  composedPath()[0] === event.target always).
  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;
};
var createFocusTrap = function createFocusTrap(elements, userOptions) {
  // SSR: a live trap shouldn't be created in this type of environment so this
  //  should be safe code to execute if the `document` option isn't specified
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || rooTrapStack;
  var config = _objectSpread2$1({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list

    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: undefined
  };
  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later

  /**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */
  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };

  /**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */
  var findContainerIndex = function findContainerIndex(element) {
    // NOTE: search `containerGroups` because it's possible a group contains no tabbable
    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)
    //  and we still need to find the element in there
    return state.containerGroups.findIndex(function (_ref) {
      var container = _ref.container,
        tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) ||
      // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function (node) {
        return node === element;
      });
    });
  };

  /**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @returns {undefined | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `false` if the option
   *  resolved to `false` (node explicitly not given); otherwise, the resolved
   *  DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node.
   */
  var getNodeForOption = function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === 'function') {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = undefined; // use default value
    }

    if (!optionValue) {
      if (optionValue === undefined || optionValue === false) {
        return optionValue;
      }
      // else, empty string (invalid), null (invalid), 0 (invalid)

      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point

    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue); // resolve to node, or null if fails
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode() {
    var node = getNodeForOption('initialFocus');

    // false explicitly indicates we want no initialFocus at all
    if (node === false) {
      return false;
    }
    if (node === undefined) {
      // option not specified: use fallback options
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;

        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)
        node = firstTabbableNode || getNodeForOption('fallbackFocus');
      }
    }
    if (!node) {
      throw new Error('Your focus-trap needs to have at least one focusable element');
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes() {
    state.containerGroups = state.containers.map(function (container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);

      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes
      //  are a superset of tabbable nodes
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container: container,
        tabbableNodes: tabbableNodes,
        focusableNodes: focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          // NOTE: If tabindex is positive (in order to manipulate the tab order separate
          //  from the DOM order), this __will not work__ because the list of focusableNodes,
          //  while it contains tabbable nodes, does not sort its nodes in any order other
          //  than DOM order, because it can't: Where would you place focusable (but not
          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...
          // Support for positive tabindex is already broken and hard to manage (possibly
          //  not supportable, TBD), so this isn't going to make things worse than they
          //  already are, and at least makes things better for the majority of cases where
          //  tabindex is either 0/unset or negative.
          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375
          var nodeIdx = focusableNodes.findIndex(function (n) {
            return n === node;
          });
          if (nodeIdx < 0) {
            return undefined;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function (n) {
              return isTabbable(n, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {
            return isTabbable(n, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function (group) {
      return group.tabbableNodes.length > 0;
    });

    // throw if no groups have tabbable nodes and we don't have a fallback focus node either
    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option
    ) {
      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
    }
  };
  var tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus', previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  var checkPointerDown = function checkPointerDown(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      // allow the click since it ocurred inside the trap
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      // immediately deactivate the trap
      trap.deactivate({
        // if, on deactivation, we should return focus to the node originally-focused
        //  when the trap was activated (or the configured `setReturnFocus` node),
        //  then assume it's also OK to return focus to the outside node that was
        //  just clicked, causing deactivation, as long as that node is focusable;
        //  if it isn't focusable, then return focus to the original node focused
        //  on activation (or the configured `setReturnFocus` node)
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked, whether it's focusable or not; by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node)
        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
      });
      return;
    }

    // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)
    if (valueOrHandler(config.allowOutsideClick, e)) {
      // allow the click outside the trap to take place
      return;
    }

    // otherwise, prevent the click
    e.preventDefault();
  };

  // In case focus escapes the trap for some strange reason, pull it back in.
  var checkFocusIn = function checkFocusIn(e) {
    var target = getActualTarget(e);
    var targetContained = findContainerIndex(target) >= 0;

    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      // escaped! pull it back in to where it just left
      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };

  // Hijack Tab events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  var checkTab = function checkTab(e) {
    var target = getActualTarget(e);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      // make sure the target is actually contained in a group
      // NOTE: the target may also be the container itself if it's focusable
      //  with tabIndex='-1' and was given initial focus
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;
      if (containerIndex < 0) {
        // target not found in any group: quite possible focus has escaped the trap,
        //  so bring it back in to...
        if (e.shiftKey) {
          // ...the last node in the last group
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          // ...the first node in the first group
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (e.shiftKey) {
        // REVERSE

        // is the target the first tabbable node in a group?
        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          // an exception case where the target is either the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle shift+tab as if focus were on the container's
          //  first tabbable node, and go to the last tabbable node of the LAST group
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          // YES: then shift+tab should go to the last tabbable node in the
          //  previous group (and wrap around to the last tabbable node of
          //  the LAST group if it's the first tabbable node of the FIRST group)
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        // FORWARD

        // is the target the last tabbable node in a group?
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          // an exception case where the target is the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle tab as if focus were on the container's
          //  last tabbable node, and go to the first tabbable node of the FIRST group
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          // YES: then tab should go to the first tabbable node in the next
          //  group (and wrap around to the first tabbable node of the FIRST
          //  group if it's the last tabbable node of the LAST group)
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      // NOTE: the fallbackFocus option does not support returning false to opt-out
      destinationNode = getNodeForOption('fallbackFocus');
    }
    if (destinationNode) {
      e.preventDefault();
      tryFocus(destinationNode);
    }
    // else, let the browser take care of [shift+]tab and move the focus
  };

  var checkKey = function checkKey(e) {
    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {
      e.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  };
  var checkClick = function checkClick(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };

  //
  // EVENT LISTENERS
  //

  var addListeners = function addListeners() {
    if (!state.active) {
      return;
    }

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trapStack, trap);

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);
    return trap;
  };

  //
  // TRAP DEFINITION
  //

  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, 'onActivate');
      var onPostActivate = getOption(activateOptions, 'onPostActivate');
      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2$1({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer); // noop if undefined
      state.delayInitialFocusTimer = undefined;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, 'onDeactivate');
      var onPostDeactivate = getOption(options, 'onPostDeactivate');
      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');
      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');
      if (onDeactivate) {
        onDeactivate();
      }
      var finishDeactivation = function finishDeactivation() {
        delay(function () {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function (element) {
        return typeof element === 'string' ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };

  // initialize container elements
  trap.updateContainerElements(elements);
  return trap;
};

const swirlModalCss = ":host{display:block}:host *{box-sizing:border-box}.modal{--swirl-ghost-button-background-default:var(--s-surface-overlay-default);--swirl-ghost-button-background-hovered:var(--s-surface-overlay-hovered);--swirl-ghost-button-background-pressed:var(--s-surface-overlay-pressed);position:fixed;z-index:var(--s-z-40);display:flex;justify-content:center;align-items:center;inset:0}.modal[aria-hidden=\"true\"]{display:none}.modal--variant-default.modal--closing{animation:0.15s modal-fade-out;animation-fill-mode:forwards}@media (prefers-reduced-motion){.modal--variant-default.modal--closing{animation:none}}.modal--variant-default:not(.modal--closing) .modal__backdrop{animation:0.15s modal-backdrop-fade-in}@media (prefers-reduced-motion){.modal--variant-default:not(.modal--closing) .modal__backdrop{animation:none}}.modal--variant-default:not(.modal--closing) .modal__body{animation:0.15s modal-scale-in}@media (prefers-reduced-motion){.modal--variant-default:not(.modal--closing) .modal__body{animation:none}}.modal--variant-drawer{justify-content:end;align-items:stretch}.modal--variant-drawer.modal--closing{animation:0.15s modal-drawer-slide-out;animation-fill-mode:forwards}@media (prefers-reduced-motion){.modal--variant-drawer.modal--closing{animation:none}}.modal--variant-drawer.modal--hide-label .modal__content{padding-top:calc(3.5rem + var(--s-space-8))}.modal--variant-drawer .modal__backdrop{background-color:transparent;animation:none}.modal--variant-drawer .modal__body{height:100%;max-height:none;border-radius:0;animation:0.15s modal-drawer-slide-in;box-shadow:var(--s-shadow-level-3)}@media (prefers-reduced-motion){.modal--variant-drawer .modal__body{animation:none}}.modal--variant-drawer .modal__close-button{right:auto;left:var(--s-space-8)}@media (min-width: 768px){.modal--variant-drawer .modal__close-button{left:var(--s-space-16)}}.modal--variant-drawer .modal__header{padding-right:var(--s-space-16);padding-left:calc(var(--s-space-8) + 2.5rem + var(--s-space-8))}@media (min-width: 768px){.modal--variant-drawer .modal__header{padding-top:var(--s-space-16);padding-right:var(--s-space-24);padding-left:calc(var(--s-space-16) + 2.5rem + var(--s-space-8))}}.modal--padded .modal__content{padding-top:var(--s-space-24);padding-right:var(--s-space-16);padding-bottom:var(--s-space-24);padding-left:var(--s-space-16)}@media (min-width: 768px){.modal--padded .modal__content{padding-top:0;padding-right:var(--s-space-24);padding-bottom:var(--s-space-16);padding-left:var(--s-space-24)}}@media (min-width: 768px){.modal--scrollable .modal__content{padding-bottom:0}}.modal--scrollable:not(.modal--scrolled-down).modal--has-custom-footer .modal__custom-footer{border-top:var(--s-border-width-default) solid var(--s-border-default)}.modal--scrollable:not(.modal--scrolled-down):not(.modal--has-custom-footer) .modal__controls{border-top:var(--s-border-width-default) solid var(--s-border-default)}.modal--has-custom-header .modal__content{padding-top:var(--s-space-16)}.modal--has-custom-footer .modal__custom-footer{padding-top:var(--s-space-16);padding-right:var(--s-space-24);padding-bottom:var(--s-space-16);padding-left:var(--s-space-24)}@media (min-width: 768px){.modal--scrolled .modal__header{border-bottom-color:var(--s-border-default)}}.modal__backdrop{position:fixed;background-color:rgba(0, 0, 0, 0.2);inset:0}.modal__body{position:relative;z-index:var(--s-z-40);display:flex;overflow:hidden;width:100vw;max-width:40rem;height:100vh;background-color:var(--s-surface-overlay-default);flex-direction:column}@media (min-width: 768px){.modal__body{width:90vw;height:auto;max-height:90vh;border-radius:var(--s-border-radius-base);box-shadow:var(--s-shadow-level-3)}}.modal__close-button{position:absolute;z-index:1;top:var(--s-space-8);left:var(--s-space-8)}@media (min-width: 768px){.modal__close-button{top:var(--s-space-16);right:var(--s-space-16);left:auto}}.modal__header{display:flex;height:3.5rem;padding-top:var(--s-space-8);padding-right:var(--s-space-16);padding-bottom:var(--s-space-8);padding-left:calc(var(--s-space-8) + 2.5rem + var(--s-space-8));flex-shrink:0;align-items:center;border-bottom:var(--s-border-width-default) solid var(--s-border-default);gap:var(--s-space-16)}@media (min-width: 768px){.modal__header{height:4.125rem;padding-top:var(--s-space-24);padding-right:calc(var(--s-space-16) + 2.5rem + var(--s-space-8));padding-bottom:var(--s-space-16);padding-left:var(--s-space-24);border-bottom:var(--s-border-width-default) solid transparent}}.modal__custom-header{flex-shrink:0;border-bottom:var(--s-border-width-default) solid var(--s-border-default)}.modal__heading{overflow:hidden}.modal__heading .heading{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.modal__content{overflow-x:hidden;overflow-y:auto;flex-grow:1;line-height:var(--s-line-height-base)}.modal__content ::slotted(*){margin:0}.modal__custom-footer{flex-shrink:0}.modal__controls{display:flex;padding-top:var(--s-space-16);padding-right:var(--s-space-24);padding-bottom:var(--s-space-16);padding-left:var(--s-space-24);flex-shrink:0;justify-content:flex-end}@keyframes modal-scale-in{from{transform:scale(0)}to{transform:scale(1)}}@keyframes modal-backdrop-fade-in{from{opacity:0}to{opacity:1}}@keyframes modal-fade-out{from{opacity:1}to{opacity:0}}@keyframes modal-drawer-slide-in{from{transform:translate3d(100%, 0, 0)}to{transform:translate3d(0, 0, 0)}}@keyframes modal-drawer-slide-out{from{transform:translate3d(0, 0, 0)}to{transform:translate3d(100%, 0, 0)}}";

/**
 * slot - Modal contents
 * custom-header - Optional custom header; should be used hidden label
 */
class SwirlModal {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.modalClose = createEvent(this, "modalClose", 7);
    this.modalOpen = createEvent(this, "modalOpen", 7);
    this.primaryAction = createEvent(this, "primaryAction", 7);
    this.secondaryAction = createEvent(this, "secondaryAction", 7);
    this.onKeyDown = (event) => {
      if (event.code === "Escape") {
        this.close();
      }
    };
    this.onBackdropClick = () => {
      this.close();
    };
    this.onCloseButtonClick = () => {
      this.close();
    };
    this.onPrimaryAction = (event) => {
      this.primaryAction.emit(event);
    };
    this.onSecondaryAction = (event) => {
      this.secondaryAction.emit(event);
    };
    this.determineScrollStatus = () => {
      var _a, _b, _c, _d, _e, _f;
      const scrolled = ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollTop) > 0;
      const scrolledDown = Math.ceil(((_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.scrollTop) + ((_c = this.scrollContainer) === null || _c === void 0 ? void 0 : _c.offsetHeight)) >= ((_d = this.scrollContainer) === null || _d === void 0 ? void 0 : _d.scrollHeight);
      const scrollable = ((_e = this.scrollContainer) === null || _e === void 0 ? void 0 : _e.scrollHeight) > ((_f = this.scrollContainer) === null || _f === void 0 ? void 0 : _f.offsetHeight);
      if (scrolled !== this.scrolled) {
        this.scrolled = scrolled;
      }
      if (scrolledDown !== this.scrolledDown) {
        this.scrolledDown = scrolledDown;
      }
      if (scrollable !== this.scrollable) {
        this.scrollable = scrollable;
      }
    };
    this.closeButtonLabel = "Close modal";
    this.hideCloseButton = undefined;
    this.hideLabel = undefined;
    this.label = undefined;
    this.maxWidth = undefined;
    this.padded = true;
    this.primaryActionLabel = undefined;
    this.secondaryActionLabel = undefined;
    this.variant = "default";
    this.isOpen = false;
    this.closing = false;
    this.hasCustomHeader = undefined;
    this.hasCustomFooter = undefined;
    this.scrollable = false;
    this.scrolled = false;
    this.scrolledDown = false;
  }
  componentDidLoad() {
    this.focusTrap = createFocusTrap(this.modalEl, {
      allowOutsideClick: true,
      tabbableOptions: {
        getShadowRoot: (node) => {
          return node.shadowRoot;
        },
      },
    });
    this.determineScrollStatus();
    queueMicrotask(() => {
      this.updateCustomFooterStatus();
      this.updateCustomHeaderStatus();
    });
  }
  disconnectedCallback() {
    this.focusTrap.deactivate();
    this.unlockBodyScroll();
  }
  onWindowResize() {
    this.determineScrollStatus();
  }
  watchIsOpen() {
    if (this.isOpen) {
      // wait for animation
      setTimeout(() => {
        this.focusTrap.activate();
      }, 200);
    }
    else {
      this.focusTrap.deactivate();
    }
  }
  /**
   * Open the modal.
   */
  async open() {
    this.isOpen = true;
    this.modalOpen.emit();
    this.lockBodyScroll();
    this.determineScrollStatus();
  }
  /**
   * Close the modal.
   */
  async close() {
    if (this.closing) {
      return;
    }
    this.closing = true;
    this.unlockBodyScroll();
    setTimeout(() => {
      this.isOpen = false;
      this.modalClose.emit();
      this.closing = false;
    }, 150);
  }
  updateCustomFooterStatus() {
    this.hasCustomFooter = Boolean(this.el.querySelector('[slot="custom-footer"]'));
  }
  updateCustomHeaderStatus() {
    this.hasCustomHeader = Boolean(this.el.querySelector('[slot="custom-header"]'));
  }
  lockBodyScroll() {
    disableBodyScroll(this.scrollContainer);
  }
  unlockBodyScroll() {
    enableBodyScroll(this.scrollContainer);
  }
  render() {
    const showControls = Boolean(this.primaryActionLabel) || Boolean(this.secondaryActionLabel);
    const className = classnames("modal", `modal--variant-${this.variant}`, {
      "modal--closing": this.closing,
      "modal--has-custom-footer": this.hasCustomFooter,
      "modal--has-custom-header": this.hasCustomHeader,
      "modal--hide-label": this.hideLabel,
      "modal--padded": this.padded,
      "modal--scrollable": this.scrollable,
      "modal--scrolled": this.scrolled,
      "modal--scrolled-down": this.scrolledDown,
    });
    return (hAsync(Host, null, hAsync("section", { "aria-hidden": String(!this.isOpen), "aria-label": this.label, "aria-modal": "true", class: className, onKeyDown: this.onKeyDown, role: "dialog", ref: (el) => (this.modalEl = el) }, hAsync("div", { class: "modal__backdrop", onClick: this.onBackdropClick }), hAsync("div", { class: "modal__body", style: { maxWidth: this.maxWidth } }, !this.hideCloseButton && (hAsync("swirl-button", { class: "modal__close-button", hideLabel: true, icon: this.variant === "default"
        ? "<swirl-icon-close></swirl-icon-close>"
        : "<swirl-icon-double-arrow-right></swirl-icon-double-arrow-right>", label: this.closeButtonLabel, onClick: this.onCloseButtonClick })), hAsync("header", { class: "modal__custom-header" }, hAsync("slot", { name: "custom-header" })), !this.hideLabel && (hAsync("header", { class: "modal__header" }, hAsync("swirl-heading", { as: "h2", class: "modal__heading", level: 3, text: this.label }))), hAsync("div", { class: "modal__content", onScroll: this.determineScrollStatus, ref: (el) => (this.scrollContainer = el) }, hAsync("slot", null)), hAsync("div", { class: "modal__custom-footer" }, hAsync("slot", { name: "custom-footer" })), showControls && (hAsync("footer", { class: "modal__controls" }, hAsync("swirl-button-group", { wrap: true }, this.secondaryActionLabel && (hAsync("swirl-button", { label: this.secondaryActionLabel, onClick: this.onSecondaryAction })), this.primaryActionLabel && (hAsync("swirl-button", { intent: "primary", label: this.primaryActionLabel, onClick: this.onPrimaryAction, variant: "flat" })))))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "isOpen": ["watchIsOpen"]
  }; }
  static get style() { return swirlModalCss; }
  static get cmpMeta() { return {
    "$flags$": 4,
    "$tagName$": "swirl-modal",
    "$members$": {
      "closeButtonLabel": [1, "close-button-label"],
      "hideCloseButton": [4, "hide-close-button"],
      "hideLabel": [4, "hide-label"],
      "label": [1],
      "maxWidth": [1, "max-width"],
      "padded": [4],
      "primaryActionLabel": [1, "primary-action-label"],
      "secondaryActionLabel": [1, "secondary-action-label"],
      "variant": [1],
      "isOpen": [32],
      "closing": [32],
      "hasCustomHeader": [32],
      "hasCustomFooter": [32],
      "scrollable": [32],
      "scrolled": [32],
      "scrolledDown": [32],
      "open": [64],
      "close": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var version = "1.15.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();

          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }

          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);

        if (firstChild === dragEl) {
          return completed(false);
        }

        target = firstChild;
        targetRect = getRect(target);

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

const swirlOptionListCss = ".sc-swirl-option-list-h{display:block}.sc-swirl-option-list-h *.sc-swirl-option-list{box-sizing:border-box}";

class SwirlOptionList {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.itemDrop = createEvent(this, "itemDrop", 7);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.onFocus = async (event) => {
      if (this.listboxEl.contains(event.relatedTarget)) {
        return;
      }
      // prevent focus from canceling the drag event in Safari
      await new Promise((resolve) => setTimeout(resolve));
      if (Boolean(this.focusedItem)) {
        this.focusItem(this.getActiveItemIndex());
      }
      else {
        this.focusItem(0);
      }
    };
    this.onClick = (event) => {
      event.preventDefault();
      const target = event.target;
      const item = target === null || target === void 0 ? void 0 : target.closest("swirl-option-list-item");
      const composedTarget = event.composedPath()[0];
      const clickedOption = Boolean(closestPassShadow(composedTarget, '[role="option"]'));
      if (!Boolean(item) || !clickedOption) {
        event.preventDefault();
        return;
      }
      this.selectItem(this.items.findIndex((i) => i.value === item.value));
    };
    this.onKeyDown = (event) => {
      if (event.code === "ArrowDown") {
        event.preventDefault();
        if (!Boolean(this.dragging)) {
          this.focusNextItem();
        }
        else {
          this.moveDraggedItemDown();
        }
      }
      else if (event.code === "ArrowUp") {
        event.preventDefault();
        if (!Boolean(this.dragging)) {
          this.focusPreviousItem();
        }
        else {
          this.moveDraggedItemUp();
        }
      }
      else if (event.code === "Space" || event.code === "Enter") {
        const target = event.composedPath()[0];
        const optionFocused = Boolean(closestPassShadow(target, '[role="option"]'));
        if (!optionFocused) {
          return;
        }
        event.preventDefault();
        if (Boolean(this.dragging)) {
          this.stopDrag(this.dragging);
        }
        else {
          this.selectFocusedItem();
        }
      }
      else if (event.code === "Home") {
        event.preventDefault();
        this.focusItem(0);
      }
      else if (event.code === "End") {
        event.preventDefault();
        this.focusItem(this.items.length - 1);
      }
      else if (event.code === "KeyA" &&
        (event.metaKey || event.ctrlKey) &&
        this.multiSelect) {
        event.preventDefault();
        this.selectAllItems();
      }
      else if (event.code === "Tab") {
        if (Boolean(this.dragging)) {
          event.preventDefault();
        }
      }
    };
    this.toggleDrag = (event) => {
      const item = event.detail;
      if (Boolean(this.dragging)) {
        this.stopDrag(item);
      }
      else {
        this.startDrag(item);
      }
    };
    this.startDrag = (item) => {
      this.dragging = item;
      this.draggingStartIndex = this.getItemIndex(this.dragging);
      item.setAttribute("dragging", "true");
      const index = this.getItemIndex(this.dragging);
      this.focusItem(index);
      this.assistiveText = this.assistiveTextItemGrabbed;
    };
    this.stopDrag = (item) => {
      this.dragging = undefined;
      item.removeAttribute("dragging");
      const newIndex = this.getActiveItemIndex();
      this.assistiveText = `${this.assistiveTextItemMoved} ${newIndex + 1}`;
      this.itemDrop.emit({ item, oldIndex: this.draggingStartIndex, newIndex });
      this.draggingStartIndex = undefined;
    };
    this.allowDrag = undefined;
    this.assistiveTextItemGrabbed = "Item grabbed. Use arrow keys to move item up or down. Use spacebar to save position.";
    this.assistiveTextItemMoving = "Current position:";
    this.assistiveTextItemMoved = "Item moved. New position:";
    this.disabled = undefined;
    this.label = undefined;
    this.optionListId = undefined;
    this.multiSelect = undefined;
    this.value = [];
    this.assistiveText = undefined;
  }
  componentDidLoad() {
    this.updateItems();
    this.observeSlotChanges();
    this.setItemAllowDragState();
    this.setItemDisabledState();
    this.setItemContext();
    this.syncItemsWithValue();
    this.setupDragDrop();
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.sortable) === null || _b === void 0 ? void 0 : _b.destroy();
  }
  watchAllowDrag() {
    this.setItemAllowDragState();
    this.setupDragDrop();
  }
  watchDisabled() {
    this.setItemDisabledState();
  }
  watchMultiSelect() {
    this.setItemContext();
  }
  watchValue() {
    this.syncItemsWithValue();
  }
  observeSlotChanges() {
    this.observer = new MutationObserver(() => {
      this.updateItems();
    });
    this.observer.observe(this.listboxEl, { childList: true });
  }
  updateItems() {
    this.items = querySelectorAllDeep(this.el, "swirl-option-list-item");
  }
  setItemDisabledState() {
    if (this.disabled) {
      this.items.forEach((item) => (item.disabled = true));
    }
  }
  setItemContext() {
    if (this.multiSelect) {
      this.items.forEach((item) => (item.context = "multi-select"));
    }
    else {
      this.items.forEach((item) => (item.context = "single-select"));
      if (this.value.length > 1) {
        this.updateValue([this.value[0]]);
      }
    }
  }
  setupDragDrop() {
    if (Boolean(this.sortable)) {
      this.sortable.destroy();
    }
    if (!this.allowDrag) {
      return;
    }
    this.sortable = Sortable.create(this.listboxEl, {
      animation: 150,
      draggable: "swirl-option-list-item",
      handle: ".option-list-item__drag-handle",
      onEnd: (event) => {
        this.itemDrop.emit({
          item: event.item,
          oldIndex: event.oldIndex,
          newIndex: event.newIndex,
        });
      },
    });
  }
  setItemAllowDragState() {
    if (this.allowDrag && !this.multiSelect) {
      console.error("[SwirlOptionList] Drag can only be allowed for multi select lists.");
      return;
    }
    const sections = querySelectorAllDeep(this.el, "swirl-option-list-section");
    if (this.allowDrag && sections.length > 0) {
      console.error("[SwirlOptionList] Drag can only be allowed for lists without sections.");
      return;
    }
    if (this.allowDrag) {
      this.items.forEach((item) => {
        item.setAttribute("allow-drag", "true");
        item.addEventListener("toggleDrag", this.toggleDrag);
      });
    }
    else {
      this.items.forEach((item) => {
        item.removeAttribute("allow-drag");
        item.removeEventListener("toggleDrag", this.toggleDrag);
      });
    }
  }
  selectItem(index) {
    if (this.disabled) {
      return;
    }
    const item = this.items[index];
    if (item.disabled) {
      return;
    }
    const itemIsAlreadySelected = this.value.includes(item.value);
    if (!this.multiSelect) {
      this.value = [];
    }
    if (!itemIsAlreadySelected) {
      this.updateValue([...this.value, item.value]);
    }
    else {
      this.updateValue(this.value.filter((v) => v !== item.value));
    }
  }
  updateValue(value) {
    this.value = value;
    this.valueChange.emit(this.value);
  }
  selectFocusedItem() {
    if (this.disabled || this.getActiveItemIndex() === -1) {
      return;
    }
    this.selectItem(this.getActiveItemIndex());
  }
  selectAllItems() {
    if (this.disabled) {
      return;
    }
    const alreadySelected = this.items.every((item) => this.value.includes(item.value));
    if (alreadySelected) {
      this.updateValue([]);
    }
    else {
      this.updateValue(this.items.map((item) => item.value));
    }
  }
  syncItemsWithValue() {
    var _a;
    (_a = this.items) === null || _a === void 0 ? void 0 : _a.forEach((item) => (item.selected = this.value.includes(item.value)));
  }
  focusItem(index) {
    var _a;
    if (this.disabled) {
      return;
    }
    this.items.forEach((item) => item.querySelector('[role="option"]').removeAttribute("tabIndex"));
    const item = (_a = this.items[index]) === null || _a === void 0 ? void 0 : _a.querySelector('[role="option"]');
    if (!Boolean(item)) {
      return;
    }
    item.setAttribute("tabIndex", "0");
    item.focus();
    this.focusedItem = item;
  }
  focusNextItem() {
    if (this.disabled) {
      return;
    }
    const activeItemIndex = this.getActiveItemIndex();
    const newIndex = Math.min(activeItemIndex + 1, this.items.length - 1);
    this.focusItem(newIndex);
  }
  focusPreviousItem() {
    const activeItemIndex = this.getActiveItemIndex();
    const newIndex = Math.max(activeItemIndex - 1, 0);
    this.focusItem(newIndex);
  }
  getActiveItemIndex() {
    return this.items
      .map((item) => item.querySelector('[role="option"]'))
      .findIndex((item) => item === this.focusedItem);
  }
  getItemIndex(item) {
    return this.items.map((i) => i).findIndex((i) => i === item);
  }
  moveDraggedItemDown() {
    const nextSibling = this.dragging.nextElementSibling;
    if (!Boolean(nextSibling)) {
      return;
    }
    nextSibling.after(this.dragging);
    this.updateItems();
    this.listboxEl.focus();
    this.assistiveText = `${this.assistiveTextItemMoving} ${this.getActiveItemIndex() + 1}`;
  }
  moveDraggedItemUp() {
    const prevSibling = this.dragging.previousElementSibling;
    if (!Boolean(prevSibling)) {
      return;
    }
    prevSibling.before(this.dragging);
    this.updateItems();
    this.listboxEl.focus();
    this.assistiveText = `${this.assistiveTextItemMoving} ${this.getItemIndex(this.dragging) + 1}`;
  }
  render() {
    const ariaMultiselectable = this.multiSelect ? "true" : undefined;
    const tabIndex = this.disabled ? -1 : 0;
    return (hAsync(Host, null, hAsync("swirl-visually-hidden", { role: "alert" }, this.assistiveText), hAsync("div", { "aria-label": this.label, "aria-multiselectable": ariaMultiselectable, class: "option-list", id: this.optionListId, onClick: this.onClick, onFocus: this.onFocus, onKeyDown: this.onKeyDown, ref: (el) => (this.listboxEl = el), role: "listbox", tabIndex: tabIndex }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "allowDrag": ["watchAllowDrag"],
    "disabled": ["watchDisabled"],
    "multiSelect": ["watchMultiSelect"],
    "value": ["watchValue"]
  }; }
  static get style() { return swirlOptionListCss; }
  static get cmpMeta() { return {
    "$flags$": 6,
    "$tagName$": "swirl-option-list",
    "$members$": {
      "allowDrag": [4, "allow-drag"],
      "assistiveTextItemGrabbed": [1, "assistive-text-item-grabbed"],
      "assistiveTextItemMoving": [1, "assistive-text-item-moving"],
      "assistiveTextItemMoved": [1, "assistive-text-item-moved"],
      "disabled": [4],
      "label": [1],
      "optionListId": [1, "option-list-id"],
      "multiSelect": [4, "multi-select"],
      "value": [1040],
      "assistiveText": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlOptionListItemCss = ".sc-swirl-option-list-item-h{position:relative;display:inline-flex;width:100%}.sc-swirl-option-list-item-h *.sc-swirl-option-list-item{box-sizing:border-box}.option-list-item.sc-swirl-option-list-item{display:inline-flex;width:100%;min-height:3rem;padding:var(--s-space-12) var(--s-space-16);align-items:center;background-color:var(--s-surface-overlay-default);cursor:pointer;gap:var(--s-space-12)}.option-list-item.sc-swirl-option-list-item:hover:not(.option-list-item--disabled){background-color:var(--s-surface-overlay-hovered)}.option-list-item.sc-swirl-option-list-item:active:not(.option-list-item--disabled){background-color:var(--s-surface-overlay-pressed)}.option-list-item.sc-swirl-option-list-item:focus{outline:none}.option-list-item.sc-swirl-option-list-item:focus-visible{background-color:var(--s-surface-overlay-hovered)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.option-list-item.sc-swirl-option-list-item{min-height:0;padding:var(--s-space-12);gap:var(--s-space-8)}}.option-list-item--draggable.sc-swirl-option-list-item .option-list-item__label.sc-swirl-option-list-item{padding-right:calc(var(--s-space-16) + 1.5rem)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.option-list-item--draggable.sc-swirl-option-list-item .option-list-item__label.sc-swirl-option-list-item{padding-right:calc(var(--s-space-16) + 1rem)}}.option-list-item--dragging.sc-swirl-option-list-item{z-index:1;border-radius:var(--s-border-radius-s);background-color:var(--s-surface-overlay-pressed);box-shadow:0 0.0625rem 0.125rem rgba(25, 26, 28, 0.08),\n    0 0.25rem 2rem rgba(25, 26, 28, 0.16)}.option-list-item--dragging.sc-swirl-option-list-item:hover:not(.option-list-item--disabled){background-color:var(--s-surface-overlay-pressed)}.option-list-item--selected.sc-swirl-option-list-item .option-list-item__label.sc-swirl-option-list-item{color:var(--s-text-highlight)}.option-list-item--selected.sc-swirl-option-list-item .option-list-item__icon.sc-swirl-option-list-item{color:var(--s-icon-highlight)}.option-list-item--selected.sc-swirl-option-list-item .option-list-item__checkbox-box.sc-swirl-option-list-item{border-color:var(--s-icon-highlight);color:var(--s-text-on-status);background-color:var(--s-icon-highlight)}.option-list-item--disabled.sc-swirl-option-list-item{cursor:default}.option-list-item--disabled.option-list-item--selected.sc-swirl-option-list-item .option-list-item__checkbox-box.sc-swirl-option-list-item{background-color:var(--s-icon-disabled)}.option-list-item--disabled.option-list-item--selected.sc-swirl-option-list-item .option-list-item__checkbox-icon.sc-swirl-option-list-item{color:var(--s-text-on-status)}.option-list-item--disabled.sc-swirl-option-list-item .option-list-item__label.sc-swirl-option-list-item{color:var(--s-text-disabled)}.option-list-item--disabled.sc-swirl-option-list-item .option-list-item__icon.sc-swirl-option-list-item,.option-list-item--disabled.sc-swirl-option-list-item .option-list-item__selection-icon.sc-swirl-option-list-item,.option-list-item--disabled.sc-swirl-option-list-item .option-list-item__checkbox-icon.sc-swirl-option-list-item{color:var(--s-icon-disabled)}.option-list-item--disabled.sc-swirl-option-list-item .option-list-item__checkbox-box.sc-swirl-option-list-item{border-color:var(--s-icon-disabled);background-color:var(--s-surface-overlay-default)}.option-list-item__label.sc-swirl-option-list-item{flex-grow:1;color:var(--s-text-default);font-size:var(--s-font-size-base);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base);text-align:left}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.option-list-item__label.sc-swirl-option-list-item{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.option-list-item__icon.sc-swirl-option-list-item{display:inline-flex;flex-shrink:0;color:var(--s-icon-default)}.option-list-item__selection-icon.sc-swirl-option-list-item{display:inline-flex;flex-shrink:0;color:var(--s-icon-highlight)}.option-list-item__checkbox.sc-swirl-option-list-item{display:inline-flex;width:1.5rem;height:1.5rem;padding:var(--s-space-2)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.option-list-item__checkbox.sc-swirl-option-list-item{width:1.375rem;height:1.375rem}}.option-list-item__checkbox-box.sc-swirl-option-list-item{display:inline-flex;width:100%;height:100%;justify-content:center;align-items:center;border:0.125rem solid var(--s-icon-default);border-radius:var(--s-border-radius-s)}.option-list-item__checkbox-icon.sc-swirl-option-list-item{display:inline-flex}.option-list-item__drag-handle.sc-swirl-option-list-item{position:absolute;z-index:1;top:50%;right:var(--s-space-4);display:inline-flex;margin:0;padding:0;padding:var(--s-space-8);flex-shrink:0;border:none;color:var(--s-icon-default);background-color:transparent;cursor:grab;transform:translateY(-50%)}.option-list-item__drag-handle.sc-swirl-option-list-item:active{cursor:grabbing}.option-list-item__drag-handle.sc-swirl-option-list-item:focus:not(:focus-visible){outline:none}.option-list-item__drag-handle.sc-swirl-option-list-item:focus-visible{outline-color:var(--s-focus-default)}";

class SwirlOptionListItem {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.toggleDrag = createEvent(this, "toggleDrag", 7);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
      this.updateIconSize(event.matches);
    };
    this.onDragHandleKeyDown = (event) => {
      if (event.code === "Space" || event.code === "Enter") {
        event.preventDefault();
        this.toggleDrag.emit(this.el);
      }
    };
    this.allowDrag = undefined;
    this.context = "single-select";
    this.disabled = undefined;
    this.dragging = undefined;
    this.dragHandleDescription = "Press spacebar to toggle grab";
    this.dragHandleLabel = "Move option";
    this.icon = undefined;
    this.label = undefined;
    this.selected = false;
    this.value = undefined;
    this.iconSize = 24;
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    this.updateIconSize(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    var _a;
    const icon = (_a = this.iconEl) === null || _a === void 0 ? void 0 : _a.children[0];
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", smallIcon ? "20" : "24");
  }
  updateIconSize(smallIcon) {
    this.iconSize = smallIcon ? 20 : 24;
  }
  render() {
    const ariaDisabled = this.disabled ? "true" : undefined;
    const ariaSelected = String(this.selected);
    const showCheckbox = this.context === "multi-select";
    const showIcon = Boolean(this.icon) && this.context === "single-select";
    const showSelectionIcon = this.selected && this.context === "single-select";
    const className = classnames("option-list-item", `option-list-item--context-${this.context}`, {
      "option-list-item--disabled": this.disabled,
      "option-list-item--draggable": this.allowDrag,
      "option-list-item--dragging": this.dragging,
      "option-list-item--selected": this.selected,
    });
    return (hAsync(Host, null, hAsync("div", { "aria-disabled": ariaDisabled, "aria-selected": ariaSelected, class: className, part: "option-list-item", role: "option" }, showIcon && (hAsync("span", { class: "option-list-item__icon", innerHTML: this.icon, ref: (el) => (this.iconEl = el) })), showCheckbox && (hAsync("span", { class: "option-list-item__checkbox" }, hAsync("span", { class: "option-list-item__checkbox-box" }, this.selected && (hAsync("swirl-icon-check-strong", { class: "option-list-item__checkbox-icon", size: 16 }))))), hAsync("span", { class: "option-list-item__label", part: "option-list-item__label" }, this.label), showSelectionIcon && (hAsync("span", { class: "option-list-item__selection-icon" }, hAsync("swirl-icon-check-small", { size: this.iconSize })))), this.allowDrag && (hAsync("button", { "aria-describedby": this.dragHandleDescription, "aria-label": `${this.dragHandleLabel} "${this.label}"`, class: "option-list-item__drag-handle", onKeyDown: this.onDragHandleKeyDown, type: "button" }, hAsync("swirl-icon-drag-handle", { size: this.iconSize })))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlOptionListItemCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-option-list-item",
    "$members$": {
      "allowDrag": [4, "allow-drag"],
      "context": [1025],
      "disabled": [4],
      "dragging": [4],
      "dragHandleDescription": [1, "drag-handle-description"],
      "dragHandleLabel": [1, "drag-handle-label"],
      "icon": [1],
      "label": [1],
      "selected": [1028],
      "value": [1],
      "iconSize": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlOptionListSectionCss = "/*!@:host*/.sc-swirl-option-list-section-h{display:block}/*!@:host **/.sc-swirl-option-list-section-h *.sc-swirl-option-list-section{box-sizing:border-box}/*!@.option-list-section*/.option-list-section.sc-swirl-option-list-section{background-color:var(--s-surface-overlay-default)}/*!@.option-list-section__label*/.option-list-section__label.sc-swirl-option-list-section{display:block;width:100%;padding:var(--s-space-8) var(--s-space-16);border-bottom:var(--s-border-width-default) solid var(--s-border-default);color:var(--s-text-subdued);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base);text-align:left}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.option-list-section__label*/.option-list-section__label.sc-swirl-option-list-section{padding:var(--s-space-8) var(--s-space-12);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}";

/**
 * @slot slot - The option list item components
 */
class SwirlOptionListSection {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.label = undefined;
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { "aria-labelledby": "label", class: "option-list-section", role: "group" }, hAsync("span", { class: "option-list-section__label", id: "label", part: "option-list-section__label" }, this.label), hAsync("div", { class: "option-list-section__items" }, hAsync("slot", null)))));
  }
  static get style() { return swirlOptionListSectionCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-option-list-section",
    "$members$": {
      "label": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlPaginationCss = "/*!@:host*/.sc-swirl-pagination-h{display:block;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}/*!@:host **/.sc-swirl-pagination-h *.sc-swirl-pagination{box-sizing:border-box}/*!@.pagination*/.pagination.sc-swirl-pagination{display:block;width:100%}/*!@.pagination--variant-simple .pagination__list*/.pagination--variant-simple.sc-swirl-pagination .pagination__list.sc-swirl-pagination{gap:0}/*!@.pagination__list*/.pagination__list.sc-swirl-pagination{display:flex;margin:0;padding:0;justify-content:flex-start;align-items:center;line-height:var(--s-line-height-base);list-style:none}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.pagination__list*/.pagination__list.sc-swirl-pagination{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.pagination__page-size-selection*/.pagination__page-size-selection.sc-swirl-pagination{display:flex;padding-right:var(--s-space-24);flex-shrink:0;align-items:center;color:var(--s-interactive-primary-default);white-space:nowrap;gap:var(--s-space-8)}/*!@.pagination__page-size-select-container*/.pagination__page-size-select-container.sc-swirl-pagination{position:relative}/*!@.pagination__page-size-select*/.pagination__page-size-select.sc-swirl-pagination{padding-right:calc(1rem + var(--s-space-4));border:none;color:var(--s-interactive-primary-default);background-color:transparent;font:inherit;font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.pagination__page-size-select:focus:not(:focus-visible)*/.pagination__page-size-select.sc-swirl-pagination:focus:not(:focus-visible){outline:none}/*!@.pagination__page-size-select:focus-visible*/.pagination__page-size-select.sc-swirl-pagination:focus-visible{outline-color:var(--s-focus-default)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.pagination__page-size-select*/.pagination__page-size-select.sc-swirl-pagination{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.pagination__page-size-select-icon*/.pagination__page-size-select-icon.sc-swirl-pagination{position:absolute;top:50%;right:0;transform:translateY(-50%);pointer-events:none}/*!@.pagination__page-label*/.pagination__page-label.sc-swirl-pagination{padding-right:var(--s-space-8);padding-left:var(--s-space-8)}/*!@.pagination__advanced-label*/.pagination__advanced-label.sc-swirl-pagination{display:flex;align-items:center;white-space:nowrap;gap:var(--s-space-8)}/*!@.pagination__page-input*/.pagination__page-input.sc-swirl-pagination{display:inline-flex;width:3.25rem;padding-top:var(--s-space-8);padding-right:var(--s-space-8);padding-bottom:var(--s-space-8);padding-left:var(--s-space-8);border:none;border-radius:var(--s-border-radius-sm);background-color:transparent;font:inherit;line-height:var(--s-line-height-base);text-align:center;box-shadow:inset 0 0 0 var(--s-border-width-default) var(--s-border-strong)}/*!@.pagination__page-input:focus:not(:focus-visible)*/.pagination__page-input.sc-swirl-pagination:focus:not(:focus-visible){outline:none}/*!@.pagination__page-input:focus-visible*/.pagination__page-input.sc-swirl-pagination:focus-visible{outline-color:var(--s-focus-default)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.pagination__page-input*/.pagination__page-input.sc-swirl-pagination{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}";

class SwirlPagination {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.setPage = createEvent(this, "setPage", 7);
    this.setPageSize = createEvent(this, "setPageSize", 7);
    this.onFocusPageInput = (event) => {
      event.target.select();
    };
    this.onFirstPageButtonClick = () => {
      if (this.page === 1) {
        return;
      }
      this.setPage.emit(1);
    };
    this.onLastPageButtonClick = () => {
      if (this.page === this.pages) {
        return;
      }
      this.setPage.emit(this.pages);
    };
    this.onPrevButtonClick = () => {
      const prevPage = Math.max(this.page - 1, 1);
      if (this.page === prevPage) {
        return;
      }
      this.setPage.emit(prevPage);
    };
    this.onNextButtonClick = () => {
      const nextPage = Math.min(this.page + 1, this.pages);
      if (this.page === nextPage) {
        return;
      }
      this.setPage.emit(nextPage);
    };
    this.onPageInput = () => {
      let page = +this.pageInput.value;
      if (isNaN(page)) {
        page = this.page;
        this.pageInput.value = String(page);
      }
      else if (page > this.pages) {
        page = this.pages;
        this.pageInput.value = String(page);
      }
      else if (page < 1) {
        page = 1;
        this.pageInput.value = String(page);
      }
      if (this.page === page) {
        return;
      }
      this.onPageUpdate(page);
    };
    this.onPageUpdate = debounce((page) => {
      this.setPage.emit(page);
    }, 500);
    this.onPageSizeSelect = (event) => {
      const pageSize = +event.target.value;
      if (this.pageSize === pageSize) {
        return;
      }
      this.setPageSize.emit(pageSize);
    };
    this.firstPageButtonLabel = "First page";
    this.lastPageButtonLabel = "Last page";
    this.label = undefined;
    this.nextButtonLabel = "Next page";
    this.page = undefined;
    this.pageLabel = "out of";
    this.pages = undefined;
    this.pageSelectLabel = "Select a page";
    this.pageSize = 10;
    this.pageSizeOptions = [10, 25, 50];
    this.pageSizeSelectLabel = "Items per page:";
    this.prevButtonLabel = "Previous page";
    this.showPageSizeSelect = undefined;
    this.variant = "default";
  }
  render() {
    const showPageLabel = this.variant !== "simple";
    const showDropDown = this.variant === "advanced";
    const ariaPageLabel = `${this.page.toLocaleString()} ${this.pageLabel} ${this.pages.toLocaleString()}`;
    const className = classnames("pagination", `pagination--variant-${this.variant}`);
    return (hAsync(Host, null, hAsync("nav", { "aria-label": this.label, class: className }, hAsync("ul", { class: "pagination__list", part: "pagination__list" }, this.showPageSizeSelect && (hAsync("li", { class: "pagination__list-item" }, hAsync("label", { class: "pagination__page-size-selection" }, hAsync("swirl-text", null, this.pageSizeSelectLabel), hAsync("swirl-stack", { align: "center", class: "pagination__page-size-select-container", orientation: "horizontal" }, hAsync("select", { class: "pagination__page-size-select", onChange: this.onPageSizeSelect }, this.pageSizeOptions.map((pageSizeOption) => (hAsync("option", { key: pageSizeOption, selected: pageSizeOption === this.pageSize, value: pageSizeOption }, pageSizeOption)))), hAsync("swirl-icon-expand-more", { "aria-hidden": "true", class: "pagination__page-size-select-icon", size: 16 }))))), hAsync("li", { class: "pagination__list-item" }, hAsync("swirl-button", { class: "pagination__first-page-button", disabled: this.page <= 1, hideLabel: true, icon: "<swirl-icon-double-arrow-left></swirl-icon-double-arrow-left>", intent: "primary", label: this.firstPageButtonLabel, onClick: this.onFirstPageButtonClick })), hAsync("li", { class: "pagination__list-item" }, hAsync("swirl-button", { class: "pagination__prev-button", disabled: this.page <= 1, hideLabel: true, icon: "<swirl-icon-chevron-left></swirl-icon-chevron-left>", intent: "primary", label: this.prevButtonLabel, onClick: this.onPrevButtonClick })), showPageLabel ? (hAsync("li", { class: "pagination__list-item  pagination__page-label" }, hAsync("span", null, showDropDown ? (hAsync("span", { "aria-current": "page", class: "pagination__advanced-label" }, hAsync("input", { "aria-label": this.pageSelectLabel, class: "pagination__page-input", onFocus: this.onFocusPageInput, onInput: this.onPageInput, ref: (el) => (this.pageInput = el), type: "text", value: this.page }), hAsync("span", { "aria-hidden": "true" }, this.pageLabel, " ", this.pages.toLocaleString()))) : (hAsync("span", { "aria-current": "page" }, ariaPageLabel))))) : (hAsync("li", { class: "pagination__list-item" }, hAsync("swirl-visually-hidden", null, hAsync("span", { "aria-current": "page" }, ariaPageLabel)))), hAsync("li", { class: "pagination__list-item" }, hAsync("swirl-button", { class: "pagination__next-button", disabled: this.page >= this.pages, hideLabel: true, icon: "<swirl-icon-chevron-right></swirl-icon-chevron-right>", iconPosition: "end", intent: "primary", label: this.nextButtonLabel, onClick: this.onNextButtonClick })), hAsync("li", { class: "pagination__list-item" }, hAsync("swirl-button", { class: "pagination__last-page-button", disabled: this.page >= this.pages, hideLabel: true, icon: "<swirl-icon-double-arrow-right></swirl-icon-double-arrow-right>", intent: "primary", label: this.lastPageButtonLabel, onClick: this.onLastPageButtonClick }))))));
  }
  static get style() { return swirlPaginationCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-pagination",
    "$members$": {
      "firstPageButtonLabel": [1, "first-page-button-label"],
      "lastPageButtonLabel": [1, "last-page-button-label"],
      "label": [1],
      "nextButtonLabel": [1, "next-button-label"],
      "page": [2],
      "pageLabel": [1, "page-label"],
      "pages": [2],
      "pageSelectLabel": [1, "page-select-label"],
      "pageSize": [2, "page-size"],
      "pageSizeOptions": [16],
      "pageSizeSelectLabel": [1, "page-size-select-label"],
      "prevButtonLabel": [1, "prev-button-label"],
      "showPageSizeSelect": [4, "show-page-size-select"],
      "variant": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlPdfReaderCss = "/*!@:host*/.sc-swirl-pdf-reader-h{--thumbnails-width:7rem;display:block}/*!@:host **/.sc-swirl-pdf-reader-h *.sc-swirl-pdf-reader{box-sizing:border-box}/*!@.pdf-reader*/.pdf-reader.sc-swirl-pdf-reader{position:fixed;z-index:var(--s-z-40);background-color:var(--s-surface-raised-default);inset:0;touch-action:pan-x pan-y}/*!@.pdf-reader[aria-hidden=\"true\"]*/.pdf-reader[aria-hidden=\"true\"].sc-swirl-pdf-reader{display:none}/*!@.pdf-reader:not(.pdf-reader--closing) .pdf-reader__body*/.pdf-reader.sc-swirl-pdf-reader:not(.pdf-reader--closing) .pdf-reader__body.sc-swirl-pdf-reader{animation:0.15s pdf-reader-fade-in}@media (prefers-reduced-motion){/*!@.pdf-reader:not(.pdf-reader--closing) .pdf-reader__body*/.pdf-reader.sc-swirl-pdf-reader:not(.pdf-reader--closing) .pdf-reader__body.sc-swirl-pdf-reader{animation:none}}/*!@.pdf-reader--closing*/.pdf-reader--closing.sc-swirl-pdf-reader{animation:0.15s pdf-reader-fade-out;animation-fill-mode:forwards}@media (prefers-reduced-motion){/*!@.pdf-reader--closing*/.pdf-reader--closing.sc-swirl-pdf-reader{animation:none}}/*!@.pdf-reader--show-thumbnails .pdf-reader__thumbnails*/.pdf-reader--show-thumbnails.sc-swirl-pdf-reader .pdf-reader__thumbnails.sc-swirl-pdf-reader{max-width:var(--thumbnails-width)}/*!@.pdf-reader--show-thumbnails .pdf-reader__floating-tools*/.pdf-reader--show-thumbnails.sc-swirl-pdf-reader .pdf-reader__floating-tools.sc-swirl-pdf-reader{left:calc(var(--s-space-16) + var(--thumbnails-width))}/*!@.pdf-reader__body*/.pdf-reader__body.sc-swirl-pdf-reader{position:relative;width:100%;height:100%}/*!@.pdf-reader__header*/.pdf-reader__header.sc-swirl-pdf-reader{display:flex;height:4rem;padding-right:var(--s-space-16);padding-left:var(--s-space-16);align-items:center;border-bottom:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-background-default);gap:var(--s-space-8)}/*!@.pdf-reader__header-left,\n.pdf-reader__header-right*/.pdf-reader__header-left.sc-swirl-pdf-reader,.pdf-reader__header-right.sc-swirl-pdf-reader{display:flex;flex-grow:1;align-items:center;gap:var(--s-space-8)}@media (min-width: 768px){/*!@.pdf-reader__header-left,\n.pdf-reader__header-right*/.pdf-reader__header-left.sc-swirl-pdf-reader,.pdf-reader__header-right.sc-swirl-pdf-reader{flex-basis:calc(100 / 3 * 1%);flex-grow:0}}/*!@.pdf-reader__header-right*/.pdf-reader__header-right.sc-swirl-pdf-reader{justify-content:flex-end}/*!@.pdf-reader__header-center*/.pdf-reader__header-center.sc-swirl-pdf-reader{display:none;flex-grow:1;justify-content:center;align-items:center;gap:var(--s-space-16)}@media (min-width: 768px){/*!@.pdf-reader__header-center*/.pdf-reader__header-center.sc-swirl-pdf-reader{display:flex}}/*!@.pdf-reader__label*/.pdf-reader__label.sc-swirl-pdf-reader{overflow:hidden;flex-grow:1;font-weight:var(--s-font-weight-semibold);white-space:nowrap;text-overflow:ellipsis}/*!@.pdf-reader__zoom-button-container*/.pdf-reader__zoom-button-container.sc-swirl-pdf-reader{display:flex;align-items:center;gap:var(--s-space-8)}/*!@.pdf-reader__zoom-button-container > *:not(:last-child)*/.pdf-reader__zoom-button-container.sc-swirl-pdf-reader>*.sc-swirl-pdf-reader:not(:last-child){position:relative}/*!@.pdf-reader__zoom-button-container > *:not(:last-child):after*/.pdf-reader__zoom-button-container.sc-swirl-pdf-reader>*.sc-swirl-pdf-reader:not(:last-child):after{position:absolute;top:50%;right:calc(-1 * var(--s-space-4));width:var(--s-border-width-default);height:1.5rem;background-color:var(--s-border-default);content:\"\";transform:translate3d(50%, -50%, 0)}/*!@.pdf-reader__zoom-select-container*/.pdf-reader__zoom-select-container.sc-swirl-pdf-reader{position:relative}/*!@.pdf-reader__zoom-select*/.pdf-reader__zoom-select.sc-swirl-pdf-reader{display:inline-flex;height:2.5rem;padding-right:var(--s-space-12);padding-right:calc(var(--s-space-8) + 1.5rem + var(--s-space-12));padding-left:var(--s-space-12);justify-content:flex-start;align-items:center;border:var(--s-border-width-default) solid var(--s-border-default);border-radius:var(--s-border-radius-sm);color:var(--s-interactive-neutral-default);background-color:transparent;font:inherit;font-weight:var(--s-font-weight-medium);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.pdf-reader__zoom-select:focus:not(:focus-visible)*/.pdf-reader__zoom-select.sc-swirl-pdf-reader:focus:not(:focus-visible){outline:none}/*!@.pdf-reader__zoom-select:focus-visible*/.pdf-reader__zoom-select.sc-swirl-pdf-reader:focus-visible{outline-color:var(--s-focus-default)}/*!@.pdf-reader__zoom-select-icon*/.pdf-reader__zoom-select-icon.sc-swirl-pdf-reader{position:absolute;top:50%;right:var(--s-space-8);display:inline-flex;transform:translateY(-50%);pointer-events:none}/*!@.pdf-reader__content*/.pdf-reader__content.sc-swirl-pdf-reader{display:flex;width:100%;height:calc(100% - 4rem)}/*!@.pdf-reader__thumbnails*/.pdf-reader__thumbnails.sc-swirl-pdf-reader{display:flex;overflow-x:hidden;overflow-y:auto;max-width:0;height:100%;padding-top:var(--s-space-16);padding-bottom:var(--s-space-16);flex-basis:var(--thumbnails-width);flex-grow:0;flex-shrink:0;align-items:center;background-color:var(--s-background-default);flex-direction:column;transition:max-width 0.2s linear;box-shadow:inset calc(-1 * var(--s-border-width-default)) 0 0 0\n    var(--s-border-default);gap:var(--s-space-4)}/*!@.pdf-reader__thumbnail*/.pdf-reader__thumbnail.sc-swirl-pdf-reader{width:5rem;margin:0;padding:0;border:var(--s-border-width-default) solid var(--s-border-default);background-color:transparent;cursor:pointer}/*!@.pdf-reader__thumbnail > img*/.pdf-reader__thumbnail.sc-swirl-pdf-reader>img.sc-swirl-pdf-reader{display:inline-flex;width:100%}/*!@.pdf-reader__thumbnail--active*/.pdf-reader__thumbnail--active.sc-swirl-pdf-reader{border-width:0.125rem;border-color:var(--s-border-highlight)}/*!@.pdf-reader__viewer*/.pdf-reader__viewer.sc-swirl-pdf-reader{flex-grow:1}/*!@.pdf-reader__mobile-zoom-controls*/.pdf-reader__mobile-zoom-controls.sc-swirl-pdf-reader{position:absolute;z-index:1;right:var(--s-space-16);bottom:var(--s-space-32);display:flex;padding-bottom:var(--s-space-4);flex-direction:column;gap:var(--s-space-8)}@media (min-width: 768px){/*!@.pdf-reader__mobile-zoom-controls*/.pdf-reader__mobile-zoom-controls.sc-swirl-pdf-reader{display:none}}/*!@.pdf-reader__mobile-zoom-button*/.pdf-reader__mobile-zoom-button.sc-swirl-pdf-reader{display:inline-flex;width:2.5rem;height:2.5rem;justify-content:center;align-items:center;border:none;border-radius:50%;color:var(--s-icon-on-image);background-color:rgba(0, 0, 0, 0.6);cursor:pointer;transition:opacity 0.15s;pointer-events:auto}/*!@.pdf-reader__mobile-zoom-button:disabled*/.pdf-reader__mobile-zoom-button.sc-swirl-pdf-reader:disabled{cursor:default}/*!@.pdf-reader__floating-tools*/.pdf-reader__floating-tools.sc-swirl-pdf-reader{position:fixed;z-index:1;bottom:var(--s-space-16);left:var(--s-space-16);display:none;flex-direction:column;transition:left 0.2s linear;gap:var(--s-space-12)}@media (min-width: 768px){/*!@.pdf-reader__floating-tools*/.pdf-reader__floating-tools.sc-swirl-pdf-reader{display:flex}}/*!@.pdf-reader__floating-tool-button*/.pdf-reader__floating-tool-button.sc-swirl-pdf-reader{display:inline-flex;width:2.5rem;height:2.5rem;justify-content:center;align-items:center;border:none;border-radius:50%;color:var(--s-icon-on-image);background-color:rgba(0, 0, 0, 0.6);cursor:pointer}/*!@.pdf-reader__meta*/.pdf-reader__meta.sc-swirl-pdf-reader{display:flex;padding-top:var(--s-space-4);padding-right:var(--s-space-16);padding-bottom:var(--s-space-4);padding-left:var(--s-space-8);align-items:center;gap:var(--s-space-12)}@media (min-width: 768px){/*!@.pdf-reader__meta*/.pdf-reader__meta.sc-swirl-pdf-reader{max-width:18rem}}/*!@.pdf-reader__file-icon*/.pdf-reader__file-icon.sc-swirl-pdf-reader{display:inline-flex;padding-left:var(--s-space-4);flex-shrink:0}/*!@.pdf-reader__file-info*/.pdf-reader__file-info.sc-swirl-pdf-reader{display:flex;min-width:0;flex-grow:1;flex-direction:column}@keyframes pdf-reader-fade-in{from{opacity:0}to{opacity:1}}@keyframes pdf-reader-fade-out{from{opacity:1}to{opacity:0}}";

class SwirlPdfReader {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.desktopZoomSteps = [0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4];
    this.mobileZoomSteps = [0.5, 0.75, 1, 1.25, 1.5];
    this.toggleViewMode = () => {
      if (this.viewMode === "single") {
        this.viewMode = "side-by-side";
      }
      else {
        this.viewMode = "single";
      }
    };
    this.toggleThumbnals = () => {
      this.showThumbnails = !this.showThumbnails;
    };
    this.onKeyDown = (event) => {
      if (event.code === "Escape") {
        this.close();
      }
    };
    this.onActivate = async (event) => {
      this.pdfViewer = event.detail;
      this.lockBodyScroll();
      this.generateThumbnails();
    };
    this.onVisiblePagesChange = async (event) => {
      this.visiblePages = event.detail;
    };
    this.onCloseButtonClick = () => {
      this.close();
    };
    this.onPrintButtonClick = () => {
      this.pdfViewer.print();
      this.menu.close();
    };
    this.onDownloadButtonClick = async () => {
      this.downloading = true;
      await this.viewer.download();
      this.downloading = false;
      this.menu.close();
    };
    this.onZoomInButtonClick = () => {
      const currentZoomStepIndex = this.zoomSteps.indexOf(+this.zoom);
      this.zoom =
        currentZoomStepIndex === -1
          ? 1
          : this.zoomSteps[Math.min(this.zoomSteps.length - 1, currentZoomStepIndex + 1)];
    };
    this.onZoomOutButtonClick = () => {
      const currentZoomStepIndex = this.zoomSteps.indexOf(+this.zoom);
      this.zoom =
        currentZoomStepIndex === -1
          ? 1
          : this.zoomSteps[Math.max(0, currentZoomStepIndex - 1)];
    };
    this.onZoomAutoButtonClick = () => {
      this.zoom = this.zoom === "auto" ? 1 : "auto";
    };
    this.onZoomChange = (event) => {
      const value = event.target.value;
      this.zoom = value === "auto" ? value : +value;
    };
    this.onThumbnailClick = (index) => () => {
      var _a;
      const page = (_a = querySelectorAllDeep(this.el, `[data-page-number="${index + 1}"]`)) === null || _a === void 0 ? void 0 : _a[0];
      page === null || page === void 0 ? void 0 : page.scrollIntoView();
    };
    this.autoZoomLabel = "Full width";
    this.closeButtonLabel = "Close PDF viewer";
    this.downloadButtonLabel = "Download PDF";
    this.file = undefined;
    this.fileTypeLabel = "PDF Document";
    this.label = undefined;
    this.menuLabel = "File menu";
    this.menuTriggerLabel = "Open file menu";
    this.printButtonLabel = "Print PDF";
    this.sideBySideButtonLabel = "Toggle side by side view";
    this.thumbnailButtonLabel = "Scroll to page";
    this.thumbnailsButtonLabel = "Toggle thumbnails";
    this.thumbnailsLabel = "Page thumbnails";
    this.zoomInButtonLabel = "Zoom in";
    this.zoomOutButtonLabel = "Zoom out";
    this.zoomSelectLabel = "Select zoom";
    this.active = false;
    this.closing = false;
    this.downloading = false;
    this.thumbnails = [];
    this.showThumbnails = undefined;
    this.viewMode = "single";
    this.visiblePages = [];
    this.zoom = undefined;
    this.zoomSteps = undefined;
  }
  componentWillLoad() {
    this.updateZoomSteps();
    this.zoom = isMobileViewport() ? "auto" : 1;
  }
  componentDidLoad() {
    this.modal = new A11yDialog(this.modalEl);
  }
  disconnectedCallback() {
    var _a;
    this.unlockBodyScroll();
    (_a = this.modal) === null || _a === void 0 ? void 0 : _a.destroy();
  }
  onWindowResize() {
    if (!Boolean(this.pdfViewer)) {
      return;
    }
    this.updateZoomSteps();
    this.zoom = isMobileViewport() ? "auto" : 1;
  }
  /**
   * Open the reader.
   */
  async open() {
    this.modal.show();
    this.active = true;
  }
  /**
   * Close the reader.
   */
  async close() {
    if (this.closing) {
      return;
    }
    this.closing = true;
    this.unlockBodyScroll();
    setTimeout(() => {
      this.modal.hide();
      this.closing = false;
      this.active = false;
    }, 150);
  }
  lockBodyScroll() {
    const scrollContainer = this.pdfViewer.shadowRoot.querySelector(".file-viewer-pdf__pages");
    if (Boolean(scrollContainer)) {
      disableBodyScroll(scrollContainer);
    }
  }
  unlockBodyScroll() {
    const scrollContainer = this.pdfViewer.shadowRoot.querySelector(".file-viewer-pdf__pages");
    if (Boolean(scrollContainer)) {
      enableBodyScroll(scrollContainer);
    }
  }
  async generateThumbnails() {
    this.thumbnails = await this.pdfViewer.getThumbnails();
  }
  updateZoomSteps() {
    this.zoomSteps = isMobileViewport()
      ? this.mobileZoomSteps
      : this.desktopZoomSteps;
  }
  render() {
    const className = classnames("pdf-reader", {
      "pdf-reader--closing": this.closing,
      "pdf-reader--show-thumbnails": this.showThumbnails,
    });
    return (hAsync(Host, null, hAsync("section", { "aria-hidden": "true", "aria-label": this.label, class: className, id: "pdf-reader", onKeyDown: this.onKeyDown, ref: (el) => (this.modalEl = el) }, hAsync("div", { class: "pdf-reader__body", role: "document" }, hAsync("header", { class: "pdf-reader__header" }, hAsync("span", { class: "pdf-reader__header-left" }, hAsync("swirl-button", { class: "pdf-reader__close-button", hideLabel: true, icon: "<swirl-icon-close></swirl-icon-close>", label: this.closeButtonLabel, onClick: this.onCloseButtonClick }), hAsync("span", { class: "pdf-reader__label" }, this.label)), hAsync("span", { class: "pdf-reader__header-center" }, hAsync("span", { class: "pdf-reader__zoom-button-container" }, hAsync("swirl-button", { class: "pdf-reader__zoom-button", disabled: this.zoom === this.zoomSteps[0], hideLabel: true, icon: "<swirl-icon-remove></swirl-icon-remove>", label: this.zoomOutButtonLabel, onClick: this.onZoomOutButtonClick }), hAsync("swirl-button", { class: "pdf-reader__zoom-button", disabled: this.zoom === this.zoomSteps[this.zoomSteps.length - 1], hideLabel: true, icon: "<swirl-icon-add></swirl-icon-add>", label: this.zoomInButtonLabel, onClick: this.onZoomInButtonClick })), hAsync("span", { class: "pdf-reader__zoom-select-container" }, hAsync("select", { "aria-label": this.zoomSelectLabel, class: "pdf-reader__zoom-select", name: "zoom-select", id: "zoom-select", onChange: this.onZoomChange }, hAsync("option", { selected: this.zoom === "auto", value: "auto" }, this.autoZoomLabel), this.zoomSteps.map((zoom) => (hAsync("option", { key: zoom, selected: this.zoom === zoom, value: zoom }, zoom * 100, "%")))), hAsync("swirl-icon-expand-more", { class: "pdf-reader__zoom-select-icon" }))), hAsync("span", { class: "pdf-reader__header-right" }, hAsync("swirl-button", { class: "pdf-reader__menu-button", hideLabel: true, icon: "<swirl-icon-more-vertikal></swirl-icon-more-vertikal>", id: "menu-trigger", label: this.menuTriggerLabel })), hAsync("span", { class: "pdf-reader__floating-tools" }, hAsync("button", { "aria-label": this.sideBySideButtonLabel, class: "pdf-reader__floating-tool-button", onClick: this.toggleViewMode, type: "button" }, hAsync("swirl-icon-menu-book", null)), hAsync("button", { "aria-controls": "thumbnails", "aria-expanded": String(Boolean(this.showThumbnails)), "aria-label": this.thumbnailsButtonLabel, class: "pdf-reader__floating-tool-button", onClick: this.toggleThumbnals, type: "button" }, hAsync("swirl-icon-file-copy", null)))), hAsync("div", { class: "pdf-reader__content" }, hAsync("nav", { "aria-label": this.thumbnailsLabel, class: "pdf-reader__thumbnails", id: "thumbnails" }, this.thumbnails.map((thumbnail, index) => {
      const thumbnailClassName = classnames("pdf-reader__thumbnail", {
        "pdf-reader__thumbnail--active": this.visiblePages[0] === index + 1,
      });
      return (hAsync("button", { "aria-label": `${this.thumbnailButtonLabel} ${index + 1}`, class: thumbnailClassName, onClick: this.onThumbnailClick(index), type: "button" }, hAsync("img", { src: thumbnail.toDataURL("image/png"), alt: "" })));
    })), hAsync("swirl-file-viewer", { active: this.active, class: "pdf-reader__viewer", file: this.file, onActivate: this.onActivate, onVisiblePagesChange: this.onVisiblePagesChange, ref: (el) => (this.viewer = el), type: "application/pdf", viewMode: this.viewMode, zoom: this.zoom }), hAsync("div", { class: "pdf-reader__mobile-zoom-controls" }, hAsync("button", { "aria-label": this.autoZoomLabel, class: "pdf-reader__mobile-zoom-button", onClick: this.onZoomAutoButtonClick, type: "button" }, this.zoom === "auto" ? (hAsync("swirl-icon-fullscreen-exit", null)) : (hAsync("swirl-icon-fullscreen", null))), hAsync("button", { "aria-label": this.zoomInButtonLabel, class: "pdf-reader__mobile-zoom-button", disabled: this.zoom === this.zoomSteps[this.zoomSteps.length - 1], onClick: this.onZoomInButtonClick, type: "button" }, hAsync("swirl-icon-add", null)), hAsync("button", { "aria-label": this.zoomOutButtonLabel, class: "pdf-reader__mobile-zoom-button", disabled: this.zoom === this.zoomSteps[0], onClick: this.onZoomOutButtonClick, type: "button" }, hAsync("swirl-icon-remove", null))))), hAsync("swirl-popover", { animation: "scale-in-y", disableScrollLock: true, label: this.menuLabel, placement: "bottom-end", popoverId: "menu", ref: (el) => (this.menu = el), trigger: "menu-trigger" }, hAsync("swirl-stack", null, hAsync("div", { class: "pdf-reader__meta" }, hAsync("div", { class: "pdf-reader__file-icon" }, hAsync("svg", { fill: "none", height: "36", viewBox: "0 0 24 36", width: "24" }, hAsync("path", { d: "M7.01755 21.6V15.192H8.39455C8.64655 15.192 8.86855 15.225 9.06055 15.291C9.25255 15.357 9.42655 15.474 9.58255 15.642C9.73855 15.81 9.84655 16.008 9.90655 16.236C9.96655 16.458 9.99655 16.761 9.99655 17.145C9.99655 17.433 9.97855 17.676 9.94255 17.874C9.91255 18.072 9.84355 18.258 9.73555 18.432C9.60955 18.642 9.44155 18.807 9.23155 18.927C9.02155 19.041 8.74555 19.098 8.40355 19.098H7.93555V21.6H7.01755ZM7.93555 16.056V18.234H8.37655C8.56255 18.234 8.70655 18.207 8.80855 18.153C8.91055 18.099 8.98555 18.024 9.03355 17.928C9.08155 17.838 9.10855 17.727 9.11455 17.595C9.12655 17.463 9.13255 17.316 9.13255 17.154C9.13255 17.004 9.12955 16.863 9.12355 16.731C9.11755 16.593 9.09055 16.473 9.04255 16.371C8.99455 16.269 8.92255 16.191 8.82655 16.137C8.73055 16.083 8.59255 16.056 8.41255 16.056H7.93555Z", fill: "white" }), hAsync("path", { d: "M10.6826 21.6V15.192H12.0416C12.5696 15.192 12.9686 15.336 13.2386 15.624C13.5146 15.912 13.6526 16.32 13.6526 16.848V19.845C13.6526 20.445 13.5056 20.889 13.2116 21.177C12.9236 21.459 12.5066 21.6 11.9606 21.6H10.6826ZM11.6006 16.056V20.736H12.0236C12.2816 20.736 12.4646 20.673 12.5726 20.547C12.6806 20.415 12.7346 20.211 12.7346 19.935V16.848C12.7346 16.596 12.6836 16.401 12.5816 16.263C12.4796 16.125 12.2936 16.056 12.0236 16.056H11.6006Z", fill: "white" }), hAsync("path", { d: "M14.5146 21.6V15.192H17.2506V16.056H15.4326V18H17.0166V18.864H15.4326V21.6H14.5146Z", fill: "white" }), hAsync("path", { d: "M3.59961 9.00001C3.59961 8.0059 4.4055 7.20001 5.39961 7.20001H14.854C15.3314 7.20001 15.7893 7.38965 16.1268 7.72722L19.8724 11.4728C20.21 11.8104 20.3996 12.2682 20.3996 12.7456V27C20.3996 27.9941 19.5937 28.8 18.5996 28.8H5.39961C4.4055 28.8 3.59961 27.9941 3.59961 27V9.00001Z", fill: "#FF574D" }), hAsync("path", { d: "M15.5996 7.36166V10.2C15.5996 11.1941 16.4055 12 17.3996 12H20.2379C20.3237 12.1884 20.3768 12.3913 20.3937 12.6H17.3996C16.0785 12.6 15.0067 11.5325 14.9996 10.213L14.9996 7.20587C15.2083 7.2228 15.4112 7.27593 15.5996 7.36166Z", fill: "white" }), hAsync("path", { d: "M7.01755 21.6V15.192H8.39455C8.64655 15.192 8.86855 15.225 9.06055 15.291C9.25255 15.357 9.42655 15.474 9.58255 15.642C9.73855 15.81 9.84655 16.008 9.90655 16.236C9.96655 16.458 9.99655 16.761 9.99655 17.145C9.99655 17.433 9.97855 17.676 9.94255 17.874C9.91255 18.072 9.84355 18.258 9.73555 18.432C9.60955 18.642 9.44155 18.807 9.23155 18.927C9.02155 19.041 8.74555 19.098 8.40355 19.098H7.93555V21.6H7.01755ZM7.93555 16.056V18.234H8.37655C8.56255 18.234 8.70655 18.207 8.80855 18.153C8.91055 18.099 8.98555 18.024 9.03355 17.928C9.08155 17.838 9.10855 17.727 9.11455 17.595C9.12655 17.463 9.13255 17.316 9.13255 17.154C9.13255 17.004 9.12955 16.863 9.12355 16.731C9.11755 16.593 9.09055 16.473 9.04255 16.371C8.99455 16.269 8.92255 16.191 8.82655 16.137C8.73055 16.083 8.59255 16.056 8.41255 16.056H7.93555Z", fill: "white" }), hAsync("path", { d: "M10.6826 21.6V15.192H12.0416C12.5696 15.192 12.9686 15.336 13.2386 15.624C13.5146 15.912 13.6526 16.32 13.6526 16.848V19.845C13.6526 20.445 13.5056 20.889 13.2116 21.177C12.9236 21.459 12.5066 21.6 11.9606 21.6H10.6826ZM11.6006 16.056V20.736H12.0236C12.2816 20.736 12.4646 20.673 12.5726 20.547C12.6806 20.415 12.7346 20.211 12.7346 19.935V16.848C12.7346 16.596 12.6836 16.401 12.5816 16.263C12.4796 16.125 12.2936 16.056 12.0236 16.056H11.6006Z", fill: "white" }), hAsync("path", { d: "M14.5146 21.6V15.192H17.2506V16.056H15.4326V18H17.0166V18.864H15.4326V21.6H14.5146Z", fill: "white" }))), hAsync("div", { class: "pdf-reader__file-info" }, hAsync("swirl-text", { truncate: true, weight: "semibold" }, this.label), hAsync("swirl-text", { color: "subdued", size: "sm", truncate: true }, this.fileTypeLabel))), hAsync("swirl-separator", null), hAsync("swirl-action-list", null, hAsync("swirl-action-list-item", { class: "pdf-reader__print-button", icon: "<swirl-icon-print></swirl-icon-print>", label: this.printButtonLabel, onClick: this.onPrintButtonClick }), hAsync("swirl-action-list-item", { class: "pdf-reader__download-button", disabled: this.downloading, icon: !this.downloading
        ? "<swirl-icon-download></swirl-icon-download>"
        : '<swirl-spinner size="xs"></swirl-spinner>', label: this.downloadButtonLabel, onClick: this.onDownloadButtonClick }), hAsync("slot", { name: "menu-items" })))))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlPdfReaderCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-pdf-reader",
    "$members$": {
      "autoZoomLabel": [1, "auto-zoom-label"],
      "closeButtonLabel": [1, "close-button-label"],
      "downloadButtonLabel": [1, "download-button-label"],
      "file": [1],
      "fileTypeLabel": [1, "file-type-label"],
      "label": [1],
      "menuLabel": [1, "menu-label"],
      "menuTriggerLabel": [1, "menu-trigger-label"],
      "printButtonLabel": [1, "print-button-label"],
      "sideBySideButtonLabel": [1, "side-by-side-button-label"],
      "thumbnailButtonLabel": [1, "thumbnail-button-label"],
      "thumbnailsButtonLabel": [1, "thumbnails-button-label"],
      "thumbnailsLabel": [1, "thumbnails-label"],
      "zoomInButtonLabel": [1, "zoom-in-button-label"],
      "zoomOutButtonLabel": [1, "zoom-out-button-label"],
      "zoomSelectLabel": [1, "zoom-select-label"],
      "active": [32],
      "closing": [32],
      "downloading": [32],
      "thumbnails": [32],
      "showThumbnails": [32],
      "viewMode": [32],
      "visiblePages": [32],
      "zoom": [32],
      "zoomSteps": [32],
      "open": [64],
      "close": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlPopoverCss = "/*!@:host*/.sc-swirl-popover-h{position:relative;z-index:var(--s-z-40);display:inline-flex}/*!@:host **/.sc-swirl-popover-h *.sc-swirl-popover{box-sizing:border-box}/*!@.popover--active:not(.popover--closing) .popover__backdrop*/.popover--active.sc-swirl-popover:not(.popover--closing) .popover__backdrop.sc-swirl-popover{animation:0.15s popover-fade-in}@media (prefers-reduced-motion){/*!@.popover--active:not(.popover--closing) .popover__backdrop*/.popover--active.sc-swirl-popover:not(.popover--closing) .popover__backdrop.sc-swirl-popover{animation:none}}/*!@.popover--active:not(.popover--closing) .popover__content*/.popover--active.sc-swirl-popover:not(.popover--closing) .popover__content.sc-swirl-popover{animation:0.15s popover-slide-in}@media (min-width: 768px){/*!@.popover--active:not(.popover--closing) .popover__content*/.popover--active.sc-swirl-popover:not(.popover--closing) .popover__content.sc-swirl-popover{transform-origin:top left;animation:0.15s popover-fade-scale-in-xy}}@media (prefers-reduced-motion){/*!@.popover--active:not(.popover--closing) .popover__content*/.popover--active.sc-swirl-popover:not(.popover--closing) .popover__content.sc-swirl-popover{animation:none}}/*!@.popover--closing .popover__backdrop*/.popover--closing.sc-swirl-popover .popover__backdrop.sc-swirl-popover{animation:0.15s popover-fade-out;animation-fill-mode:forwards}@media (prefers-reduced-motion){/*!@.popover--closing .popover__backdrop*/.popover--closing.sc-swirl-popover .popover__backdrop.sc-swirl-popover{animation:none}}/*!@.popover--closing .popover__content*/.popover--closing.sc-swirl-popover .popover__content.sc-swirl-popover{animation:0.15s popover-slide-out;animation-fill-mode:forwards}@media (min-width: 768px){/*!@.popover--closing .popover__content*/.popover--closing.sc-swirl-popover .popover__content.sc-swirl-popover{animation:0.15s popover-fade-out}}@media (prefers-reduced-motion){/*!@.popover--closing .popover__content*/.popover--closing.sc-swirl-popover .popover__content.sc-swirl-popover{animation:none}}/*!@.popover--inactive .popover__content*/.popover--inactive.sc-swirl-popover .popover__content.sc-swirl-popover{display:none}@media (max-width: 767px){/*!@.popover--fullscreen-bottom-sheet.popover--active:not(.popover--closing) .popover__content*/.popover--fullscreen-bottom-sheet.popover--active.sc-swirl-popover:not(.popover--closing) .popover__content.sc-swirl-popover{animation:0.15s popover-fade-in}/*!@@media (prefers-reduced-motion)*/@media .sc-swirl-popover (prefers-reduced-motion).sc-swirl-popover{.popover--fullscreen-bottom-sheet.popover--active:not(.popover--closing) .popover__content{animation:none}}/*!@.popover--fullscreen-bottom-sheet.popover--closing .popover__content*/.popover--fullscreen-bottom-sheet.popover--closing.sc-swirl-popover .popover__content.sc-swirl-popover{animation:0.15s popover-fade-out;animation-fill-mode:forwards}/*!@@media (prefers-reduced-motion)*/@media .sc-swirl-popover (prefers-reduced-motion).sc-swirl-popover{.popover--fullscreen-bottom-sheet.popover--closing .popover__content{animation:none}}/*!@.popover--fullscreen-bottom-sheet .popover__backdrop*/.popover--fullscreen-bottom-sheet.sc-swirl-popover .popover__backdrop.sc-swirl-popover{display:none}/*!@.popover--fullscreen-bottom-sheet .popover__content*/.popover--fullscreen-bottom-sheet.sc-swirl-popover .popover__content.sc-swirl-popover{top:0;border-top-left-radius:0;border-top-right-radius:0}/*!@.popover--fullscreen-bottom-sheet .popover__scroll-container*/.popover--fullscreen-bottom-sheet.sc-swirl-popover .popover__scroll-container.sc-swirl-popover{height:100%;max-height:none;padding-top:0;padding-bottom:0}/*!@.popover--fullscreen-bottom-sheet .popover__handle*/.popover--fullscreen-bottom-sheet.sc-swirl-popover .popover__handle.sc-swirl-popover{display:none}}@media (min-width: 768px){/*!@.popover--animation-scale-in-y.popover--active:not(.popover--closing) .popover__content*/.popover--animation-scale-in-y.popover--active.sc-swirl-popover:not(.popover--closing) .popover__content.sc-swirl-popover{animation:0.15s popover-fade-scale-in-y}}@media (prefers-reduced-motion){/*!@.popover--animation-scale-in-y.popover--active:not(.popover--closing) .popover__content*/.popover--animation-scale-in-y.popover--active.sc-swirl-popover:not(.popover--closing) .popover__content.sc-swirl-popover{animation:none}}/*!@.popover__backdrop*/.popover__backdrop.sc-swirl-popover{position:fixed;z-index:0;background-color:rgba(0, 0, 0, 0.2);animation:0.15s popover-backdrop-fade-in;inset:0}@media (prefers-reduced-motion){/*!@.popover__backdrop*/.popover__backdrop.sc-swirl-popover{animation:none}}@media (min-width: 768px){/*!@.popover__backdrop*/.popover__backdrop.sc-swirl-popover{display:none}}/*!@.popover__content*/.popover__content.sc-swirl-popover{position:fixed;z-index:2;right:0;bottom:0;left:0;overflow:hidden;border-top-left-radius:var(--s-border-radius-xl);border-top-right-radius:var(--s-border-radius-xl);background-color:var(--s-surface-overlay-default)}@media (min-width: 768px){/*!@.popover__content*/.popover__content.sc-swirl-popover{right:unset;bottom:unset;left:unset;max-width:22.5rem;border-radius:var(--s-border-radius-sm);animation:none;box-shadow:var(--s-shadow-level-1)}}/*!@.popover__scroll-container*/.popover__scroll-container.sc-swirl-popover{overflow-x:hidden;overflow-y:auto;width:100%;max-height:90vh;padding-top:var(--s-space-24);padding-bottom:var(--s-space-24);overscroll-behavior:contain}@media (min-width: 768px){/*!@.popover__scroll-container*/.popover__scroll-container.sc-swirl-popover{max-height:22rem;padding-top:var(--s-space-8);padding-bottom:var(--s-space-8)}}/*!@.popover__handle*/.popover__handle.sc-swirl-popover{position:absolute;top:var(--s-space-8);left:50%;width:2.5rem;height:0.375rem;border-radius:0.1875rem;background-color:var(--s-border-default);transform:translatex(-50%)}@media (min-width: 768px){/*!@.popover__handle*/.popover__handle.sc-swirl-popover{display:none}}@keyframes popover-slide-in{from{transform:translateY(100%)}to{transform:translateY(0)}}@keyframes popover-slide-out{from{transform:translateY(0)}to{transform:translateY(100%)}}@keyframes popover-fade-in{from{opacity:0}to{opacity:1}}@keyframes popover-fade-out{from{opacity:1}to{opacity:0}}@keyframes popover-fade-scale-in-xy{from{transform:scale(0);opacity:0}to{transform:scale(1);opacity:1}}@keyframes popover-fade-scale-in-y{from{transform:scaleY(0);opacity:0}to{transform:scaleY(1);opacity:1}}";

/**
 * @slot slot - The popover content.
 */
class SwirlPopover {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.popoverClose = createEvent(this, "popoverClose", 7);
    this.popoverOpen = createEvent(this, "popoverOpen", 7);
    this.toggle = (event) => {
      event.stopPropagation();
      if (this.active) {
        this.close();
      }
      else {
        this.open();
      }
    };
    this.onKeydown = (event) => {
      if (event.code === "Escape" && this.active) {
        event.stopPropagation();
        this.close();
      }
    };
    this.reposition = async () => {
      const mobile = isMobileViewport();
      if (!Boolean(this.triggerEl) || !Boolean(this.contentContainer)) {
        return;
      }
      if (mobile) {
        this.position = undefined;
        return;
      }
      const offsetOptions = typeof this.offset === "number"
        ? { mainAxis: this.offset, crossAxis: 0 }
        : { mainAxis: this.offset[0], crossAxis: this.offset[1] };
      const middleware = this.enableFlip
        ? [offset(offsetOptions), shift(), flip()]
        : [offset(offsetOptions), shift()];
      this.position = await computePosition(this.triggerEl, this.contentContainer, {
        middleware,
        placement: this.placement,
        strategy: "fixed",
      });
    };
    this.onCloseButtonClick = () => {
      this.close();
    };
    this.animation = "scale-in-xy";
    this.disableScrollLock = undefined;
    this.enableFlip = true;
    this.fullscreenBottomSheet = undefined;
    this.label = undefined;
    this.maxHeight = "22rem";
    this.offset = 8;
    this.placement = "bottom-start";
    this.popoverId = undefined;
    this.trigger = undefined;
    this.useContainerWidth = undefined;
    this.active = false;
    this.closing = false;
    this.position = undefined;
  }
  componentDidLoad() {
    this.connectTrigger();
    this.updateFocusableChildren();
    this.updateTriggerAttributes();
  }
  disconnectedCallback() {
    this.unlockBodyScroll();
  }
  onWindowFocusIn(event) {
    if (!this.active) {
      return;
    }
    const target = event.target;
    const relatedTarget = event.relatedTarget;
    const activeElement = getActiveElement();
    const popoverLostFocus = !this.el.contains(target) &&
      !this.el.contains(activeElement) &&
      !this.el.contains(relatedTarget || target) &&
      target !== this.triggerEl &&
      relatedTarget !== this.el;
    if (popoverLostFocus) {
      this.close();
    }
  }
  onWindowClick(event) {
    if (!this.active) {
      return;
    }
    const target = event.target;
    const clickedChild = this.el.contains(target);
    const clickedShadowChild = event
      .composedPath()
      .some((el) => Boolean(el) && el instanceof Node
      ? this.el.contains(el)
      : false);
    const clickedTrigger = event.target === this.triggerEl;
    if (!clickedChild && !clickedShadowChild && !clickedTrigger) {
      this.close();
    }
  }
  /**
   * Close the popover.
   * @returns
   */
  async close() {
    var _a;
    if (this.closing || !this.active) {
      return;
    }
    this.popoverClose.emit();
    if (this.disableAutoUpdate) {
      this.disableAutoUpdate();
    }
    this.closing = true;
    setTimeout(() => {
      this.active = false;
      this.closing = false;
      this.updateTriggerAttributes();
    }, 150);
    this.unlockBodyScroll();
    (_a = this.getNativeTriggerElement()) === null || _a === void 0 ? void 0 : _a.focus();
  }
  /**
   * Open the popover.
   * @returns
   */
  async open() {
    if (this.active) {
      return;
    }
    this.adjustWidth();
    this.active = true;
    this.updateFocusableChildren();
    this.updateTriggerAttributes();
    requestAnimationFrame(async () => {
      await this.reposition();
      this.popoverOpen.emit({ position: this.position });
      if (this.focusableChildren.length > 0) {
        this.focusableChildren[0].focus();
      }
      else {
        this.contentContainer.focus();
      }
      if (this.disableAutoUpdate) {
        this.disableAutoUpdate();
      }
      this.disableAutoUpdate = autoUpdate(this.triggerEl, this.contentContainer, this.reposition);
      this.scrollContainer.scrollTop = 0;
      this.lockBodyScroll();
    });
  }
  connectTrigger() {
    this.triggerEl = querySelectorAllDeep(document.body, `#${this.trigger}`)[0];
    if (!Boolean(this.triggerEl)) {
      return;
    }
    this.triggerEl.addEventListener("click", (event) => {
      this.toggle(event);
    });
  }
  getNativeTriggerElement() {
    var _a, _b, _c;
    return this.triggerEl.tagName.startsWith("SWIRL-")
      ? (((_a = this.triggerEl) === null || _a === void 0 ? void 0 : _a.children[0]) ||
        ((_c = (_b = this.triggerEl) === null || _b === void 0 ? void 0 : _b.shadowRoot) === null || _c === void 0 ? void 0 : _c.children[0]) ||
        this.triggerEl)
      : this.triggerEl;
  }
  updateTriggerAttributes() {
    if (!Boolean(this.triggerEl)) {
      return;
    }
    const nativeTriggerEl = this.getNativeTriggerElement();
    nativeTriggerEl.setAttribute("aria-controls", this.popoverId);
    nativeTriggerEl.setAttribute("aria-expanded", String(this.active));
    nativeTriggerEl.setAttribute("aria-haspopup", "dialog");
  }
  updateFocusableChildren() {
    this.focusableChildren = querySelectorAllDeep(this.el, '[role="menuitem"], [role="listbox"]');
  }
  adjustWidth() {
    let useContainerWidth = this.useContainerWidth;
    if ([true, "true"].includes(this.useContainerWidth)) {
      useContainerWidth = true;
    }
    else if ([false, "false"].includes(this.useContainerWidth)) {
      useContainerWidth = false;
    }
    const mobile = !window.matchMedia("(min-width: 768px)").matches;
    if (Boolean(useContainerWidth) && !mobile) {
      const container = typeof useContainerWidth === "string"
        ? this.el.closest(useContainerWidth) || this.el.parentElement
        : this.el.parentElement;
      this.contentContainer.style.maxWidth = "none";
      this.contentContainer.style.width =
        container.getBoundingClientRect().width + "px";
    }
    else {
      this.contentContainer.style.maxWidth = "";
      this.contentContainer.style.width = "";
    }
  }
  lockBodyScroll() {
    const mobile = isMobileViewport();
    if (!mobile || this.disableScrollLock) {
      return;
    }
    disableBodyScroll(this.scrollContainer);
  }
  unlockBodyScroll() {
    const mobile = isMobileViewport();
    if (!mobile || this.disableScrollLock) {
      return;
    }
    enableBodyScroll(this.scrollContainer);
  }
  render() {
    var _a, _b, _c;
    const mobile = !window.matchMedia("(min-width: 768px)").matches;
    const className = classnames("popover", `popover--animation-${this.animation}`, `popover--placement-${(_a = this.position) === null || _a === void 0 ? void 0 : _a.placement}`, {
      "popover--closing": this.closing,
      "popover--active": this.active,
      "popover--fullscreen-bottom-sheet": this.fullscreenBottomSheet,
      "popover--inactive": !this.active,
    });
    return (hAsync(Host, { id: this.popoverId }, hAsync("div", { class: className, onKeyDown: this.onKeydown }, hAsync("div", { "aria-hidden": !this.active ? "true" : "false", "aria-label": this.label, class: "popover__content", part: "popover__content", role: "dialog", ref: (el) => (this.contentContainer = el), style: {
        top: Boolean(this.position) ? `${(_b = this.position) === null || _b === void 0 ? void 0 : _b.y}px` : "",
        left: Boolean(this.position) ? `${(_c = this.position) === null || _c === void 0 ? void 0 : _c.x}px` : "",
      }, tabindex: "-1" }, hAsync("span", { class: "popover__handle" }), hAsync("div", { class: "popover__scroll-container", ref: (el) => (this.scrollContainer = el), style: {
        maxHeight: !mobile && Boolean(this.maxHeight)
          ? this.maxHeight
          : undefined,
      } }, hAsync("slot", null))), this.active && (hAsync("div", { class: "popover__backdrop", onClick: this.onCloseButtonClick })))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlPopoverCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-popover",
    "$members$": {
      "animation": [1],
      "disableScrollLock": [4, "disable-scroll-lock"],
      "enableFlip": [4, "enable-flip"],
      "fullscreenBottomSheet": [4, "fullscreen-bottom-sheet"],
      "label": [1],
      "maxHeight": [1, "max-height"],
      "offset": [2],
      "placement": [1],
      "popoverId": [1, "popover-id"],
      "trigger": [1],
      "useContainerWidth": [8, "use-container-width"],
      "active": [32],
      "closing": [32],
      "position": [32],
      "close": [64],
      "open": [64]
    },
    "$listeners$": [[8, "focusin", "onWindowFocusIn"], [8, "click", "onWindowClick"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlProgressIndicatorCss = "/*!@:host*/.sc-swirl-progress-indicator-h{display:block;width:100%}/*!@:host **/.sc-swirl-progress-indicator-h *.sc-swirl-progress-indicator{box-sizing:border-box}/*!@:host(.circle)*/.circle.sc-swirl-progress-indicator-h{display:inline-flex;width:auto}/*!@.progress-indicator--variant-bar*/.progress-indicator--variant-bar.sc-swirl-progress-indicator{display:block;width:100%;height:0.25rem;border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}/*!@.progress-indicator--variant-bar::-webkit-progress-bar*/.progress-indicator--variant-bar.sc-swirl-progress-indicator::-webkit-progress-bar{border-radius:0.125rem;background-color:var(--s-surface-raised-default)}/*!@.progress-indicator--variant-bar::-webkit-progress-value*/.progress-indicator--variant-bar.sc-swirl-progress-indicator::-webkit-progress-value{border-radius:0.125rem;background-color:var(--s-surface-highlight-default);-webkit-transition:width 0.25s;transition:width 0.25s}/*!@.progress-indicator--variant-bar::-moz-progress-bar*/.progress-indicator--variant-bar.sc-swirl-progress-indicator::-moz-progress-bar{height:0.25rem;border-radius:0.125rem;background-color:var(--s-surface-highlight-default);-moz-transition:width 0.25s;transition:width 0.25s}@media (prefers-reduced-motion){/*!@.progress-indicator--variant-bar::-moz-progress-bar*/.progress-indicator--variant-bar.sc-swirl-progress-indicator::-moz-progress-bar{-moz-transition:none;transition:none}}/*!@.progress-indicator--variant-bar.progress-indicator--size-s*/.progress-indicator--variant-bar.progress-indicator--size-s.sc-swirl-progress-indicator{height:0.125rem}/*!@.progress-indicator--variant-bar.progress-indicator--size-s::-webkit-progress-bar*/.progress-indicator--variant-bar.progress-indicator--size-s.sc-swirl-progress-indicator::-webkit-progress-bar{border-radius:0.0625rem}/*!@.progress-indicator--variant-bar.progress-indicator--size-s::-webkit-progress-value*/.progress-indicator--variant-bar.progress-indicator--size-s.sc-swirl-progress-indicator::-webkit-progress-value{border-radius:0.0625rem}/*!@.progress-indicator--variant-bar.progress-indicator--size-s::-moz-progress-bar*/.progress-indicator--variant-bar.progress-indicator--size-s.sc-swirl-progress-indicator::-moz-progress-bar{height:0.125rem;border-radius:0.0625rem}/*!@.progress-indicator--variant-circle*/.progress-indicator--variant-circle.sc-swirl-progress-indicator{position:relative;display:inline-flex;overflow:hidden;width:3rem;height:3rem}/*!@.progress-indicator--variant-circle.progress-indicator--size-s*/.progress-indicator--variant-circle.progress-indicator--size-s.sc-swirl-progress-indicator{width:1.5rem;height:1.5rem}/*!@.progress-indicator__circle*/.progress-indicator__circle.sc-swirl-progress-indicator{position:absolute;width:100%;height:100%;transform:rotate(-90deg);inset:0}/*!@.progress-indicator__circle-background*/.progress-indicator__circle-background.sc-swirl-progress-indicator{stroke:var(--s-border-default);stroke-linecap:round}/*!@.progress-indicator__circle-value*/.progress-indicator__circle-value.sc-swirl-progress-indicator{transition:stroke-dashoffset 0.25s;stroke:var(--s-interactive-primary-default);stroke-linecap:round}@media (prefers-reduced-motion){/*!@.progress-indicator__circle-value*/.progress-indicator__circle-value.sc-swirl-progress-indicator{transition:none}}";

class SwirlProgressIndicator {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.label = undefined;
    this.size = "m";
    this.value = 0;
    this.variant = "bar";
  }
  render() {
    const className = classnames("progress-indicator", `progress-indicator--size-${this.size}`, `progress-indicator--variant-${this.variant}`);
    const strokeWidth = this.size === "m" ? 4 : 2;
    const radius = this.size === "m" ? 20 : 10;
    const circumference = Math.round(radius * 2 * Math.PI);
    const dashOffset = Math.round(circumference * ((100 - this.value) / 100));
    return (hAsync(Host, { class: this.variant }, this.variant === "bar" && (hAsync("progress", { "aria-label": this.label, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": this.value, class: className, max: 100, value: this.value })), this.variant === "circle" && (hAsync("span", { role: "progressbar", "aria-label": this.label, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": this.value, class: className }, hAsync("svg", { class: "progress-indicator__circle", focusable: "false", viewBox: `0 0 ${(radius + strokeWidth) * 2} ${(radius + strokeWidth) * 2}` }, hAsync("circle", { class: "progress-indicator__circle-background", cx: radius + strokeWidth, cy: radius + strokeWidth, r: radius, fill: "none", "stroke-width": strokeWidth }), hAsync("circle", { class: "progress-indicator__circle-value", cx: radius + strokeWidth, cy: radius + strokeWidth, r: radius, fill: "none", "stroke-width": strokeWidth, "stroke-dasharray": circumference, "stroke-dashoffset": dashOffset }))))));
  }
  static get style() { return swirlProgressIndicatorCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-progress-indicator",
    "$members$": {
      "label": [1],
      "size": [1],
      "value": [2],
      "variant": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlRadioCss = ".sc-swirl-radio-h{display:inline-flex}.sc-swirl-radio-h *.sc-swirl-radio{box-sizing:border-box}.radio.sc-swirl-radio{display:inline-flex;line-height:var(--s-line-height-base);cursor:pointer}.radio.sc-swirl-radio:focus-within .radio__box.sc-swirl-radio{box-shadow:0 0 0 0.0625rem var(--s-background-default),\n      0 0 0 0.1875rem var(--s-focus-default)}.radio--checked.sc-swirl-radio .radio__control.sc-swirl-radio:hover .radio__box.sc-swirl-radio{border-color:var(--s-interactive-primary-hovered);background-color:var(--s-interactive-primary-hovered)}.radio--checked.sc-swirl-radio .radio__box.sc-swirl-radio{position:relative;border-color:var(--s-icon-highlight);background-color:var(--s-icon-highlight)}.radio--checked.sc-swirl-radio .radio__box.sc-swirl-radio:after{position:absolute;top:50%;left:50%;width:0.5rem;height:0.5rem;border-radius:50%;background-color:var(--s-background-default);content:\"\";transform:translate3d(-50%, -50%, 0)}.radio--invalid.radio--checked.sc-swirl-radio .radio__box.sc-swirl-radio,.radio--invalid.radio--indeterminate.sc-swirl-radio .radio__box.sc-swirl-radio{background-color:var(--s-icon-critical)}.radio--invalid.sc-swirl-radio .radio__box.sc-swirl-radio{border-color:var(--s-icon-critical)}.radio--disabled.sc-swirl-radio{cursor:default}.radio--disabled.radio--checked.sc-swirl-radio .radio__control.sc-swirl-radio:hover .radio__box.sc-swirl-radio{border-color:var(--s-icon-disabled);background-color:transparent}.radio--disabled.radio--checked.sc-swirl-radio .radio__box.sc-swirl-radio{border-color:var(--s-icon-disabled);background-color:var(--s-background-default)}.radio--disabled.radio--checked.sc-swirl-radio .radio__box.sc-swirl-radio:after{background-color:var(--s-icon-disabled)}.radio--disabled.sc-swirl-radio .radio__control.sc-swirl-radio:hover .radio__box.sc-swirl-radio{background-color:transparent}.radio--disabled.sc-swirl-radio .radio__box.sc-swirl-radio{border-color:var(--s-icon-disabled)}.radio--disabled.sc-swirl-radio .radio__description.sc-swirl-radio,.radio--disabled.sc-swirl-radio .radio__label.sc-swirl-radio{color:var(--s-text-disabled)}.radio__control.sc-swirl-radio{position:relative;display:inline-flex;width:1.5rem;height:1.5rem;padding:var(--s-space-2);flex-shrink:0}.radio__control.sc-swirl-radio:hover .radio__box.sc-swirl-radio{background-color:var(--s-action-neutral-hovered)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.radio__control.sc-swirl-radio{width:1.375rem;height:1.375rem}}.radio__box.sc-swirl-radio{position:relative;display:flex;width:100%;height:100%;justify-content:center;align-items:center;border:0.125rem solid var(--s-icon-default);border-radius:50%}.radio__label-container.sc-swirl-radio{display:inline-flex;margin-left:var(--s-space-8);padding-top:var(--s-space-2);flex-direction:column}.radio__label.sc-swirl-radio{font-weight:var(--s-font-weight-medium)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.radio__label.sc-swirl-radio{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.radio__description.sc-swirl-radio{color:var(--s-text-subdued)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.radio__description.sc-swirl-radio{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}";

class SwirlRadio {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.onChange = () => {
      this.checked = true;
      this.valueChange.emit(this.value);
    };
    this.checked = false;
    this.description = undefined;
    this.disabled = false;
    this.inputId = undefined;
    this.inputName = undefined;
    this.invalid = undefined;
    this.label = undefined;
    this.value = undefined;
  }
  getAriaCheckedLabel(checked, unchecked) {
    if (checked) {
      return "true";
    }
    else if (unchecked) {
      return "false";
    }
    return "mixed";
  }
  render() {
    const unchecked = this.checked === false || this.checked === "false";
    const checked = this.checked === true || this.checked === "true";
    const ariaCheckedLabel = this.getAriaCheckedLabel(checked, unchecked);
    const ariaInvalid = this.invalid;
    const className = classnames("radio", {
      "radio--checked": checked,
      "radio--disabled": this.disabled,
      "radio--invalid": this.invalid,
      "radio--unchecked": unchecked,
    });
    return (hAsync(Host, null, hAsync("label", { class: className, htmlFor: this.inputId }, hAsync("span", { class: "radio__control" }, hAsync("swirl-visually-hidden", null, hAsync("input", { "aria-checked": ariaCheckedLabel, "aria-invalid": ariaInvalid, checked: checked, class: "radio__input", disabled: this.disabled, id: this.inputId, name: this.inputName, onChange: this.onChange, type: "radio", value: this.value })), hAsync("span", { "aria-hidden": "true", class: "radio__box" })), hAsync("span", { class: "radio__label-container" }, this.label && hAsync("span", { class: "radio__label" }, this.label), this.description && (hAsync("span", { class: "radio__description" }, this.description))))));
  }
  static get style() { return swirlRadioCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-radio",
    "$members$": {
      "checked": [1032],
      "description": [1],
      "disabled": [4],
      "inputId": [1, "input-id"],
      "inputName": [1, "input-name"],
      "invalid": [4],
      "label": [1],
      "value": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlRadioGroupCss = ".sc-swirl-radio-group-h{display:block}.sc-swirl-radio-group-h *.sc-swirl-radio-group{box-sizing:border-box}.radio-group.sc-swirl-radio-group{display:flex;flex-direction:column;gap:var(--s-space-12)}";

class SwirlRadioGroup {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.swirlAriaDescribedby = undefined;
    this.value = undefined;
  }
  componentDidLoad() {
    this.radioButtons = Array.from(this.el.querySelectorAll("swirl-radio"));
    this.initValue();
    this.handleValueChanges();
  }
  initValue() {
    if (this.value === undefined) {
      return;
    }
    const radioWithValue = this.radioButtons.find((radio) => radio.value === this.value);
    if (!Boolean(radioWithValue)) {
      return;
    }
    radioWithValue.checked = true;
  }
  handleValueChanges() {
    for (const [key, radio] of Object.entries(this.radioButtons)) {
      radio.addEventListener("valueChange", () => {
        if (radio.checked === true || radio.checked === "true") {
          this.valueChange.emit(radio.value);
          this.value = radio.value;
          this.radioButtons.forEach((r, k) => {
            if (String(k) === key) {
              return;
            }
            r.checked = false;
          });
        }
      });
    }
  }
  render() {
    return (hAsync(Host, { "aria-describedby": this.swirlAriaDescribedby, role: "radiogroup" }, hAsync("div", { class: "radio-group" }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlRadioGroupCss; }
  static get cmpMeta() { return {
    "$flags$": 6,
    "$tagName$": "swirl-radio-group",
    "$members$": {
      "swirlAriaDescribedby": [1, "swirl-aria-describedby"],
      "value": [1537]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": [["value", "value"]]
  }; }
}

const swirlResourceListCss = "/*!@:host*/.sc-swirl-resource-list-h{display:block;width:100%}/*!@:host **/.sc-swirl-resource-list-h *.sc-swirl-resource-list{box-sizing:border-box}";

class SwirlResourceList {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.focusedIndex = 0;
    this.onKeyDown = (event) => {
      if (event.key === "ArrowDown") {
        event.preventDefault();
        this.focusItemAtIndex((this.focusedIndex + 1) % this.items.length);
      }
      else if (event.key === "ArrowUp") {
        event.preventDefault();
        const prevIndex = this.focusedIndex === 0 ? this.items.length - 1 : this.focusedIndex - 1;
        this.focusItemAtIndex(prevIndex);
      }
      else if (event.key === "Home") {
        event.preventDefault();
        this.focusItemAtIndex(0);
      }
      else if (event.key === "End") {
        event.preventDefault();
        this.focusItemAtIndex(this.items.length - 1);
      }
    };
    this.onSlotChange = () => {
      this.collectItems();
    };
    this.label = undefined;
  }
  componentDidLoad() {
    this.collectItems();
  }
  collectItems() {
    this.items = Array.from(this.el.querySelectorAll("swirl-resource-list-item, swirl-resource-list-file-item")).filter((el) => el.isConnected);
    this.removeItemsFromTabOrder();
    this.enableItemFocus(this.items[this.focusedIndex]);
  }
  removeItemsFromTabOrder() {
    this.items.forEach((item) => {
      var _a, _b;
      return (_b = (_a = item.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(".resource-list-item__content, .resource-list-file-item")) === null || _b === void 0 ? void 0 : _b.setAttribute("tabIndex", "-1");
    });
  }
  enableItemFocus(item, focus) {
    var _a;
    if (!Boolean(item)) {
      return;
    }
    const interactiveElement = (_a = item.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(".resource-list-item__content, .resource-list-file-item");
    if (!Boolean(interactiveElement)) {
      return;
    }
    interactiveElement.setAttribute("tabIndex", "0");
    if (focus) {
      interactiveElement.focus();
    }
  }
  focusItemAtIndex(index) {
    this.removeItemsFromTabOrder();
    const item = this.items[index];
    if (!Boolean(item) || !item.isConnected) {
      return;
    }
    this.enableItemFocus(item, true);
    this.focusedIndex = index;
  }
  render() {
    return (hAsync(Host, { onKeyDown: this.onKeyDown }, hAsync("swirl-stack", { "aria-label": this.label, role: "grid" }, hAsync("slot", { onSlotchange: this.onSlotChange }))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlResourceListCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-resource-list",
    "$members$": {
      "label": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlResourceListFileItemCss = "/*!@:host*/.sc-swirl-resource-list-file-item-h{display:block;width:100%}/*!@:host **/.sc-swirl-resource-list-file-item-h *.sc-swirl-resource-list-file-item{box-sizing:border-box}/*!@.resource-list-file-item*/.resource-list-file-item.sc-swirl-resource-list-file-item{position:relative;display:flex;width:100%;padding:var(--s-space-12) var(--s-space-16);align-items:center;background-color:var(--s-background-default);line-height:var(--s-line-height-base);gap:var(--s-space-12)}/*!@.resource-list-file-item:focus*/.resource-list-file-item.sc-swirl-resource-list-file-item:focus{outline:none}/*!@.resource-list-file-item:focus-visible*/.resource-list-file-item.sc-swirl-resource-list-file-item:focus-visible{background-color:var(--s-background-hovered)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.resource-list-file-item*/.resource-list-file-item.sc-swirl-resource-list-file-item{padding:var(--s-space-12);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.resource-list-file-item--has-control .resource-list-file-item__label-container*/.resource-list-file-item--has-control.sc-swirl-resource-list-file-item .resource-list-file-item__label-container.sc-swirl-resource-list-file-item{padding-right:calc(var(--s-space-12) + 2.5rem)}/*!@.resource-list-file-item__icon*/.resource-list-file-item__icon.sc-swirl-resource-list-file-item{color:var(--s-icon-highlight)}/*!@.resource-list-file-item__label-container*/.resource-list-file-item__label-container.sc-swirl-resource-list-file-item{position:relative;display:flex;min-width:0;min-height:2.875rem;flex-grow:1;justify-content:center;flex-direction:column}/*!@.resource-list-file-item__label-container:after*/.resource-list-file-item__label-container.sc-swirl-resource-list-file-item:after{position:absolute;right:0;bottom:calc(-1 * var(--s-space-12));left:0;height:0.0625rem;background-color:var(--s-border-default);content:\"\"}/*!@.resource-list-file-item__label*/.resource-list-file-item__label.sc-swirl-resource-list-file-item{overflow:hidden;font-weight:var(--s-font-weight-medium);white-space:nowrap;text-overflow:ellipsis}/*!@.resource-list-file-item__description*/.resource-list-file-item__description.sc-swirl-resource-list-file-item{overflow:hidden;margin-top:var(--s-space-2);color:var(--s-text-subdued);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm);white-space:nowrap;text-overflow:ellipsis}/*!@.resource-list-file-item__error-message*/.resource-list-file-item__error-message.sc-swirl-resource-list-file-item{margin-top:var(--s-space-2)}/*!@.resource-list-file-item__remove-button*/.resource-list-file-item__remove-button.sc-swirl-resource-list-file-item{position:absolute;top:50%;right:var(--s-space-16);display:inline-flex;transform:translateY(-50%)}/*!@.resource-list-file-item__spinner*/.resource-list-file-item__spinner.sc-swirl-resource-list-file-item{position:absolute;top:50%;right:var(--s-space-24);display:inline-flex;transform:translateY(-50%)}";

class SwirlResourceListFileItem {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.remove = createEvent(this, "remove", 7);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.description = undefined;
    this.errorMessage = undefined;
    this.icon = "<swirl-icon-file></swirl-icon-file>";
    this.label = undefined;
    this.loading = undefined;
    this.removable = undefined;
    this.removeButtonLabel = "Remove file";
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    if (!Boolean(this.iconEl)) {
      return;
    }
    const icon = this.iconEl.children[0];
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", smallIcon ? "20" : "24");
  }
  render() {
    const showError = Boolean(this.errorMessage);
    const showDescription = !showError && Boolean(this.description);
    const showSpinner = !showError && this.loading;
    const showRemoveButton = this.removable && !showSpinner;
    const className = classnames("resource-list-file-item", {
      "resource-list-file-item--has-control": showSpinner || showRemoveButton,
    });
    return (hAsync(Host, { role: "row" }, hAsync("div", { class: className, part: "resource-list-file-item", role: "gridcell" }, hAsync("span", { class: "resource-list-file-item__icon", innerHTML: this.icon, ref: (el) => (this.iconEl = el) }), hAsync("span", { class: "resource-list-file-item__label-container" }, hAsync("span", { class: "resource-list-file-item__label", id: "label" }, this.label), showDescription && (hAsync("span", { class: "resource-list-file-item__description" }, this.description)), showError && (hAsync("span", { "aria-live": "polite", class: "resource-list-file-item__error-message" }, hAsync("swirl-inline-error", { message: this.errorMessage, size: "s" })))), showSpinner && (hAsync("span", { class: "resource-list-file-item__spinner" }, hAsync("swirl-spinner", { size: "s" }))), showRemoveButton && (hAsync("span", { class: "resource-list-file-item__remove-button" }, hAsync("swirl-button", { hideLabel: true, icon: "<swirl-icon-close></swirl-icon-close>", label: this.removeButtonLabel, onClick: this.remove.emit }))))));
  }
  static get style() { return swirlResourceListFileItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-resource-list-file-item",
    "$members$": {
      "description": [1],
      "errorMessage": [1, "error-message"],
      "icon": [1],
      "label": [1],
      "loading": [4],
      "removable": [4],
      "removeButtonLabel": [1, "remove-button-label"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlResourceListItemCss = "/*!@:host*/.sc-swirl-resource-list-item-h{display:block;width:100%}/*!@:host **/.sc-swirl-resource-list-item-h *.sc-swirl-resource-list-item{box-sizing:border-box}/*!@.resource-list-item*/.resource-list-item.sc-swirl-resource-list-item{position:relative;width:100%}/*!@.resource-list-item--checked .resource-list-item__checkbox*/.resource-list-item--checked.sc-swirl-resource-list-item .resource-list-item__checkbox.sc-swirl-resource-list-item{border-color:var(--s-icon-highlight);color:var(--s-text-on-status);background-color:var(--s-icon-highlight)}/*!@.resource-list-item--has-menu .resource-list-item__label-container*/.resource-list-item--has-menu.sc-swirl-resource-list-item .resource-list-item__label-container.sc-swirl-resource-list-item{padding-right:calc(var(--s-space-16) + 2.5rem + var(--s-space-12))}@media (min-width: 768px){/*!@.resource-list-item--selectable .resource-list-item__content*/.resource-list-item--selectable.sc-swirl-resource-list-item .resource-list-item__content.sc-swirl-resource-list-item{padding-left:calc(var(--s-space-16) + 1.5rem + var(--s-space-12))}}/*!@.resource-list-item--selectable .resource-list-item__label-container*/.resource-list-item--selectable.sc-swirl-resource-list-item .resource-list-item__label-container.sc-swirl-resource-list-item{padding-right:calc(var(--s-space-16) + 1.5rem + var(--s-space-12))}@media (min-width: 768px){/*!@.resource-list-item--selectable .resource-list-item__label-container*/.resource-list-item--selectable.sc-swirl-resource-list-item .resource-list-item__label-container.sc-swirl-resource-list-item{padding-right:var(--s-space-16)}}/*!@.resource-list-item--hide-divider .resource-list-item__label-container:after*/.resource-list-item--hide-divider.sc-swirl-resource-list-item .resource-list-item__label-container.sc-swirl-resource-list-item:after{display:none}/*!@.resource-list-item--label-weight-medium*/.resource-list-item--label-weight-medium.sc-swirl-resource-list-item{font-weight:var(--s-font-weight-medium)}/*!@.resource-list-item__content*/.resource-list-item__content.sc-swirl-resource-list-item{--swirl-avatar-group-border-color:var(--s-background-default);--swirl-badge-border-color:var(--s-background-default);display:flex;width:100%;margin:0;padding-top:var(--s-space-12);padding-right:0;padding-bottom:var(--s-space-12);padding-left:var(--s-space-16);align-items:center;border:none;color:var(--s-text-default);background-color:var(--s-background-default);font:inherit;line-height:var(--s-line-height-base);text-align:left;text-decoration:none;cursor:pointer;gap:var(--s-space-12)}/*!@.resource-list-item__content:hover:not(:disabled)*/.resource-list-item__content.sc-swirl-resource-list-item:hover:not(:disabled){background-color:var(--s-background-hovered)}/*!@.resource-list-item__content:hover:not(:disabled) .resource-list-item__media*/.resource-list-item__content.sc-swirl-resource-list-item:hover:not(:disabled) .resource-list-item__media.sc-swirl-resource-list-item{--swirl-avatar-group-border-color:var(--s-background-hovered);--swirl-badge-border-color:var(--s-background-hovered)}/*!@.resource-list-item__content:active:not(:disabled)*/.resource-list-item__content.sc-swirl-resource-list-item:active:not(:disabled){background-color:var(--s-background-pressed)}/*!@.resource-list-item__content:active:not(:disabled) .resource-list-item__media*/.resource-list-item__content.sc-swirl-resource-list-item:active:not(:disabled) .resource-list-item__media.sc-swirl-resource-list-item{--swirl-avatar-group-border-color:var(--s-background-pressed);--swirl-badge-border-color:var(--s-background-pressed)}/*!@.resource-list-item__content:focus*/.resource-list-item__content.sc-swirl-resource-list-item:focus{outline:none}/*!@.resource-list-item__content:focus-visible*/.resource-list-item__content.sc-swirl-resource-list-item:focus-visible{background-color:var(--s-background-hovered)}/*!@.resource-list-item__content:focus-visible .resource-list-item__media*/.resource-list-item__content.sc-swirl-resource-list-item:focus-visible .resource-list-item__media.sc-swirl-resource-list-item{--swirl-avatar-group-border-color:var(--s-background-hovered);--swirl-badge-border-color:var(--s-background-hovered)}/*!@.resource-list-item__content:disabled*/.resource-list-item__content.sc-swirl-resource-list-item:disabled{color:var(--s-text-disabled);background-color:var(--s-background-default);cursor:default}/*!@.resource-list-item__content:disabled .resource-list-item__description*/.resource-list-item__content.sc-swirl-resource-list-item:disabled .resource-list-item__description.sc-swirl-resource-list-item{color:var(--s-text-disabled)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.resource-list-item__content*/.resource-list-item__content.sc-swirl-resource-list-item{padding:var(--s-space-12);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.resource-list-item__media*/.resource-list-item__media.sc-swirl-resource-list-item{display:inline-flex}/*!@.resource-list-item__label-container*/.resource-list-item__label-container.sc-swirl-resource-list-item{position:relative;display:flex;min-width:0;min-height:2.875rem;padding-right:var(--s-space-16);flex-grow:1;justify-content:center;flex-direction:column}/*!@.resource-list-item__label-container:after*/.resource-list-item__label-container.sc-swirl-resource-list-item:after{position:absolute;right:0;bottom:calc(-1 * var(--s-space-12));left:0;height:0.0625rem;background-color:var(--s-border-default);content:\"\"}/*!@.resource-list-item__label*/.resource-list-item__label.sc-swirl-resource-list-item{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}/*!@.resource-list-item__label b,\n  .resource-list-item__label strong*/.resource-list-item__label.sc-swirl-resource-list-item b.sc-swirl-resource-list-item,.resource-list-item__label.sc-swirl-resource-list-item strong.sc-swirl-resource-list-item{font-weight:var(--s-font-weight-semibold)}/*!@.resource-list-item__description*/.resource-list-item__description.sc-swirl-resource-list-item{overflow:hidden;margin-top:var(--s-space-2);color:var(--s-text-subdued);font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm);white-space:nowrap;text-overflow:ellipsis}/*!@.resource-list-item__menu-trigger*/.resource-list-item__menu-trigger.sc-swirl-resource-list-item{position:absolute;top:50%;right:var(--s-space-16);transform:translateY(-50%)}/*!@.resource-list-item__checkbox*/.resource-list-item__checkbox.sc-swirl-resource-list-item{position:absolute;top:50%;right:var(--s-space-16);display:flex;width:1.25rem;height:1.25rem;justify-content:center;align-items:center;border:0.125rem solid var(--s-icon-default);border-radius:var(--s-border-radius-s);transform:translateY(-50%)}@media (min-width: 768px){/*!@.resource-list-item__checkbox*/.resource-list-item__checkbox.sc-swirl-resource-list-item{right:auto;left:var(--s-space-16)}}/*!@.resource-list-item__checkbox-icon*/.resource-list-item__checkbox-icon.sc-swirl-resource-list-item{display:inline-flex;width:1.0625rem;height:1.0625rem}/*!@.resource-list-item__checkbox-icon > *::part(icon)*/.resource-list-item__checkbox-icon.sc-swirl-resource-list-item>*.sc-swirl-resource-list-item::part(icon){width:1.0625rem;height:1.0625rem}/*!@.resource-list-item__meta*/.resource-list-item__meta.sc-swirl-resource-list-item{position:absolute;top:calc(var(--s-space-12) + var(--s-space-4));right:var(--s-space-16);color:var(--s-text-subdued);font-size:var(--s-font-size-sm)}";

/**
 * @slot media - Media displayed inside the item (e.g. swirl-avatar)
 */
class SwirlResourceListItem {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.onClick = () => {
      if (!this.selectable) {
        return;
      }
      this.checked = !this.checked;
      this.valueChange.emit(this.checked);
    };
    this.onMenuTriggerClick = (event) => {
      if (this.disabled && !Boolean(this.href)) {
        event.stopPropagation();
      }
    };
    this.checked = false;
    this.description = undefined;
    this.disabled = undefined;
    this.hideDivider = undefined;
    this.href = undefined;
    this.label = undefined;
    this.labelWeight = "medium";
    this.menuTriggerId = undefined;
    this.menuTriggerLabel = "Options";
    this.meta = undefined;
    this.selectable = undefined;
    this.value = undefined;
    this.hasMedia = false;
  }
  async componentWillLoad() {
    this.updateMediaState();
  }
  updateMediaState() {
    const mediaContainer = this.el.querySelector('[slot="media"]');
    const hasMedia = Boolean(mediaContainer);
    if (hasMedia !== this.hasMedia) {
      this.hasMedia = hasMedia;
    }
  }
  render() {
    const Tag = Boolean(this.href) && !this.selectable ? "a" : "button";
    const disabled = this.disabled && !Boolean(this.href);
    const hasMenu = Boolean(this.menuTriggerId);
    const showMenu = hasMenu && !Boolean(this.meta) && !this.selectable;
    const showMeta = Boolean(this.meta) && !this.selectable;
    const ariaChecked = this.selectable ? String(this.checked) : undefined;
    const role = this.selectable ? "checkbox" : undefined;
    const className = classnames("resource-list-item", `resource-list-item--label-weight-${this.labelWeight}`, {
      "resource-list-item--checked": this.checked,
      "resource-list-item--has-menu": hasMenu,
      "resource-list-item--hide-divider": this.hideDivider,
      "resource-list-item--selectable": this.selectable,
    });
    return (hAsync(Host, { role: "row" }, hAsync("div", { class: className, role: "gridcell" }, hAsync(Tag, { "aria-checked": ariaChecked, "aria-disabled": disabled ? "true" : undefined, "aria-labelledby": "label", class: "resource-list-item__content", href: this.href, disabled: disabled, onClick: this.onClick, part: "resource-list-item__content", role: role, tabIndex: 0 }, this.hasMedia && (hAsync("span", { class: "resource-list-item__media" }, hAsync("slot", { name: "media" }))), hAsync("span", { class: "resource-list-item__label-container" }, hAsync("span", { class: "resource-list-item__label", id: "label", innerHTML: this.label }), this.description && (hAsync("span", { class: "resource-list-item__description" }, this.description)))), this.selectable && (hAsync("span", { "aria-hidden": "true", class: "resource-list-item__checkbox" }, hAsync("span", { class: "resource-list-item__checkbox-icon" }, this.checked && (hAsync("swirl-icon-check-strong", null))))), showMeta && (hAsync("span", { class: "resource-list-item__meta" }, this.meta)), showMenu && (hAsync("swirl-button", { "aria-disabled": disabled ? "true" : undefined, class: "resource-list-item__menu-trigger", disabled: disabled, hideLabel: true, icon: "<swirl-icon-more-horizontal></swirl-icon-more-horizontal>", id: this.menuTriggerId, intent: "primary", label: this.menuTriggerLabel, onClick: this.onMenuTriggerClick })))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlResourceListItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-resource-list-item",
    "$members$": {
      "checked": [1028],
      "description": [1],
      "disabled": [4],
      "hideDivider": [4, "hide-divider"],
      "href": [1],
      "label": [1],
      "labelWeight": [1, "label-weight"],
      "menuTriggerId": [1, "menu-trigger-id"],
      "menuTriggerLabel": [1, "menu-trigger-label"],
      "meta": [1],
      "selectable": [4],
      "value": [1],
      "hasMedia": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlSearchCss = ".sc-swirl-search-h{display:flex;width:100%}.sc-swirl-search-h *.sc-swirl-search{box-sizing:border-box}.search.sc-swirl-search{position:relative;display:flex;width:100%}.search--variant-outline.sc-swirl-search .search__input.sc-swirl-search{background-color:transparent;box-shadow:inset 0 0 0 var(--s-border-width-default) var(--s-border-strong)}.search--disabled.sc-swirl-search .search__icon.sc-swirl-search{color:var(--s-icon-disabled)}.search--disabled.sc-swirl-search .search__input.sc-swirl-search{color:var(--s-text-disabled)}.search--disabled.sc-swirl-search .search__input.sc-swirl-search::-moz-placeholder{color:var(--s-text-disabled)}.search--disabled.sc-swirl-search .search__input.sc-swirl-search::placeholder{color:var(--s-text-disabled)}.search__icon.sc-swirl-search{position:absolute;top:50%;left:var(--s-space-12);display:inline-flex;color:var(--s-icon-default);transform:translateY(-50%)}.search__input.sc-swirl-search{width:100%;height:2.5rem;padding-top:var(--s-space-8);padding-right:calc(var(--s-space-12) + 1.5rem + var(--s-space-8));padding-bottom:var(--s-space-8);padding-left:calc(var(--s-space-12) + 1.5rem + var(--s-space-8));border:none;border-radius:var(--s-border-radius-base);color:var(--s-text-default);background-color:var(--s-surface-raised-default);font:inherit;line-height:var(--s-line-height-base);caret-color:var(--s-border-highlight)}.search__input.sc-swirl-search:focus:not(:focus-visible){outline:none}.search__input.sc-swirl-search:focus-visible{outline-color:var(--s-focus-default)}.search__input.sc-swirl-search::-moz-placeholder{color:var(--s-text-subdued)}.search__input.sc-swirl-search::placeholder{color:var(--s-text-subdued)}.search__input.sc-swirl-search::-webkit-search-decoration,.search__input.sc-swirl-search::-webkit-search-cancel-button,.search__input.sc-swirl-search::-webkit-search-results-button,.search__input.sc-swirl-search::-webkit-search-results-decoration{-webkit-appearance:none;appearance:none}.search__input.sc-swirl-search:not(:-moz-placeholder-shown)+.search__clear-button.sc-swirl-search{display:inline-flex}.search__input.sc-swirl-search:not(:placeholder-shown)+.search__clear-button.sc-swirl-search{display:inline-flex}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.search__input.sc-swirl-search{height:2.25rem;padding-left:calc(var(--s-space-8) + 1.5rem + var(--s-space-8));font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.search__clear-button.sc-swirl-search{position:absolute;top:50%;right:var(--s-space-12);display:none;padding:0;border:none;color:var(--s-icon-default);background-color:transparent;cursor:pointer;transform:translateY(-50%)}";

class SwirlSearch {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.inputBlur = createEvent(this, "inputBlur", 7);
    this.inputFocus = createEvent(this, "inputFocus", 7);
    this.inputInput = createEvent(this, "inputInput", 7);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.clear = () => {
      this.input.value = "";
      this.input.focus();
      this.valueChange.emit("");
    };
    this.onBlur = (event) => {
      this.inputBlur.emit(event);
    };
    this.onChange = (event) => {
      this.valueChange.emit(event.target.value);
    };
    this.onFocus = (event) => {
      this.inputFocus.emit(event);
    };
    this.onInput = (event) => {
      this.inputInput.emit(event.target.value);
    };
    this.autoFocus = undefined;
    this.clearButtonLabel = "Clear search term";
    this.disabled = undefined;
    this.inputName = undefined;
    this.inputId = undefined;
    this.label = undefined;
    this.placeholder = "Search …";
    this.value = undefined;
    this.variant = "filled";
  }
  componentDidLoad() {
    var _a, _b;
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    if (!Boolean(this.iconEl)) {
      return;
    }
    const icon = this.iconEl.children[0];
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", smallIcon ? "20" : "24");
  }
  onKeyDown(event) {
    if ((event.code === "KeyK" || event.code === "Slash") &&
      (event.ctrlKey || event.metaKey)) {
      this.input.focus();
    }
  }
  render() {
    const className = classnames("search", `search--variant-${this.variant}`, {
      "search--disabled": this.disabled,
    });
    return (hAsync(Host, null, hAsync("span", { class: className, ref: (el) => (this.iconEl = el) }, hAsync("swirl-icon-search", { class: "search__icon" }), hAsync("input", { "aria-disabled": this.disabled ? "true" : undefined, "aria-label": this.label, autoComplete: "off", autoFocus: this.autoFocus, class: "search__input", disabled: this.disabled, id: this.inputId, inputMode: "search", name: this.inputName, onBlur: this.onBlur, onChange: this.onChange, onFocus: this.onFocus, onInput: this.onInput, placeholder: this.placeholder, ref: (el) => (this.input = el), type: "search", value: this.value }), !this.disabled && (hAsync("button", { "aria-label": this.clearButtonLabel, class: "search__clear-button", onClick: this.clear, type: "button" }, hAsync("swirl-icon-cancel", null))))));
  }
  static get style() { return swirlSearchCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-search",
    "$members$": {
      "autoFocus": [4, "auto-focus"],
      "clearButtonLabel": [1, "clear-button-label"],
      "disabled": [4],
      "inputName": [1, "input-name"],
      "inputId": [1, "input-id"],
      "label": [1],
      "placeholder": [1],
      "value": [1025],
      "variant": [1]
    },
    "$listeners$": [[8, "keydown", "onKeyDown"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlSelectCss = ".sc-swirl-select-h{display:block;width:100%}.sc-swirl-select-h *.sc-swirl-select{box-sizing:border-box}.select.sc-swirl-select{position:relative;display:flex;width:100%}.select.sc-swirl-select .sc-swirl-select::part(popover__content){margin-top:var(--s-space-16)}.select--placement-top-start.sc-swirl-select .sc-swirl-select::part(popover__content){margin-top:-2.25rem}.select--disabled.sc-swirl-select .select__label.sc-swirl-select{color:var(--s-text-disabled)}.select--disabled.sc-swirl-select .select__indicator.sc-swirl-select{color:var(--s-icon-disabled)}.select--inline.sc-swirl-select .select__indicator.sc-swirl-select{top:0}.select__label.sc-swirl-select{display:block;overflow:hidden;width:100%;height:1.375rem;margin:0;padding:0;padding-right:calc(1.5rem + var(--s-space-8));border:none;background-color:transparent;font:inherit;line-height:var(--s-line-height-base);text-align:left;white-space:nowrap;text-overflow:ellipsis;cursor:default}.select__label.sc-swirl-select:focus{outline:none}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.select__label.sc-swirl-select{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.select__indicator.sc-swirl-select{position:absolute;top:calc(-1 * var(--s-space-12));right:0;display:inline-flex;color:var(--s-icon-default)}";

class SwirlSelect {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.select = (event) => {
      this.value = event.detail;
      this.valueChange.emit(this.value);
      if (!this.multiSelect) {
        this.popover.close();
      }
    };
    this.onSlotChange = () => {
      this.updateOptions();
    };
    this.onOpen = (event) => {
      this.placement = event.detail.position.placement;
      this.open = true;
    };
    this.onClose = () => {
      this.open = false;
    };
    this.onKeyDown = (event) => {
      if (event.code === "Space" || event.code === "Enter") {
        event.preventDefault();
        this.popover.open();
      }
    };
    this.disabled = undefined;
    this.inline = undefined;
    this.invalid = undefined;
    this.label = undefined;
    this.multiSelect = undefined;
    this.required = undefined;
    this.selectId = Math.round(Math.random() * 1000000).toString();
    this.swirlAriaDescribedby = undefined;
    this.value = undefined;
    this.options = [];
    this.open = undefined;
    this.placement = undefined;
  }
  componentWillLoad() {
    queueMicrotask(() => {
      this.updateOptions();
    });
  }
  onWindowFocusIn(event) {
    if (event.target === this.el.querySelector("input")) {
      event.stopImmediatePropagation();
    }
  }
  updateOptions() {
    this.options = querySelectorAllDeep(this.el, "swirl-option-list-item");
  }
  render() {
    const label = Boolean(this.value)
      ? this.value
        .map((value) => { var _a; return (_a = this.options.find((option) => option.value === value)) === null || _a === void 0 ? void 0 : _a.label; })
        .join(", ")
      : "";
    const ariaInvalid = this.invalid === true || this.invalid === false
      ? String(this.invalid)
      : undefined;
    const className = classnames("select", `select--placement-${this.placement}`, {
      "select--disabled": this.disabled,
      "select--inline": this.inline,
    });
    return (hAsync(Host, { onKeyDown: this.onKeyDown }, hAsync("div", { class: className }, hAsync("input", { "aria-describedby": this.swirlAriaDescribedby, "aria-disabled": this.disabled ? "true" : undefined, "aria-invalid": ariaInvalid, class: "select__label", disabled: this.disabled, id: `trigger-${this.selectId}`, readOnly: true, type: "text", value: label }), hAsync("span", { class: "select__indicator" }, this.open ? (hAsync("swirl-icon-expand-less", null)) : (hAsync("swirl-icon-expand-more", null))), hAsync("swirl-popover", { animation: "scale-in-y", class: "select__popover", label: this.label, offset: [0, -16], onPopoverClose: this.onClose, onPopoverOpen: this.onOpen, popoverId: `select-options-${this.selectId}`, ref: (el) => (this.popover = el), trigger: `trigger-${this.selectId}`, useContainerWidth: "swirl-form-control" }, hAsync("swirl-option-list", { onValueChange: this.select, multiSelect: this.multiSelect, value: this.value }, hAsync("slot", { onSlotchange: this.onSlotChange }))))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlSelectCss; }
  static get cmpMeta() { return {
    "$flags$": 6,
    "$tagName$": "swirl-select",
    "$members$": {
      "disabled": [4],
      "inline": [4],
      "invalid": [4],
      "label": [1],
      "multiSelect": [4, "multi-select"],
      "required": [4],
      "selectId": [1, "select-id"],
      "swirlAriaDescribedby": [1, "swirl-aria-describedby"],
      "value": [1040],
      "options": [32],
      "open": [32],
      "placement": [32]
    },
    "$listeners$": [[8, "focusin", "onWindowFocusIn"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlSeparatorCss = "/*!@:host*/.sc-swirl-separator-h{display:flex;width:100%;align-items:center}/*!@:host **/.sc-swirl-separator-h *.sc-swirl-separator{box-sizing:border-box}/*!@:host(.separator--orientation-vertical)*/.separator--orientation-vertical.sc-swirl-separator-h{display:inline-flex;width:auto}/*!@:host(.separator--orientation-vertical) .separator__line*/.separator--orientation-vertical.sc-swirl-separator-h .separator__line.sc-swirl-separator{display:block;width:var(--s-border-width-default);height:100%;min-height:1.125rem;background-color:var(--s-border-default)}/*!@.separator__line*/.separator__line.sc-swirl-separator{display:block;width:100%;height:var(--s-border-width-default);background-color:var(--s-border-default)}";

class SwirlSeparator {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.orientation = "horizontal";
    this.spacing = "8";
  }
  render() {
    const styles = this.orientation === "horizontal"
      ? {
        paddingTop: `var(--s-space-${this.spacing})`,
        paddingBottom: `var(--s-space-${this.spacing})`,
      }
      : {
        paddingRight: `var(--s-space-${this.spacing})`,
        paddingLeft: `var(--s-space-${this.spacing})`,
      };
    const className = classnames("separator", `separator--orientation-${this.orientation}`);
    return (hAsync(Host, { "aria-orientation": this.orientation, class: className, role: "separator", style: styles }, hAsync("span", { class: "separator__line" })));
  }
  static get style() { return swirlSeparatorCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-separator",
    "$members$": {
      "orientation": [1],
      "spacing": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlShellLayoutCss = "/*!@:host*/.sc-swirl-shell-layout-h{--extended-sidebar-width:17rem;--collapsed-sidebar-width:4rem;display:flex;width:100%;height:100%}/*!@:host **/.sc-swirl-shell-layout-h *.sc-swirl-shell-layout{box-sizing:border-box}/*!@.shell-layout*/.shell-layout.sc-swirl-shell-layout{display:grid;width:100%;min-height:100%;transition:grid-template-columns 0.2s;grid-template-columns:0 1fr;grid-template-rows:auto 1fr;grid-template-areas:\"banner banner\"\n    \"sidebar main\"}@media (min-width: 992px){/*!@.shell-layout*/.shell-layout.sc-swirl-shell-layout{grid-template-columns:var(--extended-sidebar-width) 1fr}}/*!@.shell-layout--collapsed-sidebar*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout{grid-template-columns:0 1fr}@media (min-width: 992px){/*!@.shell-layout--collapsed-sidebar:not(.shell-layout--collapsing) .shell-layout__sidebar-wrapper.shell-layout__sidebar-wrapper--hovered .shell-layout__sidebar, .shell-layout--collapsed-sidebar:not(.shell-layout--collapsing) .shell-layout__sidebar-wrapper:focus-within .shell-layout__sidebar*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout:not(.shell-layout--collapsing) .shell-layout__sidebar-wrapper.shell-layout__sidebar-wrapper--hovered.sc-swirl-shell-layout .shell-layout__sidebar.sc-swirl-shell-layout,.shell-layout--collapsed-sidebar.sc-swirl-shell-layout:not(.shell-layout--collapsing) .shell-layout__sidebar-wrapper.sc-swirl-shell-layout:focus-within .shell-layout__sidebar.sc-swirl-shell-layout{width:var(--extended-sidebar-width);box-shadow:0 0.75rem 2rem rgba(25, 26, 28, 0.12),\n              0 0.25rem 0.75rem rgba(25, 26, 28, 0.08)}}/*!@.shell-layout--collapsed-sidebar .shell-layout__sidebar-wrapper*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout .shell-layout__sidebar-wrapper.sc-swirl-shell-layout{transform:translate3d(-100%, 0, 0)}/*!@.shell-layout--collapsed-sidebar .shell-layout__sidebar-wrapper .shell-layout__sidebar*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout .shell-layout__sidebar-wrapper.sc-swirl-shell-layout .shell-layout__sidebar.sc-swirl-shell-layout{width:100%;box-shadow:none}@media (min-width: 992px){/*!@.shell-layout--collapsed-sidebar .shell-layout__sidebar-wrapper*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout .shell-layout__sidebar-wrapper.sc-swirl-shell-layout{max-width:var(--collapsed-sidebar-width);flex-basis:var(--collapsed-sidebar-width);transform:none}/*!@.shell-layout--collapsed-sidebar .shell-layout__sidebar-wrapper:not(.shell-layout__sidebar-wrapper--hovered):not(:focus-within) .shell-layout__sidebar*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout .shell-layout__sidebar-wrapper.sc-swirl-shell-layout:not(.shell-layout__sidebar-wrapper--hovered):not(:focus-within) .shell-layout__sidebar.sc-swirl-shell-layout{box-shadow:none}/*!@.shell-layout--collapsed-sidebar .shell-layout__sidebar-wrapper:not(.shell-layout__sidebar-wrapper--hovered):not(:focus-within) .shell-layout__collapsed-logo*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout .shell-layout__sidebar-wrapper.sc-swirl-shell-layout:not(.shell-layout__sidebar-wrapper--hovered):not(:focus-within) .shell-layout__collapsed-logo.sc-swirl-shell-layout{display:inline-flex;justify-content:center;align-items:center}/*!@.shell-layout--collapsed-sidebar .shell-layout__sidebar-wrapper:not(.shell-layout__sidebar-wrapper--hovered):not(:focus-within) .shell-layout__expanded-logo*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout .shell-layout__sidebar-wrapper.sc-swirl-shell-layout:not(.shell-layout__sidebar-wrapper--hovered):not(:focus-within) .shell-layout__expanded-logo.sc-swirl-shell-layout{display:none}/*!@.shell-layout--collapsed-sidebar .shell-layout__sidebar-wrapper:not(.shell-layout__sidebar-wrapper--hovered):not(:focus-within) .shell-layout__toggle*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout .shell-layout__sidebar-wrapper.sc-swirl-shell-layout:not(.shell-layout__sidebar-wrapper--hovered):not(:focus-within) .shell-layout__toggle.sc-swirl-shell-layout{display:none}}@media (min-width: 992px){/*!@.shell-layout--collapsed-sidebar*/.shell-layout--collapsed-sidebar.sc-swirl-shell-layout{grid-template-columns:var(--collapsed-sidebar-width) 1fr}}/*!@.shell-layout--hide-sidebar*/.shell-layout--hide-sidebar.sc-swirl-shell-layout{grid-template-columns:1fr;grid-template-areas:\"banner\"\n    \"main\"}@media (min-width: 992px){/*!@.shell-layout--hide-sidebar*/.shell-layout--hide-sidebar.sc-swirl-shell-layout{grid-template-columns:1fr}}/*!@.shell-layout__banner*/.shell-layout__banner.sc-swirl-shell-layout{grid-area:banner}/*!@.shell-layout__sidebar-wrapper*/.shell-layout__sidebar-wrapper.sc-swirl-shell-layout{position:absolute;z-index:2;top:0;bottom:0;left:0;width:100%;max-width:var(--extended-sidebar-width);min-height:0;flex-basis:var(--extended-sidebar-width);flex-shrink:0;transition:max-width 0.2s, transform 0.2s;grid-area:sidebar}@media (min-width: 992px){/*!@.shell-layout__sidebar-wrapper*/.shell-layout__sidebar-wrapper.sc-swirl-shell-layout{position:relative;inset:auto}}/*!@.shell-layout__sidebar*/.shell-layout__sidebar.sc-swirl-shell-layout{display:flex;width:var(--extended-sidebar-width);height:100%;border-right:var(--s-border-width-default) solid var(--s-border-default);flex-direction:column;transition:box-shadow 0.2s, width 0.2s;box-shadow:0 0.75rem 2rem rgba(25, 26, 28, 0.12),\n    0 0.25rem 0.75rem rgba(25, 26, 28, 0.08)}@media (min-width: 992px){/*!@.shell-layout__sidebar*/.shell-layout__sidebar.sc-swirl-shell-layout{box-shadow:none}}/*!@.shell-layout__header*/.shell-layout__header.sc-swirl-shell-layout{flex-shrink:0;border-bottom:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-background-default)}/*!@.shell-layout__logo-bar*/.shell-layout__logo-bar.sc-swirl-shell-layout{display:flex;overflow:hidden;align-items:center;height:4.5rem}/*!@.shell-layout__expanded-logo*/.shell-layout__expanded-logo.sc-swirl-shell-layout{padding-right:var(--s-space-12);padding-left:var(--s-space-12);flex-grow:1}/*!@.shell-layout__collapsed-logo*/.shell-layout__collapsed-logo.sc-swirl-shell-layout{display:none;padding-right:var(--s-space-12);padding-left:var(--s-space-12);flex-grow:1}/*!@.shell-layout__toggle*/.shell-layout__toggle.sc-swirl-shell-layout{padding-right:var(--s-space-16);padding-left:var(--s-space-12);flex-grow:0;flex-shrink:0}/*!@.shell-layout__mobile-toggle*/.shell-layout__mobile-toggle.sc-swirl-shell-layout{position:absolute;z-index:2;top:var(--s-space-12);left:calc(100% + var(--s-space-16))}@media (min-width: 992px){/*!@.shell-layout__mobile-toggle*/.shell-layout__mobile-toggle.sc-swirl-shell-layout{display:none}}/*!@.shell-layout__main-navigation*/.shell-layout__main-navigation.sc-swirl-shell-layout{overflow:auto;flex-grow:1;background-color:var(--s-background-default)}/*!@.shell-layout__main*/.shell-layout__main.sc-swirl-shell-layout{min-height:0;background-color:var(--s-background-default);grid-area:main}/*!@.shell-layout__main > *,\n  .shell-layout__main ::slotted(*)*/.shell-layout__main.sc-swirl-shell-layout>*.sc-swirl-shell-layout,.shell-layout__main .sc-swirl-shell-layout-s>*{height:100%}/*!@.shell-layout__backdrop*/.shell-layout__backdrop.sc-swirl-shell-layout{position:fixed;z-index:1;background-color:rgba(0, 0, 0, 0.4);animation:shell-layout-backdrop-fade-in 0.1s;inset:0}@media (min-width: 992px){/*!@.shell-layout__backdrop*/.shell-layout__backdrop.sc-swirl-shell-layout{display:none}}/*!@.shell-layout__backdrop--fading*/.shell-layout__backdrop--fading.sc-swirl-shell-layout{animation:shell-layout-backdrop-fade-out 0.2s}@keyframes shell-layout-backdrop-fade-in{from{opacity:0}to{opacity:1}}@keyframes shell-layout-backdrop-fade-out{from{opacity:1}to{opacity:0}}";

/**
 * @slot logo-expanded - Logo shown inside expanded sidebar.
 * @slot logo-collapsed - Logo shown inside collapsed sidebar.
 * @slot tools - Items shown in the upper sidebar part.
 * @slot main-navigation - Items shown in the lower sidebar part.
 * @slot banner - Used to show a swirl-banner on top of the page.
 * @slot main - Contents of the main area.
 */
class SwirlShellLayout {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      if (event.matches) {
        this.expandLeftSidebar();
      }
      else {
        this.collapseLeftSidebar();
      }
    };
    this.collapseLeftSidebar = () => {
      this.collapsedSidebar = true;
      this.collapsing = true;
      setTimeout(() => {
        this.collapsing = false;
        // Some browsers don't update the hovered state of an element correctly,
        // if the element was moved and is no longer underneath the cursor.
        // https://bugs.chromium.org/p/chromium/issues/detail?id=276329
        this.sidebarHovered = false;
      }, 200);
    };
    this.expandLeftSidebar = () => {
      if (this.hideSidebar) {
        return;
      }
      this.collapsedSidebar = false;
    };
    this.toggleSidebar = () => {
      if (this.collapsedSidebar) {
        this.expandLeftSidebar();
      }
      else {
        this.collapseLeftSidebar();
      }
    };
    this.onBackdropClick = () => {
      if (!this.collapsedSidebar) {
        this.collapseLeftSidebar();
      }
    };
    this.onSidebarClick = () => {
      var _a, _b;
      if (this.collapsedSidebar) {
        (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.blur();
        (_b = getActiveElement()) === null || _b === void 0 ? void 0 : _b.blur();
      }
    };
    this.onSidebarMouseEnter = () => {
      this.sidebarHovered = true;
    };
    this.onSidebarMouseLeave = () => {
      this.sidebarHovered = false;
    };
    this.hideSidebar = undefined;
    this.mainNavigationLabel = "Main";
    this.sidebarToggleLabel = "Toggle sidebar";
    this.collapsedSidebar = undefined;
    this.collapsing = undefined;
    this.sidebarHovered = undefined;
  }
  componentWillLoad() {
    var _a, _b;
    if (!this.desktopMediaQuery.matches) {
      this.collapseLeftSidebar();
    }
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  /**
   * Collapse the left sidebar.
   */
  async collapseSidebar() {
    this.collapseLeftSidebar();
  }
  /**
   * Extend the left sidebar.
   */
  async extendSidebar() {
    this.expandLeftSidebar();
  }
  render() {
    const className = classnames("shell-layout", {
      "shell-layout--collapsed-sidebar": this.collapsedSidebar,
      "shell-layout--collapsing": this.collapsing,
      "shell-layout--hide-sidebar": this.hideSidebar,
    });
    const sidebarWrapperClassName = classnames("shell-layout__sidebar-wrapper", {
      "shell-layout__sidebar-wrapper--hovered": this.sidebarHovered,
    });
    const backdropClassName = classnames("shell-layout__backdrop", {
      "shell-layout__backdrop--fading": this.collapsing,
    });
    return (hAsync(Host, null, hAsync("div", { class: className }, hAsync("div", { class: "shell-layout__banner" }, hAsync("slot", { name: "banner" })), hAsync("div", { class: sidebarWrapperClassName, onClick: this.onSidebarClick, onMouseEnter: this.onSidebarMouseEnter, onMouseLeave: this.onSidebarMouseLeave }, !this.hideSidebar && (hAsync("div", { class: "shell-layout__sidebar" }, hAsync("header", { class: "shell-layout__header" }, hAsync("div", { class: "shell-layout__logo-bar" }, hAsync("div", { class: "shell-layout__expanded-logo" }, hAsync("slot", { name: "logo-expanded" })), hAsync("div", { class: "shell-layout__collapsed-logo" }, hAsync("slot", { name: "logo-collapsed" })), hAsync("div", { class: "shell-layout__toggle" }, hAsync("swirl-button", { swirlAriaExpanded: String(!this.collapsedSidebar), hideLabel: true, icon: this.collapsedSidebar
        ? "<swirl-icon-double-arrow-right></swirl-icon-double-arrow-right>"
        : "<swirl-icon-double-arrow-left></swirl-icon-double-arrow-left>", label: this.sidebarToggleLabel, onClick: this.toggleSidebar }))), hAsync("div", { class: "shell-layout__tools" }, hAsync("slot", { name: "tools" }))), hAsync("nav", { "aria-label": this.mainNavigationLabel, class: "shell-layout__main-navigation" }, hAsync("slot", { name: "main-navigation" }))))), hAsync("main", { class: "shell-layout__main" }, hAsync("slot", { name: "main" })), (!this.collapsedSidebar || this.collapsing) && (hAsync("div", { class: backdropClassName, onClick: this.onBackdropClick })))));
  }
  static get style() { return swirlShellLayoutCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-shell-layout",
    "$members$": {
      "hideSidebar": [4, "hide-sidebar"],
      "mainNavigationLabel": [1, "main-navigation-label"],
      "sidebarToggleLabel": [1, "sidebar-toggle-label"],
      "collapsedSidebar": [32],
      "collapsing": [32],
      "sidebarHovered": [32],
      "collapseSidebar": [64],
      "extendSidebar": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlShellNavigationItemCss = "/*!@:host*/.sc-swirl-shell-navigation-item-h {\n  container-type: inline-size;\n  position: relative;\n  display: inline-flex;\n  width: 100%;\n  height: 3.5rem;\n  padding-right: var(--s-space-12);\n  padding-left: var(--s-space-12);\n  flex-shrink: 0;\n  justify-content: flex-start;\n  align-items: center;\n  color: var(--s-text-default);\n  background-color: var(--s-background-default);\n  font-size: var(--s-font-size-sm);\n  font-weight: var(--s-font-weight-medium);\n  line-height: var(--s-line-height-sm);\n  cursor: pointer;\n  gap: var(--s-space-12);\n}\n\n/*!@:host(:hover)*/.sc-swirl-shell-navigation-item-h:hover {\n    background-color: var(--s-background-hovered);\n  }\n\n/*!@:host(:active)*/.sc-swirl-shell-navigation-item-h:active {\n    background-color: var(--s-background-pressed);\n    color: var(--s-text-highlight);\n  }\n\n/*!@:host(:focus)*/.sc-swirl-shell-navigation-item-h:focus {\n    outline: none;\n  }\n\n/*!@:host(:focus-visible) .shell-navigation-item__label*/.sc-swirl-shell-navigation-item-h:focus-visible .shell-navigation-item__label.sc-swirl-shell-navigation-item {\n      border-radius: var(--s-border-radius-xs);\n      box-shadow: 0 0 0 0.125rem var(--s-focus-default);\n    }\n\n/*!@:host(.shell-navigation-item--active)*/.shell-navigation-item--active.sc-swirl-shell-navigation-item-h {\n    color: var(--s-text-highlight);\n    background-color: var(--s-surface-raised-default);\n  }\n\n/*!@:host(.shell-navigation-item--active:hover)*/.shell-navigation-item--active.sc-swirl-shell-navigation-item-h:hover {\n    background-color: var(--s-surface-raised-hovered);\n  }\n\n/*!@:host(.shell-navigation-item--active:active)*/.shell-navigation-item--active.sc-swirl-shell-navigation-item-h:active {\n    background-color: var(--s-surface-raised-pressed);\n    color: var(--s-text-highlight);\n  }\n\n/*!@:host **/.sc-swirl-shell-navigation-item-h *.sc-swirl-shell-navigation-item {\n    box-sizing: border-box;\n  }\n\n/*!@:host:before*/.sc-swirl-shell-navigation-item-h:before {\n  content: \"\";\n  display: none;\n  position: absolute;\n  left: 0;\n  height: 2.5rem;\n  width: 4px;\n  background-color: var(--s-icon-highlight);\n  border-top-right-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n\n/*!@:host(.shell-navigation-item--active):before*/.shell-navigation-item--active.sc-swirl-shell-navigation-item-h:before {\n  display: block;\n}\n\n/*!@.shell-navigation-item__icon*/.shell-navigation-item__icon.sc-swirl-shell-navigation-item {\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  min-width: 2.5rem;\n  min-height: 2.5rem;\n}\n\n/*!@.shell-navigation-item__label*/.shell-navigation-item__label.sc-swirl-shell-navigation-item {\n  overflow: hidden;\n  min-width: 0;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n\n@container (max-width: 4rem) {\n  .shell-navigation-item__label {\n    display: none;\n  }\n\n  .shell-navigation-item__badge {\n    position: absolute;\n    bottom: 0;\n    right: var(--s-space-4);\n  }\n}\n\n@container (min-width: 14rem) {\n  .shell-navigation-item__badge {\n    margin-left: auto;\n    padding-right: var(--s-space-4);\n  }\n}";

/**
 * @slot slot - image or icon to display
 */
class SwirlShellNavigationItem {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onKeyDown = (event) => {
      if (event.code === "Enter") {
        event.preventDefault();
        this.el.click();
      }
    };
    this.active = undefined;
    this.badgeLabel = undefined;
    this.label = undefined;
  }
  render() {
    const className = classnames("shell-navigation-item", {
      "shell-navigation-item--active": this.active,
    });
    return (hAsync(Host, { class: className, onKeyDown: this.onKeyDown, role: "link", tabIndex: 0 }, hAsync("span", { class: "shell-navigation-item__icon" }, hAsync("slot", { name: "icon" })), hAsync("span", { class: "shell-navigation-item__label" }, this.label), this.badgeLabel && (hAsync("swirl-badge", { class: "shell-navigation-item__badge", size: "s", "aria-label": this.badgeLabel, label: this.badgeLabel }))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlShellNavigationItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-shell-navigation-item",
    "$members$": {
      "active": [4],
      "badgeLabel": [1, "badge-label"],
      "label": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlSkeletonBoxCss = "/*!@:host*/.sc-swirl-skeleton-box-h{display:block}/*!@:host **/.sc-swirl-skeleton-box-h *.sc-swirl-skeleton-box{box-sizing:border-box}/*!@.skeleton-box*/.skeleton-box.sc-swirl-skeleton-box{position:relative;overflow:hidden;min-height:var(--s-font-size-sm);background-color:var(--s-surface-raised-hovered)}/*!@.skeleton-box:before*/.skeleton-box.sc-swirl-skeleton-box:before{position:relative;z-index:1;display:block;width:100%;height:100%;background-image:linear-gradient(\n      90deg,\n      rgba(255, 255, 255, 0) 0,\n      rgba(255, 255, 255, 0) 12%,\n      var(--s-surface-raised-default) 50%,\n      rgba(255, 255, 255, 0) 88%,\n      rgba(255, 255, 255, 0) 100%\n    );content:\"\";transform:translateX(-100%);animation:skeleton-box-shimmer 3s infinite}@keyframes skeleton-box-shimmer{100%{transform:translateX(100%)}}/*!@.skeleton-box--static:before*/.skeleton-box--static.sc-swirl-skeleton-box:before{display:none}/*!@.skeleton-box--border-radius-pill*/.skeleton-box--border-radius-pill.sc-swirl-skeleton-box{border-radius:100rem}";

class SwirlSkeletonBox {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.animated = true;
    this.aspectRatio = undefined;
    this.borderRadius = "base";
    this.height = undefined;
    this.width = undefined;
  }
  render() {
    const className = classnames("skeleton-box", `skeleton-box--border-radius-${this.borderRadius}`, { "skeleton-box--static": !this.animated });
    return (hAsync(Host, { style: {
        width: !Boolean(this.width) && !Boolean(this.aspectRatio)
          ? "100%"
          : undefined,
      } }, hAsync("div", { class: className, style: {
        aspectRatio: this.aspectRatio,
        borderRadius: this.borderRadius !== "pill"
          ? `var(--s-border-radius-${this.borderRadius})`
          : undefined,
        height: this.height,
        width: this.width,
      } })));
  }
  static get style() { return swirlSkeletonBoxCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-skeleton-box",
    "$members$": {
      "animated": [4],
      "aspectRatio": [1, "aspect-ratio"],
      "borderRadius": [1, "border-radius"],
      "height": [1],
      "width": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlSkeletonTextCss = "/*!@:host*/.sc-swirl-skeleton-text-h{display:block;width:100%}/*!@:host **/.sc-swirl-skeleton-text-h *.sc-swirl-skeleton-text{box-sizing:border-box}/*!@.skeleton-text*/.skeleton-text.sc-swirl-skeleton-text{position:relative}/*!@.skeleton-text--static .skeleton-text__line:after*/.skeleton-text--static.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text:after{display:none}/*!@.skeleton-text--size-sm*/.skeleton-text--size-sm.sc-swirl-skeleton-text{--skeleton-text-line-padding:calc(\n    (var(--s-line-height-sm) - var(--s-font-size-sm)) / 2\n  )}/*!@.skeleton-text--size-sm .skeleton-text__line*/.skeleton-text--size-sm.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text{height:var(--s-line-height-sm);border-radius:calc(var(--s-font-size-sm) / 2)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.skeleton-text--size-sm .skeleton-text__line*/.skeleton-text--size-sm.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text{height:var(--s-line-height-sm)}}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.skeleton-text--size-sm*/.skeleton-text--size-sm.sc-swirl-skeleton-text{--skeleton-text-line-padding:calc(\n      (var(--s-line-height-sm) - var(--s-font-size-sm)) / 2\n    )}}/*!@.skeleton-text--size-base*/.skeleton-text--size-base.sc-swirl-skeleton-text{--skeleton-text-line-padding:calc(\n    (var(--s-line-height-base) - var(--s-font-size-base)) / 2\n  )}/*!@.skeleton-text--size-base .skeleton-text__line*/.skeleton-text--size-base.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text{height:var(--s-line-height-base);border-radius:calc(var(--s-font-size-base) / 2)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.skeleton-text--size-base .skeleton-text__line*/.skeleton-text--size-base.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text{height:var(--s-line-height-sm)}}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.skeleton-text--size-base*/.skeleton-text--size-base.sc-swirl-skeleton-text{--skeleton-text-line-padding:calc(\n      (var(--s-line-height-sm) - var(--s-font-size-sm)) / 2\n    )}}/*!@.skeleton-text--size-lg*/.skeleton-text--size-lg.sc-swirl-skeleton-text{--skeleton-text-line-padding:calc(\n    (var(--s-line-height-lg) - var(--s-font-size-lg)) / 2\n  )}/*!@.skeleton-text--size-lg .skeleton-text__line*/.skeleton-text--size-lg.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text{height:var(--s-line-height-lg);border-radius:calc(var(--s-font-size-lg) / 2)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.skeleton-text--size-lg .skeleton-text__line*/.skeleton-text--size-lg.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text{height:var(--s-line-height-base)}}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.skeleton-text--size-lg*/.skeleton-text--size-lg.sc-swirl-skeleton-text{--skeleton-text-line-padding:calc(\n      (var(--s-line-height-base) - var(--s-font-size-base)) / 2\n    )}}/*!@.skeleton-text--size-xl*/.skeleton-text--size-xl.sc-swirl-skeleton-text{--skeleton-text-line-padding:calc(\n    (var(--s-line-height-xl) - var(--s-font-size-xl)) / 2\n  )}/*!@.skeleton-text--size-xl .skeleton-text__line*/.skeleton-text--size-xl.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text{height:var(--s-line-height-xl);border-radius:calc(var(--s-font-size-xl) / 2)}/*!@.skeleton-text--size-2xl*/.skeleton-text--size-2xl.sc-swirl-skeleton-text{--skeleton-text-line-padding:calc(\n    (var(--s-line-height-2xl) - var(--s-font-size-2xl)) / 2\n  )}/*!@.skeleton-text--size-2xl .skeleton-text__line*/.skeleton-text--size-2xl.sc-swirl-skeleton-text .skeleton-text__line.sc-swirl-skeleton-text{height:var(--s-line-height-2xl);border-radius:calc(var(--s-font-size-2xl) / 2)}/*!@.skeleton-text__line*/.skeleton-text__line.sc-swirl-skeleton-text{overflow:hidden;width:100%;padding-top:var(--skeleton-text-line-padding);padding-bottom:var(--skeleton-text-line-padding)}/*!@.skeleton-text__line:before*/.skeleton-text__line.sc-swirl-skeleton-text:before{display:block;width:100%;height:100%;border-radius:10rem;background-color:var(--s-surface-raised-hovered);content:\"\"}/*!@.skeleton-text__line:after*/.skeleton-text__line.sc-swirl-skeleton-text:after{position:relative;z-index:1;top:-100%;display:block;width:100%;height:100%;background-image:linear-gradient(\n      90deg,\n      rgba(255, 255, 255, 0) 0,\n      var(--s-surface-raised-default) 33%,\n      rgba(255, 255, 255, 0) 66%\n    );content:\"\";transform:translateX(-100%);animation:skeleton-text-shimmer 3s infinite}/*!@.skeleton-text__line:first-child:last-child*/.skeleton-text__line.sc-swirl-skeleton-text:first-child:last-child{width:100%}/*!@.skeleton-text__line:last-child:not(:first-child)*/.skeleton-text__line.sc-swirl-skeleton-text:last-child:not(:first-child){width:25%}@keyframes skeleton-text-shimmer{100%{transform:translateX(100%)}}";

class SwirlSkeletonText {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.animated = true;
    this.lines = 1;
    this.size = "base";
  }
  render() {
    const className = classnames("skeleton-text", `skeleton-text--size-${this.size}`, { "skeleton-text--static": !this.animated });
    const lineClassName = classnames("skeleton-text__line", `skeleton-text__line--size-${this.size}`);
    return (hAsync(Host, null, hAsync("div", { class: className, part: className }, new Array(this.lines).fill(undefined).map((_, index) => (hAsync("div", { class: lineClassName, key: index, part: lineClassName }))))));
  }
  static get style() { return swirlSkeletonTextCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-skeleton-text",
    "$members$": {
      "animated": [4],
      "lines": [2],
      "size": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlSpinnerCss = "/*!@:host*/.sc-swirl-spinner-h{display:inline-flex}/*!@:host **/.sc-swirl-spinner-h *.sc-swirl-spinner{box-sizing:border-box}/*!@.spinner*/.spinner.sc-swirl-spinner{position:relative;display:inline-flex;overflow:hidden;width:2.25rem;height:2.25rem}/*!@.spinner--size-xs,\n.spinner--size-20*/.spinner--size-xs.sc-swirl-spinner,.spinner--size-20.sc-swirl-spinner{width:1.25rem;height:1.25rem}/*!@.spinner--size-xs .spinner__circle, .spinner--size-20 .spinner__circle*/.spinner--size-xs.sc-swirl-spinner .spinner__circle.sc-swirl-spinner,.spinner--size-20.sc-swirl-spinner .spinner__circle.sc-swirl-spinner{stroke-width:0.1875rem}/*!@.spinner--size-s,\n.spinner--size-24*/.spinner--size-s.sc-swirl-spinner,.spinner--size-24.sc-swirl-spinner{width:1.5rem;height:1.5rem}/*!@.spinner--size-s .spinner__circle, .spinner--size-24 .spinner__circle*/.spinner--size-s.sc-swirl-spinner .spinner__circle.sc-swirl-spinner,.spinner--size-24.sc-swirl-spinner .spinner__circle.sc-swirl-spinner{stroke-width:0.1875rem}/*!@.spinner__indicator*/.spinner__indicator.sc-swirl-spinner{position:absolute;inset:0;width:100%;height:100%;transform-origin:center center;animation:spinner-rotate 2s linear infinite}/*!@.spinner__background*/.spinner__background.sc-swirl-spinner{stroke:var(--s-border-default);stroke-linecap:round}/*!@.spinner__circle*/.spinner__circle.sc-swirl-spinner{animation:spinner-dash 1.5s ease-in-out infinite;stroke:var(--s-interactive-primary-default);stroke-dasharray:1, 200;stroke-dashoffset:0;stroke-linecap:round}@keyframes spinner-rotate{100%{transform:rotate(360deg)}}@keyframes spinner-dash{0%{stroke-dasharray:1, 200;stroke-dashoffset:0}50%{stroke-dasharray:89, 200;stroke-dashoffset:-35}100%{stroke-dasharray:89, 200;stroke-dashoffset:-124}}";

class SwirlSpinner {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.label = undefined;
    this.size = "m";
  }
  render() {
    const className = classnames("spinner", `spinner--size-${this.size}`);
    return (hAsync(Host, null, hAsync("span", { class: className, role: Boolean(this.label) ? "status" : undefined }, hAsync("svg", { "aria-hidden": "true", class: "spinner__indicator", focusable: "false", viewBox: "0 0 50 50" }, hAsync("circle", { class: "spinner__background", cx: "25", cy: "25", r: "20", fill: "none", "stroke-width": "4" }), hAsync("circle", { class: "spinner__circle", cx: "25", cy: "25", r: "20", fill: "none", "stroke-width": "4" })), this.label && (hAsync("swirl-visually-hidden", null, hAsync("span", { class: "spinner__label" }, this.label))))));
  }
  static get style() { return swirlSpinnerCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-spinner",
    "$members$": {
      "label": [1],
      "size": [8]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlStackCss = "/*!@:host*/.sc-swirl-stack-h{display:block;width:100%}/*!@:host **/.sc-swirl-stack-h *.sc-swirl-stack{box-sizing:border-box}/*!@.stack*/.stack.sc-swirl-stack{display:flex;width:100%;max-width:100%}/*!@.stack ::slotted(*)*/.stack .sc-swirl-stack-s>*{min-width:0;max-width:100%;flex-basis:auto;flex-grow:0;flex-shrink:1}/*!@.stack--align-start*/.stack--align-start.sc-swirl-stack{align-items:flex-start}/*!@.stack--align-center*/.stack--align-center.sc-swirl-stack{align-items:center}/*!@.stack--align-end*/.stack--align-end.sc-swirl-stack{align-items:flex-end}/*!@.stack--align-stretch*/.stack--align-stretch.sc-swirl-stack{align-items:stretch}/*!@.stack--justify-start*/.stack--justify-start.sc-swirl-stack{justify-content:flex-start}/*!@.stack--justify-center*/.stack--justify-center.sc-swirl-stack{justify-content:center}/*!@.stack--justify-end*/.stack--justify-end.sc-swirl-stack{justify-content:flex-end}/*!@.stack--justify-space-between*/.stack--justify-space-between.sc-swirl-stack{justify-content:space-between}/*!@.stack--justify-space-around*/.stack--justify-space-around.sc-swirl-stack{justify-content:space-around}/*!@.stack--justify-space-evenly*/.stack--justify-space-evenly.sc-swirl-stack{justify-content:space-evenly}/*!@.stack--justify-stretch*/.stack--justify-stretch.sc-swirl-stack{justify-content:stretch}/*!@.stack--justify-stretch ::slotted(*)*/.stack--justify-stretch .sc-swirl-stack-s>*{flex-grow:1}/*!@.stack--orientation-vertical*/.stack--orientation-vertical.sc-swirl-stack{flex-direction:column}/*!@.stack--orientation-horizontal*/.stack--orientation-horizontal.sc-swirl-stack{flex-direction:row}/*!@.stack--wrap*/.stack--wrap.sc-swirl-stack{flex-wrap:wrap}";

class SwirlStack {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.align = "start";
    this.as = "div";
    this.justify = "start";
    this.orientation = "vertical";
    this.spacing = "0";
    this.wrap = false;
  }
  render() {
    const Tag = this.as;
    const className = classnames("stack", `stack--align-${this.align}`, `stack--justify-${this.justify}`, `stack--orientation-${this.orientation}`, { "stack--wrap": this.wrap });
    return (hAsync(Host, null, hAsync(Tag, { class: className, style: { gap: `var(--s-space-${this.spacing})` } }, hAsync("slot", null))));
  }
  static get style() { return swirlStackCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-stack",
    "$members$": {
      "align": [1],
      "as": [1],
      "justify": [1],
      "orientation": [1],
      "spacing": [1],
      "wrap": [4]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlSwitchCss = ".sc-swirl-switch-h{display:inline-flex}.sc-swirl-switch-h *.sc-swirl-switch{box-sizing:border-box}.switch.sc-swirl-switch{display:inline-flex;align-items:center;touch-action:none}.switch.sc-swirl-switch:focus-within .switch__control.sc-swirl-switch{box-shadow:0 0 0 0.0625rem var(--s-background-default),\n      0 0 0 0.1875rem var(--s-focus-default)}.switch--size-m.sc-swirl-switch .switch__control.sc-swirl-switch{width:2.75rem;height:1.5rem;border-radius:calc(1.5rem / 2)}.switch--size-m.sc-swirl-switch .switch__thumb.sc-swirl-switch{width:1.25rem;height:1.25rem}.switch--on.switch--size-m.sc-swirl-switch .switch__thumb.sc-swirl-switch{left:calc(100% - 1.25rem - var(--s-space-2))}.switch--on.sc-swirl-switch .switch__control.sc-swirl-switch{background-color:var(--s-interactive-primary-default)}.switch--on.sc-swirl-switch .switch__thumb.sc-swirl-switch{left:calc(100% - 0.875rem - var(--s-space-2))}.switch--disabled.sc-swirl-switch .switch__control.sc-swirl-switch{background-color:var(--s-interactive-primary-disabled);cursor:default}.switch--disabled.sc-swirl-switch .switch__thumb.sc-swirl-switch{background-color:var(--s-interactive-neutral-default)}.switch--disabled.sc-swirl-switch .switch__label.sc-swirl-switch{color:var(--s-text-disabled)}.switch__control.sc-swirl-switch{position:relative;width:1.875rem;height:1.125rem;flex-shrink:0;border-radius:calc(1.125rem / 2);background-color:var(--s-interactive-primary-disabled);cursor:pointer;transition:background-color 0.2s}@media (prefers-reduced-motion){.switch__control.sc-swirl-switch{transition:none}}.switch__thumb.sc-swirl-switch{position:absolute;top:var(--s-space-2);left:var(--s-space-2);width:0.875rem;height:0.875rem;border-radius:50%;background-color:var(--s-surface-default);transition:left 0.2s;pointer-events:none}@media (prefers-reduced-motion){.switch__thumb.sc-swirl-switch{transition:none}}.switch__label.sc-swirl-switch{position:relative;z-index:1;margin-left:var(--s-space-12);font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base)}";

class SwirlSwitch {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.dragging = false;
    this.recentlyDragged = false;
    this.onChange = () => {
      if (this.dragging) {
        return;
      }
      if (this.recentlyDragged) {
        this.recentlyDragged = false;
        return;
      }
      this.checked = !this.checked;
      this.valueChange.emit(this.checked);
    };
    this.onStartDrag = () => {
      if (this.disabled) {
        return;
      }
      this.dragging = true;
      this.thumb.style.transition = "none";
    };
    this.onEndDrag = () => {
      if (this.disabled) {
        return;
      }
      if (this.recentlyDragged) {
        const controlBonds = this.control.getBoundingClientRect();
        const thumbBounds = this.thumb.getBoundingClientRect();
        const on = this.thumb.offsetLeft + thumbBounds.width / 2 > controlBonds.width / 2;
        if (this.checked !== on) {
          this.checked = on;
          this.valueChange.emit(on);
        }
      }
      this.thumb.style.left = "";
      this.thumb.style.transition = "";
      this.dragging = false;
      setTimeout(() => {
        this.recentlyDragged = false;
      });
    };
    this.onDrag = (event) => {
      if (!this.dragging) {
        return;
      }
      this.recentlyDragged = true;
      const controlBonds = this.control.getBoundingClientRect();
      const thumbBounds = this.thumb.getBoundingClientRect();
      let pos = Math.round(event.offsetX - thumbBounds.width / 2);
      if (pos < 0) {
        pos = 0;
      }
      if (pos > Math.round(controlBonds.width - thumbBounds.width)) {
        pos = Math.round(controlBonds.width - thumbBounds.width);
      }
      this.thumb.style.left = `${pos}px`;
    };
    this.checked = false;
    this.disabled = false;
    this.inputId = undefined;
    this.inputName = undefined;
    this.label = undefined;
    this.size = "m";
    this.value = undefined;
  }
  onWindowPointerUp() {
    this.onEndDrag();
  }
  render() {
    const off = !this.checked;
    const on = this.checked;
    const ariaCheckedLabel = on ? "true" : "false";
    const className = classnames("switch", `switch--size-${this.size}`, {
      "switch--off": off,
      "switch--on": on,
      "switch--disabled": this.disabled,
    });
    return (hAsync(Host, null, hAsync("label", { class: className, htmlFor: this.inputId }, hAsync("span", { class: "switch__control", onPointerDown: this.onStartDrag, onPointerMove: this.onDrag, onPointerUp: this.onEndDrag, ref: (el) => (this.control = el) }, hAsync("swirl-visually-hidden", null, hAsync("input", { "aria-checked": ariaCheckedLabel, checked: on, class: "switch__input", disabled: this.disabled, id: this.inputId, name: this.inputName, onChange: this.onChange, role: "switch", type: "checkbox", value: this.value })), hAsync("span", { "aria-hidden": "true", class: "switch__thumb", ref: (el) => (this.thumb = el) })), this.label && hAsync("span", { class: "switch__label" }, this.label))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlSwitchCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-switch",
    "$members$": {
      "checked": [1028],
      "disabled": [4],
      "inputId": [1, "input-id"],
      "inputName": [1, "input-name"],
      "label": [1],
      "size": [1],
      "value": [1]
    },
    "$listeners$": [[9, "pointerup", "onWindowPointerUp"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTabCss = "/*!@:host*/.sc-swirl-tab-h{display:block;width:100%}/*!@:host **/.sc-swirl-tab-h *.sc-swirl-tab{box-sizing:border-box}/*!@.tab*/.tab.sc-swirl-tab{display:none;width:100%;padding:var(--s-space-8)}/*!@.tab--active*/.tab--active.sc-swirl-tab{display:block}";

class SwirlTab {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.active = undefined;
    this.label = undefined;
    this.tabId = undefined;
  }
  render() {
    const className = classnames("tab", { "tab--active": this.active });
    return (hAsync(Host, { "aria-labelledby": `tab-${this.tabId}`, id: this.tabId, role: "tabpanel", tabIndex: this.active ? 0 : -1 }, hAsync("div", { class: className }, hAsync("slot", null))));
  }
  static get style() { return swirlTabCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-tab",
    "$members$": {
      "active": [4],
      "label": [1],
      "tabId": [1, "tab-id"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTabBarCss = ".sc-swirl-tab-bar-h{display:block}.sc-swirl-tab-bar-h *.sc-swirl-tab-bar{box-sizing:border-box}.tab-bar.sc-swirl-tab-bar{position:relative;display:flex;width:100%;justify-content:flex-start;border-bottom:var(--s-border-width-default) solid var(--s-border-default)}.tab-bar__tab.sc-swirl-tab-bar{position:relative;display:block;min-width:0;margin:0;padding:var(--s-space-4) var(--s-space-8);border:none;color:var(--s-interactive-neutral-default);background-color:transparent;font:inherit;font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-base);cursor:pointer}.tab-bar__tab.sc-swirl-tab-bar:focus{outline:none}.tab-bar__tab.sc-swirl-tab-bar:focus-visible .tab-bar__tab-label.sc-swirl-tab-bar{border-radius:var(--s-border-radius-s);box-shadow:inset 0 0 0 0.125rem var(--s-focus-default)}.tab-bar__tab.sc-swirl-tab-bar:not(.tab-bar__tab--active):hover:after{position:absolute;bottom:0;left:50%;width:calc(100% - var(--s-space-8));height:0.1875rem;border-radius:0.125rem;background-color:var(--s-border-default);content:\"\";transform:translateX(-50%);pointer-events:none}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.tab-bar__tab.sc-swirl-tab-bar{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.tab-bar__tab-label.sc-swirl-tab-bar{display:block;overflow:hidden;width:100%;padding:var(--s-space-8) var(--s-space-8);text-align:center;white-space:nowrap;text-overflow:ellipsis}.tab-bar__tab--active.sc-swirl-tab-bar{color:var(--s-text-highlight)}.tab-bar__tab--active.sc-swirl-tab-bar:after{position:absolute;bottom:0;left:50%;width:calc(100% - var(--s-space-8));height:0.1875rem;border-radius:0.125rem;background-color:var(--s-border-highlight);content:\"\";transform:translateX(-50%);pointer-events:none}";

class SwirlTabBar {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.activateNextTab = createEvent(this, "activateNextTab", 7);
    this.activatePreviousTab = createEvent(this, "activatePreviousTab", 7);
    this.activateTab = createEvent(this, "activateTab", 7);
    this.onKeyDown = (event) => {
      if (event.code === "ArrowLeft") {
        event.preventDefault();
        this.activatePreviousTab.emit();
      }
      else if (event.code === "ArrowRight") {
        event.preventDefault();
        this.activateNextTab.emit();
      }
    };
    this.disableTabSemantics = undefined;
    this.label = undefined;
    this.tabs = [];
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { "aria-label": this.label, class: "tab-bar", onKeyDown: this.onKeyDown, role: this.disableTabSemantics ? undefined : "tablist" }, this.tabs.map((tab) => {
      const className = classnames("tab-bar__tab", {
        "tab-bar__tab--active": tab.active,
      });
      return (hAsync("button", { "aria-controls": this.disableTabSemantics ? undefined : tab.id, "aria-selected": this.disableTabSemantics
          ? undefined
          : tab.active
            ? "true"
            : "false", class: className, id: `tab-${tab.id}`, key: tab.id,
        // eslint-disable-next-line react/jsx-no-bind
        onClick: () => this.activateTab.emit(tab.id), role: this.disableTabSemantics ? undefined : "tab", tabIndex: this.disableTabSemantics ? undefined : tab.active ? 0 : -1, type: "button" }, hAsync("span", { class: "tab-bar__tab-label" }, tab.label)));
    }))));
  }
  static get style() { return swirlTabBarCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-tab-bar",
    "$members$": {
      "disableTabSemantics": [4, "disable-tab-semantics"],
      "label": [1],
      "tabs": [16]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

/* global setTimeout, clearTimeout */

var dist = function debounce(fn) {
  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var lastCallAt = void 0;
  var deferred = void 0;
  var timer = void 0;
  var pendingArgs = [];
  return function debounced() {
    var currentWait = getWait(wait);
    var currentTime = new Date().getTime();

    var isCold = !lastCallAt || currentTime - lastCallAt > currentWait;

    lastCallAt = currentTime;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (isCold && options.leading) {
      return options.accumulate ? Promise.resolve(fn.call(this, [args])).then(function (result) {
        return result[0];
      }) : Promise.resolve(fn.call.apply(fn, [this].concat(args)));
    }

    if (deferred) {
      clearTimeout(timer);
    } else {
      deferred = defer();
    }

    pendingArgs.push(args);
    timer = setTimeout(flush.bind(this), currentWait);

    if (options.accumulate) {
      var argsIndex = pendingArgs.length - 1;
      return deferred.promise.then(function (results) {
        return results[argsIndex];
      });
    }

    return deferred.promise;
  };

  function flush() {
    var thisDeferred = deferred;
    clearTimeout(timer);

    Promise.resolve(options.accumulate ? fn.call(this, pendingArgs) : fn.apply(this, pendingArgs[pendingArgs.length - 1])).then(thisDeferred.resolve, thisDeferred.reject);

    pendingArgs = [];
    deferred = null;
  }
};

function getWait(wait) {
  return typeof wait === 'function' ? wait() : wait;
}

function defer() {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

const swirlTableCss = "/*!@:host*/.sc-swirl-table-h{position:relative;display:block}/*!@:host **/.sc-swirl-table-h *.sc-swirl-table{box-sizing:border-box}/*!@.table__container*/.table__container.sc-swirl-table{position:relative;overflow:auto;width:100%}/*!@.table__container--scrolled*/.table__container--scrolled.sc-swirl-table{--swirl-table-sticky-right-shadow:0.0625rem 0 0 0 var(--s-border-default),\n    -0.0625rem 0 0 0 var(--s-border-default),\n    0 0.25rem 1rem rgba(25, 26, 28, 0.04),\n    0 0.0625rem 0.25rem rgba(25, 26, 28, 0.16)}/*!@.table__container--scrollable:not(.table__container--scrolled-to-end)*/.table__container--scrollable.sc-swirl-table:not(.table__container--scrolled-to-end){--swirl-table-sticky-left-shadow:0.0625rem 0 0 0 var(--s-border-default),\n    -0.0625rem 0 0 0 var(--s-border-default),\n    0 0.25rem 1rem rgba(25, 26, 28, 0.04),\n    0 0.0625rem 0.25rem rgba(25, 26, 28, 0.16)}/*!@.table__table*/.table__table.sc-swirl-table{width:-webkit-max-content;width:-moz-max-content;width:max-content;min-width:max(20rem, 100%)}/*!@.table__header ::slotted(*)*/.table__header .sc-swirl-table-s>*{display:flex}/*!@.table__empty-row*/.table__empty-row.sc-swirl-table{display:flex}/*!@.table__empty-row-cell*/.table__empty-row-cell.sc-swirl-table{display:flex;overflow:auto;padding-top:var(--s-space-8);padding-right:var(--s-space-16);padding-bottom:var(--s-space-8);padding-left:var(--s-space-16);flex-basis:0;flex-grow:1;flex-shrink:1;align-items:center;border-right:var(--s-border-width-default) solid var(--s-border-default);border-bottom:var(--s-border-width-default) solid var(--s-border-default);border-left:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-surface-default)}/*!@.table__empty-row-cell > **/.table__empty-row-cell.sc-swirl-table>*.sc-swirl-table{flex-grow:1}";

/**
 * @slot columns - Column container, should contain SwirlTableColumns.
 * @slot rows - Row container, should contain SwirlTableRows.
 */
class SwirlTable {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.triggerRerender = debounce(async () => {
      await this.updateLayout();
      this.updateScrolledState();
      this.updateEmptyState();
    }, 0, true);
    this.updateLayout = dist(async () => {
      this.resetCellStyles();
      this.resetColumnStyles();
      this.resetEmptyRowStyles();
      this.resetRowGroupStyles();
      this.layoutEmptyRow();
      this.layoutRowGroups();
      this.layOutCells();
    }, 16, { leading: true });
    this.onScroll = () => {
      this.updateScrolledState();
    };
    this.onSlotChange = async () => {
      await this.updateLayout();
      this.updateScrolledState();
      this.updateEmptyState();
    };
    this.caption = undefined;
    this.emptyStateLabel = "No results found.";
    this.label = undefined;
    this.empty = undefined;
    this.scrollable = undefined;
    this.scrolled = undefined;
    this.scrolledToEnd = undefined;
  }
  async componentDidRender() {
    await this.updateLayout();
    this.updateScrolledState();
    this.updateEmptyState();
  }
  async onWindowResize() {
    await this.updateLayout();
    this.updateScrolledState();
  }
  /**
   * Force a re-render of the table
   */
  async rerender() {
    this.triggerRerender();
  }
  resetEmptyRowStyles() {
    const emptyRow = this.el.shadowRoot.querySelector(".table__empty-row");
    if (!Boolean(emptyRow)) {
      return;
    }
    emptyRow.style.width = "";
  }
  resetRowGroupStyles() {
    const tableRowGroups = Array.from(this.el.querySelectorAll("swirl-table-row-group"));
    tableRowGroups.forEach((tableRowGroup) => {
      const headerRow = tableRowGroup.shadowRoot.querySelector(".table-row-group__header-row");
      if (!Boolean(headerRow)) {
        return;
      }
      tableRowGroup.shadowRoot.querySelector(".table-row-group__header-row").style.width = "";
    });
  }
  resetColumnStyles() {
    const columns = this.getColumns();
    columns.forEach((column) => {
      column.classList.remove("table-column--has-shadow");
      column.style.right = "";
      column.style.left = "";
      column.style.position = "";
      column.style.zIndex = "";
    });
  }
  resetCellStyles() {
    const cells = this.getCells();
    cells.forEach((cell) => {
      cell.classList.remove("table-cell--has-shadow");
      cell.style.flex = "";
      cell.style.left = "";
      cell.style.right = "";
      cell.style.position = "";
      cell.style.zIndex = "";
    });
  }
  updateScrolledState() {
    const isMobile = isMobileViewport();
    const scrollable = this.container.scrollWidth > this.container.clientWidth;
    const scrolled = this.container.scrollLeft > 0;
    const scrolledToEnd = Math.ceil(this.container.clientWidth + this.container.scrollLeft) >=
      Math.floor(this.container.scrollWidth);
    if (scrollable !== this.scrollable) {
      if (scrollable && !isMobile) {
        this.container.classList.add("table__container--scrollable");
      }
      else {
        this.container.classList.remove("table__container--scrollable");
      }
    }
    if (scrolled !== this.scrolled) {
      if (scrolled && !isMobile) {
        this.container.classList.add("table__container--scrolled");
      }
      else {
        this.container.classList.remove("table__container--scrolled");
      }
    }
    if (scrolledToEnd !== this.scrolledToEnd) {
      if (scrolledToEnd && !isMobile) {
        this.container.classList.add("table__container--scrolled-to-end");
      }
      else {
        this.container.classList.remove("table__container--scrolled-to-end");
      }
    }
  }
  getColumns() {
    return Array.from(this.el.querySelectorAll("swirl-table-column"));
  }
  getCells() {
    return Array.from(this.el.querySelectorAll("swirl-table-cell"));
  }
  layoutEmptyRow() {
    const emptyRow = this.el.shadowRoot.querySelector(".table__empty-row");
    if (!Boolean(emptyRow)) {
      return;
    }
    const scrollWidth = `${this.el.shadowRoot.querySelector(".table__container").scrollWidth}px`;
    emptyRow.style.width = scrollWidth;
  }
  layoutRowGroups() {
    var _a;
    const tableRowGroups = Array.from(this.el.querySelectorAll("swirl-table-row-group"));
    const scrollWidth = `${(_a = this.el.shadowRoot.querySelector(".table__container")) === null || _a === void 0 ? void 0 : _a.scrollWidth}px`;
    tableRowGroups.forEach((tableRowGroup) => {
      const headerRow = tableRowGroup.shadowRoot.querySelector(".table-row-group__header-row");
      if (!Boolean(headerRow)) {
        return;
      }
      tableRowGroup.shadowRoot.querySelector(".table-row-group__header-row").style.width = scrollWidth;
    });
  }
  layOutCells() {
    const columns = this.getColumns();
    const cells = this.getCells();
    columns.forEach((column, colIndex) => {
      const cellsOfColumn = cells.filter((_, cellIndex) => {
        return (colIndex - cellIndex) % columns.length === 0;
      });
      const columnWidth = column.width || `${column.getBoundingClientRect().width}px`;
      cellsOfColumn.forEach((cell) => {
        cell.style.flex = Boolean(columnWidth) ? `0 0 ${columnWidth}` : "";
      });
    });
  }
  updateEmptyState() {
    const rowsContainer = this.el.querySelector('[slot="rows"]');
    this.empty = !Boolean(rowsContainer) || rowsContainer.children.length === 0;
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { class: "table" }, hAsync("div", { class: "table__container", onScroll: this.onScroll, ref: (el) => (this.container = el) }, hAsync("div", { "aria-describedby": Boolean(this.caption) ? "caption" : undefined, "aria-label": this.label, role: "table", class: "table__table" }, this.caption && (hAsync("swirl-visually-hidden", null, hAsync("div", { id: "caption" }, this.caption))), hAsync("div", { role: "rowgroup" }, hAsync("div", { class: "table__header", role: "row" }, hAsync("slot", { name: "columns", onSlotchange: this.onSlotChange }))), hAsync("div", { class: "table__body" }, hAsync("slot", { name: "rows", onSlotchange: this.onSlotChange }), this.empty && (hAsync("div", { class: "table__empty-row", role: "row" }, hAsync("div", { "aria-colspan": this.getColumns().length, class: "table__empty-row-cell", role: "cell" }, hAsync("swirl-text", { align: "center", size: "sm" }, this.emptyStateLabel))))))))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlTableCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-table",
    "$members$": {
      "caption": [1],
      "emptyStateLabel": [1, "empty-state-label"],
      "label": [1],
      "empty": [32],
      "scrollable": [32],
      "scrolled": [32],
      "scrolledToEnd": [32],
      "rerender": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTableCellCss = "/*!@:host*/.sc-swirl-table-cell-h{display:flex;overflow:auto;padding-top:var(--s-space-8);padding-right:var(--s-space-16);padding-bottom:var(--s-space-8);padding-left:var(--s-space-16);flex-basis:0;flex-grow:1;flex-shrink:1;align-items:center;background-color:var(--s-surface-default);word-break:break-word;-webkit-hyphens:auto;hyphens:auto;transition:box-shadow 0.15s}/*!@:host(.table-cell--has-shadow-right)*/.table-cell--has-shadow-right.sc-swirl-table-cell-h{box-shadow:var(--swirl-table-sticky-right-shadow)}/*!@:host(.table-cell--has-shadow-left)*/.table-cell--has-shadow-left.sc-swirl-table-cell-h{box-shadow:var(--swirl-table-sticky-left-shadow)}/*!@:host **/.sc-swirl-table-cell-h *.sc-swirl-table-cell{box-sizing:border-box}";

/**
 * @slot slot - The cell content.
 */
class SwirlTableCell {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  render() {
    return (hAsync(Host, { class: "table-cell", role: "cell" }, hAsync("slot", null)));
  }
  static get style() { return swirlTableCellCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-table-cell",
    "$members$": undefined,
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTableColumnCss = "/*!@:host*/.sc-swirl-table-column-h{display:flex;overflow:hidden;padding-top:var(--s-space-12);padding-right:var(--s-space-16);padding-bottom:var(--s-space-12);padding-left:var(--s-space-16);flex-basis:0;flex-grow:1;flex-shrink:1;align-items:center;border-bottom:var(--s-border-width-default) solid var(--s-border-default);color:var(--s-text-subdued);background-color:var(--s-surface-default);font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-sm);white-space:nowrap;letter-spacing:var(--s-letter-spacing-tighter);text-overflow:ellipsis;transition:box-shadow 0.15s;gap:var(--s-space-8)}/*!@:host(.table-column--has-shadow-right)*/.table-column--has-shadow-right.sc-swirl-table-column-h{box-shadow:var(--swirl-table-sticky-right-shadow)}/*!@:host(.table-column--has-shadow-left)*/.table-column--has-shadow-left.sc-swirl-table-column-h{box-shadow:var(--swirl-table-sticky-left-shadow)}/*!@:host **/.sc-swirl-table-column-h *.sc-swirl-table-column{box-sizing:border-box}/*!@.table-column__sort-indicator*/.table-column__sort-indicator.sc-swirl-table-column{display:inline-flex;width:1.25rem;height:1.25rem;flex-grow:0;flex-shrink:0}";

/**
 * @slot slot - The column label.
 */
class SwirlTableColumn {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sort = undefined;
    this.sortable = undefined;
    this.maxWidth = undefined;
    this.minWidth = "fit-content";
    this.sticky = undefined;
    this.width = undefined;
  }
  componentDidRender() {
    const table = closestPassShadow(this.el, "swirl-table");
    table === null || table === void 0 ? void 0 : table.rerender();
  }
  render() {
    const styles = {
      flex: Boolean(this.width) ? `0 0 ${this.width}` : "",
      maxWidth: this.maxWidth || "",
      minWidth: this.minWidth || "",
    };
    return (hAsync(Host, { "aria-sort": this.sort, class: "table-column", role: "columnheader", style: styles }, hAsync("span", null, hAsync("slot", null)), this.sortable && (hAsync("span", { class: "table-column__sort-indicator" }, this.sort === "ascending" && (hAsync("swirl-icon-arrow-upward", { "aria-hidden": "true", size: 20 })), this.sort === "descending" && (hAsync("swirl-icon-arrow-downward", { "aria-hidden": "true", size: 20 })), !Boolean(this.sort) && " "))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlTableColumnCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-table-column",
    "$members$": {
      "sort": [1],
      "sortable": [4],
      "maxWidth": [1, "max-width"],
      "minWidth": [1, "min-width"],
      "sticky": [4],
      "width": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTableRowCss = "/*!@:host*/.sc-swirl-table-row-h{display:flex}/*!@:host(.table-row--highlighted)*/.table-row--highlighted.sc-swirl-table-row-h{--swirl-ghost-button-background-default:transparent}/*!@:host(.table-row--highlighted) ::slotted(.table-cell)*/.sc-swirl-table-row-h.table-row--highlighted .sc-swirl-table-row-s>.table-cell{background-color:rgba(240, 242, 255, 1)}/*!@:host ::slotted(.table-cell)*/.sc-swirl-table-row-h .sc-swirl-table-row-s>.table-cell{border-bottom:var(--s-border-width-default) solid var(--s-border-default)}/*!@:host **/.sc-swirl-table-row-h *.sc-swirl-table-row{box-sizing:border-box}";

/**
 * @slot slot - The cells of this row.
 */
class SwirlTableRow {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.highlighted = undefined;
    this.index = undefined;
  }
  componentDidLoad() {
    const table = closestPassShadow(this.el, "swirl-table");
    table === null || table === void 0 ? void 0 : table.rerender();
  }
  render() {
    const className = classnames("table-row", {
      "table-row--highlighted": this.highlighted,
    });
    return (hAsync(Host, { "aria-rowindex": this.index, class: className, role: "row" }, hAsync("slot", null)));
  }
  get el() { return getElement(this); }
  static get style() { return swirlTableRowCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-table-row",
    "$members$": {
      "highlighted": [4],
      "index": [2]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTableRowGroupCss = "/*!@:host*/.sc-swirl-table-row-group-h{position:relative;z-index:1;display:block}/*!@:host **/.sc-swirl-table-row-group-h *.sc-swirl-table-row-group{box-sizing:border-box}/*!@.table-row-group__header-row*/.table-row-group__header-row.sc-swirl-table-row-group{padding:var(--s-space-12) var(--s-space-16);border-bottom:var(--s-border-width-default) solid var(--s-border-default);background-color:var(--s-surface-raised-default);font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-sm)}@media (min-width: 768px){/*!@.table-row-group__label*/.table-row-group__label.sc-swirl-table-row-group{position:sticky;left:var(--s-space-16)}}";

/**
 * @slot slot - The rows of this group.
 */
class SwirlTableRowGroup {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.label = undefined;
  }
  render() {
    const rowspan = this.el.querySelectorAll("swirl-table-row").length;
    return (hAsync(Host, { class: "table-row-group", role: "rowgroup" }, hAsync("div", { class: "table-row-group__header-row", role: "row" }, hAsync("span", { "aria-rowspan": rowspan, class: "table-row-group__label", role: "rowheader" }, this.label)), hAsync("slot", null)));
  }
  get el() { return getElement(this); }
  static get style() { return swirlTableRowGroupCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-table-row-group",
    "$members$": {
      "label": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTabsCss = ".sc-swirl-tabs-h{display:block;width:100%}.sc-swirl-tabs-h *.sc-swirl-tabs{box-sizing:border-box}.tabs.sc-swirl-tabs{width:100%}";

class SwirlTabs {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.tabActivated = createEvent(this, "tabActivated", 7);
    this.tabs = [];
    this.onActivateNextTab = () => {
      this.activateNextTab();
    };
    this.onActivatePreviousTab = () => {
      this.activatePreviousTab();
    };
    this.onActivateTab = (event) => {
      this.activateTab(event.detail);
    };
    this.initialTab = undefined;
    this.label = undefined;
    this.activeTab = undefined;
    this.tabBarTabs = [];
  }
  componentWillLoad() {
    this.collectTabs();
    this.updateTabBarTabs();
  }
  /**
   * Activate a tab.
   * @param tabId
   */
  async activateTab(tabId) {
    if (this.activeTab === tabId) {
      return;
    }
    this.activeTab = tabId;
    this.tabs.forEach((tab) => (tab.active = false));
    const tab = this.tabs.find((tab) => tab.tabId === tabId);
    if (!Boolean(tab)) {
      return;
    }
    tab.active = true;
    this.tabActivated.emit(tab);
    this.updateTabBarTabs();
  }
  activateNextTab() {
    const currentIndex = this.tabs.findIndex((tab) => tab.tabId === this.activeTab);
    const nextIndex = Math.min(this.tabs.length - 1, currentIndex + 1);
    this.activateTab(this.tabs[nextIndex].tabId);
    requestAnimationFrame(() => {
      var _a;
      (_a = this.el.querySelector(".tabs__tab--active")) === null || _a === void 0 ? void 0 : _a.focus();
    });
  }
  activatePreviousTab() {
    const currentIndex = this.tabs.findIndex((tab) => tab.tabId === this.activeTab);
    const previousIndex = Math.max(0, currentIndex - 1);
    this.activateTab(this.tabs[previousIndex].tabId);
    requestAnimationFrame(() => {
      var _a;
      (_a = this.el.querySelector(".tabs__tab--active")) === null || _a === void 0 ? void 0 : _a.focus();
    });
  }
  collectTabs() {
    this.tabs = Array.from(this.el.querySelectorAll("swirl-tab"));
    if (this.tabs.length === 0) {
      return;
    }
    const initialTab = this.tabs.find((tab) => tab.tabId === this.initialTab);
    this.activateTab(Boolean(initialTab) ? initialTab.tabId : this.tabs[0].tabId);
  }
  updateTabBarTabs() {
    this.tabBarTabs = this.tabs.map((tab) => ({
      id: tab.tabId,
      label: tab.label,
      active: this.activeTab === tab.tabId,
    }));
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { class: "tabs" }, hAsync("swirl-tab-bar", { label: this.label, onActivateNextTab: this.onActivateNextTab, onActivatePreviousTab: this.onActivatePreviousTab, onActivateTab: this.onActivateTab, tabs: this.tabBarTabs })), hAsync("slot", null)));
  }
  get el() { return getElement(this); }
  static get style() { return swirlTabsCss; }
  static get cmpMeta() { return {
    "$flags$": 6,
    "$tagName$": "swirl-tabs",
    "$members$": {
      "initialTab": [1, "initial-tab"],
      "label": [1],
      "activeTab": [32],
      "tabBarTabs": [32],
      "activateTab": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTagCss = "/*!@:host*/.sc-swirl-tag-h{display:inline-flex}/*!@:host **/.sc-swirl-tag-h *.sc-swirl-tag{box-sizing:border-box}/*!@.tag*/.tag.sc-swirl-tag{display:inline-flex;padding:var(--s-space-2) var(--s-space-8);align-items:center;border-radius:var(--s-border-radius-s);color:var(--s-text-default);background-color:var(--s-surface-neutral-subdued);font-size:var(--s-font-size-sm);font-weight:var(--s-font-weight-medium);line-height:var(--s-line-height-sm);white-space:nowrap;gap:var(--s-space-4)}/*!@.tag--intent-info*/.tag--intent-info.sc-swirl-tag{color:var(--s-text-info);background-color:var(--s-surface-info-subdued)}/*!@.tag--intent-info .tag__removal-button*/.tag--intent-info.sc-swirl-tag .tag__removal-button.sc-swirl-tag{color:var(--icon-info)}/*!@.tag--intent-critical*/.tag--intent-critical.sc-swirl-tag{color:var(--s-text-critical);background-color:var(--s-surface-critical-subdued)}/*!@.tag--intent-critical .tag__removal-button*/.tag--intent-critical.sc-swirl-tag .tag__removal-button.sc-swirl-tag{color:var(--icon-critical)}/*!@.tag--intent-warning*/.tag--intent-warning.sc-swirl-tag{color:var(--s-text-warning);background-color:var(--s-surface-warning-subdued)}/*!@.tag--intent-warning .tag__removal-button*/.tag--intent-warning.sc-swirl-tag .tag__removal-button.sc-swirl-tag{color:var(--icon-warning)}/*!@.tag--intent-success*/.tag--intent-success.sc-swirl-tag{color:var(--s-text-success);background-color:var(--s-surface-success-subdued)}/*!@.tag--intent-success .tag__removal-button*/.tag--intent-success.sc-swirl-tag .tag__removal-button.sc-swirl-tag{color:var(--icon-success)}/*!@.tag__removal-button*/.tag__removal-button.sc-swirl-tag{display:inline-flex;margin-right:calc(-1 * var(--s-space-4));padding:0;border:none;color:var(--s-icon-strong);background-color:transparent;cursor:pointer}/*!@.tag__removal-button:focus:not(:focus-visible)*/.tag__removal-button.sc-swirl-tag:focus:not(:focus-visible){outline:none}/*!@.tag__removal-button:focus-visible*/.tag__removal-button.sc-swirl-tag:focus-visible{outline-color:var(--s-focus-default)}";

class SwirlTag {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.remove = createEvent(this, "remove", 7);
    this.onRemove = (event) => {
      var _a;
      (_a = this.remove) === null || _a === void 0 ? void 0 : _a.emit(event);
    };
    this.intent = "default";
    this.label = undefined;
    this.removable = undefined;
    this.removalButtonLabel = "Remove";
  }
  render() {
    const className = classnames("tag", `tag--intent-${this.intent}`);
    return (hAsync(Host, null, hAsync("span", { class: className }, this.label, this.removable && (hAsync("button", { "aria-label": this.removalButtonLabel, class: "tag__removal-button", onClick: this.onRemove, type: "button" }, hAsync("swirl-icon-close", { size: 16 }))))));
  }
  static get style() { return swirlTagCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-tag",
    "$members$": {
      "intent": [1],
      "label": [1],
      "removable": [4],
      "removalButtonLabel": [1, "removal-button-label"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

/**
  shave - Shave is a javascript plugin that truncates multi-line text within a html element based on set max height
  @version v5.0.2
  @link https://github.com/yowainwright/shave#readme
  @author Jeff Wainwright <yowainwright@gmail.com> (jeffry.in)
  @license MIT
**/
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function generateArrayOfNodes(target) {
    if (typeof target === 'string') {
        return __spreadArray([], __read(document.querySelectorAll(target)), false);
    }
    else if ('length' in target) {
        return __spreadArray([], __read(target), false);
    }
    else {
        return [target];
    }
}
function shave(target, maxHeight, opts) {
    if (opts === void 0) { opts = {}; }
    if (typeof maxHeight === 'undefined' || isNaN(maxHeight)) {
        throw Error('maxHeight is required');
    }
    var els = generateArrayOfNodes(target);
    if (!els.length) {
        return;
    }
    var _a = opts.character, character = _a === void 0 ? '…' : _a, _b = opts.classname, classname = _b === void 0 ? 'js-shave' : _b, _c = opts.spaces, initialSpaces = _c === void 0 ? true : _c, _d = opts.charclassname, charclassname = _d === void 0 ? 'js-shave-char' : _d, _e = opts.link, link = _e === void 0 ? {} : _e;
    /**
     * @notes
     * the initialSpaces + spaces variable definition below fixes
     * a previous bug where spaces being a boolean type wasn't clear
     * meaning people were using (a string, in example—which is truthy)
     * hence, doing it this way is a non-breaking change
     */
    var spaces = typeof initialSpaces === 'boolean' ? initialSpaces : true;
    /**
     * @notes
     * - create a span or anchor element and assign properties to it
     * - JSON.stringify is used to support IE8+
     * - if link.href is not provided, link object properties are ignored
     */
    var isLink = link && JSON.stringify(link) !== '{}' && link.href;
    var shavedTextElType = isLink ? 'a' : 'span';
    for (var i = 0; i < els.length; i += 1) {
        var el = els[i];
        var styles = el.style;
        var span = el.querySelector('.' + classname);
        var textProp = el.textContent === undefined ? 'innerText' : 'textContent';
        // If element text has already been shaved
        if (span) {
            // Remove the ellipsis to recapture the original text
            el.removeChild(el.querySelector('.' + charclassname));
            el[textProp] = el[textProp]; // eslint-disable-line
            // nuke span, recombine text
        }
        var fullText = el[textProp];
        var words = spaces ? fullText.split(' ') : fullText;
        // If 0 or 1 words, we're done
        if (words.length < 2) {
            continue;
        }
        // Temporarily remove any CSS height for text height calculation
        var heightStyle = styles.height;
        styles.height = 'auto';
        var maxHeightStyle = styles.maxHeight;
        styles.maxHeight = 'none';
        // If already short enough, we're done
        if (el.offsetHeight <= maxHeight) {
            styles.height = heightStyle;
            styles.maxHeight = maxHeightStyle;
            continue;
        }
        var textContent = isLink && link.textContent ? link.textContent : character;
        var shavedTextEl = document.createElement(shavedTextElType);
        var shavedTextElAttributes = {
            className: charclassname,
            textContent: textContent,
        };
        for (var property in shavedTextElAttributes) {
            shavedTextEl[property] = shavedTextElAttributes[property];
            shavedTextEl.textContent = character;
        }
        if (isLink) {
            for (var linkProperty in link) {
                shavedTextEl[linkProperty] = link[linkProperty];
            }
        }
        // Binary search for number of words which can fit in allotted height
        var max = words.length - 1;
        var min = 0;
        var pivot = void 0;
        while (min < max) {
            pivot = (min + max + 1) >> 1; // eslint-disable-line no-bitwise
            el[textProp] = spaces
                ? words.slice(0, pivot).join(' ')
                : words.slice(0, pivot);
            el.insertAdjacentElement('beforeend', shavedTextEl);
            if (el.offsetHeight > maxHeight) {
                max = pivot - 1;
            }
            else {
                min = pivot;
            }
        }
        el[textProp] = spaces ? words.slice(0, max).join(' ') : words.slice(0, max);
        el.insertAdjacentElement('beforeend', shavedTextEl);
        var diff = spaces
            ? " ".concat(words.slice(max).join(' '))
            : words.slice(max);
        var shavedText = document.createTextNode(diff);
        var elWithShavedText = document.createElement('span');
        elWithShavedText.classList.add(classname);
        elWithShavedText.style.display = 'none';
        elWithShavedText.appendChild(shavedText);
        el.insertAdjacentElement('beforeend', elWithShavedText);
        styles.height = heightStyle;
        styles.maxHeight = maxHeightStyle;
    }
}

const swirlTextCss = ".sc-swirl-text-h{display:block;max-width:100%}.sc-swirl-text-h *.sc-swirl-text{box-sizing:border-box}.text.sc-swirl-text{overflow:hidden;margin:0;padding:0}.text--align-start.sc-swirl-text{text-align:start}.text--align-center.sc-swirl-text{text-align:center}.text--align-end.sc-swirl-text{text-align:end}.text--color-default.sc-swirl-text{color:var(--s-text-default)}.text--color-subdued.sc-swirl-text{color:var(--s-text-subdued)}.text--color-critical.sc-swirl-text{color:var(--s-text-critical)}.text--color-success.sc-swirl-text{color:var(--s-text-success)}.text--color-warning.sc-swirl-text{color:var(--s-text-warning)}.text--size-sm.sc-swirl-text{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}.text--size-base.sc-swirl-text{font-size:var(--s-font-size-base);line-height:var(--s-line-height-base)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.text--size-base.sc-swirl-text{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.text--size-lg.sc-swirl-text{font-size:var(--s-font-size-lg);line-height:var(--s-line-height-lg)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.text--size-lg.sc-swirl-text{font-size:var(--s-font-size-base);line-height:var(--s-line-height-base)}}.text--weight-normal.sc-swirl-text{font-weight:var(--s-font-weight-normal)}.text--weight-medium.sc-swirl-text{font-weight:var(--s-font-weight-medium)}.text--weight-semibold.sc-swirl-text{font-weight:var(--s-font-weight-semibold)}.text--weight-bold.sc-swirl-text{font-weight:var(--s-font-weight-bold)}.text--font-style-normal.sc-swirl-text{font-style:normal}.text--font-style-italic.sc-swirl-text{font-style:italic}.text--font-family-code.sc-swirl-text{font-family:var(--s-font-family-code)}.text--truncate.sc-swirl-text{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}";

class SwirlText {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.align = "start";
    this.as = "p";
    this.balance = undefined;
    this.color = "default";
    this.fontFamily = "text";
    this.fontStyle = "normal";
    this.lines = undefined;
    this.size = "base";
    this.truncate = undefined;
    this.weight = "normal";
  }
  componentDidRender() {
    this.rebalance();
    this.handleTruncation();
  }
  onWindowResize() {
    this.rebalance();
    this.handleTruncation();
  }
  handleTruncation() {
    if (!this.truncate || !Boolean(this.lines) || this.lines === 1) {
      return;
    }
    const lineHeight = +window
      .getComputedStyle(this.textEl, null)
      .getPropertyValue("line-height")
      .replace("px", "");
    if (lineHeight > 0) {
      shave(this.textEl, lineHeight * this.lines);
    }
  }
  rebalance() {
    if (!this.balance || !Boolean(this.textEl)) {
      return;
    }
    balancetext(this.textEl);
  }
  render() {
    const Tag = this.as;
    const className = classnames("text", `text--align-${this.align}`, `text--color-${this.color}`, `text--font-family-${this.fontFamily}`, `text--font-style-${this.fontStyle}`, `text--size-${this.size}`, `text--weight-${this.weight}`, {
      "text--truncate": this.truncate && (!Boolean(this.lines) || this.lines === 1),
    });
    return (hAsync(Host, null, hAsync(Tag, { class: className, ref: (el) => (this.textEl = el) }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get style() { return swirlTextCss; }
  static get cmpMeta() { return {
    "$flags$": 6,
    "$tagName$": "swirl-text",
    "$members$": {
      "align": [1],
      "as": [1],
      "balance": [4],
      "color": [1],
      "fontFamily": [1, "font-family"],
      "fontStyle": [1, "font-style"],
      "lines": [2],
      "size": [1],
      "truncate": [4],
      "weight": [1]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTextInputCss = ".sc-swirl-text-input-h{display:block;width:100%}.sc-swirl-text-input-h *.sc-swirl-text-input{box-sizing:border-box}.text-input.sc-swirl-text-input{position:relative;display:flex;width:100%;align-items:center;color:var(--s-text-default);font:inherit;line-height:var(--s-line-height-sm)}.text-input--auto-grow.sc-swirl-text-input .text-input__input.sc-swirl-text-input{max-height:none}.text-input--clearable.sc-swirl-text-input,.text-input--type-number.sc-swirl-text-input,.text-input--type-password.sc-swirl-text-input{padding-right:calc(1.5rem + var(--s-space-8))}.text-input--show-password.sc-swirl-text-input .text-input__input.sc-swirl-text-input{width:100%}.text-input--disabled.sc-swirl-text-input .text-input__character-counter.sc-swirl-text-input{color:var(--s-text-disabled)}.text-input--inline.sc-swirl-text-input .text-input__stepper.sc-swirl-text-input{top:calc(-1 * var(--s-space-8));right:calc(-1 * var(--s-space-12))}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.text-input--inline.sc-swirl-text-input .text-input__stepper.sc-swirl-text-input{top:calc(-1 * var(--s-space-8));right:calc(-1 * var(--s-space-12))}}.text-input--inline.sc-swirl-text-input .text-input__step-button.sc-swirl-text-input{width:2rem;height:1.125rem;justify-content:center;background-color:var(--s-surface-raised-default)}.text-input--inline.sc-swirl-text-input .text-input__step-button.sc-swirl-text-input:first-of-type{border-top-right-radius:var(--s-border-radius-sm)}.text-input--inline.sc-swirl-text-input .text-input__step-button.sc-swirl-text-input:last-of-type{border-bottom-right-radius:var(--s-border-radius-sm)}.text-input--inline.sc-swirl-text-input .text-input__step-button.sc-swirl-text-input:hover{background-color:var(--s-surface-raised-hovered)}.text-input--inline.sc-swirl-text-input .text-input__step-button.sc-swirl-text-input swirl-icon-expand-less.sc-swirl-text-input,.text-input--inline.sc-swirl-text-input .text-input__step-button.sc-swirl-text-input swirl-icon-expand-more.sc-swirl-text-input{width:1rem}.text-input--inline.sc-swirl-text-input .text-input__clear-button.sc-swirl-text-input,.text-input--inline.sc-swirl-text-input .text-input__password-toggle.sc-swirl-text-input{top:-0.0625rem}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.text-input--inline.sc-swirl-text-input .text-input__clear-button.sc-swirl-text-input,.text-input--inline.sc-swirl-text-input .text-input__password-toggle.sc-swirl-text-input{top:0}}.text-input--inline.sc-swirl-text-input .text-input__character-counter.sc-swirl-text-input{top:calc(100% + var(--s-space-12) + var(--s-border-width-default));right:calc(-1 * var(--s-space-12));max-width:6rem}.text-input__input.sc-swirl-text-input{display:inline-flex;width:100%;max-height:13.75rem;margin:0;padding:0;border:none;color:var(--s-text-default);background-color:transparent;font:inherit;font-size:var(--s-font-size-base);line-height:var(--s-line-height-base);resize:none;caret-color:var(--s-border-highlight)}.text-input__input.sc-swirl-text-input:focus{outline:none}.text-input__input.sc-swirl-text-input:disabled{color:var(--s-text-disabled);background-color:transparent}.text-input__input.sc-swirl-text-input::-webkit-outer-spin-button,.text-input__input.sc-swirl-text-input::-webkit-inner-spin-button{margin:0;-webkit-appearance:none}.text-input__input[type=\"number\"].sc-swirl-text-input{-moz-appearance:textfield}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.text-input__input.sc-swirl-text-input{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}input.text-input__input.sc-swirl-text-input:not([type=\"password\"]){width:0.25rem;min-width:0.25rem}.text-input--disable-dynamic-width.sc-swirl-text-input input.text-input__input.sc-swirl-text-input:not([type=\"password\"]){width:100%;min-width:0}.text-input__clear-button.sc-swirl-text-input,.text-input__password-toggle.sc-swirl-text-input{position:absolute;top:calc(-1 * var(--s-space-12));right:0;display:inline-flex;margin:0;padding:0;border:none;color:var(--s-icon-default);background-color:transparent;cursor:pointer}.text-input__clear-button.sc-swirl-text-input:focus:not(:focus-visible),.text-input__password-toggle.sc-swirl-text-input:focus:not(:focus-visible){outline:none}.text-input__clear-button.sc-swirl-text-input:focus-visible,.text-input__password-toggle.sc-swirl-text-input:focus-visible{outline-color:var(--s-focus-default)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.text-input__clear-button.sc-swirl-text-input,.text-input__password-toggle.sc-swirl-text-input{top:-0.625rem}}.text-input__stepper.sc-swirl-text-input{position:absolute;top:-1.4375rem;right:0;display:flex;flex-direction:column}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.text-input__stepper.sc-swirl-text-input{top:-1.25rem}}.text-input__step-button.sc-swirl-text-input{display:inline-flex;margin:0;padding:0;border:none;color:var(--s-icon-default);background-color:transparent;cursor:pointer}.text-input__step-button.sc-swirl-text-input:focus:not(:focus-visible){outline:none}.text-input__step-button.sc-swirl-text-input:focus-visible{outline-color:var(--s-focus-default)}.text-input__character-counter.sc-swirl-text-input{position:absolute;top:-1.375rem;right:0;display:flex;color:var(--s-text-subdued);line-height:var(--s-line-height-sm);flex-direction:column}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){.text-input__character-counter.sc-swirl-text-input{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}.text-input__prefix.sc-swirl-text-input{padding-right:var(--s-space-4);color:var(--s-text-subdued);font-size:var(--s-font-size-base)}.text-input__suffix.sc-swirl-text-input{padding-left:var(--s-space-4);color:var(--s-text-subdued);font-size:var(--s-font-size-base)}";

class SwirlTextInput {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.inputBlur = createEvent(this, "inputBlur", 7);
    this.inputFocus = createEvent(this, "inputFocus", 7);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.updateIconSize(event.matches);
    };
    this.clear = () => {
      this.inputEl.value = "";
      this.value = "";
      this.valueChange.emit("");
      this.inputEl.focus();
    };
    this.onChange = (event) => {
      const el = event.target;
      this.value = el.value;
      this.valueChange.emit(el.value);
    };
    this.onBlur = (event) => {
      this.inputBlur.emit(event);
    };
    this.onFocus = (event) => {
      this.inputFocus.emit(event);
      this.handleAutoSelect(event);
    };
    this.onInput = (event) => {
      this.onChange(event);
    };
    this.onKeyPress = (event) => {
      if (this.type !== "number") {
        return;
      }
      if (["+", "-", "e"].includes(event.key)) {
        event.preventDefault();
      }
    };
    this.decreaseValue = () => {
      if (this.type !== "number") {
        return;
      }
      const step = this.step || 1;
      let currentValue = this.inputEl.valueAsNumber;
      if (isNaN(this.inputEl.valueAsNumber)) {
        currentValue = this.min !== undefined ? this.min + 1 : 1;
      }
      this.value = String(Math.max(this.min || -Infinity, currentValue - step));
      this.valueChange.emit(this.value);
    };
    this.increaseValue = () => {
      if (this.type !== "number") {
        return;
      }
      const step = this.step || 1;
      let currentValue = this.inputEl.valueAsNumber;
      if (isNaN(this.inputEl.valueAsNumber)) {
        currentValue = this.min !== undefined ? this.min - 1 : -1;
      }
      this.value = String(Math.min(this.max || Infinity, currentValue + step));
      this.valueChange.emit(this.value);
    };
    this.togglePassword = () => {
      if (this.type !== "password") {
        return;
      }
      this.showPassword = !this.showPassword;
    };
    this.autoComplete = "on";
    this.autoFocus = undefined;
    this.autoGrow = undefined;
    this.autoSelect = undefined;
    this.clearable = undefined;
    this.clearButtonLabel = "Clear input";
    this.disabled = undefined;
    this.disableDynamicWidth = undefined;
    this.swirlAriaAutocomplete = undefined;
    this.swirlAriaControls = undefined;
    this.swirlAriaDescribedby = undefined;
    this.swirlAriaExpanded = undefined;
    this.swirlRole = undefined;
    this.inline = undefined;
    this.invalid = undefined;
    this.maxLength = undefined;
    this.max = undefined;
    this.min = undefined;
    this.mode = undefined;
    this.placeholder = undefined;
    this.prefixLabel = undefined;
    this.required = undefined;
    this.rows = 1;
    this.showCharacterCounter = undefined;
    this.spellCheck = undefined;
    this.suffixLabel = undefined;
    this.step = undefined;
    this.passwordToggleLabel = "Toggle password display";
    this.type = "text";
    this.value = undefined;
    this.iconSize = 24;
    this.showPassword = false;
  }
  componentDidLoad() {
    var _a, _b;
    this.updateIconSize(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  componentDidRender() {
    this.adjustInputSize();
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  updateIconSize(smallIcon) {
    this.iconSize = smallIcon ? 20 : 24;
  }
  adjustInputSize() {
    if (this.rows > 1 || this.autoGrow) {
      this.inputEl.style.width = "";
      this.inputEl.style.height = "";
      this.inputEl.style.height = this.inputEl.scrollHeight / 16 + "rem";
    }
    if (this.rows === 1 && !this.autoGrow) {
      this.inputEl.style.height = "";
      this.inputEl.style.width = "";
      if (this.type !== "password" &&
        !this.disableDynamicWidth &&
        !Boolean(this.placeholder)) {
        this.inputEl.style.width = this.inputEl.scrollWidth / 16 + "rem";
      }
    }
  }
  handleAutoSelect(event) {
    if (!this.autoSelect) {
      return;
    }
    event.target.select();
  }
  render() {
    var _a;
    const Tag = this.rows === 1 && !this.autoGrow ? "input" : "textarea";
    const ariaInvalid = this.invalid === true || this.invalid === false
      ? String(this.invalid)
      : undefined;
    const showStepper = this.type === "number" && !this.disabled;
    const showPasswordToggle = this.type === "password" && !this.disabled;
    const showClearButton = this.clearable &&
      !this.disabled &&
      Boolean(this.value) &&
      !showPasswordToggle &&
      !showStepper &&
      !this.showCharacterCounter;
    const type = this.type === "password" && this.showPassword ? "text" : this.type;
    const className = classnames("text-input", `text-input--type-${this.type}`, {
      "text-input--auto-grow": this.autoGrow,
      "text-input--clearable": this.clearable,
      "text-input--disabled": this.disabled,
      "text-input--disable-dynamic-width": this.disableDynamicWidth || Boolean(this.placeholder),
      "text-input--has-suffix": Boolean(this.suffixLabel),
      "text-input--inline": this.inline,
      "text-input--show-password": this.type === "password" && this.showPassword,
    });
    return (hAsync(Host, null, hAsync("div", { class: className }, this.prefixLabel && (hAsync("span", { class: "text-input__prefix" }, this.prefixLabel)), hAsync(Tag, { "aria-autocomplete": this.swirlAriaAutocomplete, "aria-controls": this.swirlAriaControls, "aria-describedby": this.swirlAriaDescribedby, "aria-disabled": this.disabled ? "true" : undefined, "aria-expanded": this.swirlAriaExpanded, "aria-invalid": ariaInvalid, autoComplete: this.autoComplete, autoFocus: this.autoFocus, class: "text-input__input", disabled: this.disabled, inputMode: this.mode, maxLength: this.maxLength, max: this.type === "number" ? this.max : undefined, min: this.type === "number" ? this.min : undefined, onBlur: this.onBlur, onFocus: this.onFocus, onInput: this.onInput, onKeyPress: this.onKeyPress, placeholder: !Boolean(this.suffixLabel) ? this.placeholder : undefined, ref: (el) => (this.inputEl = el), required: this.required, role: this.swirlRole, rows: this.rows > 1 ? this.rows : this.autoGrow ? 1 : undefined, spellcheck: this.spellCheck, step: this.type === "number" ? this.step : undefined, type: type, value: this.rows === 1 ? this.value : undefined }, this.rows > 1 && this.value), this.suffixLabel && (hAsync("span", { class: "text-input__suffix" }, this.suffixLabel)), showClearButton && (hAsync("button", { "aria-label": this.clearButtonLabel, class: "text-input__clear-button", onClick: this.clear, part: "text-input__clear-button", type: "button" }, hAsync("swirl-icon-cancel", { size: this.iconSize }))), showPasswordToggle && (hAsync("button", { "aria-label": this.passwordToggleLabel, class: "text-input__password-toggle", onClick: this.togglePassword, type: "button" }, this.showPassword ? (hAsync("swirl-icon-visibility-off", { size: this.iconSize })) : (hAsync("swirl-icon-visibility", { size: this.iconSize })))), showStepper && (hAsync("span", { class: "text-input__stepper" }, hAsync("button", { "aria-hidden": "true", class: "text-input__step-button", onClick: this.increaseValue, tabIndex: -1, type: "button" }, hAsync("swirl-icon-expand-less", { size: this.iconSize })), hAsync("button", { "aria-hidden": "true", class: "text-input__step-button", onClick: this.decreaseValue, tabIndex: -1, type: "button" }, hAsync("swirl-icon-expand-more", { size: this.iconSize })))), this.showCharacterCounter && (hAsync("span", { class: "text-input__character-counter" }, ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) || 0, " ", Boolean(this.maxLength) ? `/ ${this.maxLength}` : "")))));
  }
  static get style() { return swirlTextInputCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "swirl-text-input",
    "$members$": {
      "autoComplete": [1, "auto-complete"],
      "autoFocus": [4, "auto-focus"],
      "autoGrow": [4, "auto-grow"],
      "autoSelect": [4, "auto-select"],
      "clearable": [4],
      "clearButtonLabel": [1, "clear-button-label"],
      "disabled": [4],
      "disableDynamicWidth": [4, "disable-dynamic-width"],
      "swirlAriaAutocomplete": [1, "swirl-aria-autocomplete"],
      "swirlAriaControls": [1, "swirl-aria-controls"],
      "swirlAriaDescribedby": [1, "swirl-aria-describedby"],
      "swirlAriaExpanded": [1, "swirl-aria-expanded"],
      "swirlRole": [1, "swirl-role"],
      "inline": [4],
      "invalid": [4],
      "maxLength": [2, "max-length"],
      "max": [2],
      "min": [2],
      "mode": [1],
      "placeholder": [1],
      "prefixLabel": [1, "prefix-label"],
      "required": [4],
      "rows": [2],
      "showCharacterCounter": [4, "show-character-counter"],
      "spellCheck": [4, "spell-check"],
      "suffixLabel": [1, "suffix-label"],
      "step": [2],
      "passwordToggleLabel": [1, "password-toggle-label"],
      "type": [1],
      "value": [1537],
      "iconSize": [32],
      "showPassword": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": [["value", "value"]]
  }; }
}

/**
 * A simple guard function:
 *
 * ```js
 * Math.min(Math.max(low, value), high)
 * ```
 */
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}

class ColorError extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }

}

var ColorError$1 = ColorError;

/**
 * Parses a color into red, gree, blue, alpha parts
 *
 * @param color the input color. Can be a RGB, RBGA, HSL, HSLA, or named color
 */

function parseToRgba(color) {
  if (typeof color !== 'string') throw new ColorError$1(color);
  if (color.trim().toLowerCase() === 'transparent') return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);

  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || 'f', 2), 16) / 255];
  }

  const hexMatch = hexRegex.exec(normalizedColor);

  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(x, 16)), parseInt(arr[3] || 'ff', 16) / 255];
  }

  const rgbaMatch = rgbaRegex.exec(normalizedColor);

  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(x, 10)), parseFloat(arr[3] || '1')];
  }

  const hslaMatch = hslaRegex.exec(normalizedColor);

  if (hslaMatch) {
    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s) throw new ColorError$1(color);
    if (guard(0, 100, l) !== l) throw new ColorError$1(color);
    return [...hslToRgb(h, s, l), a || 1];
  }

  throw new ColorError$1(color);
}

function hash(str) {
  let hash = 5381;
  let i = str.length;

  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }
  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */


  return (hash >>> 0) % 2341;
}

const colorToInt = x => parseInt(x.replace(/_/g, ''), 36);

const compressedColorMap = '1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm'.split(' ').reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex = colorToInt(next.substring(3)).toString(16); // NOTE: padStart could be used here but it breaks Node 6 compat
  // https://github.com/ricokahler/color2k/issues/351

  let prefix = '';

  for (let i = 0; i < 6 - hex.length; i++) {
    prefix += '0';
  }

  acc[key] = `${prefix}${hex}`;
  return acc;
}, {});
/**
 * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
 */

function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result) throw new ColorError$1(color);
  return `#${result}`;
}

const r = (str, amount) => Array.from(Array(amount)).map(() => str).join('');

const reducedHexRegex = new RegExp(`^#${r('([a-f0-9])', 3)}([a-f0-9])?$`, 'i');
const hexRegex = new RegExp(`^#${r('([a-f0-9]{2})', 3)}([a-f0-9]{2})?$`, 'i');
const rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(',\\s*(\\d+)\\s*', 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, 'i');
const hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;

const roundColor = color => {
  return Math.round(color * 255);
};

const hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;

  if (saturation === 0) {
    // achromatic
    return [l, l, l].map(roundColor);
  } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV


  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;

  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }

  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};

// taken from:
/**
 * Parses a color in hue, saturation, lightness, and the alpha channel.
 *
 * Hue is a number between 0 and 360, saturation, lightness, and alpha are
 * decimal percentages between 0 and 1
 */

function parseToHsla(color) {
  const [red, green, blue, alpha] = parseToRgba(color).map((value, index) => // 3rd index is alpha channel which is already normalized
  index === 3 ? value : value / 255);
  const max = Math.max(red, green, blue);
  const min = Math.min(red, green, blue);
  const lightness = (max + min) / 2; // achromatic

  if (max === min) return [0, 0, lightness, alpha];
  const delta = max - min;
  const saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
  const hue = 60 * (red === max ? (green - blue) / delta + (green < blue ? 6 : 0) : green === max ? (blue - red) / delta + 2 : (red - green) / delta + 4);
  return [hue, saturation, lightness, alpha];
}

/**
 * Takes in hsla parts and constructs an hsla string
 *
 * @param hue The color circle (from 0 to 360) - 0 (or 360) is red, 120 is green, 240 is blue
 * @param saturation Percentage of saturation, given as a decimal between 0 and 1
 * @param lightness Percentage of lightness, given as a decimal between 0 and 1
 * @param alpha Percentage of opacity, given as a decimal between 0 and 1
 */

function hsla(hue, saturation, lightness, alpha) {
  return `hsla(${(hue % 360).toFixed()}, ${guard(0, 100, saturation * 100).toFixed()}%, ${guard(0, 100, lightness * 100).toFixed()}%, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
}

/**
 * Takes in rgba parts and returns an rgba string
 *
 * @param red The amount of red in the red channel, given in a number between 0 and 255 inclusive
 * @param green The amount of green in the red channel, given in a number between 0 and 255 inclusive
 * @param blue The amount of blue in the red channel, given in a number between 0 and 255 inclusive
 * @param alpha Percentage of opacity, given as a decimal between 0 and 1
 */

function rgba(red, green, blue, alpha) {
  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
}

/**
 * Takes in any color and returns it as an rgba string.
 */

function toRgba(color) {
  return rgba(...parseToRgba(color));
}

const swirlThemeProviderCss = ".sc-swirl-theme-provider-h{display:block}";

const preferredThemeStorageKey = "swirl-preferred-theme";
const tenantColorMapping = {
  "--s-action-primary-default": "primary",
  "--s-action-primary-hovered": "primaryHovered",
  "--s-action-primary-pressed": "primaryPressed",
  "--s-text-on-action-primary": "primaryContrast",
  "--s-icon-on-action-primary": "primaryContrast",
  "--s-surface-highlight-default": "secondary",
  "--s-surface-highlight-hovered": "secondaryHovered",
  "--s-surface-highlight-pressed": "secondaryPressed",
  "--s-on-surface-highlight-default": "secondaryHovered",
  "--s-text-on-surface-highlight": "secondaryContrast",
  "--s-icon-on-surface-highlight": "secondaryContrast",
  "--s-text-highlight": "text",
  "--s-interactive-primary-default": "text",
  "--s-interactive-primary-hovered": "textHovered",
  "--s-interactive-primary-pressed": "textPressed",
};
class SwirlThemeProvider {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.themeChange = createEvent(this, "themeChange", 7);
    this.config = undefined;
  }
  componentWillLoad() {
    this.resolveConfig();
    this.determineOSTheme();
    this.updateAppTheme();
  }
  watchConfig() {
    this.resolveConfig();
    this.determineOSTheme();
    this.updateAppTheme();
  }
  /**
   * Returns the active app theme.
   * @returns SwirlTheme
   */
  async getActiveTheme() {
    return this.appTheme;
  }
  /**
   * Returns the user's preferred theme stored in local storage.
   * @returns SwirlTheme
   */
  async getPreferredTheme() {
    if (!Boolean(this.resolvedConfig.storage)) {
      return;
    }
    return this.resolvedConfig.storage.getItem(preferredThemeStorageKey);
  }
  /**
   * Sets the user's preferred theme and stores it in local storage. Overrides
   * the OS theme.
   */
  async setPreferredTheme(theme) {
    if (!Boolean(this.resolvedConfig.storage)) {
      return;
    }
    this.resolvedConfig.storage.setItem(preferredThemeStorageKey, theme);
    this.updateAppTheme();
  }
  /**
   * Resets the user's preferred theme, using the OS theme instead.
   */
  async resetPreferredTheme() {
    if (!Boolean(this.resolvedConfig.storage)) {
      return;
    }
    this.resolvedConfig.storage.removeItem(preferredThemeStorageKey);
    this.updateAppTheme();
  }
  resolveConfig() {
    var _a, _b;
    this.resolvedConfig = Object.assign(Object.assign({}, (this.config || {})), { rootElement: ((_a = this.config) === null || _a === void 0 ? void 0 : _a.rootElement) || document.documentElement, storage: ((_b = this.config) === null || _b === void 0 ? void 0 : _b.storage) || (window === null || window === void 0 ? void 0 : window.localStorage) });
  }
  determineOSTheme() {
    if (!Boolean(window.matchMedia)) {
      this.osTheme = "light";
      return;
    }
    const darkThemeMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    this.osTheme = darkThemeMediaQuery.matches ? "dark" : "light";
    darkThemeMediaQuery.addEventListener("change", (e) => {
      this.osTheme = e.matches ? "dark" : "light";
      this.updateAppTheme();
    });
  }
  async updateAppTheme() {
    this.appTheme = (await this.getPreferredTheme()) || this.osTheme;
    if (this.appTheme === "dark") {
      document.documentElement.classList.remove("theme-light");
      document.documentElement.classList.add("theme-dark");
    }
    else {
      document.documentElement.classList.remove("theme-dark");
      document.documentElement.classList.add("theme-light");
    }
    this.updateTenantVariables();
    const themeChangeEventData = {
      activeTheme: await this.getActiveTheme(),
      preferredTheme: await this.getPreferredTheme(),
    };
    if (!Boolean(this.recentThemeChangeEventData) ||
      themeChangeEventData.activeTheme !==
        this.recentThemeChangeEventData.activeTheme ||
      themeChangeEventData.preferredTheme !==
        this.recentThemeChangeEventData.preferredTheme) {
      this.recentThemeChangeEventData = themeChangeEventData;
      this.themeChange.emit(this.recentThemeChangeEventData);
    }
  }
  updateTenantVariables() {
    var _a;
    const tenantTheme = (_a = this.resolvedConfig) === null || _a === void 0 ? void 0 : _a.tenantColors;
    if (!Boolean(tenantTheme)) {
      this.resetTenantVariables();
      return;
    }
    const rootElement = this.resolvedConfig.rootElement;
    // generate state colors (hovered, pressed) from base colors
    const primaryHsla = parseToHsla(tenantTheme.primary);
    const secondaryHsla = parseToHsla(tenantTheme.secondary);
    const textHsla = parseToHsla(tenantTheme.text);
    const primaryHovered = toRgba(hsla(primaryHsla[0], primaryHsla[1] - 0.21, primaryHsla[2] + 0.09, 1));
    const primaryPressed = toRgba(hsla(primaryHsla[0], primaryHsla[1] - 0.2, primaryHsla[2] + 0.17, 1));
    const secondaryHovered = toRgba(hsla(secondaryHsla[0], secondaryHsla[1], secondaryHsla[2] + 0.07, 1));
    const secondaryPressed = toRgba(hsla(secondaryHsla[0], secondaryHsla[1], secondaryHsla[2] + 0.15, 1));
    const textHovered = toRgba(hsla(textHsla[0], textHsla[1] - 0.34, textHsla[2] + 0.1, 1));
    const textPressed = toRgba(hsla(textHsla[0], textHsla[1] - 0.48, textHsla[2] + 0.2, 1));
    const tenantThemeWithGeneratedStateColors = Object.assign(Object.assign({}, tenantTheme), { primaryHovered: primaryHovered, primaryPressed: primaryPressed, secondaryHovered: secondaryHovered, secondaryPressed: secondaryPressed, textHovered: textHovered, textPressed: textPressed });
    // set custom properties for tenant theme colors
    Object.entries(tenantColorMapping).forEach(([key, value]) => rootElement.style.setProperty(key, tenantThemeWithGeneratedStateColors[value]));
  }
  resetTenantVariables() {
    const rootElement = this.resolvedConfig.rootElement;
    [
      ...Object.keys(tenantColorMapping),
      "primaryHovered",
      "primaryPressed",
      "secondaryHovered",
      "secondaryPressed",
      "textHovered",
      "textPressed",
    ].forEach((key) => rootElement.style.removeProperty(key));
  }
  render() {
    return (hAsync(Host, null, hAsync("slot", null)));
  }
  static get watchers() { return {
    "config": ["watchConfig"]
  }; }
  static get style() { return swirlThemeProviderCss; }
  static get cmpMeta() { return {
    "$flags$": 6,
    "$tagName$": "swirl-theme-provider",
    "$members$": {
      "config": [16],
      "getActiveTheme": [64],
      "getPreferredTheme": [64],
      "setPreferredTheme": [64],
      "resetPreferredTheme": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlThumbnailCss = "/*!@:host*/.sc-swirl-thumbnail-h{display:inline-flex}/*!@:host **/.sc-swirl-thumbnail-h *.sc-swirl-thumbnail{box-sizing:border-box}/*!@.thumbnail*/.thumbnail.sc-swirl-thumbnail{position:relative;display:inline-flex;overflow:hidden;border-radius:var(--s-border-radius-s);box-shadow:inset 0 0 0 0.03125rem rgba(0, 0, 0, 0.1)}/*!@.thumbnail--size-s*/.thumbnail--size-s.sc-swirl-thumbnail{--swirl-thumbnail-size:2.5rem}/*!@.thumbnail--size-m*/.thumbnail--size-m.sc-swirl-thumbnail{--swirl-thumbnail-size:3rem}/*!@.thumbnail--size-l*/.thumbnail--size-l.sc-swirl-thumbnail{--swirl-thumbnail-size:4rem}/*!@.thumbnail--format-landscape*/.thumbnail--format-landscape.sc-swirl-thumbnail{width:var(--swirl-thumbnail-size);aspect-ratio:4 / 3}/*!@.thumbnail--format-landscape .thumbnail__image*/.thumbnail--format-landscape.sc-swirl-thumbnail .thumbnail__image.sc-swirl-thumbnail{width:100%}/*!@.thumbnail--format-portrait*/.thumbnail--format-portrait.sc-swirl-thumbnail{height:var(--swirl-thumbnail-size);aspect-ratio:3 / 4}/*!@.thumbnail--format-portrait .thumbnail__image*/.thumbnail--format-portrait.sc-swirl-thumbnail .thumbnail__image.sc-swirl-thumbnail{height:100%}/*!@.thumbnail--format-square*/.thumbnail--format-square.sc-swirl-thumbnail{width:var(--swirl-thumbnail-size);height:var(--swirl-thumbnail-size)}/*!@.thumbnail--format-square .thumbnail__image*/.thumbnail--format-square.sc-swirl-thumbnail .thumbnail__image.sc-swirl-thumbnail{width:100%}/*!@.thumbnail__image*/.thumbnail__image.sc-swirl-thumbnail{position:absolute;top:50%;left:50%;transform:translate3d(-50%, -50%, 0)}";

class SwirlThumbnail {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.alt = undefined;
    this.format = "landscape";
    this.size = "m";
    this.src = undefined;
  }
  render() {
    const className = classnames("thumbnail", `thumbnail--format-${this.format}`, `thumbnail--size-${this.size}`);
    return (hAsync(Host, null, hAsync("span", { class: className }, hAsync("img", { alt: this.alt, class: "thumbnail__image", loading: "lazy", src: this.src }))));
  }
  static get style() { return swirlThumbnailCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-thumbnail",
    "$members$": {
      "alt": [1],
      "format": [1],
      "size": [1],
      "src": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlToastCss = "/*!@:host*/.sc-swirl-toast-h{display:flex}/*!@:host **/.sc-swirl-toast-h *.sc-swirl-toast{box-sizing:border-box}/*!@.toast*/.toast.sc-swirl-toast{display:flex;width:100%;max-width:28rem;padding:var(--s-space-16);border-radius:var(--s-border-radius-sm);color:var(--s-text-on-status);background-color:var(--s-surface-neutral-default);box-shadow:var(--s-shadow-level-2)}/*!@.toast--intent-critical*/.toast--intent-critical.sc-swirl-toast{background-color:var(--s-surface-critical-default)}/*!@.toast--intent-success*/.toast--intent-success.sc-swirl-toast{background-color:var(--s-surface-success-default)}/*!@.toast__icon*/.toast__icon.sc-swirl-toast{display:inline-flex;margin-top:calc(-1 * var(--s-space-2));margin-right:0.625rem;flex-shrink:0}/*!@.toast__icon ::part(icon)*/.toast__icon.sc-swirl-toast .sc-swirl-toast::part(icon){color:var(--s-icon-on-status)}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.toast__icon*/.toast__icon.sc-swirl-toast{margin-top:0}}/*!@.toast__content*/.toast__content.sc-swirl-toast{flex-grow:1;line-height:var(--s-line-height-base);text-align:left;align-self:flex-start}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.toast__content*/.toast__content.sc-swirl-toast{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.toast__content ::part(link)*/.toast__content.sc-swirl-toast .sc-swirl-toast::part(link){color:var(--text-default)}/*!@.toast__dismiss-button*/.toast__dismiss-button.sc-swirl-toast{display:inline-flex;min-width:1.5rem;height:1.5rem;margin-top:calc(-1 * var(--s-space-2));margin-left:var(--s-space-16);padding:0;flex-shrink:0;justify-content:center;align-items:center;border:none;color:var(--s-text-on-status);background-color:transparent;font:inherit;font-weight:var(--s-font-weight-semibold);cursor:pointer}/*!@.toast__dismiss-button ::part(icon)*/.toast__dismiss-button.sc-swirl-toast .sc-swirl-toast::part(icon){color:var(--s-icon-on-status)}";

class SwirlToast {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dismiss = createEvent(this, "dismiss", 7);
    this.desktopMediaQuery = getDesktopMediaQuery();
    this.desktopMediaQueryHandler = (event) => {
      this.forceIconProps(event.matches);
    };
    this.onDismiss = () => {
      this.dismiss.emit(this.toastId);
    };
    this.accessibleDismissLabel = "Dismiss";
    this.content = undefined;
    this.dismissLabel = undefined;
    this.duration = undefined;
    this.icon = undefined;
    this.intent = "default";
    this.toastId = undefined;
  }
  watchDuration() {
    this.startTimer();
  }
  componentDidLoad() {
    var _a, _b;
    this.startTimer();
    this.forceIconProps(this.desktopMediaQuery.matches);
    (_b = (_a = this.desktopMediaQuery).addEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.desktopMediaQuery).removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, "change", this.desktopMediaQueryHandler);
  }
  forceIconProps(smallIcon) {
    var _a;
    const icon = (_a = this.iconEl) === null || _a === void 0 ? void 0 : _a.children[0];
    const dismissIcon = this.dismissIconEl;
    icon === null || icon === void 0 ? void 0 : icon.setAttribute("size", smallIcon ? "20" : "24");
    dismissIcon === null || dismissIcon === void 0 ? void 0 : dismissIcon.setAttribute("size", smallIcon ? "20" : "24");
  }
  startTimer() {
    this.clearTimer();
    if (this.duration === undefined) {
      return;
    }
    this.timeout = setTimeout(() => {
      this.dismiss.emit(this.toastId);
    }, this.duration);
  }
  clearTimer() {
    if (!Boolean(this.timeout)) {
      return;
    }
    clearTimeout(this.timeout);
    this.timeout = undefined;
  }
  render() {
    const className = classnames("toast", `toast--intent-${this.intent}`);
    return (hAsync(Host, null, hAsync("div", { class: className }, this.icon && (hAsync("span", { class: "toast__icon", innerHTML: this.icon, part: "toast__icon", ref: (el) => (this.iconEl = el) })), hAsync("span", { class: "toast__content", innerHTML: this.content, part: "toast__content" }, hAsync("slot", null)), hAsync("button", { "aria-label": this.dismissLabel || this.accessibleDismissLabel, class: "toast__dismiss-button", onClick: this.onDismiss, type: "button" }, this.dismissLabel, !Boolean(this.dismissLabel) && (hAsync("swirl-icon-close", { ref: (el) => (this.dismissIconEl = el) }))))));
  }
  static get watchers() { return {
    "duration": ["watchDuration"]
  }; }
  static get style() { return swirlToastCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-toast",
    "$members$": {
      "accessibleDismissLabel": [1, "accessible-dismiss-label"],
      "content": [1],
      "dismissLabel": [1, "dismiss-label"],
      "duration": [2],
      "icon": [1],
      "intent": [1],
      "toastId": [1, "toast-id"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

class SwirlToastProvider {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onDismiss = (event) => {
      this.toasts = [...this.toasts].filter((toast) => toast.toastId !== event.detail);
    };
    this.globalDuration = undefined;
    this.toasts = [];
  }
  /**
   * Clear all toasts
   * @param newToast
   * @returns
   */
  async clearAll() {
    this.toasts = [];
  }
  /**
   * Dismiss a toast
   * @param toastId
   * @returns
   */
  async dismiss(toastId) {
    this.toasts = [...this.toasts].filter((toast) => toast.toastId !== toastId);
  }
  /**
   * Create a new toast
   * @param newToast
   * @returns
   */
  async toast(newToast) {
    if (this.toasts.some((toast) => toast.toastId === newToast.toastId)) {
      return;
    }
    let duration = this.globalDuration;
    if (this.globalDuration === undefined) {
      duration = newToast.duration;
    }
    else if (this.globalDuration === 0) {
      duration = undefined;
    }
    const newToastWithId = Object.assign(Object.assign({}, newToast), { createdAt: new Date(), duration, toastId: newToast.toastId || String(Math.round(Math.random() * 10000)) });
    this.toasts = [...this.toasts, newToastWithId];
    return newToastWithId;
  }
  render() {
    return (hAsync(Host, { role: "status" }, hAsync("swirl-stack", { spacing: "12" }, this.toasts.map((toast) => {
      const props = Object.assign(Object.assign({}, toast), { content: undefined });
      return (hAsync("swirl-toast", Object.assign({ key: toast.toastId, onDismiss: this.onDismiss }, props), toast.content));
    }))));
  }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-toast-provider",
    "$members$": {
      "globalDuration": [2, "global-duration"],
      "toasts": [32],
      "clearAll": [64],
      "dismiss": [64],
      "toast": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTooltipCss = "/*!@:host*/.sc-swirl-tooltip-h{display:inline-flex}/*!@:host **/.sc-swirl-tooltip-h *.sc-swirl-tooltip{box-sizing:border-box}/*!@.tooltip*/.tooltip.sc-swirl-tooltip{display:inline-flex}/*!@.tooltip .tooltip__reference*/.tooltip.sc-swirl-tooltip .tooltip__reference.sc-swirl-tooltip{display:inline-flex}/*!@.tooltip__popper*/.tooltip__popper.sc-swirl-tooltip{position:fixed;z-index:var(--s-z-40);max-width:17.5rem}/*!@.tooltip__bubble*/.tooltip__bubble.sc-swirl-tooltip{position:relative;display:block;padding-top:var(--s-space-8);padding-right:var(--s-space-12);padding-bottom:var(--s-space-8);padding-left:var(--s-space-12);border-radius:var(--s-border-radius-sm);color:var(--s-text-on-status);background-color:var(--s-surface-neutral-default);line-height:var(--s-line-height-base);animation:tooltip-fade-in 0.1s}@media (min-width: 992px) and (max-width: 1439px) and (hover: hover),(min-width: 1440px){/*!@.tooltip__bubble*/.tooltip__bubble.sc-swirl-tooltip{font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm)}}/*!@.tooltip__arrow*/.tooltip__arrow.sc-swirl-tooltip{position:absolute;width:0.5rem;height:0.5rem;background-color:var(--s-surface-neutral-default)}@keyframes tooltip-fade-in{from{opacity:0}to{opacity:1}}";

class SwirlTooltip {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onKeydown = (event) => {
      if (event.code === "Escape") {
        this.hide();
      }
    };
    this.reposition = async () => {
      if (!Boolean(this.referenceEl) || !Boolean(this.popperEl)) {
        return;
      }
      this.actualPosition = await computePosition(this.referenceEl, this.popperEl, this.options);
    };
    this.show = () => {
      this.visible = true;
      requestAnimationFrame(() => {
        this.reposition();
      });
    };
    this.showWithDelay = () => {
      if (Boolean(this.showTimeout)) {
        clearTimeout(this.showTimeout);
        this.showTimeout = undefined;
      }
      this.showTimeout = setTimeout(() => {
        this.show();
      }, this.delay);
    };
    this.hide = () => {
      if (Boolean(this.showTimeout)) {
        clearTimeout(this.showTimeout);
        this.showTimeout = undefined;
      }
      this.visible = false;
    };
    this.updateOptions = () => {
      const margin = +getComputedStyle(document.documentElement)
        .getPropertyValue("--s-space-12")
        .replace("rem", "") * 16;
      this.options = {
        middleware: [offset(margin), shift(), flip()],
        placement: this.position,
        strategy: "fixed",
      };
    };
    this.getArrowStyles = () => {
      var _a, _b, _c, _d;
      if (((_a = this.actualPosition) === null || _a === void 0 ? void 0 : _a.placement) === "top") {
        return {
          top: "100%",
          left: "50%",
          transform: "translate3d(-50%, -50%, 0) rotate(45deg)",
        };
      }
      if (((_b = this.actualPosition) === null || _b === void 0 ? void 0 : _b.placement) === "bottom") {
        return {
          bottom: "100%",
          left: "50%",
          transform: "translate3d(-50%, 50%, 0) rotate(45deg)",
        };
      }
      if (((_c = this.actualPosition) === null || _c === void 0 ? void 0 : _c.placement) === "right") {
        return {
          top: "50%",
          right: "100%",
          transform: "translate3d(50%, -50%, 0) rotate(45deg)",
        };
      }
      if (((_d = this.actualPosition) === null || _d === void 0 ? void 0 : _d.placement) === "left") {
        return {
          top: "50%",
          left: "100%",
          transform: "translate3d(-50%, -50%, 0) rotate(45deg)",
        };
      }
    };
    this.content = undefined;
    this.delay = 300;
    this.position = "top";
    this.actualPosition = undefined;
    this.visible = false;
  }
  watchPosition() {
    this.updateOptions();
  }
  onMouseEnter() {
    this.showWithDelay();
  }
  onMouseLeave() {
    this.hide();
  }
  onWindowResize() {
    this.reposition();
  }
  onWindowScroll() {
    this.reposition();
  }
  componentWillLoad() {
    this.reposition();
  }
  componentDidLoad() {
    this.updateOptions();
  }
  render() {
    var _a, _b;
    const arrowStyles = this.getArrowStyles();
    return (hAsync(Host, { onKeydown: this.onKeydown }, hAsync("span", { class: "tooltip" }, hAsync("span", { class: "tooltip__reference", "aria-describedby": "tooltip", onBlur: this.hide, onClick: this.hide, onFocus: this.show, ref: (el) => (this.referenceEl = el), tabIndex: 0 }, hAsync("slot", null)), hAsync("span", { class: "tooltip__popper", ref: (el) => (this.popperEl = el), style: {
        top: Boolean(this.actualPosition)
          ? `${(_a = this.actualPosition) === null || _a === void 0 ? void 0 : _a.y}px`
          : "",
        left: Boolean(this.actualPosition)
          ? `${(_b = this.actualPosition) === null || _b === void 0 ? void 0 : _b.x}px`
          : "",
      } }, this.visible && (hAsync("span", { class: "tooltip__bubble", id: "tooltip", part: "tooltip__bubble", role: "tooltip" }, hAsync("span", { class: "tooltip__content", innerHTML: this.content }), hAsync("span", { class: "tooltip__arrow", style: arrowStyles })))))));
  }
  static get watchers() { return {
    "position": ["watchPosition"]
  }; }
  static get style() { return swirlTooltipCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-tooltip",
    "$members$": {
      "content": [1],
      "delay": [2],
      "position": [1],
      "actualPosition": [32],
      "visible": [32]
    },
    "$listeners$": [[1, "mouseenter", "onMouseEnter"], [1, "mouseleave", "onMouseLeave"], [9, "resize", "onWindowResize"], [9, "scroll", "onWindowScroll"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlTreeNavigationItemCss = "/*!@:host*/.sc-swirl-tree-navigation-item-h{display:inline-flex;width:100%;height:2.5rem;padding-right:var(--s-space-16);padding-left:calc(var(--s-space-16) + 1.5rem + var(--s-space-8));flex-shrink:0;justify-content:flex-start;align-items:center;color:var(--s-text-default);background-color:transparent;font-size:var(--s-font-size-sm);line-height:var(--s-line-height-sm);cursor:pointer;gap:calc(var(--s-space-8) - var(--s-space-2))}/*!@:host(:hover)*/.sc-swirl-tree-navigation-item-h:hover{background-color:var(--s-surface-hovered)}/*!@:host(:active)*/.sc-swirl-tree-navigation-item-h:active{background-color:var(--s-surface-pressed)}/*!@:host(:focus)*/.sc-swirl-tree-navigation-item-h:focus{outline:none}/*!@:host(:focus-visible) .tree-navigation-item__label*/.sc-swirl-tree-navigation-item-h:focus-visible .tree-navigation-item__label.sc-swirl-tree-navigation-item{border-radius:var(--s-border-radius-xs);box-shadow:0 0 0 0.125rem var(--s-focus-default)}/*!@:host(.tree-navigation-item--active)*/.tree-navigation-item--active.sc-swirl-tree-navigation-item-h{background-color:var(--s-surface-raised-default);box-shadow:inset 0.25rem 0 0 0 var(--s-surface-highlight-default)}/*!@:host(.tree-navigation-item--active:hover)*/.tree-navigation-item--active.sc-swirl-tree-navigation-item-h:hover{background-color:var(--s-surface-raised-hovered)}/*!@:host(.tree-navigation-item--active:active)*/.tree-navigation-item--active.sc-swirl-tree-navigation-item-h:active{background-color:var(--s-surface-raised-pressed)}/*!@:host(.tree-navigation-item--has-icon)*/.tree-navigation-item--has-icon.sc-swirl-tree-navigation-item-h{padding-left:var(--s-space-16)}/*!@:host **/.sc-swirl-tree-navigation-item-h *.sc-swirl-tree-navigation-item{box-sizing:border-box}/*!@.tree-navigation-item__icon*/.tree-navigation-item__icon.sc-swirl-tree-navigation-item{display:inline-flex}/*!@.tree-navigation-item__label*/.tree-navigation-item__label.sc-swirl-tree-navigation-item{overflow:hidden;min-width:0;white-space:nowrap;text-overflow:ellipsis;padding-right:var(--s-space-2);padding-left:var(--s-space-2)}";

class SwirlTreeNavigationItem {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onKeyDown = (event) => {
      if (event.code === "Enter") {
        event.preventDefault();
        this.el.click();
      }
    };
    this.active = undefined;
    this.icon = undefined;
    this.label = undefined;
  }
  render() {
    const className = classnames("tree-navigation-item", {
      "tree-navigation-item--active": this.active,
      "tree-navigation-item--has-icon": Boolean(this.icon),
    });
    return (hAsync(Host, { class: className, onKeyDown: this.onKeyDown, role: "link", tabIndex: 0 }, this.icon && (hAsync("span", { class: "tree-navigation-item__icon", innerHTML: this.icon })), hAsync("span", { class: "tree-navigation-item__label" }, this.label)));
  }
  get el() { return getElement(this); }
  static get style() { return swirlTreeNavigationItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-tree-navigation-item",
    "$members$": {
      "active": [4],
      "icon": [1],
      "label": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlVideoThumbnailCss = "/*!@:host*/.sc-swirl-video-thumbnail-h {\n  display: flex;\n  width: 100%;\n}\n\n  /*!@:host **/.sc-swirl-video-thumbnail-h *.sc-swirl-video-thumbnail {\n    box-sizing: border-box;\n  }\n\n/*!@.video-thumbnail*/.video-thumbnail.sc-swirl-video-thumbnail {\n  position: relative;\n  display: inline-flex;\n  width: 100%;\n  margin: 0;\n  padding: 0;\n  border: none;\n  background-color: transparent;\n  cursor: pointer;\n  container-type: inline-size;\n  container-name: video-thumbnail;\n}\n\n/*!@.video-thumbnail:after*/.video-thumbnail.sc-swirl-video-thumbnail:after {\n    position: absolute;\n    background-color: rgba(0, 0, 0, 0.05);\n    content: \"\";\n    inset: 0;\n  }\n\n/*!@.video-thumbnail:focus:not(:focus-visible)*/.video-thumbnail.sc-swirl-video-thumbnail:focus:not(:focus-visible) {\n    outline: none;\n  }\n\n/*!@.video-thumbnail:focus-visible*/.video-thumbnail.sc-swirl-video-thumbnail:focus-visible {\n    outline-color: var(--s-focus-default);\n    outline-offset: var(--s-space-4);\n  }\n\n/*!@.video-thumbnail__image*/.video-thumbnail__image.sc-swirl-video-thumbnail {\n  width: 100%;\n}\n\n/*!@.video-thumbnail__duration*/.video-thumbnail__duration.sc-swirl-video-thumbnail {\n  position: absolute;\n  bottom: var(--s-space-8);\n  left: var(--s-space-8);\n  padding: var(--s-space-2) var(--s-space-8);\n  border-radius: var(--s-border-radius-sm);\n  color: var(--s-text-on-image);\n  background: linear-gradient(0deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)),\n    rgba(255, 255, 255, 0.1);\n  font-size: var(--s-font-size-sm);\n  font-weight: var(--s-font-weight-medium);\n  line-height: var(--s-line-height-sm);\n  letter-spacing: var(--s-letter-spacing-tighter);\n}\n\n/*!@.video-thumbnail__play-icon*/.video-thumbnail__play-icon.sc-swirl-video-thumbnail {\n  position: absolute;\n  z-index: 1;\n  top: 50%;\n  left: 50%;\n  width: 2.5rem;\n  height: 2.5rem;\n  transform: translate3d(-50%, -50%, 0);\n}\n\n@container video-thumbnail (min-width: 448px) {\n  .video-thumbnail__play-icon {\n    width: 3.5rem;\n    height: 4.5rem;\n  }\n}";

class SwirlVideoThumbnail {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.durationLabel = "Duration";
    this.duration = undefined;
    this.label = undefined;
    this.src = undefined;
  }
  render() {
    return (hAsync(Host, null, hAsync("button", { "aria-describedby": this.duration !== undefined ? "duration" : undefined, "aria-label": this.label, class: "video-thumbnail", type: "button" }, hAsync("img", { alt: "", class: "video-thumbnail__image", loading: "lazy", src: this.src }), this.duration && (hAsync("span", { class: "video-thumbnail__duration", id: "duration" }, hAsync("swirl-visually-hidden", null, this.durationLabel), this.duration)), hAsync("svg", { class: "video-thumbnail__play-icon", fill: "none", viewBox: "0 0 40 40", xmlns: "http://www.w3.org/2000/svg" }, hAsync("path", { d: "M15 14.65V25.35C15 26.1167 15.35 26.7 16.05 27.1C16.75 27.5 17.4333 27.4667 18.1 27L26.4 21.7C27.0333 21.3 27.35 20.7333 27.35 20C27.35 19.2667 27.0333 18.7 26.4 18.3L18.1 13C17.4333 12.5333 16.75 12.5 16.05 12.9C15.35 13.3 15 13.8833 15 14.65ZM20 40C17.2333 40 14.6333 39.4747 12.2 38.424C9.76667 37.3747 7.65 35.95 5.85 34.15C4.05 32.35 2.62533 30.2333 1.576 27.8C0.525334 25.3667 0 22.7667 0 20C0 17.2333 0.525334 14.6333 1.576 12.2C2.62533 9.76667 4.05 7.65 5.85 5.85C7.65 4.05 9.76667 2.62467 12.2 1.574C14.6333 0.524667 17.2333 0 20 0C22.7667 0 25.3667 0.524667 27.8 1.574C30.2333 2.62467 32.35 4.05 34.15 5.85C35.95 7.65 37.3747 9.76667 38.424 12.2C39.4747 14.6333 40 17.2333 40 20C40 22.7667 39.4747 25.3667 38.424 27.8C37.3747 30.2333 35.95 32.35 34.15 34.15C32.35 35.95 30.2333 37.3747 27.8 38.424C25.3667 39.4747 22.7667 40 20 40Z", fill: "white", "fill-opacity": "0.95" })))));
  }
  static get style() { return swirlVideoThumbnailCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-video-thumbnail",
    "$members$": {
      "durationLabel": [1, "duration-label"],
      "duration": [1],
      "label": [1],
      "src": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const swirlVisuallyHiddenCss = "/*!@:host*/.sc-swirl-visually-hidden-h{position:absolute;display:inline;overflow:hidden;width:1px;height:1px;margin:-1px;padding:0;border:0;white-space:nowrap;word-wrap:normal;clip:rect(0, 0, 0, 0)}";

class SwirlVisuallyHidden {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  render() {
    return (hAsync(Host, null, hAsync("slot", null)));
  }
  static get style() { return swirlVisuallyHiddenCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "swirl-visually-hidden",
    "$members$": undefined,
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

function addDays(date, days) {
  const newDate = new Date(date);
  newDate.setDate(newDate.getDate() + days);
  return newDate;
}
function getDaysOfMonth(date, padded, firstDayOfWeek) {
  const days = [];
  const firstOfMonth = getFirstOfMonth(date);
  const firstDayMonth = firstOfMonth.getDay() === 0 ? 7 : firstOfMonth.getDay();
  const lastOfMonth = getLastOfMonth(date);
  const lastDayOfMonth = lastOfMonth.getDay() === 0 ? 7 : lastOfMonth.getDay();
  const lastDayOfWeek = firstDayOfWeek === 1 ? 7 : firstDayOfWeek - 1;
  const leftPaddingDays = [];
  const rightPaddingDays = [];
  if (padded) {
    const leftPadding = (7 - firstDayOfWeek + firstDayMonth) % 7;
    let leftPaddingAmount = leftPadding;
    let leftPaddingDay = getPreviousDay(firstOfMonth);
    while (leftPaddingAmount > 0) {
      leftPaddingDays.push(leftPaddingDay);
      leftPaddingDay = getPreviousDay(leftPaddingDay);
      leftPaddingAmount -= 1;
    }
    leftPaddingDays.reverse();
    const rightPadding = (7 - lastDayOfMonth + lastDayOfWeek) % 7;
    let rightPaddingAmount = rightPadding;
    let rightPaddingDay = getNextDay(lastOfMonth);
    while (rightPaddingAmount > 0) {
      rightPaddingDays.push(rightPaddingDay);
      rightPaddingDay = getNextDay(rightPaddingDay);
      rightPaddingAmount -= 1;
    }
  }
  let currentDay = firstOfMonth;
  while (currentDay.getMonth() === date.getMonth()) {
    days.push(currentDay);
    currentDay = getNextDay(currentDay);
  }
  return [...leftPaddingDays, ...days, ...rightPaddingDays];
}
function getFirstOfMonth(date) {
  const firstOfMonth = removeTimezoneOffset(new Date(`${getYear(date)}-${String(getMonth(date)).padStart(2, '0')}-01`));
  return firstOfMonth;
}
function getISODateString(date) {
  if (!(date instanceof Date)) {
    return;
  }
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
}
function getLastOfMonth(date) {
  const newDate = getFirstOfMonth(date);
  newDate.setMonth(newDate.getMonth() + 1);
  newDate.setDate(newDate.getDate() - 1);
  return newDate;
}
function getMonth(date) {
  return date.getMonth() + 1;
}
function getMonths(locale) {
  return new Array(12).fill(undefined).map((_, month) => {
    const date = removeTimezoneOffset(new Date(`2006-${String(month + 1).padStart(2, '0')}-01`));
    return Intl.DateTimeFormat(locale, {
      month: 'long'
    }).format(date);
  });
}
function getNextDay(date) {
  return addDays(date, 1);
}
function getNextMonth(date) {
  const newDate = new Date(date);
  newDate.setMonth(newDate.getMonth() + 1);
  return newDate;
}
function getNextYear(date) {
  const newDate = new Date(date);
  newDate.setFullYear(newDate.getFullYear() + 1);
  return newDate;
}
function getPreviousDay(date) {
  return subDays(date, 1);
}
function getPreviousMonth(date) {
  const newDate = new Date(date);
  newDate.setMonth(newDate.getMonth() - 1);
  return newDate;
}
function getPreviousYear(date) {
  const newDate = new Date(date);
  newDate.setFullYear(newDate.getFullYear() - 1);
  return newDate;
}
function getWeekDays(firstDayOfWeek, locale) {
  return new Array(7)
    .fill(undefined)
    .map((_, index) => ((firstDayOfWeek + index) % 7) + 1)
    .map((day) => {
    const date = removeTimezoneOffset(new Date(`2006-01-0${day}`));
    return [
      Intl.DateTimeFormat(locale, {
        weekday: 'short'
      }).format(date),
      Intl.DateTimeFormat(locale, {
        weekday: 'long'
      }).format(date)
    ];
  });
}
function getYear(date) {
  return date.getFullYear();
}
function isDateInRange(date, range) {
  if (!date || !range || !range.from || !range.to) {
    return false;
  }
  const earlyDate = range.from < range.to ? range.from : range.to;
  const laterDate = range.from < range.to ? range.to : range.from;
  return date >= earlyDate && date <= laterDate;
}
function isSameDay(date1, date2) {
  if (!date1 || !date2) {
    return false;
  }
  return (date1.getFullYear() === date2.getFullYear() &&
    date1.getMonth() === date2.getMonth() &&
    date1.getDate() === date2.getDate());
}
function removeTimezoneOffset(date) {
  const newDate = new Date(date);
  newDate.setMinutes(newDate.getMinutes() + newDate.getTimezoneOffset());
  return newDate;
}
function subDays(date, days) {
  const newDate = new Date(date);
  newDate.setDate(newDate.getDate() - days);
  return newDate;
}

const wcDatepickerCss = ".visually-hidden.sc-wc-datepicker{position:absolute;overflow:hidden;width:1px;height:1px;white-space:nowrap;clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%)}";

const defaultLabels = {
  clearButton: 'Clear value',
  monthSelect: 'Select month',
  nextMonthButton: 'Next month',
  nextYearButton: 'Next year',
  picker: 'Choose date',
  previousMonthButton: 'Previous month',
  previousYearButton: 'Previous year',
  todayButton: 'Show today',
  yearSelect: 'Select year'
};
class WCDatepicker {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.selectDate = createEvent(this, "selectDate", 7);
    this.changeMonth = createEvent(this, "changeMonth", 7);
    this.disabled = false;
    this.disableDate = () => false;
    this.elementClassName = 'wc-datepicker';
    this.firstDayOfWeek = 0;
    this.labels = defaultLabels;
    this.locale = (navigator === null || navigator === void 0 ? void 0 : navigator.language) || 'en-US';
    this.showClearButton = false;
    this.showMonthStepper = true;
    this.showTodayButton = false;
    this.showYearStepper = false;
    this.startDate = getISODateString(new Date());
    this.init = () => {
      this.currentDate = this.startDate
        ? removeTimezoneOffset(new Date(this.startDate))
        : new Date();
      this.updateWeekdays();
    };
    this.nextMonth = () => {
      this.updateCurrentDate(getNextMonth(this.currentDate));
    };
    this.nextYear = () => {
      this.updateCurrentDate(getNextYear(this.currentDate));
    };
    this.previousMonth = () => {
      this.updateCurrentDate(getPreviousMonth(this.currentDate));
    };
    this.previousYear = () => {
      this.updateCurrentDate(getPreviousYear(this.currentDate));
    };
    this.showToday = () => {
      this.updateCurrentDate(new Date());
    };
    this.clear = () => {
      this.value = undefined;
      this.selectDate.emit(undefined);
    };
    this.onClick = (event) => {
      if (this.disabled) {
        return;
      }
      const target = event.target.closest('[data-date]');
      if (!Boolean(target)) {
        return;
      }
      const date = removeTimezoneOffset(new Date(target.dataset.date));
      this.updateCurrentDate(date);
      this.onSelectDate(date);
    };
    this.onMonthSelect = (event) => {
      const month = +event.target.value - 1;
      const date = new Date(this.currentDate);
      date.setMonth(month);
      this.updateCurrentDate(date);
    };
    this.onYearSelect = (event) => {
      const year = +event.target.value;
      const date = new Date(this.currentDate);
      date.setFullYear(year);
      this.updateCurrentDate(date);
    };
    this.onKeyDown = (event) => {
      if (this.disabled) {
        return;
      }
      if (event.code === 'ArrowLeft') {
        event.preventDefault();
        this.updateCurrentDate(getPreviousDay(this.currentDate), true);
      }
      else if (event.code === 'ArrowRight') {
        event.preventDefault();
        this.updateCurrentDate(getNextDay(this.currentDate), true);
      }
      else if (event.code === 'ArrowUp') {
        event.preventDefault();
        this.updateCurrentDate(subDays(this.currentDate, 7), true);
      }
      else if (event.code === 'ArrowDown') {
        event.preventDefault();
        this.updateCurrentDate(addDays(this.currentDate, 7), true);
      }
      else if (event.code === 'PageUp') {
        event.preventDefault();
        if (event.shiftKey) {
          this.updateCurrentDate(getPreviousYear(this.currentDate), true);
        }
        else {
          this.updateCurrentDate(getPreviousMonth(this.currentDate), true);
        }
      }
      else if (event.code === 'PageDown') {
        event.preventDefault();
        if (event.shiftKey) {
          this.updateCurrentDate(getNextYear(this.currentDate), true);
        }
        else {
          this.updateCurrentDate(getNextMonth(this.currentDate), true);
        }
      }
      else if (event.code === 'Home') {
        event.preventDefault();
        this.updateCurrentDate(getFirstOfMonth(this.currentDate), true);
      }
      else if (event.code === 'End') {
        event.preventDefault();
        this.updateCurrentDate(getLastOfMonth(this.currentDate), true);
      }
      else if (event.code === 'Space' || event.code === 'Enter') {
        event.preventDefault();
        this.onSelectDate(this.currentDate);
      }
    };
    this.onMouseEnter = (event) => {
      if (this.disabled) {
        return;
      }
      const date = removeTimezoneOffset(new Date(event.target.closest('td').dataset.date));
      this.hoveredDate = date;
    };
    this.onMouseLeave = () => {
      this.hoveredDate = undefined;
    };
  }
  componentWillLoad() {
    this.init();
  }
  watchFirstDayOfWeek() {
    this.updateWeekdays();
  }
  watchLocale() {
    if (!Boolean(this.locale)) {
      this.locale = (navigator === null || navigator === void 0 ? void 0 : navigator.language) || 'en-US';
    }
    this.updateWeekdays();
  }
  watchRange() {
    this.value = undefined;
    this.selectDate.emit(undefined);
  }
  watchStartDate() {
    this.currentDate = this.startDate
      ? removeTimezoneOffset(new Date(this.startDate))
      : new Date();
  }
  watchValue() {
    if (Boolean(this.value)) {
      if (Array.isArray(this.value) && this.value.length >= 1) {
        this.currentDate = this.value[0];
      }
      else if (this.value instanceof Date) {
        this.currentDate = this.value;
      }
    }
  }
  componentDidRender() {
    if (this.moveFocusAfterMonthChanged) {
      this.focusDate(this.currentDate);
      this.moveFocusAfterMonthChanged = false;
    }
  }
  updateWeekdays() {
    this.weekdays = getWeekDays(this.firstDayOfWeek === 0 ? 7 : this.firstDayOfWeek, this.locale);
  }
  getClassName(element) {
    return Boolean(element)
      ? `${this.elementClassName}__${element}`
      : this.elementClassName;
  }
  getCalendarRows() {
    const daysOfMonth = getDaysOfMonth(this.currentDate, true, this.firstDayOfWeek === 0 ? 7 : this.firstDayOfWeek);
    const calendarRows = [];
    for (let i = 0; i < daysOfMonth.length; i += 7) {
      const row = daysOfMonth.slice(i, i + 7);
      calendarRows.push(row);
    }
    return calendarRows;
  }
  getTitle() {
    if (!Boolean(this.currentDate)) {
      return;
    }
    return Intl.DateTimeFormat(this.locale, {
      day: 'numeric',
      month: 'long',
      year: 'numeric'
    }).format(this.currentDate);
  }
  focusDate(date) {
    var _a;
    (_a = this.el
      .querySelector(`[data-date="${getISODateString(date)}"]`)) === null || _a === void 0 ? void 0 : _a.focus();
  }
  updateCurrentDate(date, moveFocus) {
    const month = date.getMonth();
    const year = date.getFullYear();
    const monthChanged = month !== this.currentDate.getMonth() ||
      year !== this.currentDate.getFullYear();
    if (monthChanged) {
      this.changeMonth.emit({ month: getMonth(date), year: getYear(date) });
      if (moveFocus) {
        this.moveFocusAfterMonthChanged = true;
      }
    }
    this.currentDate = date;
    if (moveFocus) {
      this.focusDate(this.currentDate);
    }
  }
  onSelectDate(date) {
    var _a, _b;
    if (this.disableDate(date)) {
      return;
    }
    if (this.isRangeValue(this.value)) {
      const newValue = ((_a = this.value) === null || _a === void 0 ? void 0 : _a[0]) === undefined || this.value.length === 2
        ? [date]
        : [this.value[0], date];
      if (newValue.length === 2 && newValue[0] > newValue[1]) {
        newValue.reverse();
      }
      const isoValue = newValue[1] === undefined
        ? [getISODateString(newValue[0])]
        : [getISODateString(newValue[0]), getISODateString(newValue[1])];
      this.value = newValue;
      this.selectDate.emit(isoValue);
    }
    else {
      if (((_b = this.value) === null || _b === void 0 ? void 0 : _b.getTime()) === date.getTime()) {
        return;
      }
      this.value = date;
      this.selectDate.emit(getISODateString(date));
    }
  }
  // @ts-ignore
  isRangeValue(value) {
    return this.range;
  }
  render() {
    const showFooter = this.showTodayButton || this.showClearButton;
    return (hAsync(Host, null, hAsync("div", { "aria-disabled": String(this.disabled), "aria-label": this.labels.picker, class: {
        [this.getClassName()]: true,
        [`${this.getClassName()}--disabled`]: this.disabled
      }, role: "group" }, hAsync("div", { class: this.getClassName('header') }, hAsync("span", { "aria-atomic": "true", "aria-live": "polite", class: "visually-hidden" }, this.getTitle()), this.showYearStepper && (hAsync("button", { "aria-label": this.labels.previousYearButton, class: this.getClassName('previous-year-button'), disabled: this.disabled, innerHTML: this.previousYearButtonContent || undefined, onClick: this.previousYear, type: "button" }, hAsync("svg", { fill: "none", height: "24", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", stroke: "currentColor", viewBox: "0 0 24 24", width: "24" }, hAsync("polyline", { points: "11 17 6 12 11 7" }), hAsync("polyline", { points: "18 17 13 12 18 7" })))), this.showMonthStepper && (hAsync("button", { "aria-label": this.labels.previousMonthButton, class: this.getClassName('previous-month-button'), disabled: this.disabled, innerHTML: this.previousMonthButtonContent || undefined, onClick: this.previousMonth, type: "button" }, hAsync("svg", { fill: "none", height: "24", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", stroke: "currentColor", viewBox: "0 0 24 24", width: "24" }, hAsync("polyline", { points: "15 18 9 12 15 6" })))), hAsync("span", { class: this.getClassName('current-month') }, hAsync("select", { "aria-label": this.labels.monthSelect, class: this.getClassName('month-select'), disabled: this.disabled, name: "month", onChange: this.onMonthSelect }, getMonths(this.locale).map((month, index) => (hAsync("option", { key: month, selected: this.currentDate.getMonth() === index, value: index + 1 }, month)))), hAsync("input", { "aria-label": this.labels.yearSelect, class: this.getClassName('year-select'), disabled: this.disabled, max: 9999, min: 1, name: "year", onChange: this.onYearSelect, type: "number", value: this.currentDate.getFullYear() })), this.showMonthStepper && (hAsync("button", { "aria-label": this.labels.nextMonthButton, class: this.getClassName('next-month-button'), disabled: this.disabled, innerHTML: this.nextMonthButtonContent || undefined, onClick: this.nextMonth, type: "button" }, hAsync("svg", { fill: "none", height: "24", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", stroke: "currentColor", viewBox: "0 0 24 24", width: "24" }, hAsync("polyline", { points: "9 18 15 12 9 6" })))), this.showYearStepper && (hAsync("button", { "aria-label": this.labels.nextYearButton, class: this.getClassName('next-year-button'), disabled: this.disabled, innerHTML: this.nextYearButtonContent || undefined, onClick: this.nextYear, type: "button" }, hAsync("svg", { fill: "none", height: "24", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", stroke: "currentColor", viewBox: "0 0 24 24", width: "24" }, hAsync("polyline", { points: "13 17 18 12 13 7" }), hAsync("polyline", { points: "6 17 11 12 6 7" }))))), hAsync("div", { class: this.getClassName('body') }, hAsync("table", { class: this.getClassName('calendar'), onKeyDown: this.onKeyDown, role: "grid" }, hAsync("thead", { class: this.getClassName('calendar-header') }, hAsync("tr", { class: this.getClassName('weekday-row') }, this.weekdays.map((weekday) => (hAsync("th", { abbr: weekday[1], class: this.getClassName('weekday'), key: weekday[0], scope: "col" }, hAsync("span", null, weekday[0])))))), hAsync("tbody", null, this.getCalendarRows().map((calendarRow) => {
      const rowKey = `row-${calendarRow[0].getMonth()}-${calendarRow[0].getDate()}`;
      return (hAsync("tr", { class: this.getClassName('calendar-row'), key: rowKey }, calendarRow.map((day) => {
        var _a, _b, _c, _d, _e;
        const isCurrent = isSameDay(day, this.currentDate);
        const isOverflowing = day.getMonth() !== this.currentDate.getMonth();
        const isSelected = Array.isArray(this.value)
          ? isSameDay(day, this.value[0]) ||
            isSameDay(day, this.value[1])
          : isSameDay(day, this.value);
        const isInRange = !this.isRangeValue
          ? false
          : isDateInRange(day, {
            from: (_a = this.value) === null || _a === void 0 ? void 0 : _a[0],
            to: ((_b = this.value) === null || _b === void 0 ? void 0 : _b[1]) ||
              this.hoveredDate ||
              this.currentDate
          });
        const orderedValues = Boolean((_c = this.value) === null || _c === void 0 ? void 0 : _c[0])
          ? [
            (_d = this.value) === null || _d === void 0 ? void 0 : _d[0],
            ((_e = this.value) === null || _e === void 0 ? void 0 : _e[1]) || this.hoveredDate
          ].sort((a, b) => a - b)
          : [];
        const isStart = this.range && isSameDay(orderedValues[0], day);
        const isEnd = this.range && isSameDay(orderedValues[1], day);
        const isToday = isSameDay(day, new Date());
        const isDisabled = this.disableDate(day);
        const cellKey = `cell-${day.getMonth()}-${day.getDate()}`;
        const className = {
          [this.getClassName('date')]: true,
          [this.getClassName('date--current')]: isCurrent,
          [this.getClassName('date--disabled')]: isDisabled,
          [this.getClassName('date--overflowing')]: isOverflowing,
          [this.getClassName('date--today')]: isToday,
          [this.getClassName('date--selected')]: isSelected,
          [this.getClassName('date--in-range')]: isInRange,
          [this.getClassName('date--start')]: isStart,
          [this.getClassName('date--end')]: isEnd
        };
        const Tag = isSelected
          ? 'strong'
          : isToday
            ? 'em'
            : 'span';
        return (hAsync("td", { "aria-disabled": String(isDisabled), "aria-selected": isSelected ? 'true' : undefined, class: className, "data-date": getISODateString(day), key: cellKey, onClick: this.onClick, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave, role: "gridcell", tabIndex: isSameDay(day, this.currentDate) && !this.disabled
            ? 0
            : -1 }, hAsync(Tag, { "aria-hidden": "true" }, day.getDate()), hAsync("span", { class: "visually-hidden" }, Intl.DateTimeFormat(this.locale, {
          day: 'numeric',
          month: 'long'
        }).format(day))));
      })));
    })))), showFooter && (hAsync("div", { class: this.getClassName('footer') }, this.showTodayButton && (hAsync("button", { class: this.getClassName('today-button'), disabled: this.disabled, innerHTML: this.todayButtonContent || undefined, onClick: this.showToday, type: "button" }, this.labels.todayButton)), this.showClearButton && (hAsync("button", { class: this.getClassName('clear-button'), disabled: this.disabled, innerHTML: this.clearButtonContent || undefined, onClick: this.clear, type: "button" }, this.labels.clearButton)))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "firstDayOfWeek": ["watchFirstDayOfWeek"],
    "locale": ["watchLocale"],
    "range": ["watchRange"],
    "startDate": ["watchStartDate"],
    "value": ["watchValue"]
  }; }
  static get style() { return wcDatepickerCss; }
  static get cmpMeta() { return {
    "$flags$": 2,
    "$tagName$": "wc-datepicker",
    "$members$": {
      "clearButtonContent": [1, "clear-button-content"],
      "disabled": [4],
      "disableDate": [16],
      "elementClassName": [1, "element-class-name"],
      "firstDayOfWeek": [2, "first-day-of-week"],
      "range": [4],
      "labels": [16],
      "locale": [1],
      "nextMonthButtonContent": [1, "next-month-button-content"],
      "nextYearButtonContent": [1, "next-year-button-content"],
      "previousMonthButtonContent": [1, "previous-month-button-content"],
      "previousYearButtonContent": [1, "previous-year-button-content"],
      "showClearButton": [4, "show-clear-button"],
      "showMonthStepper": [4, "show-month-stepper"],
      "showTodayButton": [4, "show-today-button"],
      "showYearStepper": [4, "show-year-stepper"],
      "startDate": [1, "start-date"],
      "todayButtonContent": [1, "today-button-content"],
      "value": [1040],
      "currentDate": [32],
      "hoveredDate": [32],
      "weekdays": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

registerComponents([
  FileManager,
  SwirlActionList,
  SwirlActionListItem,
  SwirlActionListSection,
  SwirlAppBar,
  SwirlAppIcon,
  SwirlAppLayout,
  SwirlAutocomplete,
  SwirlAvatar,
  SwirlAvatarGroup,
  SwirlBadge,
  SwirlBanner,
  SwirlBox,
  SwirlButton,
  SwirlButtonGroup,
  SwirlCard,
  SwirlCarousel,
  SwirlCarouselSlide,
  SwirlCheckbox,
  SwirlChip,
  SwirlColumns,
  SwirlConsoleLayout,
  SwirlDateInput,
  SwirlDatePicker,
  SwirlDescriptionList,
  SwirlDescriptionListItem,
  SwirlDialog,
  SwirlEmptyState,
  SwirlFileUploader,
  SwirlFileViewer,
  SwirlFileViewerAudio,
  SwirlFileViewerCsv,
  SwirlFileViewerImage,
  SwirlFileViewerPdf,
  SwirlFileViewerText,
  SwirlFileViewerVideo,
  SwirlFormControl,
  SwirlFormGroup,
  SwirlHeading$1,
  SwirlHeading,
  SwirlIconAdd,
  SwirlIconAddPhoto,
  SwirlIconAdminPanelSettings,
  SwirlIconAi,
  SwirlIconArrowBack,
  SwirlIconArrowDownward,
  SwirlIconArrowForward,
  SwirlIconArrowLeft,
  SwirlIconArrowRight,
  SwirlIconArrowRightSmall,
  SwirlIconArrowUpward,
  SwirlIconAttachment,
  SwirlIconBarChart,
  SwirlIconBlock,
  SwirlIconBookmark,
  SwirlIconCancel,
  SwirlIconChatBubble,
  SwirlIconChatsFilled,
  SwirlIconChatsOutlined,
  SwirlIconCheck,
  SwirlIconCheckCircle,
  SwirlIconCheckSmall,
  SwirlIconCheckStrong,
  SwirlIconChevronLeft,
  SwirlIconChevronRight,
  SwirlIconClose,
  SwirlIconCloseSmall,
  SwirlIconCloudUpload,
  SwirlIconColumn,
  SwirlIconComment,
  SwirlIconCopy,
  SwirlIconDateRange,
  SwirlIconDelete,
  SwirlIconDescription,
  SwirlIconDoubleArrowLeft,
  SwirlIconDoubleArrowRight,
  SwirlIconDownload,
  SwirlIconDragHandle,
  SwirlIconEdit,
  SwirlIconEmojiMood,
  SwirlIconEmojiSatisfied,
  SwirlIconError,
  SwirlIconExpandLess,
  SwirlIconExpandMore,
  SwirlIconFile,
  SwirlIconFileCopy,
  SwirlIconFilter,
  SwirlIconFolder,
  SwirlIconFolderShared,
  SwirlIconFullscreen,
  SwirlIconFullscreenExit,
  SwirlIconGif,
  SwirlIconGroupAssign,
  SwirlIconGroups,
  SwirlIconGroupsCustom,
  SwirlIconGroupsFilled,
  SwirlIconGroupsOutlined,
  SwirlIconHelp,
  SwirlIconHighlight,
  SwirlIconHome,
  SwirlIconImage,
  SwirlIconImproveText,
  SwirlIconInfo,
  SwirlIconInsertBelow,
  SwirlIconInsertOnTop,
  SwirlIconInventory,
  SwirlIconLike,
  SwirlIconLink,
  SwirlIconLock,
  SwirlIconLockPerson,
  SwirlIconLogout,
  SwirlIconLongText,
  SwirlIconMail,
  SwirlIconManageAccounts,
  SwirlIconMarkChatRead,
  SwirlIconMarkChatUnread,
  SwirlIconMention,
  SwirlIconMenu,
  SwirlIconMenuBook,
  SwirlIconMenuFilled,
  SwirlIconMenuOutlined,
  SwirlIconMessage,
  SwirlIconMoreHorizontal,
  SwirlIconMoreVertikal,
  SwirlIconNewsFilled,
  SwirlIconNewsOutlined,
  SwirlIconNotifications,
  SwirlIconNotificationsActive,
  SwirlIconNotificationsOff,
  SwirlIconOpenInNew,
  SwirlIconPeopleAlt,
  SwirlIconPerson,
  SwirlIconPersonOff,
  SwirlIconPhone,
  SwirlIconPlayArrow,
  SwirlIconPoll,
  SwirlIconPrint,
  SwirlIconRecieved,
  SwirlIconRemove,
  SwirlIconReply,
  SwirlIconRoadmap,
  SwirlIconSearch,
  SwirlIconSearchStrong,
  SwirlIconSend,
  SwirlIconSettings,
  SwirlIconShortText,
  SwirlIconSimplify,
  SwirlIconSpellcheck,
  SwirlIconSync,
  SwirlIconTasksFilled,
  SwirlIconTasksOutlined,
  SwirlIconTimeFilled,
  SwirlIconTimeOutlined,
  SwirlIconToday,
  SwirlIconUndo,
  SwirlIconUnlockPerson,
  SwirlIconUserAssign,
  SwirlIconVideoCamera,
  SwirlIconVideoLibrary,
  SwirlIconVisibility,
  SwirlIconVisibilityOff,
  SwirlIconVoice,
  SwirlIconWarning,
  SwirlInlineError,
  SwirlInlineNotification,
  SwirlInlineStatus,
  SwirlLightbox,
  SwirlLink,
  SwirlList,
  SwirlModal,
  SwirlOptionList,
  SwirlOptionListItem,
  SwirlOptionListSection,
  SwirlPagination,
  SwirlPdfReader,
  SwirlPopover,
  SwirlProgressIndicator,
  SwirlRadio,
  SwirlRadioGroup,
  SwirlResourceList,
  SwirlResourceListFileItem,
  SwirlResourceListItem,
  SwirlSearch,
  SwirlSelect,
  SwirlSeparator,
  SwirlShellLayout,
  SwirlShellNavigationItem,
  SwirlSkeletonBox,
  SwirlSkeletonText,
  SwirlSpinner,
  SwirlStack,
  SwirlSwitch,
  SwirlTab,
  SwirlTabBar,
  SwirlTable,
  SwirlTableCell,
  SwirlTableColumn,
  SwirlTableRow,
  SwirlTableRowGroup,
  SwirlTabs,
  SwirlTag,
  SwirlText,
  SwirlTextInput,
  SwirlThemeProvider,
  SwirlThumbnail,
  SwirlToast,
  SwirlToastProvider,
  SwirlTooltip,
  SwirlTreeNavigationItem,
  SwirlVideoThumbnail,
  SwirlVisuallyHidden,
  WCDatepicker,
]);

exports.hydrateApp = hydrateApp;


  /*hydrateAppClosure end*/
  hydrateApp(window, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve);
  }

  hydrateAppClosure($stencilWindow);
}

function createWindowFromHtml(e, t) {
 let r = templateWindows.get(t);
 return null == r && (r = new MockWindow(e), templateWindows.set(t, r)), cloneWindow(r);
}

function inspectElement(e, t, r) {
 const s = t.children;
 for (let t = 0, n = s.length; t < n; t++) {
  const n = s[t], o = n.nodeName.toLowerCase();
  if (o.includes("-")) {
   const t = e.components.find((e => e.tag === o));
   null != t && (t.count++, r > t.depth && (t.depth = r));
  } else switch (o) {
  case "a":
   const t = collectAttributes(n);
   t.href = n.href, "string" == typeof t.href && (e.anchors.some((e => e.href === t.href)) || e.anchors.push(t));
   break;

  case "img":
   const r = collectAttributes(n);
   r.src = n.src, "string" == typeof r.src && (e.imgs.some((e => e.src === r.src)) || e.imgs.push(r));
   break;

  case "link":
   const s = collectAttributes(n);
   s.href = n.href, "string" == typeof s.rel && "stylesheet" === s.rel.toLowerCase() && "string" == typeof s.href && (e.styles.some((e => e.link === s.href)) || (delete s.rel, 
   delete s.type, e.styles.push(s)));
   break;

  case "script":
   const o = collectAttributes(n);
   if (n.hasAttribute("src")) o.src = n.src, "string" == typeof o.src && (e.scripts.some((e => e.src === o.src)) || e.scripts.push(o)); else {
    const t = n.getAttribute("data-stencil-static");
    t && e.staticData.push({
     id: t,
     type: n.getAttribute("type"),
     content: n.textContent
    });
   }
  }
  inspectElement(e, n, ++r);
 }
}

function collectAttributes(e) {
 const t = {}, r = e.attributes;
 for (let e = 0, s = r.length; e < s; e++) {
  const s = r.item(e), n = s.nodeName.toLowerCase();
  if (SKIP_ATTRS.has(n)) continue;
  const o = s.nodeValue;
  "class" === n && "" === o || (t[n] = o);
 }
 return t;
}

function patchDomImplementation(e, t) {
 let r;
 if (null != e.defaultView ? (t.destroyWindow = !0, patchWindow(e.defaultView), r = e.defaultView) : (t.destroyWindow = !0, 
 t.destroyDocument = !1, r = new MockWindow(!1)), r.document !== e && (r.document = e), 
 e.defaultView !== r && (e.defaultView = r), "function" != typeof e.documentElement.constructor.prototype.getRootNode && (e.createElement("unknown-element").constructor.prototype.getRootNode = getRootNode), 
 "function" == typeof e.createEvent) {
  const t = e.createEvent("CustomEvent").constructor;
  r.CustomEvent !== t && (r.CustomEvent = t);
 }
 try {
  e.baseURI;
 } catch (t) {
  Object.defineProperty(e, "baseURI", {
   get() {
    const t = e.querySelector("base[href]");
    return t ? new URL(t.getAttribute("href"), r.location.href).href : r.location.href;
   }
  });
 }
 return r;
}

function getRootNode(e) {
 const t = null != e && !0 === e.composed;
 let r = this;
 for (;null != r.parentNode; ) r = r.parentNode, !0 === t && null == r.parentNode && null != r.host && (r = r.host);
 return r;
}

function normalizeHydrateOptions(e) {
 const t = Object.assign({
  serializeToHtml: !1,
  destroyWindow: !1,
  destroyDocument: !1
 }, e || {});
 return "boolean" != typeof t.clientHydrateAnnotations && (t.clientHydrateAnnotations = !0), 
 "boolean" != typeof t.constrainTimeouts && (t.constrainTimeouts = !0), "number" != typeof t.maxHydrateCount && (t.maxHydrateCount = 300), 
 "boolean" != typeof t.runtimeLogging && (t.runtimeLogging = !1), "number" != typeof t.timeout && (t.timeout = 15e3), 
 Array.isArray(t.excludeComponents) ? t.excludeComponents = t.excludeComponents.filter(filterValidTags).map(mapValidTags) : t.excludeComponents = [], 
 Array.isArray(t.staticComponents) ? t.staticComponents = t.staticComponents.filter(filterValidTags).map(mapValidTags) : t.staticComponents = [], 
 t;
}

function filterValidTags(e) {
 return "string" == typeof e && e.includes("-");
}

function mapValidTags(e) {
 return e.trim().toLowerCase();
}

function generateHydrateResults(e) {
 "string" != typeof e.url && (e.url = "https://hydrate.stenciljs.com/"), "string" != typeof e.buildId && (e.buildId = createHydrateBuildId());
 const t = {
  buildId: e.buildId,
  diagnostics: [],
  url: e.url,
  host: null,
  hostname: null,
  href: null,
  pathname: null,
  port: null,
  search: null,
  hash: null,
  html: null,
  httpStatus: null,
  hydratedCount: 0,
  anchors: [],
  components: [],
  imgs: [],
  scripts: [],
  staticData: [],
  styles: [],
  title: null
 };
 try {
  const r = new URL(e.url, "https://hydrate.stenciljs.com/");
  t.url = r.href, t.host = r.host, t.hostname = r.hostname, t.href = r.href, t.port = r.port, 
  t.pathname = r.pathname, t.search = r.search, t.hash = r.hash;
 } catch (e) {
  renderCatchError(t, e);
 }
 return t;
}

function renderBuildDiagnostic(e, t, r, s) {
 const n = {
  level: t,
  type: "build",
  header: r,
  messageText: s,
  relFilePath: null,
  absFilePath: null,
  lines: []
 };
 return e.pathname ? "/" !== e.pathname && (n.header += ": " + e.pathname) : e.url && (n.header += ": " + e.url), 
 e.diagnostics.push(n), n;
}

function renderBuildError(e, t) {
 return renderBuildDiagnostic(e, "error", "Hydrate Error", t);
}

function renderCatchError(e, t) {
 const r = renderBuildError(e, null);
 return null != t && (null != t.stack ? r.messageText = t.stack.toString() : null != t.message ? r.messageText = t.message.toString() : r.messageText = t.toString()), 
 r;
}

function runtimeLog(e, t, r) {
 global.console[t].apply(global.console, [ `[ ${e}  ${t} ] `, ...r ]);
}

function renderToString(e, t) {
 const r = normalizeHydrateOptions(t);
 return r.serializeToHtml = !0, new Promise((t => {
  let s;
  const n = generateHydrateResults(r);
  if (hasError(n.diagnostics)) t(n); else if ("string" == typeof e) try {
   r.destroyWindow = !0, r.destroyDocument = !0, s = new MockWindow(e), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else if (isValidDocument(e)) try {
   r.destroyDocument = !1, s = patchDomImplementation(e, r), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else renderBuildError(n, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), 
  t(n);
 }));
}

function hydrateDocument(e, t) {
 const r = normalizeHydrateOptions(t);
 return r.serializeToHtml = !1, new Promise((t => {
  let s;
  const n = generateHydrateResults(r);
  if (hasError(n.diagnostics)) t(n); else if ("string" == typeof e) try {
   r.destroyWindow = !0, r.destroyDocument = !0, s = new MockWindow(e), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else if (isValidDocument(e)) try {
   r.destroyDocument = !1, s = patchDomImplementation(e, r), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else renderBuildError(n, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), 
  t(n);
 }));
}

function render(e, t, r, s) {
 if (process.__stencilErrors || (process.__stencilErrors = !0, process.on("unhandledRejection", (e => {
  console.log("unhandledRejection", e);
 }))), function n(e, t, r, s) {
  try {
   e.location.href = r.url;
  } catch (e) {
   renderCatchError(s, e);
  }
  if ("string" == typeof r.userAgent) try {
   e.navigator.userAgent = r.userAgent;
  } catch (e) {}
  if ("string" == typeof r.cookie) try {
   t.cookie = r.cookie;
  } catch (e) {}
  if ("string" == typeof r.referrer) try {
   t.referrer = r.referrer;
  } catch (e) {}
  if ("string" == typeof r.direction) try {
   t.documentElement.setAttribute("dir", r.direction);
  } catch (e) {}
  if ("string" == typeof r.language) try {
   t.documentElement.setAttribute("lang", r.language);
  } catch (e) {}
  if ("string" == typeof r.buildId) try {
   t.documentElement.setAttribute("data-stencil-build", r.buildId);
  } catch (e) {}
  try {
   e.customElements = null;
  } catch (e) {}
  return r.constrainTimeouts && constrainTimeouts(e), function n(e, t, r) {
   try {
    const s = e.location.pathname;
    e.console.error = (...e) => {
     const n = e.reduce(((e, t) => {
      if (t) {
       if (null != t.stack) return e + " " + String(t.stack);
       if (null != t.message) return e + " " + String(t.message);
      }
      return String(t);
     }), "").trim();
     "" !== n && (renderCatchError(r, n), t.runtimeLogging && runtimeLog(s, "error", [ n ]));
    }, e.console.debug = (...e) => {
     renderBuildDiagnostic(r, "debug", "Hydrate Debug", [ ...e ].join(", ")), t.runtimeLogging && runtimeLog(s, "debug", e);
    }, t.runtimeLogging && [ "log", "warn", "assert", "info", "trace" ].forEach((t => {
     e.console[t] = (...e) => {
      runtimeLog(s, t, e);
     };
    }));
   } catch (e) {
    renderCatchError(r, e);
   }
  }(e, r, s), e;
 }(e, e.document, t, r), "function" == typeof t.beforeHydrate) try {
  const n = t.beforeHydrate(e.document);
  isPromise(n) ? n.then((() => {
   hydrateFactory(e, t, r, afterHydrate, s);
  })) : hydrateFactory(e, t, r, afterHydrate, s);
 } catch (n) {
  renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
 } else hydrateFactory(e, t, r, afterHydrate, s);
}

function afterHydrate(e, t, r, s) {
 if ("function" == typeof t.afterHydrate) try {
  const n = t.afterHydrate(e.document);
  isPromise(n) ? n.then((() => {
   finalizeHydrate(e, e.document, t, r, s);
  })) : finalizeHydrate(e, e.document, t, r, s);
 } catch (n) {
  renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
 } else finalizeHydrate(e, e.document, t, r, s);
}

function finalizeHydrate(e, t, r, s, n) {
 try {
  if (inspectElement(s, t.documentElement, 0), !1 !== r.removeUnusedStyles) try {
   ((e, t) => {
    try {
     const r = e.head.querySelectorAll("style[data-styles]"), s = r.length;
     if (s > 0) {
      const n = (e => {
       const t = {
        attrs: new Set,
        classNames: new Set,
        ids: new Set,
        tags: new Set
       };
       return collectUsedSelectors(t, e), t;
      })(e.documentElement);
      for (let e = 0; e < s; e++) removeUnusedStyleText(n, t, r[e]);
     }
    } catch (e) {
     ((e, t, r) => {
      const s = {
       level: "error",
       type: "build",
       header: "Build Error",
       messageText: "build error",
       relFilePath: null,
       absFilePath: null,
       lines: []
      };
      null != t && (null != t.stack ? s.messageText = t.stack.toString() : null != t.message ? s.messageText = t.message.length ? t.message : "UNKNOWN ERROR" : s.messageText = t.toString()), 
      null == e || shouldIgnoreError(s.messageText) || e.push(s);
     })(t, e);
    }
   })(t, s.diagnostics);
  } catch (e) {
   renderCatchError(s, e);
  }
  if ("string" == typeof r.title) try {
   t.title = r.title;
  } catch (e) {
   renderCatchError(s, e);
  }
  s.title = t.title, r.removeScripts && removeScripts(t.documentElement);
  try {
   ((e, t) => {
    let r = e.head.querySelector('link[rel="canonical"]');
    "string" == typeof t ? (null == r && (r = e.createElement("link"), r.setAttribute("rel", "canonical"), 
    e.head.appendChild(r)), r.setAttribute("href", t)) : null != r && (r.getAttribute("href") || r.parentNode.removeChild(r));
   })(t, r.canonicalUrl);
  } catch (e) {
   renderCatchError(s, e);
  }
  try {
   (e => {
    const t = e.head;
    let r = t.querySelector("meta[charset]");
    null == r ? (r = e.createElement("meta"), r.setAttribute("charset", "utf-8")) : r.remove(), 
    t.insertBefore(r, t.firstChild);
   })(t);
  } catch (e) {}
  hasError(s.diagnostics) || (s.httpStatus = 200);
  try {
   const e = t.head.querySelector('meta[http-equiv="status"]');
   if (null != e) {
    const t = e.getAttribute("content");
    t && t.length > 0 && (s.httpStatus = parseInt(t, 10));
   }
  } catch (e) {}
  r.clientHydrateAnnotations && t.documentElement.classList.add("hydrated"), r.serializeToHtml && (s.html = serializeDocumentToString(t, r));
 } catch (e) {
  renderCatchError(s, e);
 }
 if (r.destroyWindow) try {
  r.destroyDocument || (e.document = null, t.defaultView = null), e.close && e.close();
 } catch (e) {
  renderCatchError(s, e);
 }
 n(s);
}

function serializeDocumentToString(e, t) {
 return serializeNodeToHtml(e, {
  approximateLineWidth: t.approximateLineWidth,
  outerHtml: !1,
  prettyHtml: t.prettyHtml,
  removeAttributeQuotes: t.removeAttributeQuotes,
  removeBooleanAttributeQuotes: t.removeBooleanAttributeQuotes,
  removeEmptyAttributes: t.removeEmptyAttributes,
  removeHtmlComments: t.removeHtmlComments,
  serializeShadowRoot: !1
 });
}

function isValidDocument(e) {
 return null != e && 9 === e.nodeType && null != e.documentElement && 1 === e.documentElement.nodeType && null != e.body && 1 === e.body.nodeType;
}

function removeScripts(e) {
 const t = e.children;
 for (let e = t.length - 1; e >= 0; e--) {
  const r = t[e];
  removeScripts(r), ("SCRIPT" === r.nodeName || "LINK" === r.nodeName && "modulepreload" === r.getAttribute("rel")) && r.remove();
 }
}

const templateWindows = new Map, isPromise = e => !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then, hasError = e => null != e && 0 !== e.length && e.some((e => "error" === e.level && "runtime" !== e.type)), shouldIgnoreError = e => e === TASK_CANCELED_MSG, TASK_CANCELED_MSG = "task canceled", parseCss = (e, t) => {
 let r = 1, s = 1;
 const n = [], o = e => {
  const t = e.match(/\n/g);
  t && (r += t.length);
  const n = e.lastIndexOf("\n");
  s = ~n ? e.length - n : s + e.length;
 }, i = () => {
  const e = {
   line: r,
   column: s
  };
  return t => (t.position = new z(e), m(), t);
 }, a = o => {
  const i = e.split("\n"), a = {
   level: "error",
   type: "css",
   language: "css",
   header: "CSS Parse",
   messageText: o,
   absFilePath: t,
   lines: [ {
    lineIndex: r - 1,
    lineNumber: r,
    errorCharStart: s,
    text: e[r - 1]
   } ]
  };
  if (r > 1) {
   const t = {
    lineIndex: r - 1,
    lineNumber: r - 1,
    text: e[r - 2],
    errorCharStart: -1,
    errorLength: -1
   };
   a.lines.unshift(t);
  }
  if (r + 2 < i.length) {
   const e = {
    lineIndex: r,
    lineNumber: r + 1,
    text: i[r],
    errorCharStart: -1,
    errorLength: -1
   };
   a.lines.push(e);
  }
  return n.push(a), null;
 }, l = () => u(/^{\s*/), c = () => u(/^}/), u = t => {
  const r = t.exec(e);
  if (!r) return;
  const s = r[0];
  return o(s), e = e.slice(s.length), r;
 }, d = () => {
  let t;
  const r = [];
  for (m(), h(r); e.length && "}" !== e.charAt(0) && (t = w() || A()); ) r.push(t), 
  h(r);
  return r;
 }, m = () => u(/^\s*/), h = e => {
  let t;
  for (e = e || []; t = p(); ) e.push(t);
  return e;
 }, p = () => {
  const t = i();
  if ("/" !== e.charAt(0) || "*" !== e.charAt(1)) return null;
  let r = 2;
  for (;"" !== e.charAt(r) && ("*" !== e.charAt(r) || "/" !== e.charAt(r + 1)); ) ++r;
  if (r += 2, "" === e.charAt(r - 1)) return a("End of comment missing");
  const n = e.slice(2, r - 2);
  return s += 2, o(n), e = e.slice(r), s += 2, t({
   type: 1,
   comment: n
  });
 }, f = () => {
  const e = u(/^([^{]+)/);
  return e ? trim(e[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, (function(e) {
   return e.replace(/,/g, "‌");
  })).split(/\s*(?![^(]*\)),\s*/).map((function(e) {
   return e.replace(/\u200C/g, ",");
  })) : null;
 }, g = () => {
  const e = i();
  let t = u(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
  if (!t) return null;
  if (t = trim(t[0]), !u(/^:\s*/)) return a("property missing ':'");
  const r = u(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/), s = e({
   type: 4,
   property: t.replace(commentre, ""),
   value: r ? trim(r[0]).replace(commentre, "") : ""
  });
  return u(/^[;\s]*/), s;
 }, y = () => {
  const e = [];
  if (!l()) return a("missing '{'");
  let t;
  for (h(e); t = g(); ) e.push(t), h(e);
  return c() ? e : a("missing '}'");
 }, C = () => {
  let e;
  const t = [], r = i();
  for (;e = u(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/); ) t.push(e[1]), u(/^,\s*/);
  return t.length ? r({
   type: 9,
   values: t,
   declarations: y()
  }) : null;
 }, S = (e, t) => {
  const r = new RegExp("^@" + e + "\\s*([^;]+);");
  return () => {
   const s = i(), n = u(r);
   if (!n) return null;
   const o = {
    type: t
   };
   return o[e] = n[1].trim(), s(o);
  };
 }, E = S("import", 7), b = S("charset", 0), T = S("namespace", 11), w = () => "@" !== e[0] ? null : (() => {
  const e = i();
  let t = u(/^@([-\w]+)?keyframes\s*/);
  if (!t) return null;
  const r = t[1];
  if (t = u(/^([-\w]+)\s*/), !t) return a("@keyframes missing name");
  const s = t[1];
  if (!l()) return a("@keyframes missing '{'");
  let n, o = h();
  for (;n = C(); ) o.push(n), o = o.concat(h());
  return c() ? e({
   type: 8,
   name: s,
   vendor: r,
   keyframes: o
  }) : a("@keyframes missing '}'");
 })() || (() => {
  const e = i(), t = u(/^@media *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]);
  if (!l()) return a("@media missing '{'");
  const s = h().concat(d());
  return c() ? e({
   type: 10,
   media: r,
   rules: s
  }) : a("@media missing '}'");
 })() || (() => {
  const e = i(), t = u(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
  return t ? e({
   type: 2,
   name: trim(t[1]),
   media: trim(t[2])
  }) : null;
 })() || (() => {
  const e = i(), t = u(/^@supports *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]);
  if (!l()) return a("@supports missing '{'");
  const s = h().concat(d());
  return c() ? e({
   type: 15,
   supports: r,
   rules: s
  }) : a("@supports missing '}'");
 })() || E() || b() || T() || (() => {
  const e = i(), t = u(/^@([-\w]+)?document *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]), s = trim(t[2]);
  if (!l()) return a("@document missing '{'");
  const n = h().concat(d());
  return c() ? e({
   type: 3,
   document: s,
   vendor: r,
   rules: n
  }) : a("@document missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@page */)) return null;
  const t = f() || [];
  if (!l()) return a("@page missing '{'");
  let r, s = h();
  for (;r = g(); ) s.push(r), s = s.concat(h());
  return c() ? e({
   type: 12,
   selectors: t,
   declarations: s
  }) : a("@page missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@host\s*/)) return null;
  if (!l()) return a("@host missing '{'");
  const t = h().concat(d());
  return c() ? e({
   type: 6,
   rules: t
  }) : a("@host missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@font-face\s*/)) return null;
  if (!l()) return a("@font-face missing '{'");
  let t, r = h();
  for (;t = g(); ) r.push(t), r = r.concat(h());
  return c() ? e({
   type: 5,
   declarations: r
  }) : a("@font-face missing '}'");
 })(), A = () => {
  const e = i(), t = f();
  return t ? (h(), e({
   type: 13,
   selectors: t,
   declarations: y()
  })) : a("selector missing");
 };
 class z {
  constructor(e) {
   this.start = e, this.end = {
    line: r,
    column: s
   }, this.source = t;
  }
 }
 return z.prototype.content = e, {
  diagnostics: n,
  ...addParent((() => {
   const e = d();
   return {
    type: 14,
    stylesheet: {
     source: t,
     rules: e
    }
   };
  })())
 };
}, trim = e => e ? e.trim() : "", addParent = (e, t) => {
 const r = e && "string" == typeof e.type, s = r ? e : t;
 for (const t in e) {
  const r = e[t];
  Array.isArray(r) ? r.forEach((function(e) {
   addParent(e, s);
  })) : r && "object" == typeof r && addParent(r, s);
 }
 return r && Object.defineProperty(e, "parent", {
  configurable: !0,
  writable: !0,
  enumerable: !1,
  value: t || null
 }), e;
}, commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, getCssSelectors = e => {
 SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
 const t = (e = e.replace(/\./g, " .").replace(/\#/g, " #").replace(/\[/g, " [").replace(/\>/g, " > ").replace(/\+/g, " + ").replace(/\~/g, " ~ ").replace(/\*/g, " * ").replace(/\:not\((.*?)\)/g, " ")).split(" ");
 for (let e = 0, r = t.length; e < r; e++) t[e] = t[e].split(":")[0], 0 !== t[e].length && ("." === t[e].charAt(0) ? SELECTORS.classNames.push(t[e].slice(1)) : "#" === t[e].charAt(0) ? SELECTORS.ids.push(t[e].slice(1)) : "[" === t[e].charAt(0) ? (t[e] = t[e].slice(1).split("=")[0].split("]")[0].trim(), 
 SELECTORS.attrs.push(t[e].toLowerCase())) : /[a-z]/g.test(t[e].charAt(0)) && SELECTORS.tags.push(t[e].toLowerCase()));
 return SELECTORS.classNames = SELECTORS.classNames.sort(((e, t) => e.length < t.length ? -1 : e.length > t.length ? 1 : 0)), 
 SELECTORS;
}, SELECTORS = {
 all: [],
 tags: [],
 classNames: [],
 ids: [],
 attrs: []
}, serializeCssVisitNode = (e, t, r, s) => {
 const n = t.type;
 return 4 === n ? serializeCssDeclaration(t, r, s) : 13 === n ? serializeCssRule(e, t) : 1 === n ? "!" === t.comment[0] ? `/*${t.comment}*/` : "" : 10 === n ? serializeCssMedia(e, t) : 8 === n ? serializeCssKeyframes(e, t) : 9 === n ? serializeCssKeyframe(e, t) : 5 === n ? serializeCssFontFace(e, t) : 15 === n ? serializeCssSupports(e, t) : 7 === n ? "@import " + t.import + ";" : 0 === n ? "@charset " + t.charset + ";" : 12 === n ? serializeCssPage(e, t) : 6 === n ? "@host{" + serializeCssMapVisit(e, t.rules) + "}" : 2 === n ? "@custom-media " + t.name + " " + t.media + ";" : 3 === n ? serializeCssDocument(e, t) : 11 === n ? "@namespace " + t.namespace + ";" : "";
}, serializeCssRule = (e, t) => {
 const r = t.declarations, s = e.usedSelectors, n = t.selectors.slice();
 if (null == r || 0 === r.length) return "";
 if (s) {
  let t, r, o = !0;
  for (t = n.length - 1; t >= 0; t--) {
   const i = getCssSelectors(n[t]);
   o = !0;
   let a = i.classNames.length;
   if (a > 0 && e.hasUsedClassNames) for (r = 0; r < a; r++) if (!s.classNames.has(i.classNames[r])) {
    o = !1;
    break;
   }
   if (o && e.hasUsedTags && (a = i.tags.length, a > 0)) for (r = 0; r < a; r++) if (!s.tags.has(i.tags[r])) {
    o = !1;
    break;
   }
   if (o && e.hasUsedAttrs && (a = i.attrs.length, a > 0)) for (r = 0; r < a; r++) if (!s.attrs.has(i.attrs[r])) {
    o = !1;
    break;
   }
   if (o && e.hasUsedIds && (a = i.ids.length, a > 0)) for (r = 0; r < a; r++) if (!s.ids.has(i.ids[r])) {
    o = !1;
    break;
   }
   o || n.splice(t, 1);
  }
 }
 if (0 === n.length) return "";
 const o = [];
 let i = "";
 for (const e of t.selectors) i = removeSelectorWhitespace(e), o.includes(i) || o.push(i);
 return `${o}{${serializeCssMapVisit(e, r)}}`;
}, serializeCssDeclaration = (e, t, r) => "" === e.value ? "" : r - 1 === t ? e.property + ":" + e.value : e.property + ":" + e.value + ";", serializeCssMedia = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules);
 return "" === r ? "" : "@media " + removeMediaWhitespace(t.media) + "{" + r + "}";
}, serializeCssKeyframes = (e, t) => {
 const r = serializeCssMapVisit(e, t.keyframes);
 return "" === r ? "" : "@" + (t.vendor || "") + "keyframes " + t.name + "{" + r + "}";
}, serializeCssKeyframe = (e, t) => t.values.join(",") + "{" + serializeCssMapVisit(e, t.declarations) + "}", serializeCssFontFace = (e, t) => {
 const r = serializeCssMapVisit(e, t.declarations);
 return "" === r ? "" : "@font-face{" + r + "}";
}, serializeCssSupports = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules);
 return "" === r ? "" : "@supports " + t.supports + "{" + r + "}";
}, serializeCssPage = (e, t) => "@page " + t.selectors.join(", ") + "{" + serializeCssMapVisit(e, t.declarations) + "}", serializeCssDocument = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules), s = "@" + (t.vendor || "") + "document " + t.document;
 return "" === r ? "" : s + "{" + r + "}";
}, serializeCssMapVisit = (e, t) => {
 let r = "";
 if (t) for (let s = 0, n = t.length; s < n; s++) r += serializeCssVisitNode(e, t[s], s, n);
 return r;
}, removeSelectorWhitespace = e => {
 let t = "", r = "", s = !1;
 for (let n = 0, o = (e = e.trim()).length; n < o; n++) if (r = e[n], "[" === r && "\\" !== t[t.length - 1] ? s = !0 : "]" === r && "\\" !== t[t.length - 1] && (s = !1), 
 !s && CSS_WS_REG.test(r)) {
  if (CSS_NEXT_CHAR_REG.test(e[n + 1])) continue;
  if (CSS_PREV_CHAR_REG.test(t[t.length - 1])) continue;
  t += " ";
 } else t += r;
 return t;
}, removeMediaWhitespace = e => {
 let t = "", r = "";
 for (let s = 0, n = (e = e.trim()).length; s < n; s++) if (r = e[s], CSS_WS_REG.test(r)) {
  if (CSS_WS_REG.test(t[t.length - 1])) continue;
  t += " ";
 } else t += r;
 return t;
}, CSS_WS_REG = /\s/, CSS_NEXT_CHAR_REG = /[>\(\)\~\,\+\s]/, CSS_PREV_CHAR_REG = /[>\(\~\,\+]/, collectUsedSelectors = (e, t) => {
 if (null != t && 1 === t.nodeType) {
  const r = t.children, s = t.nodeName.toLowerCase();
  e.tags.add(s);
  const n = t.attributes;
  for (let r = 0, s = n.length; r < s; r++) {
   const s = n.item(r), o = s.name.toLowerCase();
   if (e.attrs.add(o), "class" === o) {
    const r = t.classList;
    for (let t = 0, s = r.length; t < s; t++) e.classNames.add(r.item(t));
   } else "id" === o && e.ids.add(s.value);
  }
  if (r) for (let t = 0, s = r.length; t < s; t++) collectUsedSelectors(e, r[t]);
 }
}, removeUnusedStyleText = (e, t, r) => {
 try {
  const s = parseCss(r.innerHTML);
  if (t.push(...s.diagnostics), hasError(t)) return;
  try {
   r.innerHTML = ((e, t) => {
    const r = t.usedSelectors || null, s = {
     usedSelectors: r || null,
     hasUsedAttrs: !!r && r.attrs.size > 0,
     hasUsedClassNames: !!r && r.classNames.size > 0,
     hasUsedIds: !!r && r.ids.size > 0,
     hasUsedTags: !!r && r.tags.size > 0
    }, n = e.rules;
    if (!n) return "";
    const o = n.length, i = [];
    for (let e = 0; e < o; e++) i.push(serializeCssVisitNode(s, n[e], e, o));
    return i.join("");
   })(s.stylesheet, {
    usedSelectors: e
   });
  } catch (e) {
   t.push({
    level: "warn",
    type: "css",
    header: "CSS Stringify",
    messageText: e,
    lines: []
   });
  }
 } catch (e) {
  t.push({
   level: "warn",
   type: "css",
   header: "CSS Parse",
   messageText: e,
   lines: []
  });
 }
}, SKIP_ATTRS = new Set([ "s-id", "c-id" ]), createHydrateBuildId = () => {
 let e = "abcdefghijklmnopqrstuvwxyz", t = "";
 for (;t.length < 8; ) t += e[Math.floor(Math.random() * e.length)], 1 === t.length && (e += "0123456789");
 return t;
};

exports.createWindowFromHtml = createWindowFromHtml;
exports.hydrateDocument = hydrateDocument;
exports.renderToString = renderToString;
exports.serializeDocumentToString = serializeDocumentToString;
